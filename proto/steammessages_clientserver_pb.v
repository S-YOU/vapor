
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


[_allow_multiple_values]
enum EMmslobbyStatus {
k_emmslobbystatusinvalid = 0
k_emmslobbystatusexists = 1
k_emmslobbystatusdoesnotexist = 2
k_emmslobbystatusnotamember = 3
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_emmslobbystatus(e EMmslobbyStatus, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_emmslobbystatus(buf []byte, tag_wiretype vproto.WireType) ?(int, EMmslobbyStatus) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, EMmslobbyStatus(v)
}
pub struct CMsgClientUDsp2PSessionStarted {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid_remote u64
has_steamid_remote bool
appid int
has_appid bool
}
pub fn (o &CMsgClientUDsp2PSessionStarted) pack() []byte {
mut res := []byte{}
if o.has_steamid_remote {
res << vproto.pack_64bit_field(o.steamid_remote, 1)
}

if o.has_appid {
res << vproto.pack_int32_field(o.appid, 2)
}

return res
}

pub fn cmsgclientudsp2psessionstarted_unpack(buf []byte) ?CMsgClientUDsp2PSessionStarted {
mut res := CMsgClientUDsp2PSessionStarted{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid_remote = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid_remote = v
i = ii
}

2 {
res.has_appid = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientudsp2psessionstarted() CMsgClientUDsp2PSessionStarted {
return CMsgClientUDsp2PSessionStarted{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientudsp2psessionstarted(o CMsgClientUDsp2PSessionStarted, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientudsp2psessionstarted(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUDsp2PSessionStarted) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientudsp2psessionstarted_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUDsp2PSessionEnded {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid_remote u64
has_steamid_remote bool
appid int
has_appid bool
session_length_sec int
has_session_length_sec bool
session_error int
has_session_error bool
nattype int
has_nattype bool
bytes_recv int
has_bytes_recv bool
bytes_sent int
has_bytes_sent bool
bytes_sent_relay int
has_bytes_sent_relay bool
bytes_recv_relay int
has_bytes_recv_relay bool
time_to_connect_ms int
has_time_to_connect_ms bool
}
pub fn (o &CMsgClientUDsp2PSessionEnded) pack() []byte {
mut res := []byte{}
if o.has_steamid_remote {
res << vproto.pack_64bit_field(o.steamid_remote, 1)
}

if o.has_appid {
res << vproto.pack_int32_field(o.appid, 2)
}

if o.has_session_length_sec {
res << vproto.pack_int32_field(o.session_length_sec, 3)
}

if o.has_session_error {
res << vproto.pack_int32_field(o.session_error, 4)
}

if o.has_nattype {
res << vproto.pack_int32_field(o.nattype, 5)
}

if o.has_bytes_recv {
res << vproto.pack_int32_field(o.bytes_recv, 6)
}

if o.has_bytes_sent {
res << vproto.pack_int32_field(o.bytes_sent, 7)
}

if o.has_bytes_sent_relay {
res << vproto.pack_int32_field(o.bytes_sent_relay, 8)
}

if o.has_bytes_recv_relay {
res << vproto.pack_int32_field(o.bytes_recv_relay, 9)
}

if o.has_time_to_connect_ms {
res << vproto.pack_int32_field(o.time_to_connect_ms, 10)
}

return res
}

pub fn cmsgclientudsp2psessionended_unpack(buf []byte) ?CMsgClientUDsp2PSessionEnded {
mut res := CMsgClientUDsp2PSessionEnded{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid_remote = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid_remote = v
i = ii
}

2 {
res.has_appid = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

3 {
res.has_session_length_sec = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.session_length_sec = v
i = ii
}

4 {
res.has_session_error = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.session_error = v
i = ii
}

5 {
res.has_nattype = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.nattype = v
i = ii
}

6 {
res.has_bytes_recv = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.bytes_recv = v
i = ii
}

7 {
res.has_bytes_sent = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.bytes_sent = v
i = ii
}

8 {
res.has_bytes_sent_relay = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.bytes_sent_relay = v
i = ii
}

9 {
res.has_bytes_recv_relay = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.bytes_recv_relay = v
i = ii
}

10 {
res.has_time_to_connect_ms = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.time_to_connect_ms = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientudsp2psessionended() CMsgClientUDsp2PSessionEnded {
return CMsgClientUDsp2PSessionEnded{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientudsp2psessionended(o CMsgClientUDsp2PSessionEnded, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientudsp2psessionended(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUDsp2PSessionEnded) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientudsp2psessionended_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRegisterAuthTicketWithCM {
mut:
unknown_fields []vproto.UnknownField
pub mut:
protocol_version u32
has_protocol_version bool
ticket []byte
has_ticket bool
client_instance_id u64
has_client_instance_id bool
}
pub fn (o &CMsgClientRegisterAuthTicketWithCM) pack() []byte {
mut res := []byte{}
if o.has_protocol_version {
res << vproto.pack_uint32_field(o.protocol_version, 1)
}

if o.has_ticket {
res << vproto.pack_bytes_field(o.ticket, 3)
}

if o.has_client_instance_id {
res << vproto.pack_uint64_field(o.client_instance_id, 4)
}

return res
}

pub fn cmsgclientregisterauthticketwithcm_unpack(buf []byte) ?CMsgClientRegisterAuthTicketWithCM {
mut res := CMsgClientRegisterAuthTicketWithCM{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_protocol_version = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.protocol_version = v
i = ii
}

3 {
res.has_ticket = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.ticket = v
i = ii
}

4 {
res.has_client_instance_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.client_instance_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientregisterauthticketwithcm() CMsgClientRegisterAuthTicketWithCM {
return CMsgClientRegisterAuthTicketWithCM{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientregisterauthticketwithcm(o CMsgClientRegisterAuthTicketWithCM, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientregisterauthticketwithcm(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRegisterAuthTicketWithCM) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientregisterauthticketwithcm_unpack(v)?
return i, unpacked
}
pub struct CMsgClientTicketAuthComplete {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
game_id u64
has_game_id bool
estate u32
has_estate bool
eauth_session_response u32
has_eauth_session_response bool
deprecated_ticket []byte
has_deprecated_ticket bool
ticket_crc u32
has_ticket_crc bool
ticket_sequence u32
has_ticket_sequence bool
owner_steam_id u64
has_owner_steam_id bool
}
pub fn (o &CMsgClientTicketAuthComplete) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

if o.has_game_id {
res << vproto.pack_64bit_field(o.game_id, 2)
}

if o.has_estate {
res << vproto.pack_uint32_field(o.estate, 3)
}

if o.has_eauth_session_response {
res << vproto.pack_uint32_field(o.eauth_session_response, 4)
}

if o.has_deprecated_ticket {
res << vproto.pack_bytes_field(o.deprecated_ticket, 5)
}

if o.has_ticket_crc {
res << vproto.pack_uint32_field(o.ticket_crc, 6)
}

if o.has_ticket_sequence {
res << vproto.pack_uint32_field(o.ticket_sequence, 7)
}

if o.has_owner_steam_id {
res << vproto.pack_64bit_field(o.owner_steam_id, 8)
}

return res
}

pub fn cmsgclientticketauthcomplete_unpack(buf []byte) ?CMsgClientTicketAuthComplete {
mut res := CMsgClientTicketAuthComplete{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

2 {
res.has_game_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.game_id = v
i = ii
}

3 {
res.has_estate = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.estate = v
i = ii
}

4 {
res.has_eauth_session_response = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eauth_session_response = v
i = ii
}

5 {
res.has_deprecated_ticket = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_ticket = v
i = ii
}

6 {
res.has_ticket_crc = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ticket_crc = v
i = ii
}

7 {
res.has_ticket_sequence = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ticket_sequence = v
i = ii
}

8 {
res.has_owner_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.owner_steam_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientticketauthcomplete() CMsgClientTicketAuthComplete {
return CMsgClientTicketAuthComplete{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientticketauthcomplete(o CMsgClientTicketAuthComplete, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientticketauthcomplete(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientTicketAuthComplete) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientticketauthcomplete_unpack(v)?
return i, unpacked
}
pub struct CMsgClientCMlist {
mut:
unknown_fields []vproto.UnknownField
pub mut:
cm_addresses []u32
cm_ports []u32
cm_websocket_addresses []string
percent_default_to_websocket u32
has_percent_default_to_websocket bool
}
pub fn (o &CMsgClientCMlist) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.cm_addresses {
res << vproto.pack_uint32_field(x, 1)
}

// [packed=false]
for _, x in o.cm_ports {
res << vproto.pack_uint32_field(x, 2)
}

// [packed=false]
for _, x in o.cm_websocket_addresses {
res << vproto.pack_string_field(x, 3)
}

if o.has_percent_default_to_websocket {
res << vproto.pack_uint32_field(o.percent_default_to_websocket, 4)
}

return res
}

pub fn cmsgclientcmlist_unpack(buf []byte) ?CMsgClientCMlist {
mut res := CMsgClientCMlist{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cm_addresses << v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cm_ports << v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.cm_websocket_addresses << v
i = ii
}

4 {
res.has_percent_default_to_websocket = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.percent_default_to_websocket = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcmlist() CMsgClientCMlist {
return CMsgClientCMlist{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcmlist(o CMsgClientCMlist, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcmlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCMlist) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientcmlist_unpack(v)?
return i, unpacked
}
pub struct CMsgClientP2PConnectionInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id_dest u64
has_steam_id_dest bool
steam_id_src u64
has_steam_id_src bool
app_id u32
has_app_id bool
candidate []byte
has_candidate bool
connection_id_src u64
has_connection_id_src bool
rendezvous []byte
has_rendezvous bool
}
pub fn (o &CMsgClientP2PConnectionInfo) pack() []byte {
mut res := []byte{}
if o.has_steam_id_dest {
res << vproto.pack_64bit_field(o.steam_id_dest, 1)
}

if o.has_steam_id_src {
res << vproto.pack_64bit_field(o.steam_id_src, 2)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 3)
}

if o.has_candidate {
res << vproto.pack_bytes_field(o.candidate, 4)
}

if o.has_connection_id_src {
res << vproto.pack_64bit_field(o.connection_id_src, 5)
}

if o.has_rendezvous {
res << vproto.pack_bytes_field(o.rendezvous, 6)
}

return res
}

pub fn cmsgclientp2pconnectioninfo_unpack(buf []byte) ?CMsgClientP2PConnectionInfo {
mut res := CMsgClientP2PConnectionInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id_dest = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_dest = v
i = ii
}

2 {
res.has_steam_id_src = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_src = v
i = ii
}

3 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

4 {
res.has_candidate = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.candidate = v
i = ii
}

5 {
res.has_connection_id_src = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.connection_id_src = v
i = ii
}

6 {
res.has_rendezvous = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.rendezvous = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientp2pconnectioninfo() CMsgClientP2PConnectionInfo {
return CMsgClientP2PConnectionInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientp2pconnectioninfo(o CMsgClientP2PConnectionInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientp2pconnectioninfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientP2PConnectionInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientp2pconnectioninfo_unpack(v)?
return i, unpacked
}
pub struct CMsgClientP2PConnectionFailInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id_dest u64
has_steam_id_dest bool
steam_id_src u64
has_steam_id_src bool
app_id u32
has_app_id bool
ep2p_session_error u32
has_ep2p_session_error bool
connection_id_dest u64
has_connection_id_dest bool
close_reason u32
has_close_reason bool
close_message string
has_close_message bool
}
pub fn (o &CMsgClientP2PConnectionFailInfo) pack() []byte {
mut res := []byte{}
if o.has_steam_id_dest {
res << vproto.pack_64bit_field(o.steam_id_dest, 1)
}

if o.has_steam_id_src {
res << vproto.pack_64bit_field(o.steam_id_src, 2)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 3)
}

if o.has_ep2p_session_error {
res << vproto.pack_uint32_field(o.ep2p_session_error, 4)
}

if o.has_connection_id_dest {
res << vproto.pack_64bit_field(o.connection_id_dest, 5)
}

if o.has_close_reason {
res << vproto.pack_uint32_field(o.close_reason, 7)
}

if o.has_close_message {
res << vproto.pack_string_field(o.close_message, 8)
}

return res
}

pub fn cmsgclientp2pconnectionfailinfo_unpack(buf []byte) ?CMsgClientP2PConnectionFailInfo {
mut res := CMsgClientP2PConnectionFailInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id_dest = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_dest = v
i = ii
}

2 {
res.has_steam_id_src = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_src = v
i = ii
}

3 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

4 {
res.has_ep2p_session_error = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ep2p_session_error = v
i = ii
}

5 {
res.has_connection_id_dest = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.connection_id_dest = v
i = ii
}

7 {
res.has_close_reason = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.close_reason = v
i = ii
}

8 {
res.has_close_message = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.close_message = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientp2pconnectionfailinfo() CMsgClientP2PConnectionFailInfo {
return CMsgClientP2PConnectionFailInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientp2pconnectionfailinfo(o CMsgClientP2PConnectionFailInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientp2pconnectionfailinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientP2PConnectionFailInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientp2pconnectionfailinfo_unpack(v)?
return i, unpacked
}
pub struct CMsgClientNetworkingCertRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
key_data []byte
has_key_data bool
app_id u32
has_app_id bool
}
pub fn (o &CMsgClientNetworkingCertRequest) pack() []byte {
mut res := []byte{}
if o.has_key_data {
res << vproto.pack_bytes_field(o.key_data, 2)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 3)
}

return res
}

pub fn cmsgclientnetworkingcertrequest_unpack(buf []byte) ?CMsgClientNetworkingCertRequest {
mut res := CMsgClientNetworkingCertRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
2 {
res.has_key_data = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.key_data = v
i = ii
}

3 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientnetworkingcertrequest() CMsgClientNetworkingCertRequest {
return CMsgClientNetworkingCertRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientnetworkingcertrequest(o CMsgClientNetworkingCertRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientnetworkingcertrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNetworkingCertRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientnetworkingcertrequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientNetworkingCertReply {
mut:
unknown_fields []vproto.UnknownField
pub mut:
cert []byte
has_cert bool
ca_key_id u64
has_ca_key_id bool
ca_signature []byte
has_ca_signature bool
}
pub fn (o &CMsgClientNetworkingCertReply) pack() []byte {
mut res := []byte{}
if o.has_cert {
res << vproto.pack_bytes_field(o.cert, 4)
}

if o.has_ca_key_id {
res << vproto.pack_64bit_field(o.ca_key_id, 5)
}

if o.has_ca_signature {
res << vproto.pack_bytes_field(o.ca_signature, 6)
}

return res
}

pub fn cmsgclientnetworkingcertreply_unpack(buf []byte) ?CMsgClientNetworkingCertReply {
mut res := CMsgClientNetworkingCertReply{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
4 {
res.has_cert = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.cert = v
i = ii
}

5 {
res.has_ca_key_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.ca_key_id = v
i = ii
}

6 {
res.has_ca_signature = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.ca_signature = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientnetworkingcertreply() CMsgClientNetworkingCertReply {
return CMsgClientNetworkingCertReply{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientnetworkingcertreply(o CMsgClientNetworkingCertReply, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientnetworkingcertreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNetworkingCertReply) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientnetworkingcertreply_unpack(v)?
return i, unpacked
}
pub struct CMsgClientNetworkingMobileCertRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
}
pub fn (o &CMsgClientNetworkingMobileCertRequest) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

return res
}

pub fn cmsgclientnetworkingmobilecertrequest_unpack(buf []byte) ?CMsgClientNetworkingMobileCertRequest {
mut res := CMsgClientNetworkingMobileCertRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientnetworkingmobilecertrequest() CMsgClientNetworkingMobileCertRequest {
return CMsgClientNetworkingMobileCertRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientnetworkingmobilecertrequest(o CMsgClientNetworkingMobileCertRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientnetworkingmobilecertrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNetworkingMobileCertRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientnetworkingmobilecertrequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientNetworkingMobileCertReply {
mut:
unknown_fields []vproto.UnknownField
pub mut:
encoded_cert string
has_encoded_cert bool
}
pub fn (o &CMsgClientNetworkingMobileCertReply) pack() []byte {
mut res := []byte{}
if o.has_encoded_cert {
res << vproto.pack_string_field(o.encoded_cert, 1)
}

return res
}

pub fn cmsgclientnetworkingmobilecertreply_unpack(buf []byte) ?CMsgClientNetworkingMobileCertReply {
mut res := CMsgClientNetworkingMobileCertReply{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_encoded_cert = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.encoded_cert = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientnetworkingmobilecertreply() CMsgClientNetworkingMobileCertReply {
return CMsgClientNetworkingMobileCertReply{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientnetworkingmobilecertreply(o CMsgClientNetworkingMobileCertReply, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientnetworkingmobilecertreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNetworkingMobileCertReply) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientnetworkingmobilecertreply_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetAppOwnershipTicket {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
}
pub fn (o &CMsgClientGetAppOwnershipTicket) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

return res
}

pub fn cmsgclientgetappownershipticket_unpack(buf []byte) ?CMsgClientGetAppOwnershipTicket {
mut res := CMsgClientGetAppOwnershipTicket{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetappownershipticket() CMsgClientGetAppOwnershipTicket {
return CMsgClientGetAppOwnershipTicket{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetappownershipticket(o CMsgClientGetAppOwnershipTicket, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetappownershipticket(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetAppOwnershipTicket) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetappownershipticket_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetAppOwnershipTicketResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult u32
has_eresult bool
app_id u32
has_app_id bool
ticket []byte
has_ticket bool
}
pub fn (o &CMsgClientGetAppOwnershipTicketResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

if o.has_ticket {
res << vproto.pack_bytes_field(o.ticket, 3)
}

return res
}

pub fn cmsgclientgetappownershipticketresponse_unpack(buf []byte) ?CMsgClientGetAppOwnershipTicketResponse {
mut res := CMsgClientGetAppOwnershipTicketResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

3 {
res.has_ticket = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.ticket = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetappownershipticketresponse() CMsgClientGetAppOwnershipTicketResponse {
return CMsgClientGetAppOwnershipTicketResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetappownershipticketresponse(o CMsgClientGetAppOwnershipTicketResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetappownershipticketresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetAppOwnershipTicketResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetappownershipticketresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientSessionToken {
mut:
unknown_fields []vproto.UnknownField
pub mut:
token u64
has_token bool
}
pub fn (o &CMsgClientSessionToken) pack() []byte {
mut res := []byte{}
if o.has_token {
res << vproto.pack_uint64_field(o.token, 1)
}

return res
}

pub fn cmsgclientsessiontoken_unpack(buf []byte) ?CMsgClientSessionToken {
mut res := CMsgClientSessionToken{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsessiontoken() CMsgClientSessionToken {
return CMsgClientSessionToken{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsessiontoken(o CMsgClientSessionToken, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsessiontoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSessionToken) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientsessiontoken_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGameConnectTokens {
mut:
unknown_fields []vproto.UnknownField
pub mut:
max_tokens_to_keep u32
has_max_tokens_to_keep bool
tokens [][]byte
}
pub fn (o &CMsgClientGameConnectTokens) pack() []byte {
mut res := []byte{}
if o.has_max_tokens_to_keep {
res << vproto.pack_uint32_field(o.max_tokens_to_keep, 1)
}

// [packed=false]
for _, x in o.tokens {
res << vproto.pack_bytes_field(x, 2)
}

return res
}

pub fn cmsgclientgameconnecttokens_unpack(buf []byte) ?CMsgClientGameConnectTokens {
mut res := CMsgClientGameConnectTokens{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_max_tokens_to_keep = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.max_tokens_to_keep = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.tokens << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgameconnecttokens() CMsgClientGameConnectTokens {
return CMsgClientGameConnectTokens{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgameconnecttokens(o CMsgClientGameConnectTokens, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgameconnecttokens(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGameConnectTokens) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgameconnecttokens_unpack(v)?
return i, unpacked
}
pub struct CMsgGSserverType {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id_served u32
has_app_id_served bool
flags u32
has_flags bool
deprecated_game_ip_address u32
has_deprecated_game_ip_address bool
game_port u32
has_game_port bool
game_dir string
has_game_dir bool
game_version string
has_game_version bool
game_query_port u32
has_game_query_port bool
}
pub fn (o &CMsgGSserverType) pack() []byte {
mut res := []byte{}
if o.has_app_id_served {
res << vproto.pack_uint32_field(o.app_id_served, 1)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 2)
}

if o.has_deprecated_game_ip_address {
res << vproto.pack_uint32_field(o.deprecated_game_ip_address, 3)
}

if o.has_game_port {
res << vproto.pack_uint32_field(o.game_port, 4)
}

if o.has_game_dir {
res << vproto.pack_string_field(o.game_dir, 5)
}

if o.has_game_version {
res << vproto.pack_string_field(o.game_version, 6)
}

if o.has_game_query_port {
res << vproto.pack_uint32_field(o.game_query_port, 7)
}

return res
}

pub fn cmsggsservertype_unpack(buf []byte) ?CMsgGSserverType {
mut res := CMsgGSserverType{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id_served = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id_served = v
i = ii
}

2 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

3 {
res.has_deprecated_game_ip_address = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_game_ip_address = v
i = ii
}

4 {
res.has_game_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.game_port = v
i = ii
}

5 {
res.has_game_dir = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.game_dir = v
i = ii
}

6 {
res.has_game_version = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.game_version = v
i = ii
}

7 {
res.has_game_query_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.game_query_port = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsservertype() CMsgGSserverType {
return CMsgGSserverType{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsservertype(o CMsgGSserverType, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsservertype(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSserverType) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggsservertype_unpack(v)?
return i, unpacked
}
pub struct CMsgGSstatusReply {
mut:
unknown_fields []vproto.UnknownField
pub mut:
is_secure bool
has_is_secure bool
}
pub fn (o &CMsgGSstatusReply) pack() []byte {
mut res := []byte{}
if o.has_is_secure {
res << vproto.pack_bool_field(o.is_secure, 1)
}

return res
}

pub fn cmsggsstatusreply_unpack(buf []byte) ?CMsgGSstatusReply {
mut res := CMsgGSstatusReply{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_is_secure = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_secure = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsstatusreply() CMsgGSstatusReply {
return CMsgGSstatusReply{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsstatusreply(o CMsgGSstatusReply, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsstatusreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSstatusReply) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggsstatusreply_unpack(v)?
return i, unpacked
}
pub struct CMsgGSplayerListPlayer {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
deprecated_public_ip u32
has_deprecated_public_ip bool
token []byte
has_token bool
public_ip CMsgIPaddress
has_public_ip bool
}
pub fn (o &CMsgGSplayerListPlayer) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_uint64_field(o.steam_id, 1)
}

if o.has_deprecated_public_ip {
res << vproto.pack_uint32_field(o.deprecated_public_ip, 2)
}

if o.has_token {
res << vproto.pack_bytes_field(o.token, 3)
}

if o.has_public_ip {
res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 4)
}

return res
}

pub fn cmsggsplayerlistplayer_unpack(buf []byte) ?CMsgGSplayerListPlayer {
mut res := CMsgGSplayerListPlayer{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

2 {
res.has_deprecated_public_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_public_ip = v
i = ii
}

3 {
res.has_token = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.token = v
i = ii
}

4 {
res.has_public_ip = true
ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
res.public_ip = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsplayerlistplayer() CMsgGSplayerListPlayer {
return CMsgGSplayerListPlayer{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsplayerlistplayer(o CMsgGSplayerListPlayer, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsplayerlistplayer(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSplayerListPlayer) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggsplayerlistplayer_unpack(v)?
return i, unpacked
}
pub struct CMsgGSplayerList {
mut:
unknown_fields []vproto.UnknownField
pub mut:
players []CMsgGSplayerListPlayer
}
pub fn (o &CMsgGSplayerList) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.players {
res << zzz_vproto_internal_pack_cmsggsplayerlistplayer(x, 1)
}

return res
}

pub fn cmsggsplayerlist_unpack(buf []byte) ?CMsgGSplayerList {
mut res := CMsgGSplayerList{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsggsplayerlistplayer(cur_buf, tag_wiretype.wire_type)?
res.players << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsplayerlist() CMsgGSplayerList {
return CMsgGSplayerList{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsplayerlist(o CMsgGSplayerList, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsplayerlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSplayerList) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggsplayerlist_unpack(v)?
return i, unpacked
}
pub struct CMsgGSuserPlaying {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
deprecated_public_ip u32
has_deprecated_public_ip bool
token []byte
has_token bool
public_ip CMsgIPaddress
has_public_ip bool
}
pub fn (o &CMsgGSuserPlaying) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

if o.has_deprecated_public_ip {
res << vproto.pack_uint32_field(o.deprecated_public_ip, 2)
}

if o.has_token {
res << vproto.pack_bytes_field(o.token, 3)
}

if o.has_public_ip {
res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 4)
}

return res
}

pub fn cmsggsuserplaying_unpack(buf []byte) ?CMsgGSuserPlaying {
mut res := CMsgGSuserPlaying{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

2 {
res.has_deprecated_public_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_public_ip = v
i = ii
}

3 {
res.has_token = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.token = v
i = ii
}

4 {
res.has_public_ip = true
ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
res.public_ip = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsuserplaying() CMsgGSuserPlaying {
return CMsgGSuserPlaying{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsuserplaying(o CMsgGSuserPlaying, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsuserplaying(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSuserPlaying) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggsuserplaying_unpack(v)?
return i, unpacked
}
pub struct CMsgGSdisconnectNotice {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
}
pub fn (o &CMsgGSdisconnectNotice) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

return res
}

pub fn cmsggsdisconnectnotice_unpack(buf []byte) ?CMsgGSdisconnectNotice {
mut res := CMsgGSdisconnectNotice{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsdisconnectnotice() CMsgGSdisconnectNotice {
return CMsgGSdisconnectNotice{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsdisconnectnotice(o CMsgGSdisconnectNotice, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsdisconnectnotice(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSdisconnectNotice) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggsdisconnectnotice_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGamesPlayedGamePlayed {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id_gs u64
has_steam_id_gs bool
game_id u64
has_game_id bool
deprecated_game_ip_address u32
has_deprecated_game_ip_address bool
game_port u32
has_game_port bool
is_secure bool
has_is_secure bool
token []byte
has_token bool
game_extra_info string
has_game_extra_info bool
game_data_blob []byte
has_game_data_blob bool
process_id u32
has_process_id bool
streaming_provider_id u32
has_streaming_provider_id bool
game_flags u32
has_game_flags bool
owner_id u32
has_owner_id bool
vr_hmd_vendor string
has_vr_hmd_vendor bool
vr_hmd_model string
has_vr_hmd_model bool
launch_option_type u32
has_launch_option_type bool
primary_controller_type int
has_primary_controller_type bool
primary_steam_controller_serial string
has_primary_steam_controller_serial bool
total_steam_controller_count u32
has_total_steam_controller_count bool
total_non_steam_controller_count u32
has_total_non_steam_controller_count bool
controller_workshop_file_id u64
has_controller_workshop_file_id bool
launch_source u32
has_launch_source bool
vr_hmd_runtime u32
has_vr_hmd_runtime bool
game_ip_address CMsgIPaddress
has_game_ip_address bool
controller_connection_type u32
has_controller_connection_type bool
}
pub fn (o &CMsgClientGamesPlayedGamePlayed) pack() []byte {
mut res := []byte{}
if o.has_steam_id_gs {
res << vproto.pack_uint64_field(o.steam_id_gs, 1)
}

if o.has_game_id {
res << vproto.pack_64bit_field(o.game_id, 2)
}

if o.has_deprecated_game_ip_address {
res << vproto.pack_uint32_field(o.deprecated_game_ip_address, 3)
}

if o.has_game_port {
res << vproto.pack_uint32_field(o.game_port, 4)
}

if o.has_is_secure {
res << vproto.pack_bool_field(o.is_secure, 5)
}

if o.has_token {
res << vproto.pack_bytes_field(o.token, 6)
}

if o.has_game_extra_info {
res << vproto.pack_string_field(o.game_extra_info, 7)
}

if o.has_game_data_blob {
res << vproto.pack_bytes_field(o.game_data_blob, 8)
}

if o.has_process_id {
res << vproto.pack_uint32_field(o.process_id, 9)
}

if o.has_streaming_provider_id {
res << vproto.pack_uint32_field(o.streaming_provider_id, 10)
}

if o.has_game_flags {
res << vproto.pack_uint32_field(o.game_flags, 11)
}

if o.has_owner_id {
res << vproto.pack_uint32_field(o.owner_id, 12)
}

if o.has_vr_hmd_vendor {
res << vproto.pack_string_field(o.vr_hmd_vendor, 13)
}

if o.has_vr_hmd_model {
res << vproto.pack_string_field(o.vr_hmd_model, 14)
}

if o.has_launch_option_type {
res << vproto.pack_uint32_field(o.launch_option_type, 15)
}

if o.has_primary_controller_type {
res << vproto.pack_int32_field(o.primary_controller_type, 16)
}

if o.has_primary_steam_controller_serial {
res << vproto.pack_string_field(o.primary_steam_controller_serial, 17)
}

if o.has_total_steam_controller_count {
res << vproto.pack_uint32_field(o.total_steam_controller_count, 18)
}

if o.has_total_non_steam_controller_count {
res << vproto.pack_uint32_field(o.total_non_steam_controller_count, 19)
}

if o.has_controller_workshop_file_id {
res << vproto.pack_uint64_field(o.controller_workshop_file_id, 20)
}

if o.has_launch_source {
res << vproto.pack_uint32_field(o.launch_source, 21)
}

if o.has_vr_hmd_runtime {
res << vproto.pack_uint32_field(o.vr_hmd_runtime, 22)
}

if o.has_game_ip_address {
res << zzz_vproto_internal_pack_cmsgipaddress(o.game_ip_address, 23)
}

if o.has_controller_connection_type {
res << vproto.pack_uint32_field(o.controller_connection_type, 24)
}

return res
}

pub fn cmsgclientgamesplayedgameplayed_unpack(buf []byte) ?CMsgClientGamesPlayedGamePlayed {
mut res := CMsgClientGamesPlayedGamePlayed{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id_gs = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_gs = v
i = ii
}

2 {
res.has_game_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.game_id = v
i = ii
}

3 {
res.has_deprecated_game_ip_address = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_game_ip_address = v
i = ii
}

4 {
res.has_game_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.game_port = v
i = ii
}

5 {
res.has_is_secure = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_secure = v
i = ii
}

6 {
res.has_token = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.token = v
i = ii
}

7 {
res.has_game_extra_info = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.game_extra_info = v
i = ii
}

8 {
res.has_game_data_blob = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.game_data_blob = v
i = ii
}

9 {
res.has_process_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.process_id = v
i = ii
}

10 {
res.has_streaming_provider_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.streaming_provider_id = v
i = ii
}

11 {
res.has_game_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.game_flags = v
i = ii
}

12 {
res.has_owner_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.owner_id = v
i = ii
}

13 {
res.has_vr_hmd_vendor = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.vr_hmd_vendor = v
i = ii
}

14 {
res.has_vr_hmd_model = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.vr_hmd_model = v
i = ii
}

15 {
res.has_launch_option_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.launch_option_type = v
i = ii
}

16 {
res.has_primary_controller_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.primary_controller_type = v
i = ii
}

17 {
res.has_primary_steam_controller_serial = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.primary_steam_controller_serial = v
i = ii
}

18 {
res.has_total_steam_controller_count = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.total_steam_controller_count = v
i = ii
}

19 {
res.has_total_non_steam_controller_count = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.total_non_steam_controller_count = v
i = ii
}

20 {
res.has_controller_workshop_file_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.controller_workshop_file_id = v
i = ii
}

21 {
res.has_launch_source = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.launch_source = v
i = ii
}

22 {
res.has_vr_hmd_runtime = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.vr_hmd_runtime = v
i = ii
}

23 {
res.has_game_ip_address = true
ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
res.game_ip_address = v
i = ii
}

24 {
res.has_controller_connection_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.controller_connection_type = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgamesplayedgameplayed() CMsgClientGamesPlayedGamePlayed {
return CMsgClientGamesPlayedGamePlayed{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgamesplayedgameplayed(o CMsgClientGamesPlayedGamePlayed, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgamesplayedgameplayed(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGamesPlayedGamePlayed) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgamesplayedgameplayed_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGamesPlayed {
mut:
unknown_fields []vproto.UnknownField
pub mut:
games_played []CMsgClientGamesPlayedGamePlayed
client_os_type u32
has_client_os_type bool
cloud_gaming_platform u32
has_cloud_gaming_platform bool
}
pub fn (o &CMsgClientGamesPlayed) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.games_played {
res << zzz_vproto_internal_pack_cmsgclientgamesplayedgameplayed(x, 1)
}

if o.has_client_os_type {
res << vproto.pack_uint32_field(o.client_os_type, 2)
}

if o.has_cloud_gaming_platform {
res << vproto.pack_uint32_field(o.cloud_gaming_platform, 3)
}

return res
}

pub fn cmsgclientgamesplayed_unpack(buf []byte) ?CMsgClientGamesPlayed {
mut res := CMsgClientGamesPlayed{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientgamesplayedgameplayed(cur_buf, tag_wiretype.wire_type)?
res.games_played << v
i = ii
}

2 {
res.has_client_os_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.client_os_type = v
i = ii
}

3 {
res.has_cloud_gaming_platform = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cloud_gaming_platform = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgamesplayed() CMsgClientGamesPlayed {
return CMsgClientGamesPlayed{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgamesplayed(o CMsgClientGamesPlayed, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgamesplayed(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGamesPlayed) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgamesplayed_unpack(v)?
return i, unpacked
}
pub struct CMsgGSapprove {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
owner_steam_id u64
has_owner_steam_id bool
}
pub fn (o &CMsgGSapprove) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

if o.has_owner_steam_id {
res << vproto.pack_64bit_field(o.owner_steam_id, 2)
}

return res
}

pub fn cmsggsapprove_unpack(buf []byte) ?CMsgGSapprove {
mut res := CMsgGSapprove{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

2 {
res.has_owner_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.owner_steam_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsapprove() CMsgGSapprove {
return CMsgGSapprove{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsapprove(o CMsgGSapprove, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsapprove(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSapprove) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggsapprove_unpack(v)?
return i, unpacked
}
pub struct CMsgGSdeny {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
edeny_reason int
has_edeny_reason bool
deny_string string
has_deny_string bool
}
pub fn (o &CMsgGSdeny) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

if o.has_edeny_reason {
res << vproto.pack_int32_field(o.edeny_reason, 2)
}

if o.has_deny_string {
res << vproto.pack_string_field(o.deny_string, 3)
}

return res
}

pub fn cmsggsdeny_unpack(buf []byte) ?CMsgGSdeny {
mut res := CMsgGSdeny{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

2 {
res.has_edeny_reason = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.edeny_reason = v
i = ii
}

3 {
res.has_deny_string = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.deny_string = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsdeny() CMsgGSdeny {
return CMsgGSdeny{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsdeny(o CMsgGSdeny, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsdeny(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSdeny) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggsdeny_unpack(v)?
return i, unpacked
}
pub struct CMsgGSkick {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
edeny_reason int
has_edeny_reason bool
}
pub fn (o &CMsgGSkick) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

if o.has_edeny_reason {
res << vproto.pack_int32_field(o.edeny_reason, 2)
}

return res
}

pub fn cmsggskick_unpack(buf []byte) ?CMsgGSkick {
mut res := CMsgGSkick{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

2 {
res.has_edeny_reason = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.edeny_reason = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggskick() CMsgGSkick {
return CMsgGSkick{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggskick(o CMsgGSkick, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggskick(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSkick) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggskick_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAuthList {
mut:
unknown_fields []vproto.UnknownField
pub mut:
tokens_left u32
has_tokens_left bool
last_request_seq u32
has_last_request_seq bool
last_request_seq_from_server u32
has_last_request_seq_from_server bool
tickets []CMsgAuthTicket
app_ids []u32
message_sequence u32
has_message_sequence bool
}
pub fn (o &CMsgClientAuthList) pack() []byte {
mut res := []byte{}
if o.has_tokens_left {
res << vproto.pack_uint32_field(o.tokens_left, 1)
}

if o.has_last_request_seq {
res << vproto.pack_uint32_field(o.last_request_seq, 2)
}

if o.has_last_request_seq_from_server {
res << vproto.pack_uint32_field(o.last_request_seq_from_server, 3)
}

// [packed=false]
for _, x in o.tickets {
res << zzz_vproto_internal_pack_cmsgauthticket(x, 4)
}

// [packed=false]
for _, x in o.app_ids {
res << vproto.pack_uint32_field(x, 5)
}

if o.has_message_sequence {
res << vproto.pack_uint32_field(o.message_sequence, 6)
}

return res
}

pub fn cmsgclientauthlist_unpack(buf []byte) ?CMsgClientAuthList {
mut res := CMsgClientAuthList{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_tokens_left = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.tokens_left = v
i = ii
}

2 {
res.has_last_request_seq = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_request_seq = v
i = ii
}

3 {
res.has_last_request_seq_from_server = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_request_seq_from_server = v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgauthticket(cur_buf, tag_wiretype.wire_type)?
res.tickets << v
i = ii
}

5 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_ids << v
i = ii
}

6 {
res.has_message_sequence = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.message_sequence = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientauthlist() CMsgClientAuthList {
return CMsgClientAuthList{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientauthlist(o CMsgClientAuthList, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientauthlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAuthList) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientauthlist_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAuthListAck {
mut:
unknown_fields []vproto.UnknownField
pub mut:
ticket_crc []u32
app_ids []u32
message_sequence u32
has_message_sequence bool
}
pub fn (o &CMsgClientAuthListAck) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.ticket_crc {
res << vproto.pack_uint32_field(x, 1)
}

// [packed=false]
for _, x in o.app_ids {
res << vproto.pack_uint32_field(x, 2)
}

if o.has_message_sequence {
res << vproto.pack_uint32_field(o.message_sequence, 3)
}

return res
}

pub fn cmsgclientauthlistack_unpack(buf []byte) ?CMsgClientAuthListAck {
mut res := CMsgClientAuthListAck{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ticket_crc << v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_ids << v
i = ii
}

3 {
res.has_message_sequence = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.message_sequence = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientauthlistack() CMsgClientAuthListAck {
return CMsgClientAuthListAck{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientauthlistack(o CMsgClientAuthListAck, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientauthlistack(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAuthListAck) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientauthlistack_unpack(v)?
return i, unpacked
}
pub struct CMsgClientLicenseListLicense {
mut:
unknown_fields []vproto.UnknownField
pub mut:
package_id u32
has_package_id bool
time_created u32
has_time_created bool
time_next_process u32
has_time_next_process bool
minute_limit int
has_minute_limit bool
minutes_used int
has_minutes_used bool
payment_method u32
has_payment_method bool
flags u32
has_flags bool
purchase_country_code string
has_purchase_country_code bool
license_type u32
has_license_type bool
territory_code int
has_territory_code bool
change_number int
has_change_number bool
owner_id u32
has_owner_id bool
initial_period u32
has_initial_period bool
initial_time_unit u32
has_initial_time_unit bool
renewal_period u32
has_renewal_period bool
renewal_time_unit u32
has_renewal_time_unit bool
access_token u64
has_access_token bool
master_package_id u32
has_master_package_id bool
}
pub fn (o &CMsgClientLicenseListLicense) pack() []byte {
mut res := []byte{}
if o.has_package_id {
res << vproto.pack_uint32_field(o.package_id, 1)
}

if o.has_time_created {
res << vproto.pack_32bit_field(o.time_created, 2)
}

if o.has_time_next_process {
res << vproto.pack_32bit_field(o.time_next_process, 3)
}

if o.has_minute_limit {
res << vproto.pack_int32_field(o.minute_limit, 4)
}

if o.has_minutes_used {
res << vproto.pack_int32_field(o.minutes_used, 5)
}

if o.has_payment_method {
res << vproto.pack_uint32_field(o.payment_method, 6)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 7)
}

if o.has_purchase_country_code {
res << vproto.pack_string_field(o.purchase_country_code, 8)
}

if o.has_license_type {
res << vproto.pack_uint32_field(o.license_type, 9)
}

if o.has_territory_code {
res << vproto.pack_int32_field(o.territory_code, 10)
}

if o.has_change_number {
res << vproto.pack_int32_field(o.change_number, 11)
}

if o.has_owner_id {
res << vproto.pack_uint32_field(o.owner_id, 12)
}

if o.has_initial_period {
res << vproto.pack_uint32_field(o.initial_period, 13)
}

if o.has_initial_time_unit {
res << vproto.pack_uint32_field(o.initial_time_unit, 14)
}

if o.has_renewal_period {
res << vproto.pack_uint32_field(o.renewal_period, 15)
}

if o.has_renewal_time_unit {
res << vproto.pack_uint32_field(o.renewal_time_unit, 16)
}

if o.has_access_token {
res << vproto.pack_uint64_field(o.access_token, 17)
}

if o.has_master_package_id {
res << vproto.pack_uint32_field(o.master_package_id, 18)
}

return res
}

pub fn cmsgclientlicenselistlicense_unpack(buf []byte) ?CMsgClientLicenseListLicense {
mut res := CMsgClientLicenseListLicense{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_package_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.package_id = v
i = ii
}

2 {
res.has_time_created = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.time_created = v
i = ii
}

3 {
res.has_time_next_process = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.time_next_process = v
i = ii
}

4 {
res.has_minute_limit = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.minute_limit = v
i = ii
}

5 {
res.has_minutes_used = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.minutes_used = v
i = ii
}

6 {
res.has_payment_method = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.payment_method = v
i = ii
}

7 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

8 {
res.has_purchase_country_code = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.purchase_country_code = v
i = ii
}

9 {
res.has_license_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.license_type = v
i = ii
}

10 {
res.has_territory_code = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.territory_code = v
i = ii
}

11 {
res.has_change_number = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.change_number = v
i = ii
}

12 {
res.has_owner_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.owner_id = v
i = ii
}

13 {
res.has_initial_period = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.initial_period = v
i = ii
}

14 {
res.has_initial_time_unit = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.initial_time_unit = v
i = ii
}

15 {
res.has_renewal_period = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.renewal_period = v
i = ii
}

16 {
res.has_renewal_time_unit = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.renewal_time_unit = v
i = ii
}

17 {
res.has_access_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.access_token = v
i = ii
}

18 {
res.has_master_package_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.master_package_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlicenselistlicense() CMsgClientLicenseListLicense {
return CMsgClientLicenseListLicense{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlicenselistlicense(o CMsgClientLicenseListLicense, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlicenselistlicense(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLicenseListLicense) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientlicenselistlicense_unpack(v)?
return i, unpacked
}
pub struct CMsgClientLicenseList {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
licenses []CMsgClientLicenseListLicense
}
pub fn (o &CMsgClientLicenseList) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

// [packed=false]
for _, x in o.licenses {
res << zzz_vproto_internal_pack_cmsgclientlicenselistlicense(x, 2)
}

return res
}

pub fn cmsgclientlicenselist_unpack(buf []byte) ?CMsgClientLicenseList {
mut res := CMsgClientLicenseList{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientlicenselistlicense(cur_buf, tag_wiretype.wire_type)?
res.licenses << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlicenselist() CMsgClientLicenseList {
return CMsgClientLicenseList{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlicenselist(o CMsgClientLicenseList, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlicenselist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLicenseList) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientlicenselist_unpack(v)?
return i, unpacked
}
pub struct CMsgClientLBssetScore {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
leaderboard_id int
has_leaderboard_id bool
score int
has_score bool
details []byte
has_details bool
upload_score_method int
has_upload_score_method bool
}
pub fn (o &CMsgClientLBssetScore) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_leaderboard_id {
res << vproto.pack_int32_field(o.leaderboard_id, 2)
}

if o.has_score {
res << vproto.pack_int32_field(o.score, 3)
}

if o.has_details {
res << vproto.pack_bytes_field(o.details, 4)
}

if o.has_upload_score_method {
res << vproto.pack_int32_field(o.upload_score_method, 5)
}

return res
}

pub fn cmsgclientlbssetscore_unpack(buf []byte) ?CMsgClientLBssetScore {
mut res := CMsgClientLBssetScore{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_leaderboard_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_id = v
i = ii
}

3 {
res.has_score = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.score = v
i = ii
}

4 {
res.has_details = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.details = v
i = ii
}

5 {
res.has_upload_score_method = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.upload_score_method = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbssetscore() CMsgClientLBssetScore {
return CMsgClientLBssetScore{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbssetscore(o CMsgClientLBssetScore, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbssetscore(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBssetScore) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientlbssetscore_unpack(v)?
return i, unpacked
}
pub struct CMsgClientLBssetScoreResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
leaderboard_entry_count int
has_leaderboard_entry_count bool
score_changed bool
has_score_changed bool
global_rank_previous int
has_global_rank_previous bool
global_rank_new int
has_global_rank_new bool
}
pub fn (o &CMsgClientLBssetScoreResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_leaderboard_entry_count {
res << vproto.pack_int32_field(o.leaderboard_entry_count, 2)
}

if o.has_score_changed {
res << vproto.pack_bool_field(o.score_changed, 3)
}

if o.has_global_rank_previous {
res << vproto.pack_int32_field(o.global_rank_previous, 4)
}

if o.has_global_rank_new {
res << vproto.pack_int32_field(o.global_rank_new, 5)
}

return res
}

pub fn cmsgclientlbssetscoreresponse_unpack(buf []byte) ?CMsgClientLBssetScoreResponse {
mut res := CMsgClientLBssetScoreResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_leaderboard_entry_count = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_entry_count = v
i = ii
}

3 {
res.has_score_changed = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.score_changed = v
i = ii
}

4 {
res.has_global_rank_previous = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.global_rank_previous = v
i = ii
}

5 {
res.has_global_rank_new = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.global_rank_new = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbssetscoreresponse() CMsgClientLBssetScoreResponse {
return CMsgClientLBssetScoreResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbssetscoreresponse(o CMsgClientLBssetScoreResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbssetscoreresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBssetScoreResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientlbssetscoreresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientLBssetUGc {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
leaderboard_id int
has_leaderboard_id bool
ugc_id u64
has_ugc_id bool
}
pub fn (o &CMsgClientLBssetUGc) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_leaderboard_id {
res << vproto.pack_int32_field(o.leaderboard_id, 2)
}

if o.has_ugc_id {
res << vproto.pack_64bit_field(o.ugc_id, 3)
}

return res
}

pub fn cmsgclientlbssetugc_unpack(buf []byte) ?CMsgClientLBssetUGc {
mut res := CMsgClientLBssetUGc{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_leaderboard_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_id = v
i = ii
}

3 {
res.has_ugc_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.ugc_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbssetugc() CMsgClientLBssetUGc {
return CMsgClientLBssetUGc{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbssetugc(o CMsgClientLBssetUGc, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbssetugc(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBssetUGc) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientlbssetugc_unpack(v)?
return i, unpacked
}
pub struct CMsgClientLBssetUGcresponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
}
pub fn (o &CMsgClientLBssetUGcresponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

return res
}

pub fn cmsgclientlbssetugcresponse_unpack(buf []byte) ?CMsgClientLBssetUGcresponse {
mut res := CMsgClientLBssetUGcresponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbssetugcresponse() CMsgClientLBssetUGcresponse {
return CMsgClientLBssetUGcresponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbssetugcresponse(o CMsgClientLBssetUGcresponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbssetugcresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBssetUGcresponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientlbssetugcresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientLBsfindOrCreateLB {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
leaderboard_sort_method int
has_leaderboard_sort_method bool
leaderboard_display_type int
has_leaderboard_display_type bool
create_if_not_found bool
has_create_if_not_found bool
leaderboard_name string
has_leaderboard_name bool
}
pub fn (o &CMsgClientLBsfindOrCreateLB) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_leaderboard_sort_method {
res << vproto.pack_int32_field(o.leaderboard_sort_method, 2)
}

if o.has_leaderboard_display_type {
res << vproto.pack_int32_field(o.leaderboard_display_type, 3)
}

if o.has_create_if_not_found {
res << vproto.pack_bool_field(o.create_if_not_found, 4)
}

if o.has_leaderboard_name {
res << vproto.pack_string_field(o.leaderboard_name, 5)
}

return res
}

pub fn cmsgclientlbsfindorcreatelb_unpack(buf []byte) ?CMsgClientLBsfindOrCreateLB {
mut res := CMsgClientLBsfindOrCreateLB{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_leaderboard_sort_method = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_sort_method = v
i = ii
}

3 {
res.has_leaderboard_display_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_display_type = v
i = ii
}

4 {
res.has_create_if_not_found = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.create_if_not_found = v
i = ii
}

5 {
res.has_leaderboard_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbsfindorcreatelb() CMsgClientLBsfindOrCreateLB {
return CMsgClientLBsfindOrCreateLB{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbsfindorcreatelb(o CMsgClientLBsfindOrCreateLB, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbsfindorcreatelb(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBsfindOrCreateLB) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientlbsfindorcreatelb_unpack(v)?
return i, unpacked
}
pub struct CMsgClientLBsfindOrCreateLBresponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
leaderboard_id int
has_leaderboard_id bool
leaderboard_entry_count int
has_leaderboard_entry_count bool
leaderboard_sort_method int
has_leaderboard_sort_method bool
leaderboard_display_type int
has_leaderboard_display_type bool
leaderboard_name string
has_leaderboard_name bool
}
pub fn (o &CMsgClientLBsfindOrCreateLBresponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_leaderboard_id {
res << vproto.pack_int32_field(o.leaderboard_id, 2)
}

if o.has_leaderboard_entry_count {
res << vproto.pack_int32_field(o.leaderboard_entry_count, 3)
}

if o.has_leaderboard_sort_method {
res << vproto.pack_int32_field(o.leaderboard_sort_method, 4)
}

if o.has_leaderboard_display_type {
res << vproto.pack_int32_field(o.leaderboard_display_type, 5)
}

if o.has_leaderboard_name {
res << vproto.pack_string_field(o.leaderboard_name, 6)
}

return res
}

pub fn cmsgclientlbsfindorcreatelbresponse_unpack(buf []byte) ?CMsgClientLBsfindOrCreateLBresponse {
mut res := CMsgClientLBsfindOrCreateLBresponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_leaderboard_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_id = v
i = ii
}

3 {
res.has_leaderboard_entry_count = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_entry_count = v
i = ii
}

4 {
res.has_leaderboard_sort_method = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_sort_method = v
i = ii
}

5 {
res.has_leaderboard_display_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_display_type = v
i = ii
}

6 {
res.has_leaderboard_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbsfindorcreatelbresponse() CMsgClientLBsfindOrCreateLBresponse {
return CMsgClientLBsfindOrCreateLBresponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbsfindorcreatelbresponse(o CMsgClientLBsfindOrCreateLBresponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbsfindorcreatelbresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBsfindOrCreateLBresponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientlbsfindorcreatelbresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientLBsgetLBentries {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id int
has_app_id bool
leaderboard_id int
has_leaderboard_id bool
range_start int
has_range_start bool
range_end int
has_range_end bool
leaderboard_data_request int
has_leaderboard_data_request bool
steamids []u64
}
pub fn (o &CMsgClientLBsgetLBentries) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_int32_field(o.app_id, 1)
}

if o.has_leaderboard_id {
res << vproto.pack_int32_field(o.leaderboard_id, 2)
}

if o.has_range_start {
res << vproto.pack_int32_field(o.range_start, 3)
}

if o.has_range_end {
res << vproto.pack_int32_field(o.range_end, 4)
}

if o.has_leaderboard_data_request {
res << vproto.pack_int32_field(o.leaderboard_data_request, 5)
}

// [packed=false]
for _, x in o.steamids {
res << vproto.pack_64bit_field(x, 6)
}

return res
}

pub fn cmsgclientlbsgetlbentries_unpack(buf []byte) ?CMsgClientLBsgetLBentries {
mut res := CMsgClientLBsgetLBentries{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_leaderboard_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_id = v
i = ii
}

3 {
res.has_range_start = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.range_start = v
i = ii
}

4 {
res.has_range_end = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.range_end = v
i = ii
}

5 {
res.has_leaderboard_data_request = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_data_request = v
i = ii
}

6 {
// [packed=false]
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbsgetlbentries() CMsgClientLBsgetLBentries {
return CMsgClientLBsgetLBentries{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbsgetlbentries(o CMsgClientLBsgetLBentries, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbsgetlbentries(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBsgetLBentries) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientlbsgetlbentries_unpack(v)?
return i, unpacked
}
pub struct CMsgClientLBsgetLBentriesResponseEntry {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id_user u64
has_steam_id_user bool
global_rank int
has_global_rank bool
score int
has_score bool
details []byte
has_details bool
ugc_id u64
has_ugc_id bool
}
pub fn (o &CMsgClientLBsgetLBentriesResponseEntry) pack() []byte {
mut res := []byte{}
if o.has_steam_id_user {
res << vproto.pack_64bit_field(o.steam_id_user, 1)
}

if o.has_global_rank {
res << vproto.pack_int32_field(o.global_rank, 2)
}

if o.has_score {
res << vproto.pack_int32_field(o.score, 3)
}

if o.has_details {
res << vproto.pack_bytes_field(o.details, 4)
}

if o.has_ugc_id {
res << vproto.pack_64bit_field(o.ugc_id, 5)
}

return res
}

pub fn cmsgclientlbsgetlbentriesresponseentry_unpack(buf []byte) ?CMsgClientLBsgetLBentriesResponseEntry {
mut res := CMsgClientLBsgetLBentriesResponseEntry{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id_user = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_user = v
i = ii
}

2 {
res.has_global_rank = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.global_rank = v
i = ii
}

3 {
res.has_score = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.score = v
i = ii
}

4 {
res.has_details = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.details = v
i = ii
}

5 {
res.has_ugc_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.ugc_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbsgetlbentriesresponseentry() CMsgClientLBsgetLBentriesResponseEntry {
return CMsgClientLBsgetLBentriesResponseEntry{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbsgetlbentriesresponseentry(o CMsgClientLBsgetLBentriesResponseEntry, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbsgetlbentriesresponseentry(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBsgetLBentriesResponseEntry) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientlbsgetlbentriesresponseentry_unpack(v)?
return i, unpacked
}
pub struct CMsgClientLBsgetLBentriesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
leaderboard_entry_count int
has_leaderboard_entry_count bool
entries []CMsgClientLBsgetLBentriesResponseEntry
}
pub fn (o &CMsgClientLBsgetLBentriesResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_leaderboard_entry_count {
res << vproto.pack_int32_field(o.leaderboard_entry_count, 2)
}

// [packed=false]
for _, x in o.entries {
res << zzz_vproto_internal_pack_cmsgclientlbsgetlbentriesresponseentry(x, 3)
}

return res
}

pub fn cmsgclientlbsgetlbentriesresponse_unpack(buf []byte) ?CMsgClientLBsgetLBentriesResponse {
mut res := CMsgClientLBsgetLBentriesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_leaderboard_entry_count = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.leaderboard_entry_count = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientlbsgetlbentriesresponseentry(cur_buf, tag_wiretype.wire_type)?
res.entries << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbsgetlbentriesresponse() CMsgClientLBsgetLBentriesResponse {
return CMsgClientLBsgetLBentriesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbsgetlbentriesresponse(o CMsgClientLBsgetLBentriesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbsgetlbentriesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBsgetLBentriesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientlbsgetlbentriesresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAppMinutesPlayedDataAppMinutesPlayedData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
forever int
has_forever bool
last_two_weeks int
has_last_two_weeks bool
}
pub fn (o &CMsgClientAppMinutesPlayedDataAppMinutesPlayedData) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_forever {
res << vproto.pack_int32_field(o.forever, 2)
}

if o.has_last_two_weeks {
res << vproto.pack_int32_field(o.last_two_weeks, 3)
}

return res
}

pub fn cmsgclientappminutesplayeddataappminutesplayeddata_unpack(buf []byte) ?CMsgClientAppMinutesPlayedDataAppMinutesPlayedData {
mut res := CMsgClientAppMinutesPlayedDataAppMinutesPlayedData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_forever = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.forever = v
i = ii
}

3 {
res.has_last_two_weeks = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.last_two_weeks = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappminutesplayeddataappminutesplayeddata() CMsgClientAppMinutesPlayedDataAppMinutesPlayedData {
return CMsgClientAppMinutesPlayedDataAppMinutesPlayedData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappminutesplayeddataappminutesplayeddata(o CMsgClientAppMinutesPlayedDataAppMinutesPlayedData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappminutesplayeddataappminutesplayeddata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppMinutesPlayedDataAppMinutesPlayedData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientappminutesplayeddataappminutesplayeddata_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAppMinutesPlayedData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
minutes_played []CMsgClientAppMinutesPlayedDataAppMinutesPlayedData
}
pub fn (o &CMsgClientAppMinutesPlayedData) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.minutes_played {
res << zzz_vproto_internal_pack_cmsgclientappminutesplayeddataappminutesplayeddata(x, 1)
}

return res
}

pub fn cmsgclientappminutesplayeddata_unpack(buf []byte) ?CMsgClientAppMinutesPlayedData {
mut res := CMsgClientAppMinutesPlayedData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientappminutesplayeddataappminutesplayeddata(cur_buf, tag_wiretype.wire_type)?
res.minutes_played << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappminutesplayeddata() CMsgClientAppMinutesPlayedData {
return CMsgClientAppMinutesPlayedData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappminutesplayeddata(o CMsgClientAppMinutesPlayedData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappminutesplayeddata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppMinutesPlayedData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientappminutesplayeddata_unpack(v)?
return i, unpacked
}
pub struct CMsgClientIsLimitedAccount {
mut:
unknown_fields []vproto.UnknownField
pub mut:
bis_limited_account bool
has_bis_limited_account bool
bis_community_banned bool
has_bis_community_banned bool
bis_locked_account bool
has_bis_locked_account bool
bis_limited_account_allowed_to_invite_friends bool
has_bis_limited_account_allowed_to_invite_friends bool
}
pub fn (o &CMsgClientIsLimitedAccount) pack() []byte {
mut res := []byte{}
if o.has_bis_limited_account {
res << vproto.pack_bool_field(o.bis_limited_account, 1)
}

if o.has_bis_community_banned {
res << vproto.pack_bool_field(o.bis_community_banned, 2)
}

if o.has_bis_locked_account {
res << vproto.pack_bool_field(o.bis_locked_account, 3)
}

if o.has_bis_limited_account_allowed_to_invite_friends {
res << vproto.pack_bool_field(o.bis_limited_account_allowed_to_invite_friends, 4)
}

return res
}

pub fn cmsgclientislimitedaccount_unpack(buf []byte) ?CMsgClientIsLimitedAccount {
mut res := CMsgClientIsLimitedAccount{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_bis_limited_account = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.bis_limited_account = v
i = ii
}

2 {
res.has_bis_community_banned = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.bis_community_banned = v
i = ii
}

3 {
res.has_bis_locked_account = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.bis_locked_account = v
i = ii
}

4 {
res.has_bis_limited_account_allowed_to_invite_friends = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.bis_limited_account_allowed_to_invite_friends = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientislimitedaccount() CMsgClientIsLimitedAccount {
return CMsgClientIsLimitedAccount{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientislimitedaccount(o CMsgClientIsLimitedAccount, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientislimitedaccount(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientIsLimitedAccount) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientislimitedaccount_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestedClientStatsStatsToSend {
mut:
unknown_fields []vproto.UnknownField
pub mut:
client_stat u32
has_client_stat bool
stat_aggregate_method u32
has_stat_aggregate_method bool
}
pub fn (o &CMsgClientRequestedClientStatsStatsToSend) pack() []byte {
mut res := []byte{}
if o.has_client_stat {
res << vproto.pack_uint32_field(o.client_stat, 1)
}

if o.has_stat_aggregate_method {
res << vproto.pack_uint32_field(o.stat_aggregate_method, 2)
}

return res
}

pub fn cmsgclientrequestedclientstatsstatstosend_unpack(buf []byte) ?CMsgClientRequestedClientStatsStatsToSend {
mut res := CMsgClientRequestedClientStatsStatsToSend{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_client_stat = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.client_stat = v
i = ii
}

2 {
res.has_stat_aggregate_method = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.stat_aggregate_method = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestedclientstatsstatstosend() CMsgClientRequestedClientStatsStatsToSend {
return CMsgClientRequestedClientStatsStatsToSend{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestedclientstatsstatstosend(o CMsgClientRequestedClientStatsStatsToSend, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestedclientstatsstatstosend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestedClientStatsStatsToSend) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestedclientstatsstatstosend_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestedClientStats {
mut:
unknown_fields []vproto.UnknownField
pub mut:
stats_to_send []CMsgClientRequestedClientStatsStatsToSend
}
pub fn (o &CMsgClientRequestedClientStats) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.stats_to_send {
res << zzz_vproto_internal_pack_cmsgclientrequestedclientstatsstatstosend(x, 1)
}

return res
}

pub fn cmsgclientrequestedclientstats_unpack(buf []byte) ?CMsgClientRequestedClientStats {
mut res := CMsgClientRequestedClientStats{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientrequestedclientstatsstatstosend(cur_buf, tag_wiretype.wire_type)?
res.stats_to_send << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestedclientstats() CMsgClientRequestedClientStats {
return CMsgClientRequestedClientStats{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestedclientstats(o CMsgClientRequestedClientStats, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestedclientstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestedClientStats) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestedclientstats_unpack(v)?
return i, unpacked
}
pub struct CMsgClientStat2StatDetail {
mut:
unknown_fields []vproto.UnknownField
pub mut:
client_stat u32
has_client_stat bool
ll_value i64
has_ll_value bool
time_of_day u32
has_time_of_day bool
cell_id u32
has_cell_id bool
depot_id u32
has_depot_id bool
app_id u32
has_app_id bool
}
pub fn (o &CMsgClientStat2StatDetail) pack() []byte {
mut res := []byte{}
if o.has_client_stat {
res << vproto.pack_uint32_field(o.client_stat, 1)
}

if o.has_ll_value {
res << vproto.pack_int64_field(o.ll_value, 2)
}

if o.has_time_of_day {
res << vproto.pack_uint32_field(o.time_of_day, 3)
}

if o.has_cell_id {
res << vproto.pack_uint32_field(o.cell_id, 4)
}

if o.has_depot_id {
res << vproto.pack_uint32_field(o.depot_id, 5)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 6)
}

return res
}

pub fn cmsgclientstat2statdetail_unpack(buf []byte) ?CMsgClientStat2StatDetail {
mut res := CMsgClientStat2StatDetail{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_client_stat = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.client_stat = v
i = ii
}

2 {
res.has_ll_value = true
ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
res.ll_value = v
i = ii
}

3 {
res.has_time_of_day = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_of_day = v
i = ii
}

4 {
res.has_cell_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cell_id = v
i = ii
}

5 {
res.has_depot_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.depot_id = v
i = ii
}

6 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstat2statdetail() CMsgClientStat2StatDetail {
return CMsgClientStat2StatDetail{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstat2statdetail(o CMsgClientStat2StatDetail, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstat2statdetail(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStat2StatDetail) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientstat2statdetail_unpack(v)?
return i, unpacked
}
pub struct CMsgClientStat2 {
mut:
unknown_fields []vproto.UnknownField
pub mut:
stat_detail []CMsgClientStat2StatDetail
}
pub fn (o &CMsgClientStat2) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.stat_detail {
res << zzz_vproto_internal_pack_cmsgclientstat2statdetail(x, 1)
}

return res
}

pub fn cmsgclientstat2_unpack(buf []byte) ?CMsgClientStat2 {
mut res := CMsgClientStat2{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientstat2statdetail(cur_buf, tag_wiretype.wire_type)?
res.stat_detail << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstat2() CMsgClientStat2 {
return CMsgClientStat2{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstat2(o CMsgClientStat2, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstat2(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStat2) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientstat2_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMssetRatelimitPolicyOnClient {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
enable_rate_limits bool
has_enable_rate_limits bool
seconds_per_message int
has_seconds_per_message bool
milliseconds_per_data_update int
has_milliseconds_per_data_update bool
}
pub fn (o &CMsgClientMMssetRatelimitPolicyOnClient) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_enable_rate_limits {
res << vproto.pack_bool_field(o.enable_rate_limits, 2)
}

if o.has_seconds_per_message {
res << vproto.pack_int32_field(o.seconds_per_message, 3)
}

if o.has_milliseconds_per_data_update {
res << vproto.pack_int32_field(o.milliseconds_per_data_update, 4)
}

return res
}

pub fn cmsgclientmmssetratelimitpolicyonclient_unpack(buf []byte) ?CMsgClientMMssetRatelimitPolicyOnClient {
mut res := CMsgClientMMssetRatelimitPolicyOnClient{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_enable_rate_limits = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.enable_rate_limits = v
i = ii
}

3 {
res.has_seconds_per_message = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_per_message = v
i = ii
}

4 {
res.has_milliseconds_per_data_update = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.milliseconds_per_data_update = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetratelimitpolicyonclient() CMsgClientMMssetRatelimitPolicyOnClient {
return CMsgClientMMssetRatelimitPolicyOnClient{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetratelimitpolicyonclient(o CMsgClientMMssetRatelimitPolicyOnClient, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetratelimitpolicyonclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMssetRatelimitPolicyOnClient) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmssetratelimitpolicyonclient_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMscreateLobby {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
max_members int
has_max_members bool
lobby_type int
has_lobby_type bool
lobby_flags int
has_lobby_flags bool
cell_id u32
has_cell_id bool
deprecated_public_ip u32
has_deprecated_public_ip bool
metadata []byte
has_metadata bool
persona_name_owner string
has_persona_name_owner bool
public_ip CMsgIPaddress
has_public_ip bool
}
pub fn (o &CMsgClientMMscreateLobby) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_max_members {
res << vproto.pack_int32_field(o.max_members, 2)
}

if o.has_lobby_type {
res << vproto.pack_int32_field(o.lobby_type, 3)
}

if o.has_lobby_flags {
res << vproto.pack_int32_field(o.lobby_flags, 4)
}

if o.has_cell_id {
res << vproto.pack_uint32_field(o.cell_id, 5)
}

if o.has_deprecated_public_ip {
res << vproto.pack_uint32_field(o.deprecated_public_ip, 6)
}

if o.has_metadata {
res << vproto.pack_bytes_field(o.metadata, 7)
}

if o.has_persona_name_owner {
res << vproto.pack_string_field(o.persona_name_owner, 8)
}

if o.has_public_ip {
res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 9)
}

return res
}

pub fn cmsgclientmmscreatelobby_unpack(buf []byte) ?CMsgClientMMscreateLobby {
mut res := CMsgClientMMscreateLobby{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_max_members = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.max_members = v
i = ii
}

3 {
res.has_lobby_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.lobby_type = v
i = ii
}

4 {
res.has_lobby_flags = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.lobby_flags = v
i = ii
}

5 {
res.has_cell_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cell_id = v
i = ii
}

6 {
res.has_deprecated_public_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_public_ip = v
i = ii
}

7 {
res.has_metadata = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.metadata = v
i = ii
}

8 {
res.has_persona_name_owner = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.persona_name_owner = v
i = ii
}

9 {
res.has_public_ip = true
ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
res.public_ip = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmscreatelobby() CMsgClientMMscreateLobby {
return CMsgClientMMscreateLobby{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmscreatelobby(o CMsgClientMMscreateLobby, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmscreatelobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMscreateLobby) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmscreatelobby_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMscreateLobbyResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
eresult int
has_eresult bool
}
pub fn (o &CMsgClientMMscreateLobbyResponse) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 3)
}

return res
}

pub fn cmsgclientmmscreatelobbyresponse_unpack(buf []byte) ?CMsgClientMMscreateLobbyResponse {
mut res := CMsgClientMMscreateLobbyResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmscreatelobbyresponse() CMsgClientMMscreateLobbyResponse {
return CMsgClientMMscreateLobbyResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmscreatelobbyresponse(o CMsgClientMMscreateLobbyResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmscreatelobbyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMscreateLobbyResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmscreatelobbyresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsjoinLobby {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
persona_name string
has_persona_name bool
}
pub fn (o &CMsgClientMMsjoinLobby) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_persona_name {
res << vproto.pack_string_field(o.persona_name, 3)
}

return res
}

pub fn cmsgclientmmsjoinlobby_unpack(buf []byte) ?CMsgClientMMsjoinLobby {
mut res := CMsgClientMMsjoinLobby{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_persona_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.persona_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsjoinlobby() CMsgClientMMsjoinLobby {
return CMsgClientMMsjoinLobby{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsjoinlobby(o CMsgClientMMsjoinLobby, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsjoinlobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsjoinLobby) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsjoinlobby_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsjoinLobbyResponseMember {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
persona_name string
has_persona_name bool
metadata []byte
has_metadata bool
}
pub fn (o &CMsgClientMMsjoinLobbyResponseMember) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

if o.has_persona_name {
res << vproto.pack_string_field(o.persona_name, 2)
}

if o.has_metadata {
res << vproto.pack_bytes_field(o.metadata, 3)
}

return res
}

pub fn cmsgclientmmsjoinlobbyresponsemember_unpack(buf []byte) ?CMsgClientMMsjoinLobbyResponseMember {
mut res := CMsgClientMMsjoinLobbyResponseMember{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

2 {
res.has_persona_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.persona_name = v
i = ii
}

3 {
res.has_metadata = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.metadata = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsjoinlobbyresponsemember() CMsgClientMMsjoinLobbyResponseMember {
return CMsgClientMMsjoinLobbyResponseMember{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsjoinlobbyresponsemember(o CMsgClientMMsjoinLobbyResponseMember, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsjoinlobbyresponsemember(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsjoinLobbyResponseMember) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsjoinlobbyresponsemember_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsjoinLobbyResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
chat_room_enter_response int
has_chat_room_enter_response bool
max_members int
has_max_members bool
lobby_type int
has_lobby_type bool
lobby_flags int
has_lobby_flags bool
steam_id_owner u64
has_steam_id_owner bool
metadata []byte
has_metadata bool
members []CMsgClientMMsjoinLobbyResponseMember
}
pub fn (o &CMsgClientMMsjoinLobbyResponse) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_chat_room_enter_response {
res << vproto.pack_int32_field(o.chat_room_enter_response, 3)
}

if o.has_max_members {
res << vproto.pack_int32_field(o.max_members, 4)
}

if o.has_lobby_type {
res << vproto.pack_int32_field(o.lobby_type, 5)
}

if o.has_lobby_flags {
res << vproto.pack_int32_field(o.lobby_flags, 6)
}

if o.has_steam_id_owner {
res << vproto.pack_64bit_field(o.steam_id_owner, 7)
}

if o.has_metadata {
res << vproto.pack_bytes_field(o.metadata, 8)
}

// [packed=false]
for _, x in o.members {
res << zzz_vproto_internal_pack_cmsgclientmmsjoinlobbyresponsemember(x, 9)
}

return res
}

pub fn cmsgclientmmsjoinlobbyresponse_unpack(buf []byte) ?CMsgClientMMsjoinLobbyResponse {
mut res := CMsgClientMMsjoinLobbyResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_chat_room_enter_response = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.chat_room_enter_response = v
i = ii
}

4 {
res.has_max_members = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.max_members = v
i = ii
}

5 {
res.has_lobby_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.lobby_type = v
i = ii
}

6 {
res.has_lobby_flags = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.lobby_flags = v
i = ii
}

7 {
res.has_steam_id_owner = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_owner = v
i = ii
}

8 {
res.has_metadata = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.metadata = v
i = ii
}

9 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientmmsjoinlobbyresponsemember(cur_buf, tag_wiretype.wire_type)?
res.members << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsjoinlobbyresponse() CMsgClientMMsjoinLobbyResponse {
return CMsgClientMMsjoinLobbyResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsjoinlobbyresponse(o CMsgClientMMsjoinLobbyResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsjoinlobbyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsjoinLobbyResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsjoinlobbyresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsleaveLobby {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
}
pub fn (o &CMsgClientMMsleaveLobby) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

return res
}

pub fn cmsgclientmmsleavelobby_unpack(buf []byte) ?CMsgClientMMsleaveLobby {
mut res := CMsgClientMMsleaveLobby{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsleavelobby() CMsgClientMMsleaveLobby {
return CMsgClientMMsleaveLobby{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsleavelobby(o CMsgClientMMsleaveLobby, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsleavelobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsleaveLobby) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsleavelobby_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsleaveLobbyResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
eresult int
has_eresult bool
}
pub fn (o &CMsgClientMMsleaveLobbyResponse) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 3)
}

return res
}

pub fn cmsgclientmmsleavelobbyresponse_unpack(buf []byte) ?CMsgClientMMsleaveLobbyResponse {
mut res := CMsgClientMMsleaveLobbyResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsleavelobbyresponse() CMsgClientMMsleaveLobbyResponse {
return CMsgClientMMsleaveLobbyResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsleavelobbyresponse(o CMsgClientMMsleaveLobbyResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsleavelobbyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsleaveLobbyResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsleavelobbyresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsgetLobbyListFilter {
mut:
unknown_fields []vproto.UnknownField
pub mut:
key string
has_key bool
value string
has_value bool
comparision int
has_comparision bool
filter_type int
has_filter_type bool
}
pub fn (o &CMsgClientMMsgetLobbyListFilter) pack() []byte {
mut res := []byte{}
if o.has_key {
res << vproto.pack_string_field(o.key, 1)
}

if o.has_value {
res << vproto.pack_string_field(o.value, 2)
}

if o.has_comparision {
res << vproto.pack_int32_field(o.comparision, 3)
}

if o.has_filter_type {
res << vproto.pack_int32_field(o.filter_type, 4)
}

return res
}

pub fn cmsgclientmmsgetlobbylistfilter_unpack(buf []byte) ?CMsgClientMMsgetLobbyListFilter {
mut res := CMsgClientMMsgetLobbyListFilter{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_key = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.key = v
i = ii
}

2 {
res.has_value = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.value = v
i = ii
}

3 {
res.has_comparision = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.comparision = v
i = ii
}

4 {
res.has_filter_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.filter_type = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbylistfilter() CMsgClientMMsgetLobbyListFilter {
return CMsgClientMMsgetLobbyListFilter{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbylistfilter(o CMsgClientMMsgetLobbyListFilter, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylistfilter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsgetLobbyListFilter) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsgetlobbylistfilter_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsgetLobbyList {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
num_lobbies_requested int
has_num_lobbies_requested bool
cell_id u32
has_cell_id bool
deprecated_public_ip u32
has_deprecated_public_ip bool
filters []CMsgClientMMsgetLobbyListFilter
public_ip CMsgIPaddress
has_public_ip bool
}
pub fn (o &CMsgClientMMsgetLobbyList) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_num_lobbies_requested {
res << vproto.pack_int32_field(o.num_lobbies_requested, 3)
}

if o.has_cell_id {
res << vproto.pack_uint32_field(o.cell_id, 4)
}

if o.has_deprecated_public_ip {
res << vproto.pack_uint32_field(o.deprecated_public_ip, 5)
}

// [packed=false]
for _, x in o.filters {
res << zzz_vproto_internal_pack_cmsgclientmmsgetlobbylistfilter(x, 6)
}

if o.has_public_ip {
res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 7)
}

return res
}

pub fn cmsgclientmmsgetlobbylist_unpack(buf []byte) ?CMsgClientMMsgetLobbyList {
mut res := CMsgClientMMsgetLobbyList{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

3 {
res.has_num_lobbies_requested = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.num_lobbies_requested = v
i = ii
}

4 {
res.has_cell_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cell_id = v
i = ii
}

5 {
res.has_deprecated_public_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_public_ip = v
i = ii
}

6 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylistfilter(cur_buf, tag_wiretype.wire_type)?
res.filters << v
i = ii
}

7 {
res.has_public_ip = true
ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
res.public_ip = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbylist() CMsgClientMMsgetLobbyList {
return CMsgClientMMsgetLobbyList{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbylist(o CMsgClientMMsgetLobbyList, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsgetLobbyList) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsgetlobbylist_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsgetLobbyListResponseLobby {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
max_members int
has_max_members bool
lobby_type int
has_lobby_type bool
lobby_flags int
has_lobby_flags bool
metadata []byte
has_metadata bool
num_members int
has_num_members bool
distance f32
has_distance bool
weight i64
has_weight bool
}
pub fn (o &CMsgClientMMsgetLobbyListResponseLobby) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

if o.has_max_members {
res << vproto.pack_int32_field(o.max_members, 2)
}

if o.has_lobby_type {
res << vproto.pack_int32_field(o.lobby_type, 3)
}

if o.has_lobby_flags {
res << vproto.pack_int32_field(o.lobby_flags, 4)
}

if o.has_metadata {
res << vproto.pack_bytes_field(o.metadata, 5)
}

if o.has_num_members {
res << vproto.pack_int32_field(o.num_members, 6)
}

if o.has_distance {
res << vproto.pack_float_field(o.distance, 7)
}

if o.has_weight {
res << vproto.pack_int64_field(o.weight, 8)
}

return res
}

pub fn cmsgclientmmsgetlobbylistresponselobby_unpack(buf []byte) ?CMsgClientMMsgetLobbyListResponseLobby {
mut res := CMsgClientMMsgetLobbyListResponseLobby{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

2 {
res.has_max_members = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.max_members = v
i = ii
}

3 {
res.has_lobby_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.lobby_type = v
i = ii
}

4 {
res.has_lobby_flags = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.lobby_flags = v
i = ii
}

5 {
res.has_metadata = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.metadata = v
i = ii
}

6 {
res.has_num_members = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.num_members = v
i = ii
}

7 {
res.has_distance = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.distance = v
i = ii
}

8 {
res.has_weight = true
ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
res.weight = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbylistresponselobby() CMsgClientMMsgetLobbyListResponseLobby {
return CMsgClientMMsgetLobbyListResponseLobby{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbylistresponselobby(o CMsgClientMMsgetLobbyListResponseLobby, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylistresponselobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsgetLobbyListResponseLobby) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsgetlobbylistresponselobby_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsgetLobbyListResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
eresult int
has_eresult bool
lobbies []CMsgClientMMsgetLobbyListResponseLobby
}
pub fn (o &CMsgClientMMsgetLobbyListResponse) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 3)
}

// [packed=false]
for _, x in o.lobbies {
res << zzz_vproto_internal_pack_cmsgclientmmsgetlobbylistresponselobby(x, 4)
}

return res
}

pub fn cmsgclientmmsgetlobbylistresponse_unpack(buf []byte) ?CMsgClientMMsgetLobbyListResponse {
mut res := CMsgClientMMsgetLobbyListResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

3 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylistresponselobby(cur_buf, tag_wiretype.wire_type)?
res.lobbies << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbylistresponse() CMsgClientMMsgetLobbyListResponse {
return CMsgClientMMsgetLobbyListResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbylistresponse(o CMsgClientMMsgetLobbyListResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsgetLobbyListResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsgetlobbylistresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMssetLobbyData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
steam_id_member u64
has_steam_id_member bool
max_members int
has_max_members bool
lobby_type int
has_lobby_type bool
lobby_flags int
has_lobby_flags bool
metadata []byte
has_metadata bool
}
pub fn (o &CMsgClientMMssetLobbyData) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_steam_id_member {
res << vproto.pack_64bit_field(o.steam_id_member, 3)
}

if o.has_max_members {
res << vproto.pack_int32_field(o.max_members, 4)
}

if o.has_lobby_type {
res << vproto.pack_int32_field(o.lobby_type, 5)
}

if o.has_lobby_flags {
res << vproto.pack_int32_field(o.lobby_flags, 6)
}

if o.has_metadata {
res << vproto.pack_bytes_field(o.metadata, 7)
}

return res
}

pub fn cmsgclientmmssetlobbydata_unpack(buf []byte) ?CMsgClientMMssetLobbyData {
mut res := CMsgClientMMssetLobbyData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_steam_id_member = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_member = v
i = ii
}

4 {
res.has_max_members = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.max_members = v
i = ii
}

5 {
res.has_lobby_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.lobby_type = v
i = ii
}

6 {
res.has_lobby_flags = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.lobby_flags = v
i = ii
}

7 {
res.has_metadata = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.metadata = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbydata() CMsgClientMMssetLobbyData {
return CMsgClientMMssetLobbyData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbydata(o CMsgClientMMssetLobbyData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbydata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMssetLobbyData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmssetlobbydata_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMssetLobbyDataResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
eresult int
has_eresult bool
}
pub fn (o &CMsgClientMMssetLobbyDataResponse) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 3)
}

return res
}

pub fn cmsgclientmmssetlobbydataresponse_unpack(buf []byte) ?CMsgClientMMssetLobbyDataResponse {
mut res := CMsgClientMMssetLobbyDataResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbydataresponse() CMsgClientMMssetLobbyDataResponse {
return CMsgClientMMssetLobbyDataResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbydataresponse(o CMsgClientMMssetLobbyDataResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbydataresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMssetLobbyDataResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmssetlobbydataresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsgetLobbyData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
}
pub fn (o &CMsgClientMMsgetLobbyData) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

return res
}

pub fn cmsgclientmmsgetlobbydata_unpack(buf []byte) ?CMsgClientMMsgetLobbyData {
mut res := CMsgClientMMsgetLobbyData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbydata() CMsgClientMMsgetLobbyData {
return CMsgClientMMsgetLobbyData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbydata(o CMsgClientMMsgetLobbyData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbydata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsgetLobbyData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsgetlobbydata_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMslobbyDataMember {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
persona_name string
has_persona_name bool
metadata []byte
has_metadata bool
}
pub fn (o &CMsgClientMMslobbyDataMember) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

if o.has_persona_name {
res << vproto.pack_string_field(o.persona_name, 2)
}

if o.has_metadata {
res << vproto.pack_bytes_field(o.metadata, 3)
}

return res
}

pub fn cmsgclientmmslobbydatamember_unpack(buf []byte) ?CMsgClientMMslobbyDataMember {
mut res := CMsgClientMMslobbyDataMember{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

2 {
res.has_persona_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.persona_name = v
i = ii
}

3 {
res.has_metadata = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.metadata = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmslobbydatamember() CMsgClientMMslobbyDataMember {
return CMsgClientMMslobbyDataMember{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmslobbydatamember(o CMsgClientMMslobbyDataMember, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmslobbydatamember(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMslobbyDataMember) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmslobbydatamember_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMslobbyData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
num_members int
has_num_members bool
max_members int
has_max_members bool
lobby_type int
has_lobby_type bool
lobby_flags int
has_lobby_flags bool
steam_id_owner u64
has_steam_id_owner bool
metadata []byte
has_metadata bool
members []CMsgClientMMslobbyDataMember
lobby_cellid u32
has_lobby_cellid bool
owner_should_accept_changes bool
has_owner_should_accept_changes bool
}
pub fn (o &CMsgClientMMslobbyData) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_num_members {
res << vproto.pack_int32_field(o.num_members, 3)
}

if o.has_max_members {
res << vproto.pack_int32_field(o.max_members, 4)
}

if o.has_lobby_type {
res << vproto.pack_int32_field(o.lobby_type, 5)
}

if o.has_lobby_flags {
res << vproto.pack_int32_field(o.lobby_flags, 6)
}

if o.has_steam_id_owner {
res << vproto.pack_64bit_field(o.steam_id_owner, 7)
}

if o.has_metadata {
res << vproto.pack_bytes_field(o.metadata, 8)
}

// [packed=false]
for _, x in o.members {
res << zzz_vproto_internal_pack_cmsgclientmmslobbydatamember(x, 9)
}

if o.has_lobby_cellid {
res << vproto.pack_uint32_field(o.lobby_cellid, 10)
}

if o.has_owner_should_accept_changes {
res << vproto.pack_bool_field(o.owner_should_accept_changes, 11)
}

return res
}

pub fn cmsgclientmmslobbydata_unpack(buf []byte) ?CMsgClientMMslobbyData {
mut res := CMsgClientMMslobbyData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_num_members = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.num_members = v
i = ii
}

4 {
res.has_max_members = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.max_members = v
i = ii
}

5 {
res.has_lobby_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.lobby_type = v
i = ii
}

6 {
res.has_lobby_flags = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.lobby_flags = v
i = ii
}

7 {
res.has_steam_id_owner = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_owner = v
i = ii
}

8 {
res.has_metadata = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.metadata = v
i = ii
}

9 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientmmslobbydatamember(cur_buf, tag_wiretype.wire_type)?
res.members << v
i = ii
}

10 {
res.has_lobby_cellid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.lobby_cellid = v
i = ii
}

11 {
res.has_owner_should_accept_changes = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.owner_should_accept_changes = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmslobbydata() CMsgClientMMslobbyData {
return CMsgClientMMslobbyData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmslobbydata(o CMsgClientMMslobbyData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmslobbydata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMslobbyData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmslobbydata_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMssendLobbyChatMsg {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
steam_id_target u64
has_steam_id_target bool
lobby_message []byte
has_lobby_message bool
}
pub fn (o &CMsgClientMMssendLobbyChatMsg) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_steam_id_target {
res << vproto.pack_64bit_field(o.steam_id_target, 3)
}

if o.has_lobby_message {
res << vproto.pack_bytes_field(o.lobby_message, 4)
}

return res
}

pub fn cmsgclientmmssendlobbychatmsg_unpack(buf []byte) ?CMsgClientMMssendLobbyChatMsg {
mut res := CMsgClientMMssendLobbyChatMsg{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_steam_id_target = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_target = v
i = ii
}

4 {
res.has_lobby_message = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.lobby_message = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssendlobbychatmsg() CMsgClientMMssendLobbyChatMsg {
return CMsgClientMMssendLobbyChatMsg{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssendlobbychatmsg(o CMsgClientMMssendLobbyChatMsg, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssendlobbychatmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMssendLobbyChatMsg) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmssendlobbychatmsg_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMslobbyChatMsg {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
steam_id_sender u64
has_steam_id_sender bool
lobby_message []byte
has_lobby_message bool
}
pub fn (o &CMsgClientMMslobbyChatMsg) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_steam_id_sender {
res << vproto.pack_64bit_field(o.steam_id_sender, 3)
}

if o.has_lobby_message {
res << vproto.pack_bytes_field(o.lobby_message, 4)
}

return res
}

pub fn cmsgclientmmslobbychatmsg_unpack(buf []byte) ?CMsgClientMMslobbyChatMsg {
mut res := CMsgClientMMslobbyChatMsg{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_steam_id_sender = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_sender = v
i = ii
}

4 {
res.has_lobby_message = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.lobby_message = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmslobbychatmsg() CMsgClientMMslobbyChatMsg {
return CMsgClientMMslobbyChatMsg{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmslobbychatmsg(o CMsgClientMMslobbyChatMsg, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmslobbychatmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMslobbyChatMsg) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmslobbychatmsg_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMssetLobbyOwner {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
steam_id_new_owner u64
has_steam_id_new_owner bool
}
pub fn (o &CMsgClientMMssetLobbyOwner) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_steam_id_new_owner {
res << vproto.pack_64bit_field(o.steam_id_new_owner, 3)
}

return res
}

pub fn cmsgclientmmssetlobbyowner_unpack(buf []byte) ?CMsgClientMMssetLobbyOwner {
mut res := CMsgClientMMssetLobbyOwner{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_steam_id_new_owner = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_new_owner = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbyowner() CMsgClientMMssetLobbyOwner {
return CMsgClientMMssetLobbyOwner{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbyowner(o CMsgClientMMssetLobbyOwner, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbyowner(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMssetLobbyOwner) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmssetlobbyowner_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMssetLobbyOwnerResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
eresult int
has_eresult bool
}
pub fn (o &CMsgClientMMssetLobbyOwnerResponse) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 3)
}

return res
}

pub fn cmsgclientmmssetlobbyownerresponse_unpack(buf []byte) ?CMsgClientMMssetLobbyOwnerResponse {
mut res := CMsgClientMMssetLobbyOwnerResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbyownerresponse() CMsgClientMMssetLobbyOwnerResponse {
return CMsgClientMMssetLobbyOwnerResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbyownerresponse(o CMsgClientMMssetLobbyOwnerResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbyownerresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMssetLobbyOwnerResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmssetlobbyownerresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMssetLobbyLinked {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
steam_id_lobby2 u64
has_steam_id_lobby2 bool
}
pub fn (o &CMsgClientMMssetLobbyLinked) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_steam_id_lobby2 {
res << vproto.pack_64bit_field(o.steam_id_lobby2, 3)
}

return res
}

pub fn cmsgclientmmssetlobbylinked_unpack(buf []byte) ?CMsgClientMMssetLobbyLinked {
mut res := CMsgClientMMssetLobbyLinked{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_steam_id_lobby2 = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby2 = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbylinked() CMsgClientMMssetLobbyLinked {
return CMsgClientMMssetLobbyLinked{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbylinked(o CMsgClientMMssetLobbyLinked, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbylinked(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMssetLobbyLinked) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmssetlobbylinked_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMssetLobbyGameServer {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
deprecated_game_server_ip u32
has_deprecated_game_server_ip bool
game_server_port u32
has_game_server_port bool
game_server_steam_id u64
has_game_server_steam_id bool
game_server_ip CMsgIPaddress
has_game_server_ip bool
}
pub fn (o &CMsgClientMMssetLobbyGameServer) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_deprecated_game_server_ip {
res << vproto.pack_uint32_field(o.deprecated_game_server_ip, 3)
}

if o.has_game_server_port {
res << vproto.pack_uint32_field(o.game_server_port, 4)
}

if o.has_game_server_steam_id {
res << vproto.pack_64bit_field(o.game_server_steam_id, 5)
}

if o.has_game_server_ip {
res << zzz_vproto_internal_pack_cmsgipaddress(o.game_server_ip, 6)
}

return res
}

pub fn cmsgclientmmssetlobbygameserver_unpack(buf []byte) ?CMsgClientMMssetLobbyGameServer {
mut res := CMsgClientMMssetLobbyGameServer{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_deprecated_game_server_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_game_server_ip = v
i = ii
}

4 {
res.has_game_server_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.game_server_port = v
i = ii
}

5 {
res.has_game_server_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.game_server_steam_id = v
i = ii
}

6 {
res.has_game_server_ip = true
ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
res.game_server_ip = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbygameserver() CMsgClientMMssetLobbyGameServer {
return CMsgClientMMssetLobbyGameServer{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbygameserver(o CMsgClientMMssetLobbyGameServer, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbygameserver(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMssetLobbyGameServer) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmssetlobbygameserver_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMslobbyGameServerSet {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
deprecated_game_server_ip u32
has_deprecated_game_server_ip bool
game_server_port u32
has_game_server_port bool
game_server_steam_id u64
has_game_server_steam_id bool
game_server_ip CMsgIPaddress
has_game_server_ip bool
}
pub fn (o &CMsgClientMMslobbyGameServerSet) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_deprecated_game_server_ip {
res << vproto.pack_uint32_field(o.deprecated_game_server_ip, 3)
}

if o.has_game_server_port {
res << vproto.pack_uint32_field(o.game_server_port, 4)
}

if o.has_game_server_steam_id {
res << vproto.pack_64bit_field(o.game_server_steam_id, 5)
}

if o.has_game_server_ip {
res << zzz_vproto_internal_pack_cmsgipaddress(o.game_server_ip, 6)
}

return res
}

pub fn cmsgclientmmslobbygameserverset_unpack(buf []byte) ?CMsgClientMMslobbyGameServerSet {
mut res := CMsgClientMMslobbyGameServerSet{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_deprecated_game_server_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_game_server_ip = v
i = ii
}

4 {
res.has_game_server_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.game_server_port = v
i = ii
}

5 {
res.has_game_server_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.game_server_steam_id = v
i = ii
}

6 {
res.has_game_server_ip = true
ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
res.game_server_ip = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmslobbygameserverset() CMsgClientMMslobbyGameServerSet {
return CMsgClientMMslobbyGameServerSet{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmslobbygameserverset(o CMsgClientMMslobbyGameServerSet, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmslobbygameserverset(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMslobbyGameServerSet) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmslobbygameserverset_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsuserJoinedLobby {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
steam_id_user u64
has_steam_id_user bool
persona_name string
has_persona_name bool
}
pub fn (o &CMsgClientMMsuserJoinedLobby) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_steam_id_user {
res << vproto.pack_64bit_field(o.steam_id_user, 3)
}

if o.has_persona_name {
res << vproto.pack_string_field(o.persona_name, 4)
}

return res
}

pub fn cmsgclientmmsuserjoinedlobby_unpack(buf []byte) ?CMsgClientMMsuserJoinedLobby {
mut res := CMsgClientMMsuserJoinedLobby{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_steam_id_user = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_user = v
i = ii
}

4 {
res.has_persona_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.persona_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsuserjoinedlobby() CMsgClientMMsuserJoinedLobby {
return CMsgClientMMsuserJoinedLobby{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsuserjoinedlobby(o CMsgClientMMsuserJoinedLobby, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsuserjoinedlobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsuserJoinedLobby) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsuserjoinedlobby_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsuserLeftLobby {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
steam_id_user u64
has_steam_id_user bool
persona_name string
has_persona_name bool
}
pub fn (o &CMsgClientMMsuserLeftLobby) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_steam_id_user {
res << vproto.pack_64bit_field(o.steam_id_user, 3)
}

if o.has_persona_name {
res << vproto.pack_string_field(o.persona_name, 4)
}

return res
}

pub fn cmsgclientmmsuserleftlobby_unpack(buf []byte) ?CMsgClientMMsuserLeftLobby {
mut res := CMsgClientMMsuserLeftLobby{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_steam_id_user = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_user = v
i = ii
}

4 {
res.has_persona_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.persona_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsuserleftlobby() CMsgClientMMsuserLeftLobby {
return CMsgClientMMsuserLeftLobby{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsuserleftlobby(o CMsgClientMMsuserLeftLobby, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsuserleftlobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsuserLeftLobby) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsuserleftlobby_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsinviteToLobby {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
steam_id_user_invited u64
has_steam_id_user_invited bool
}
pub fn (o &CMsgClientMMsinviteToLobby) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_steam_id_user_invited {
res << vproto.pack_64bit_field(o.steam_id_user_invited, 3)
}

return res
}

pub fn cmsgclientmmsinvitetolobby_unpack(buf []byte) ?CMsgClientMMsinviteToLobby {
mut res := CMsgClientMMsinviteToLobby{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_steam_id_user_invited = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_user_invited = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsinvitetolobby() CMsgClientMMsinviteToLobby {
return CMsgClientMMsinviteToLobby{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsinvitetolobby(o CMsgClientMMsinviteToLobby, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsinvitetolobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsinviteToLobby) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsinvitetolobby_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsgetLobbyStatus {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
claim_membership bool
has_claim_membership bool
claim_ownership bool
has_claim_ownership bool
}
pub fn (o &CMsgClientMMsgetLobbyStatus) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_claim_membership {
res << vproto.pack_bool_field(o.claim_membership, 3)
}

if o.has_claim_ownership {
res << vproto.pack_bool_field(o.claim_ownership, 4)
}

return res
}

pub fn cmsgclientmmsgetlobbystatus_unpack(buf []byte) ?CMsgClientMMsgetLobbyStatus {
mut res := CMsgClientMMsgetLobbyStatus{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_claim_membership = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.claim_membership = v
i = ii
}

4 {
res.has_claim_ownership = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.claim_ownership = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbystatus() CMsgClientMMsgetLobbyStatus {
return CMsgClientMMsgetLobbyStatus{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbystatus(o CMsgClientMMsgetLobbyStatus, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbystatus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsgetLobbyStatus) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsgetlobbystatus_unpack(v)?
return i, unpacked
}
pub struct CMsgClientMMsgetLobbyStatusResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
steam_id_lobby u64
has_steam_id_lobby bool
lobby_status EMmslobbyStatus
has_lobby_status bool
}
pub fn (o &CMsgClientMMsgetLobbyStatusResponse) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_steam_id_lobby {
res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
}

if o.has_lobby_status {
res << zzz_vproto_internal_pack_emmslobbystatus(o.lobby_status, 3)
}

return res
}

pub fn cmsgclientmmsgetlobbystatusresponse_unpack(buf []byte) ?CMsgClientMMsgetLobbyStatusResponse {
mut res := CMsgClientMMsgetLobbyStatusResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_steam_id_lobby = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_lobby = v
i = ii
}

3 {
res.has_lobby_status = true
ii, v := zzz_vproto_internal_unpack_emmslobbystatus(cur_buf, tag_wiretype.wire_type)?
res.lobby_status = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbystatusresponse() CMsgClientMMsgetLobbyStatusResponse {
return CMsgClientMMsgetLobbyStatusResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbystatusresponse(o CMsgClientMMsgetLobbyStatusResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbystatusresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMsgetLobbyStatusResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientmmsgetlobbystatusresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientInviteToGame {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id_dest u64
has_steam_id_dest bool
steam_id_src u64
has_steam_id_src bool
connect_string string
has_connect_string bool
remote_play string
has_remote_play bool
}
pub fn (o &CMsgClientInviteToGame) pack() []byte {
mut res := []byte{}
if o.has_steam_id_dest {
res << vproto.pack_64bit_field(o.steam_id_dest, 1)
}

if o.has_steam_id_src {
res << vproto.pack_64bit_field(o.steam_id_src, 2)
}

if o.has_connect_string {
res << vproto.pack_string_field(o.connect_string, 3)
}

if o.has_remote_play {
res << vproto.pack_string_field(o.remote_play, 4)
}

return res
}

pub fn cmsgclientinvitetogame_unpack(buf []byte) ?CMsgClientInviteToGame {
mut res := CMsgClientInviteToGame{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id_dest = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_dest = v
i = ii
}

2 {
res.has_steam_id_src = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_src = v
i = ii
}

3 {
res.has_connect_string = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.connect_string = v
i = ii
}

4 {
res.has_remote_play = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.remote_play = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientinvitetogame() CMsgClientInviteToGame {
return CMsgClientInviteToGame{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientinvitetogame(o CMsgClientInviteToGame, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientinvitetogame(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientInviteToGame) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientinvitetogame_unpack(v)?
return i, unpacked
}
pub struct CMsgClientChatInvite {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id_invited u64
has_steam_id_invited bool
steam_id_chat u64
has_steam_id_chat bool
steam_id_patron u64
has_steam_id_patron bool
chatroom_type int
has_chatroom_type bool
steam_id_friend_chat u64
has_steam_id_friend_chat bool
chat_name string
has_chat_name bool
game_id u64
has_game_id bool
}
pub fn (o &CMsgClientChatInvite) pack() []byte {
mut res := []byte{}
if o.has_steam_id_invited {
res << vproto.pack_64bit_field(o.steam_id_invited, 1)
}

if o.has_steam_id_chat {
res << vproto.pack_64bit_field(o.steam_id_chat, 2)
}

if o.has_steam_id_patron {
res << vproto.pack_64bit_field(o.steam_id_patron, 3)
}

if o.has_chatroom_type {
res << vproto.pack_int32_field(o.chatroom_type, 4)
}

if o.has_steam_id_friend_chat {
res << vproto.pack_64bit_field(o.steam_id_friend_chat, 5)
}

if o.has_chat_name {
res << vproto.pack_string_field(o.chat_name, 6)
}

if o.has_game_id {
res << vproto.pack_64bit_field(o.game_id, 7)
}

return res
}

pub fn cmsgclientchatinvite_unpack(buf []byte) ?CMsgClientChatInvite {
mut res := CMsgClientChatInvite{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id_invited = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_invited = v
i = ii
}

2 {
res.has_steam_id_chat = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_chat = v
i = ii
}

3 {
res.has_steam_id_patron = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_patron = v
i = ii
}

4 {
res.has_chatroom_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.chatroom_type = v
i = ii
}

5 {
res.has_steam_id_friend_chat = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_friend_chat = v
i = ii
}

6 {
res.has_chat_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.chat_name = v
i = ii
}

7 {
res.has_game_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.game_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientchatinvite() CMsgClientChatInvite {
return CMsgClientChatInvite{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientchatinvite(o CMsgClientChatInvite, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientchatinvite(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChatInvite) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientchatinvite_unpack(v)?
return i, unpacked
}
pub struct CMsgClientConnectionStatsStatsLogon {
mut:
unknown_fields []vproto.UnknownField
pub mut:
connect_attempts int
has_connect_attempts bool
connect_successes int
has_connect_successes bool
connect_failures int
has_connect_failures bool
connections_dropped int
has_connections_dropped bool
seconds_running u32
has_seconds_running bool
msec_tologonthistime u32
has_msec_tologonthistime bool
count_bad_cms u32
has_count_bad_cms bool
}
pub fn (o &CMsgClientConnectionStatsStatsLogon) pack() []byte {
mut res := []byte{}
if o.has_connect_attempts {
res << vproto.pack_int32_field(o.connect_attempts, 1)
}

if o.has_connect_successes {
res << vproto.pack_int32_field(o.connect_successes, 2)
}

if o.has_connect_failures {
res << vproto.pack_int32_field(o.connect_failures, 3)
}

if o.has_connections_dropped {
res << vproto.pack_int32_field(o.connections_dropped, 4)
}

if o.has_seconds_running {
res << vproto.pack_uint32_field(o.seconds_running, 5)
}

if o.has_msec_tologonthistime {
res << vproto.pack_uint32_field(o.msec_tologonthistime, 6)
}

if o.has_count_bad_cms {
res << vproto.pack_uint32_field(o.count_bad_cms, 7)
}

return res
}

pub fn cmsgclientconnectionstatsstatslogon_unpack(buf []byte) ?CMsgClientConnectionStatsStatsLogon {
mut res := CMsgClientConnectionStatsStatsLogon{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_connect_attempts = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.connect_attempts = v
i = ii
}

2 {
res.has_connect_successes = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.connect_successes = v
i = ii
}

3 {
res.has_connect_failures = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.connect_failures = v
i = ii
}

4 {
res.has_connections_dropped = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.connections_dropped = v
i = ii
}

5 {
res.has_seconds_running = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_running = v
i = ii
}

6 {
res.has_msec_tologonthistime = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.msec_tologonthistime = v
i = ii
}

7 {
res.has_count_bad_cms = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.count_bad_cms = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientconnectionstatsstatslogon() CMsgClientConnectionStatsStatsLogon {
return CMsgClientConnectionStatsStatsLogon{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientconnectionstatsstatslogon(o CMsgClientConnectionStatsStatsLogon, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientconnectionstatsstatslogon(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientConnectionStatsStatsLogon) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientconnectionstatsstatslogon_unpack(v)?
return i, unpacked
}
pub struct CMsgClientConnectionStatsStatsUDp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
pkts_sent u64
has_pkts_sent bool
bytes_sent u64
has_bytes_sent bool
pkts_recv u64
has_pkts_recv bool
pkts_processed u64
has_pkts_processed bool
bytes_recv u64
has_bytes_recv bool
}
pub fn (o &CMsgClientConnectionStatsStatsUDp) pack() []byte {
mut res := []byte{}
if o.has_pkts_sent {
res << vproto.pack_uint64_field(o.pkts_sent, 1)
}

if o.has_bytes_sent {
res << vproto.pack_uint64_field(o.bytes_sent, 2)
}

if o.has_pkts_recv {
res << vproto.pack_uint64_field(o.pkts_recv, 3)
}

if o.has_pkts_processed {
res << vproto.pack_uint64_field(o.pkts_processed, 4)
}

if o.has_bytes_recv {
res << vproto.pack_uint64_field(o.bytes_recv, 5)
}

return res
}

pub fn cmsgclientconnectionstatsstatsudp_unpack(buf []byte) ?CMsgClientConnectionStatsStatsUDp {
mut res := CMsgClientConnectionStatsStatsUDp{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_pkts_sent = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.pkts_sent = v
i = ii
}

2 {
res.has_bytes_sent = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.bytes_sent = v
i = ii
}

3 {
res.has_pkts_recv = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.pkts_recv = v
i = ii
}

4 {
res.has_pkts_processed = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.pkts_processed = v
i = ii
}

5 {
res.has_bytes_recv = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.bytes_recv = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientconnectionstatsstatsudp() CMsgClientConnectionStatsStatsUDp {
return CMsgClientConnectionStatsStatsUDp{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientconnectionstatsstatsudp(o CMsgClientConnectionStatsStatsUDp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientconnectionstatsstatsudp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientConnectionStatsStatsUDp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientconnectionstatsstatsudp_unpack(v)?
return i, unpacked
}
pub struct CMsgClientConnectionStatsStatsVConn {
mut:
unknown_fields []vproto.UnknownField
pub mut:
connections_udp u32
has_connections_udp bool
connections_tcp u32
has_connections_tcp bool
stats_udp CMsgClientConnectionStatsStatsUDp
has_stats_udp bool
pkts_abandoned u64
has_pkts_abandoned bool
conn_req_received u64
has_conn_req_received bool
pkts_resent u64
has_pkts_resent bool
msgs_sent u64
has_msgs_sent bool
msgs_sent_failed u64
has_msgs_sent_failed bool
msgs_recv u64
has_msgs_recv bool
datagrams_sent u64
has_datagrams_sent bool
datagrams_recv u64
has_datagrams_recv bool
bad_pkts_recv u64
has_bad_pkts_recv bool
unknown_conn_pkts_recv u64
has_unknown_conn_pkts_recv bool
missed_pkts_recv u64
has_missed_pkts_recv bool
dup_pkts_recv u64
has_dup_pkts_recv bool
failed_connect_challenges u64
has_failed_connect_challenges bool
micro_sec_avg_latency u32
has_micro_sec_avg_latency bool
micro_sec_min_latency u32
has_micro_sec_min_latency bool
micro_sec_max_latency u32
has_micro_sec_max_latency bool
mem_pool_msg_in_use u32
has_mem_pool_msg_in_use bool
}
pub fn (o &CMsgClientConnectionStatsStatsVConn) pack() []byte {
mut res := []byte{}
if o.has_connections_udp {
res << vproto.pack_uint32_field(o.connections_udp, 1)
}

if o.has_connections_tcp {
res << vproto.pack_uint32_field(o.connections_tcp, 2)
}

if o.has_stats_udp {
res << zzz_vproto_internal_pack_cmsgclientconnectionstatsstatsudp(o.stats_udp, 3)
}

if o.has_pkts_abandoned {
res << vproto.pack_uint64_field(o.pkts_abandoned, 4)
}

if o.has_conn_req_received {
res << vproto.pack_uint64_field(o.conn_req_received, 5)
}

if o.has_pkts_resent {
res << vproto.pack_uint64_field(o.pkts_resent, 6)
}

if o.has_msgs_sent {
res << vproto.pack_uint64_field(o.msgs_sent, 7)
}

if o.has_msgs_sent_failed {
res << vproto.pack_uint64_field(o.msgs_sent_failed, 8)
}

if o.has_msgs_recv {
res << vproto.pack_uint64_field(o.msgs_recv, 9)
}

if o.has_datagrams_sent {
res << vproto.pack_uint64_field(o.datagrams_sent, 10)
}

if o.has_datagrams_recv {
res << vproto.pack_uint64_field(o.datagrams_recv, 11)
}

if o.has_bad_pkts_recv {
res << vproto.pack_uint64_field(o.bad_pkts_recv, 12)
}

if o.has_unknown_conn_pkts_recv {
res << vproto.pack_uint64_field(o.unknown_conn_pkts_recv, 13)
}

if o.has_missed_pkts_recv {
res << vproto.pack_uint64_field(o.missed_pkts_recv, 14)
}

if o.has_dup_pkts_recv {
res << vproto.pack_uint64_field(o.dup_pkts_recv, 15)
}

if o.has_failed_connect_challenges {
res << vproto.pack_uint64_field(o.failed_connect_challenges, 16)
}

if o.has_micro_sec_avg_latency {
res << vproto.pack_uint32_field(o.micro_sec_avg_latency, 17)
}

if o.has_micro_sec_min_latency {
res << vproto.pack_uint32_field(o.micro_sec_min_latency, 18)
}

if o.has_micro_sec_max_latency {
res << vproto.pack_uint32_field(o.micro_sec_max_latency, 19)
}

if o.has_mem_pool_msg_in_use {
res << vproto.pack_uint32_field(o.mem_pool_msg_in_use, 20)
}

return res
}

pub fn cmsgclientconnectionstatsstatsvconn_unpack(buf []byte) ?CMsgClientConnectionStatsStatsVConn {
mut res := CMsgClientConnectionStatsStatsVConn{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_connections_udp = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.connections_udp = v
i = ii
}

2 {
res.has_connections_tcp = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.connections_tcp = v
i = ii
}

3 {
res.has_stats_udp = true
ii, v := zzz_vproto_internal_unpack_cmsgclientconnectionstatsstatsudp(cur_buf, tag_wiretype.wire_type)?
res.stats_udp = v
i = ii
}

4 {
res.has_pkts_abandoned = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.pkts_abandoned = v
i = ii
}

5 {
res.has_conn_req_received = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.conn_req_received = v
i = ii
}

6 {
res.has_pkts_resent = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.pkts_resent = v
i = ii
}

7 {
res.has_msgs_sent = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.msgs_sent = v
i = ii
}

8 {
res.has_msgs_sent_failed = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.msgs_sent_failed = v
i = ii
}

9 {
res.has_msgs_recv = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.msgs_recv = v
i = ii
}

10 {
res.has_datagrams_sent = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.datagrams_sent = v
i = ii
}

11 {
res.has_datagrams_recv = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.datagrams_recv = v
i = ii
}

12 {
res.has_bad_pkts_recv = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.bad_pkts_recv = v
i = ii
}

13 {
res.has_unknown_conn_pkts_recv = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.unknown_conn_pkts_recv = v
i = ii
}

14 {
res.has_missed_pkts_recv = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.missed_pkts_recv = v
i = ii
}

15 {
res.has_dup_pkts_recv = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.dup_pkts_recv = v
i = ii
}

16 {
res.has_failed_connect_challenges = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.failed_connect_challenges = v
i = ii
}

17 {
res.has_micro_sec_avg_latency = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.micro_sec_avg_latency = v
i = ii
}

18 {
res.has_micro_sec_min_latency = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.micro_sec_min_latency = v
i = ii
}

19 {
res.has_micro_sec_max_latency = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.micro_sec_max_latency = v
i = ii
}

20 {
res.has_mem_pool_msg_in_use = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.mem_pool_msg_in_use = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientconnectionstatsstatsvconn() CMsgClientConnectionStatsStatsVConn {
return CMsgClientConnectionStatsStatsVConn{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientconnectionstatsstatsvconn(o CMsgClientConnectionStatsStatsVConn, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientconnectionstatsstatsvconn(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientConnectionStatsStatsVConn) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientconnectionstatsstatsvconn_unpack(v)?
return i, unpacked
}
pub struct CMsgClientConnectionStats {
mut:
unknown_fields []vproto.UnknownField
pub mut:
stats_logon CMsgClientConnectionStatsStatsLogon
has_stats_logon bool
stats_vconn CMsgClientConnectionStatsStatsVConn
has_stats_vconn bool
}
pub fn (o &CMsgClientConnectionStats) pack() []byte {
mut res := []byte{}
if o.has_stats_logon {
res << zzz_vproto_internal_pack_cmsgclientconnectionstatsstatslogon(o.stats_logon, 1)
}

if o.has_stats_vconn {
res << zzz_vproto_internal_pack_cmsgclientconnectionstatsstatsvconn(o.stats_vconn, 2)
}

return res
}

pub fn cmsgclientconnectionstats_unpack(buf []byte) ?CMsgClientConnectionStats {
mut res := CMsgClientConnectionStats{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_stats_logon = true
ii, v := zzz_vproto_internal_unpack_cmsgclientconnectionstatsstatslogon(cur_buf, tag_wiretype.wire_type)?
res.stats_logon = v
i = ii
}

2 {
res.has_stats_vconn = true
ii, v := zzz_vproto_internal_unpack_cmsgclientconnectionstatsstatsvconn(cur_buf, tag_wiretype.wire_type)?
res.stats_vconn = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientconnectionstats() CMsgClientConnectionStats {
return CMsgClientConnectionStats{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientconnectionstats(o CMsgClientConnectionStats, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientconnectionstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientConnectionStats) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientconnectionstats_unpack(v)?
return i, unpacked
}
pub struct CMsgClientServersAvailableServerTypesAvailable {
mut:
unknown_fields []vproto.UnknownField
pub mut:
server u32
has_server bool
changed bool
has_changed bool
}
pub fn (o &CMsgClientServersAvailableServerTypesAvailable) pack() []byte {
mut res := []byte{}
if o.has_server {
res << vproto.pack_uint32_field(o.server, 1)
}

if o.has_changed {
res << vproto.pack_bool_field(o.changed, 2)
}

return res
}

pub fn cmsgclientserversavailableservertypesavailable_unpack(buf []byte) ?CMsgClientServersAvailableServerTypesAvailable {
mut res := CMsgClientServersAvailableServerTypesAvailable{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_server = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.server = v
i = ii
}

2 {
res.has_changed = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.changed = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientserversavailableservertypesavailable() CMsgClientServersAvailableServerTypesAvailable {
return CMsgClientServersAvailableServerTypesAvailable{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientserversavailableservertypesavailable(o CMsgClientServersAvailableServerTypesAvailable, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientserversavailableservertypesavailable(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServersAvailableServerTypesAvailable) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientserversavailableservertypesavailable_unpack(v)?
return i, unpacked
}
pub struct CMsgClientServersAvailable {
mut:
unknown_fields []vproto.UnknownField
pub mut:
server_types_available []CMsgClientServersAvailableServerTypesAvailable
server_type_for_auth_services u32
has_server_type_for_auth_services bool
}
pub fn (o &CMsgClientServersAvailable) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.server_types_available {
res << zzz_vproto_internal_pack_cmsgclientserversavailableservertypesavailable(x, 1)
}

if o.has_server_type_for_auth_services {
res << vproto.pack_uint32_field(o.server_type_for_auth_services, 2)
}

return res
}

pub fn cmsgclientserversavailable_unpack(buf []byte) ?CMsgClientServersAvailable {
mut res := CMsgClientServersAvailable{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientserversavailableservertypesavailable(cur_buf, tag_wiretype.wire_type)?
res.server_types_available << v
i = ii
}

2 {
res.has_server_type_for_auth_services = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.server_type_for_auth_services = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientserversavailable() CMsgClientServersAvailable {
return CMsgClientServersAvailable{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientserversavailable(o CMsgClientServersAvailable, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientserversavailable(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServersAvailable) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientserversavailable_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetUserStats {
mut:
unknown_fields []vproto.UnknownField
pub mut:
game_id u64
has_game_id bool
crc_stats u32
has_crc_stats bool
schema_local_version int
has_schema_local_version bool
steam_id_for_user u64
has_steam_id_for_user bool
}
pub fn (o &CMsgClientGetUserStats) pack() []byte {
mut res := []byte{}
if o.has_game_id {
res << vproto.pack_64bit_field(o.game_id, 1)
}

if o.has_crc_stats {
res << vproto.pack_uint32_field(o.crc_stats, 2)
}

if o.has_schema_local_version {
res << vproto.pack_int32_field(o.schema_local_version, 3)
}

if o.has_steam_id_for_user {
res << vproto.pack_64bit_field(o.steam_id_for_user, 4)
}

return res
}

pub fn cmsgclientgetuserstats_unpack(buf []byte) ?CMsgClientGetUserStats {
mut res := CMsgClientGetUserStats{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_game_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.game_id = v
i = ii
}

2 {
res.has_crc_stats = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.crc_stats = v
i = ii
}

3 {
res.has_schema_local_version = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.schema_local_version = v
i = ii
}

4 {
res.has_steam_id_for_user = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_for_user = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetuserstats() CMsgClientGetUserStats {
return CMsgClientGetUserStats{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetuserstats(o CMsgClientGetUserStats, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetuserstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetUserStats) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetuserstats_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetUserStatsResponseStats {
mut:
unknown_fields []vproto.UnknownField
pub mut:
stat_id u32
has_stat_id bool
stat_value u32
has_stat_value bool
}
pub fn (o &CMsgClientGetUserStatsResponseStats) pack() []byte {
mut res := []byte{}
if o.has_stat_id {
res << vproto.pack_uint32_field(o.stat_id, 1)
}

if o.has_stat_value {
res << vproto.pack_uint32_field(o.stat_value, 2)
}

return res
}

pub fn cmsgclientgetuserstatsresponsestats_unpack(buf []byte) ?CMsgClientGetUserStatsResponseStats {
mut res := CMsgClientGetUserStatsResponseStats{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_stat_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.stat_id = v
i = ii
}

2 {
res.has_stat_value = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.stat_value = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetuserstatsresponsestats() CMsgClientGetUserStatsResponseStats {
return CMsgClientGetUserStatsResponseStats{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetuserstatsresponsestats(o CMsgClientGetUserStatsResponseStats, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponsestats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetUserStatsResponseStats) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetuserstatsresponsestats_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetUserStatsResponseAchievementBlocks {
mut:
unknown_fields []vproto.UnknownField
pub mut:
achievement_id u32
has_achievement_id bool
unlock_time []u32
}
pub fn (o &CMsgClientGetUserStatsResponseAchievementBlocks) pack() []byte {
mut res := []byte{}
if o.has_achievement_id {
res << vproto.pack_uint32_field(o.achievement_id, 1)
}

// [packed=false]
for _, x in o.unlock_time {
res << vproto.pack_32bit_field(x, 2)
}

return res
}

pub fn cmsgclientgetuserstatsresponseachievementblocks_unpack(buf []byte) ?CMsgClientGetUserStatsResponseAchievementBlocks {
mut res := CMsgClientGetUserStatsResponseAchievementBlocks{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_achievement_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.achievement_id = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.unlock_time << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetuserstatsresponseachievementblocks() CMsgClientGetUserStatsResponseAchievementBlocks {
return CMsgClientGetUserStatsResponseAchievementBlocks{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetuserstatsresponseachievementblocks(o CMsgClientGetUserStatsResponseAchievementBlocks, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponseachievementblocks(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetUserStatsResponseAchievementBlocks) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetuserstatsresponseachievementblocks_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetUserStatsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
game_id u64
has_game_id bool
eresult int
has_eresult bool
crc_stats u32
has_crc_stats bool
schema []byte
has_schema bool
stats []CMsgClientGetUserStatsResponseStats
achievement_blocks []CMsgClientGetUserStatsResponseAchievementBlocks
}
pub fn (o &CMsgClientGetUserStatsResponse) pack() []byte {
mut res := []byte{}
if o.has_game_id {
res << vproto.pack_64bit_field(o.game_id, 1)
}

if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 2)
}

if o.has_crc_stats {
res << vproto.pack_uint32_field(o.crc_stats, 3)
}

if o.has_schema {
res << vproto.pack_bytes_field(o.schema, 4)
}

// [packed=false]
for _, x in o.stats {
res << zzz_vproto_internal_pack_cmsgclientgetuserstatsresponsestats(x, 5)
}

// [packed=false]
for _, x in o.achievement_blocks {
res << zzz_vproto_internal_pack_cmsgclientgetuserstatsresponseachievementblocks(x, 6)
}

return res
}

pub fn cmsgclientgetuserstatsresponse_unpack(buf []byte) ?CMsgClientGetUserStatsResponse {
mut res := CMsgClientGetUserStatsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_game_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.game_id = v
i = ii
}

2 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

3 {
res.has_crc_stats = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.crc_stats = v
i = ii
}

4 {
res.has_schema = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.schema = v
i = ii
}

5 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponsestats(cur_buf, tag_wiretype.wire_type)?
res.stats << v
i = ii
}

6 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponseachievementblocks(cur_buf, tag_wiretype.wire_type)?
res.achievement_blocks << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetuserstatsresponse() CMsgClientGetUserStatsResponse {
return CMsgClientGetUserStatsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetuserstatsresponse(o CMsgClientGetUserStatsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetUserStatsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetuserstatsresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientStoreUserStatsResponseStatsFailedValidation {
mut:
unknown_fields []vproto.UnknownField
pub mut:
stat_id u32
has_stat_id bool
reverted_stat_value u32
has_reverted_stat_value bool
}
pub fn (o &CMsgClientStoreUserStatsResponseStatsFailedValidation) pack() []byte {
mut res := []byte{}
if o.has_stat_id {
res << vproto.pack_uint32_field(o.stat_id, 1)
}

if o.has_reverted_stat_value {
res << vproto.pack_uint32_field(o.reverted_stat_value, 2)
}

return res
}

pub fn cmsgclientstoreuserstatsresponsestatsfailedvalidation_unpack(buf []byte) ?CMsgClientStoreUserStatsResponseStatsFailedValidation {
mut res := CMsgClientStoreUserStatsResponseStatsFailedValidation{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_stat_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.stat_id = v
i = ii
}

2 {
res.has_reverted_stat_value = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.reverted_stat_value = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstatsresponsestatsfailedvalidation() CMsgClientStoreUserStatsResponseStatsFailedValidation {
return CMsgClientStoreUserStatsResponseStatsFailedValidation{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstatsresponsestatsfailedvalidation(o CMsgClientStoreUserStatsResponseStatsFailedValidation, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstatsresponsestatsfailedvalidation(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStatsResponseStatsFailedValidation) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientstoreuserstatsresponsestatsfailedvalidation_unpack(v)?
return i, unpacked
}
pub struct CMsgClientStoreUserStatsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
game_id u64
has_game_id bool
eresult int
has_eresult bool
crc_stats u32
has_crc_stats bool
stats_failed_validation []CMsgClientStoreUserStatsResponseStatsFailedValidation
stats_out_of_date bool
has_stats_out_of_date bool
}
pub fn (o &CMsgClientStoreUserStatsResponse) pack() []byte {
mut res := []byte{}
if o.has_game_id {
res << vproto.pack_64bit_field(o.game_id, 1)
}

if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 2)
}

if o.has_crc_stats {
res << vproto.pack_uint32_field(o.crc_stats, 3)
}

// [packed=false]
for _, x in o.stats_failed_validation {
res << zzz_vproto_internal_pack_cmsgclientstoreuserstatsresponsestatsfailedvalidation(x, 4)
}

if o.has_stats_out_of_date {
res << vproto.pack_bool_field(o.stats_out_of_date, 5)
}

return res
}

pub fn cmsgclientstoreuserstatsresponse_unpack(buf []byte) ?CMsgClientStoreUserStatsResponse {
mut res := CMsgClientStoreUserStatsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_game_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.game_id = v
i = ii
}

2 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

3 {
res.has_crc_stats = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.crc_stats = v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientstoreuserstatsresponsestatsfailedvalidation(cur_buf, tag_wiretype.wire_type)?
res.stats_failed_validation << v
i = ii
}

5 {
res.has_stats_out_of_date = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.stats_out_of_date = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstatsresponse() CMsgClientStoreUserStatsResponse {
return CMsgClientStoreUserStatsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstatsresponse(o CMsgClientStoreUserStatsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstatsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStatsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientstoreuserstatsresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientStoreUserStats2Stats {
mut:
unknown_fields []vproto.UnknownField
pub mut:
stat_id u32
has_stat_id bool
stat_value u32
has_stat_value bool
}
pub fn (o &CMsgClientStoreUserStats2Stats) pack() []byte {
mut res := []byte{}
if o.has_stat_id {
res << vproto.pack_uint32_field(o.stat_id, 1)
}

if o.has_stat_value {
res << vproto.pack_uint32_field(o.stat_value, 2)
}

return res
}

pub fn cmsgclientstoreuserstats2stats_unpack(buf []byte) ?CMsgClientStoreUserStats2Stats {
mut res := CMsgClientStoreUserStats2Stats{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_stat_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.stat_id = v
i = ii
}

2 {
res.has_stat_value = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.stat_value = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstats2stats() CMsgClientStoreUserStats2Stats {
return CMsgClientStoreUserStats2Stats{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstats2stats(o CMsgClientStoreUserStats2Stats, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstats2stats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStats2Stats) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientstoreuserstats2stats_unpack(v)?
return i, unpacked
}
pub struct CMsgClientStoreUserStats2 {
mut:
unknown_fields []vproto.UnknownField
pub mut:
game_id u64
has_game_id bool
settor_steam_id u64
has_settor_steam_id bool
settee_steam_id u64
has_settee_steam_id bool
crc_stats u32
has_crc_stats bool
explicit_reset bool
has_explicit_reset bool
stats []CMsgClientStoreUserStats2Stats
}
pub fn (o &CMsgClientStoreUserStats2) pack() []byte {
mut res := []byte{}
if o.has_game_id {
res << vproto.pack_64bit_field(o.game_id, 1)
}

if o.has_settor_steam_id {
res << vproto.pack_64bit_field(o.settor_steam_id, 2)
}

if o.has_settee_steam_id {
res << vproto.pack_64bit_field(o.settee_steam_id, 3)
}

if o.has_crc_stats {
res << vproto.pack_uint32_field(o.crc_stats, 4)
}

if o.has_explicit_reset {
res << vproto.pack_bool_field(o.explicit_reset, 5)
}

// [packed=false]
for _, x in o.stats {
res << zzz_vproto_internal_pack_cmsgclientstoreuserstats2stats(x, 6)
}

return res
}

pub fn cmsgclientstoreuserstats2_unpack(buf []byte) ?CMsgClientStoreUserStats2 {
mut res := CMsgClientStoreUserStats2{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_game_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.game_id = v
i = ii
}

2 {
res.has_settor_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.settor_steam_id = v
i = ii
}

3 {
res.has_settee_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.settee_steam_id = v
i = ii
}

4 {
res.has_crc_stats = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.crc_stats = v
i = ii
}

5 {
res.has_explicit_reset = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.explicit_reset = v
i = ii
}

6 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientstoreuserstats2stats(cur_buf, tag_wiretype.wire_type)?
res.stats << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstats2() CMsgClientStoreUserStats2 {
return CMsgClientStoreUserStats2{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstats2(o CMsgClientStoreUserStats2, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstats2(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStats2) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientstoreuserstats2_unpack(v)?
return i, unpacked
}
pub struct CMsgClientStatsUpdatedUpdatedStats {
mut:
unknown_fields []vproto.UnknownField
pub mut:
stat_id u32
has_stat_id bool
stat_value u32
has_stat_value bool
}
pub fn (o &CMsgClientStatsUpdatedUpdatedStats) pack() []byte {
mut res := []byte{}
if o.has_stat_id {
res << vproto.pack_uint32_field(o.stat_id, 1)
}

if o.has_stat_value {
res << vproto.pack_uint32_field(o.stat_value, 2)
}

return res
}

pub fn cmsgclientstatsupdatedupdatedstats_unpack(buf []byte) ?CMsgClientStatsUpdatedUpdatedStats {
mut res := CMsgClientStatsUpdatedUpdatedStats{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_stat_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.stat_id = v
i = ii
}

2 {
res.has_stat_value = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.stat_value = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstatsupdatedupdatedstats() CMsgClientStatsUpdatedUpdatedStats {
return CMsgClientStatsUpdatedUpdatedStats{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstatsupdatedupdatedstats(o CMsgClientStatsUpdatedUpdatedStats, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstatsupdatedupdatedstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStatsUpdatedUpdatedStats) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientstatsupdatedupdatedstats_unpack(v)?
return i, unpacked
}
pub struct CMsgClientStatsUpdated {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
game_id u64
has_game_id bool
crc_stats u32
has_crc_stats bool
updated_stats []CMsgClientStatsUpdatedUpdatedStats
}
pub fn (o &CMsgClientStatsUpdated) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

if o.has_game_id {
res << vproto.pack_64bit_field(o.game_id, 2)
}

if o.has_crc_stats {
res << vproto.pack_uint32_field(o.crc_stats, 3)
}

// [packed=false]
for _, x in o.updated_stats {
res << zzz_vproto_internal_pack_cmsgclientstatsupdatedupdatedstats(x, 4)
}

return res
}

pub fn cmsgclientstatsupdated_unpack(buf []byte) ?CMsgClientStatsUpdated {
mut res := CMsgClientStatsUpdated{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

2 {
res.has_game_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.game_id = v
i = ii
}

3 {
res.has_crc_stats = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.crc_stats = v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientstatsupdatedupdatedstats(cur_buf, tag_wiretype.wire_type)?
res.updated_stats << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstatsupdated() CMsgClientStatsUpdated {
return CMsgClientStatsUpdated{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstatsupdated(o CMsgClientStatsUpdated, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstatsupdated(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStatsUpdated) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientstatsupdated_unpack(v)?
return i, unpacked
}
pub struct CMsgClientStoreUserStatsStatsToStore {
mut:
unknown_fields []vproto.UnknownField
pub mut:
stat_id u32
has_stat_id bool
stat_value u32
has_stat_value bool
}
pub fn (o &CMsgClientStoreUserStatsStatsToStore) pack() []byte {
mut res := []byte{}
if o.has_stat_id {
res << vproto.pack_uint32_field(o.stat_id, 1)
}

if o.has_stat_value {
res << vproto.pack_uint32_field(o.stat_value, 2)
}

return res
}

pub fn cmsgclientstoreuserstatsstatstostore_unpack(buf []byte) ?CMsgClientStoreUserStatsStatsToStore {
mut res := CMsgClientStoreUserStatsStatsToStore{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_stat_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.stat_id = v
i = ii
}

2 {
res.has_stat_value = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.stat_value = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstatsstatstostore() CMsgClientStoreUserStatsStatsToStore {
return CMsgClientStoreUserStatsStatsToStore{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstatsstatstostore(o CMsgClientStoreUserStatsStatsToStore, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstatsstatstostore(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStatsStatsToStore) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientstoreuserstatsstatstostore_unpack(v)?
return i, unpacked
}
pub struct CMsgClientStoreUserStats {
mut:
unknown_fields []vproto.UnknownField
pub mut:
game_id u64
has_game_id bool
explicit_reset bool
has_explicit_reset bool
stats_to_store []CMsgClientStoreUserStatsStatsToStore
}
pub fn (o &CMsgClientStoreUserStats) pack() []byte {
mut res := []byte{}
if o.has_game_id {
res << vproto.pack_64bit_field(o.game_id, 1)
}

if o.has_explicit_reset {
res << vproto.pack_bool_field(o.explicit_reset, 2)
}

// [packed=false]
for _, x in o.stats_to_store {
res << zzz_vproto_internal_pack_cmsgclientstoreuserstatsstatstostore(x, 3)
}

return res
}

pub fn cmsgclientstoreuserstats_unpack(buf []byte) ?CMsgClientStoreUserStats {
mut res := CMsgClientStoreUserStats{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_game_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.game_id = v
i = ii
}

2 {
res.has_explicit_reset = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.explicit_reset = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientstoreuserstatsstatstostore(cur_buf, tag_wiretype.wire_type)?
res.stats_to_store << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstats() CMsgClientStoreUserStats {
return CMsgClientStoreUserStats{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstats(o CMsgClientStoreUserStats, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStats) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientstoreuserstats_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetClientDetails {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CMsgClientGetClientDetails) pack() []byte {
res := []byte{}
return res
}

pub fn cmsgclientgetclientdetails_unpack(buf []byte) ?CMsgClientGetClientDetails {
res := CMsgClientGetClientDetails{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientdetails() CMsgClientGetClientDetails {
return CMsgClientGetClientDetails{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientdetails(o CMsgClientGetClientDetails, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientdetails(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientDetails) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetclientdetails_unpack(v)?
return i, unpacked
}
pub struct CMsgClientReportOverlayDetourFailure {
mut:
unknown_fields []vproto.UnknownField
pub mut:
failure_strings []string
}
pub fn (o &CMsgClientReportOverlayDetourFailure) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.failure_strings {
res << vproto.pack_string_field(x, 1)
}

return res
}

pub fn cmsgclientreportoverlaydetourfailure_unpack(buf []byte) ?CMsgClientReportOverlayDetourFailure {
mut res := CMsgClientReportOverlayDetourFailure{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.failure_strings << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientreportoverlaydetourfailure() CMsgClientReportOverlayDetourFailure {
return CMsgClientReportOverlayDetourFailure{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientreportoverlaydetourfailure(o CMsgClientReportOverlayDetourFailure, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientreportoverlaydetourfailure(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientReportOverlayDetourFailure) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientreportoverlaydetourfailure_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetClientDetailsResponseGame {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
extra_info string
has_extra_info bool
time_running_sec u32
has_time_running_sec bool
}
pub fn (o &CMsgClientGetClientDetailsResponseGame) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_extra_info {
res << vproto.pack_string_field(o.extra_info, 2)
}

if o.has_time_running_sec {
res << vproto.pack_uint32_field(o.time_running_sec, 3)
}

return res
}

pub fn cmsgclientgetclientdetailsresponsegame_unpack(buf []byte) ?CMsgClientGetClientDetailsResponseGame {
mut res := CMsgClientGetClientDetailsResponseGame{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_extra_info = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.extra_info = v
i = ii
}

3 {
res.has_time_running_sec = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_running_sec = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientdetailsresponsegame() CMsgClientGetClientDetailsResponseGame {
return CMsgClientGetClientDetailsResponseGame{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientdetailsresponsegame(o CMsgClientGetClientDetailsResponseGame, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientdetailsresponsegame(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientDetailsResponseGame) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetclientdetailsresponsegame_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetClientDetailsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
package_version u32
has_package_version bool
protocol_version u32
has_protocol_version bool
os string
has_os bool
machine_name string
has_machine_name bool
ip_public string
has_ip_public bool
ip_private string
has_ip_private bool
bytes_available u64
has_bytes_available bool
games_running []CMsgClientGetClientDetailsResponseGame
}
pub fn (o &CMsgClientGetClientDetailsResponse) pack() []byte {
mut res := []byte{}
if o.has_package_version {
res << vproto.pack_uint32_field(o.package_version, 1)
}

if o.has_protocol_version {
res << vproto.pack_uint32_field(o.protocol_version, 8)
}

if o.has_os {
res << vproto.pack_string_field(o.os, 2)
}

if o.has_machine_name {
res << vproto.pack_string_field(o.machine_name, 3)
}

if o.has_ip_public {
res << vproto.pack_string_field(o.ip_public, 4)
}

if o.has_ip_private {
res << vproto.pack_string_field(o.ip_private, 5)
}

if o.has_bytes_available {
res << vproto.pack_uint64_field(o.bytes_available, 7)
}

// [packed=false]
for _, x in o.games_running {
res << zzz_vproto_internal_pack_cmsgclientgetclientdetailsresponsegame(x, 6)
}

return res
}

pub fn cmsgclientgetclientdetailsresponse_unpack(buf []byte) ?CMsgClientGetClientDetailsResponse {
mut res := CMsgClientGetClientDetailsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_package_version = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.package_version = v
i = ii
}

8 {
res.has_protocol_version = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.protocol_version = v
i = ii
}

2 {
res.has_os = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.os = v
i = ii
}

3 {
res.has_machine_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.machine_name = v
i = ii
}

4 {
res.has_ip_public = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.ip_public = v
i = ii
}

5 {
res.has_ip_private = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.ip_private = v
i = ii
}

7 {
res.has_bytes_available = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.bytes_available = v
i = ii
}

6 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientgetclientdetailsresponsegame(cur_buf, tag_wiretype.wire_type)?
res.games_running << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientdetailsresponse() CMsgClientGetClientDetailsResponse {
return CMsgClientGetClientDetailsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientdetailsresponse(o CMsgClientGetClientDetailsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientdetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientDetailsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetclientdetailsresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetClientAppList {
mut:
unknown_fields []vproto.UnknownField
pub mut:
media bool
has_media bool
tools bool
has_tools bool
games bool
has_games bool
only_installed bool
has_only_installed bool
only_changing bool
has_only_changing bool
comics bool
has_comics bool
}
pub fn (o &CMsgClientGetClientAppList) pack() []byte {
mut res := []byte{}
if o.has_media {
res << vproto.pack_bool_field(o.media, 1)
}

if o.has_tools {
res << vproto.pack_bool_field(o.tools, 2)
}

if o.has_games {
res << vproto.pack_bool_field(o.games, 3)
}

if o.has_only_installed {
res << vproto.pack_bool_field(o.only_installed, 4)
}

if o.has_only_changing {
res << vproto.pack_bool_field(o.only_changing, 5)
}

if o.has_comics {
res << vproto.pack_bool_field(o.comics, 6)
}

return res
}

pub fn cmsgclientgetclientapplist_unpack(buf []byte) ?CMsgClientGetClientAppList {
mut res := CMsgClientGetClientAppList{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_media = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.media = v
i = ii
}

2 {
res.has_tools = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.tools = v
i = ii
}

3 {
res.has_games = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.games = v
i = ii
}

4 {
res.has_only_installed = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.only_installed = v
i = ii
}

5 {
res.has_only_changing = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.only_changing = v
i = ii
}

6 {
res.has_comics = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.comics = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientapplist() CMsgClientGetClientAppList {
return CMsgClientGetClientAppList{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientapplist(o CMsgClientGetClientAppList, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientapplist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientAppList) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetclientapplist_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetClientAppListResponseAppDLc {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
installed bool
has_installed bool
}
pub fn (o &CMsgClientGetClientAppListResponseAppDLc) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_installed {
res << vproto.pack_bool_field(o.installed, 2)
}

return res
}

pub fn cmsgclientgetclientapplistresponseappdlc_unpack(buf []byte) ?CMsgClientGetClientAppListResponseAppDLc {
mut res := CMsgClientGetClientAppListResponseAppDLc{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_installed = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.installed = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientapplistresponseappdlc() CMsgClientGetClientAppListResponseAppDLc {
return CMsgClientGetClientAppListResponseAppDLc{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientapplistresponseappdlc(o CMsgClientGetClientAppListResponseAppDLc, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponseappdlc(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientAppListResponseAppDLc) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetclientapplistresponseappdlc_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetClientAppListResponseApp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
category string
has_category bool
app_type string
has_app_type bool
favorite bool
has_favorite bool
installed bool
has_installed bool
auto_update bool
has_auto_update bool
bytes_downloaded u64
has_bytes_downloaded bool
bytes_needed u64
has_bytes_needed bool
bytes_download_rate u32
has_bytes_download_rate bool
download_paused bool
has_download_paused bool
num_downloading u32
has_num_downloading bool
num_paused u32
has_num_paused bool
changing bool
has_changing bool
available_on_platform bool
has_available_on_platform bool
dlcs []CMsgClientGetClientAppListResponseAppDLc
}
pub fn (o &CMsgClientGetClientAppListResponseApp) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_category {
res << vproto.pack_string_field(o.category, 2)
}

if o.has_app_type {
res << vproto.pack_string_field(o.app_type, 10)
}

if o.has_favorite {
res << vproto.pack_bool_field(o.favorite, 3)
}

if o.has_installed {
res << vproto.pack_bool_field(o.installed, 4)
}

if o.has_auto_update {
res << vproto.pack_bool_field(o.auto_update, 5)
}

if o.has_bytes_downloaded {
res << vproto.pack_uint64_field(o.bytes_downloaded, 6)
}

if o.has_bytes_needed {
res << vproto.pack_uint64_field(o.bytes_needed, 7)
}

if o.has_bytes_download_rate {
res << vproto.pack_uint32_field(o.bytes_download_rate, 8)
}

if o.has_download_paused {
res << vproto.pack_bool_field(o.download_paused, 11)
}

if o.has_num_downloading {
res << vproto.pack_uint32_field(o.num_downloading, 12)
}

if o.has_num_paused {
res << vproto.pack_uint32_field(o.num_paused, 13)
}

if o.has_changing {
res << vproto.pack_bool_field(o.changing, 14)
}

if o.has_available_on_platform {
res << vproto.pack_bool_field(o.available_on_platform, 15)
}

// [packed=false]
for _, x in o.dlcs {
res << zzz_vproto_internal_pack_cmsgclientgetclientapplistresponseappdlc(x, 9)
}

return res
}

pub fn cmsgclientgetclientapplistresponseapp_unpack(buf []byte) ?CMsgClientGetClientAppListResponseApp {
mut res := CMsgClientGetClientAppListResponseApp{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_category = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.category = v
i = ii
}

10 {
res.has_app_type = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.app_type = v
i = ii
}

3 {
res.has_favorite = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.favorite = v
i = ii
}

4 {
res.has_installed = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.installed = v
i = ii
}

5 {
res.has_auto_update = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.auto_update = v
i = ii
}

6 {
res.has_bytes_downloaded = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.bytes_downloaded = v
i = ii
}

7 {
res.has_bytes_needed = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.bytes_needed = v
i = ii
}

8 {
res.has_bytes_download_rate = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.bytes_download_rate = v
i = ii
}

11 {
res.has_download_paused = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.download_paused = v
i = ii
}

12 {
res.has_num_downloading = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.num_downloading = v
i = ii
}

13 {
res.has_num_paused = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.num_paused = v
i = ii
}

14 {
res.has_changing = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.changing = v
i = ii
}

15 {
res.has_available_on_platform = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.available_on_platform = v
i = ii
}

9 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponseappdlc(cur_buf, tag_wiretype.wire_type)?
res.dlcs << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientapplistresponseapp() CMsgClientGetClientAppListResponseApp {
return CMsgClientGetClientAppListResponseApp{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientapplistresponseapp(o CMsgClientGetClientAppListResponseApp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponseapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientAppListResponseApp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetclientapplistresponseapp_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetClientAppListResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
apps []CMsgClientGetClientAppListResponseApp
bytes_available u64
has_bytes_available bool
}
pub fn (o &CMsgClientGetClientAppListResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.apps {
res << zzz_vproto_internal_pack_cmsgclientgetclientapplistresponseapp(x, 1)
}

if o.has_bytes_available {
res << vproto.pack_uint64_field(o.bytes_available, 2)
}

return res
}

pub fn cmsgclientgetclientapplistresponse_unpack(buf []byte) ?CMsgClientGetClientAppListResponse {
mut res := CMsgClientGetClientAppListResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponseapp(cur_buf, tag_wiretype.wire_type)?
res.apps << v
i = ii
}

2 {
res.has_bytes_available = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.bytes_available = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientapplistresponse() CMsgClientGetClientAppListResponse {
return CMsgClientGetClientAppListResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientapplistresponse(o CMsgClientGetClientAppListResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientAppListResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetclientapplistresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientInstallClientApp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
}
pub fn (o &CMsgClientInstallClientApp) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

return res
}

pub fn cmsgclientinstallclientapp_unpack(buf []byte) ?CMsgClientInstallClientApp {
mut res := CMsgClientInstallClientApp{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientinstallclientapp() CMsgClientInstallClientApp {
return CMsgClientInstallClientApp{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientinstallclientapp(o CMsgClientInstallClientApp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientinstallclientapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientInstallClientApp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientinstallclientapp_unpack(v)?
return i, unpacked
}
pub struct CMsgClientInstallClientAppResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
result u32
has_result bool
}
pub fn (o &CMsgClientInstallClientAppResponse) pack() []byte {
mut res := []byte{}
if o.has_result {
res << vproto.pack_uint32_field(o.result, 1)
}

return res
}

pub fn cmsgclientinstallclientappresponse_unpack(buf []byte) ?CMsgClientInstallClientAppResponse {
mut res := CMsgClientInstallClientAppResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_result = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.result = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientinstallclientappresponse() CMsgClientInstallClientAppResponse {
return CMsgClientInstallClientAppResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientinstallclientappresponse(o CMsgClientInstallClientAppResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientinstallclientappresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientInstallClientAppResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientinstallclientappresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUninstallClientApp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
}
pub fn (o &CMsgClientUninstallClientApp) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

return res
}

pub fn cmsgclientuninstallclientapp_unpack(buf []byte) ?CMsgClientUninstallClientApp {
mut res := CMsgClientUninstallClientApp{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientuninstallclientapp() CMsgClientUninstallClientApp {
return CMsgClientUninstallClientApp{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientuninstallclientapp(o CMsgClientUninstallClientApp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientuninstallclientapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUninstallClientApp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientuninstallclientapp_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUninstallClientAppResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
result u32
has_result bool
}
pub fn (o &CMsgClientUninstallClientAppResponse) pack() []byte {
mut res := []byte{}
if o.has_result {
res << vproto.pack_uint32_field(o.result, 1)
}

return res
}

pub fn cmsgclientuninstallclientappresponse_unpack(buf []byte) ?CMsgClientUninstallClientAppResponse {
mut res := CMsgClientUninstallClientAppResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_result = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.result = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientuninstallclientappresponse() CMsgClientUninstallClientAppResponse {
return CMsgClientUninstallClientAppResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientuninstallclientappresponse(o CMsgClientUninstallClientAppResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientuninstallclientappresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUninstallClientAppResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientuninstallclientappresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientSetClientAppUpdateState {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
update bool
has_update bool
}
pub fn (o &CMsgClientSetClientAppUpdateState) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_update {
res << vproto.pack_bool_field(o.update, 2)
}

return res
}

pub fn cmsgclientsetclientappupdatestate_unpack(buf []byte) ?CMsgClientSetClientAppUpdateState {
mut res := CMsgClientSetClientAppUpdateState{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_update = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.update = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsetclientappupdatestate() CMsgClientSetClientAppUpdateState {
return CMsgClientSetClientAppUpdateState{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsetclientappupdatestate(o CMsgClientSetClientAppUpdateState, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsetclientappupdatestate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSetClientAppUpdateState) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientsetclientappupdatestate_unpack(v)?
return i, unpacked
}
pub struct CMsgClientSetClientAppUpdateStateResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
result u32
has_result bool
}
pub fn (o &CMsgClientSetClientAppUpdateStateResponse) pack() []byte {
mut res := []byte{}
if o.has_result {
res << vproto.pack_uint32_field(o.result, 1)
}

return res
}

pub fn cmsgclientsetclientappupdatestateresponse_unpack(buf []byte) ?CMsgClientSetClientAppUpdateStateResponse {
mut res := CMsgClientSetClientAppUpdateStateResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_result = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.result = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsetclientappupdatestateresponse() CMsgClientSetClientAppUpdateStateResponse {
return CMsgClientSetClientAppUpdateStateResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsetclientappupdatestateresponse(o CMsgClientSetClientAppUpdateStateResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsetclientappupdatestateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSetClientAppUpdateStateResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientsetclientappupdatestateresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsuploadFileRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
file_size u32
has_file_size bool
raw_file_size u32
has_raw_file_size bool
sha_file []byte
has_sha_file bool
time_stamp u64
has_time_stamp bool
file_name string
has_file_name bool
platforms_to_sync_deprecated u32
has_platforms_to_sync_deprecated bool
platforms_to_sync u32
has_platforms_to_sync bool
cell_id u32
has_cell_id bool
can_encrypt bool
has_can_encrypt bool
}
pub fn (o &CMsgClientUFsuploadFileRequest) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_file_size {
res << vproto.pack_uint32_field(o.file_size, 2)
}

if o.has_raw_file_size {
res << vproto.pack_uint32_field(o.raw_file_size, 3)
}

if o.has_sha_file {
res << vproto.pack_bytes_field(o.sha_file, 4)
}

if o.has_time_stamp {
res << vproto.pack_uint64_field(o.time_stamp, 5)
}

if o.has_file_name {
res << vproto.pack_string_field(o.file_name, 6)
}

if o.has_platforms_to_sync_deprecated {
res << vproto.pack_uint32_field(o.platforms_to_sync_deprecated, 7)
}

if o.has_platforms_to_sync {
res << vproto.pack_uint32_field(o.platforms_to_sync, 8)
}

if o.has_cell_id {
res << vproto.pack_uint32_field(o.cell_id, 9)
}

if o.has_can_encrypt {
res << vproto.pack_bool_field(o.can_encrypt, 10)
}

return res
}

pub fn cmsgclientufsuploadfilerequest_unpack(buf []byte) ?CMsgClientUFsuploadFileRequest {
mut res := CMsgClientUFsuploadFileRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_file_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.file_size = v
i = ii
}

3 {
res.has_raw_file_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.raw_file_size = v
i = ii
}

4 {
res.has_sha_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_file = v
i = ii
}

5 {
res.has_time_stamp = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.time_stamp = v
i = ii
}

6 {
res.has_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_name = v
i = ii
}

7 {
res.has_platforms_to_sync_deprecated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.platforms_to_sync_deprecated = v
i = ii
}

8 {
res.has_platforms_to_sync = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.platforms_to_sync = v
i = ii
}

9 {
res.has_cell_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cell_id = v
i = ii
}

10 {
res.has_can_encrypt = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.can_encrypt = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadfilerequest() CMsgClientUFsuploadFileRequest {
return CMsgClientUFsuploadFileRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadfilerequest(o CMsgClientUFsuploadFileRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadfilerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsuploadFileRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsuploadfilerequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsuploadFileResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
sha_file []byte
has_sha_file bool
use_http bool
has_use_http bool
http_host string
has_http_host bool
http_url string
has_http_url bool
kv_headers []byte
has_kv_headers bool
use_https bool
has_use_https bool
encrypt_file bool
has_encrypt_file bool
}
pub fn (o &CMsgClientUFsuploadFileResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_sha_file {
res << vproto.pack_bytes_field(o.sha_file, 2)
}

if o.has_use_http {
res << vproto.pack_bool_field(o.use_http, 3)
}

if o.has_http_host {
res << vproto.pack_string_field(o.http_host, 4)
}

if o.has_http_url {
res << vproto.pack_string_field(o.http_url, 5)
}

if o.has_kv_headers {
res << vproto.pack_bytes_field(o.kv_headers, 6)
}

if o.has_use_https {
res << vproto.pack_bool_field(o.use_https, 7)
}

if o.has_encrypt_file {
res << vproto.pack_bool_field(o.encrypt_file, 8)
}

return res
}

pub fn cmsgclientufsuploadfileresponse_unpack(buf []byte) ?CMsgClientUFsuploadFileResponse {
mut res := CMsgClientUFsuploadFileResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_sha_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_file = v
i = ii
}

3 {
res.has_use_http = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.use_http = v
i = ii
}

4 {
res.has_http_host = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.http_host = v
i = ii
}

5 {
res.has_http_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.http_url = v
i = ii
}

6 {
res.has_kv_headers = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.kv_headers = v
i = ii
}

7 {
res.has_use_https = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.use_https = v
i = ii
}

8 {
res.has_encrypt_file = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.encrypt_file = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadfileresponse() CMsgClientUFsuploadFileResponse {
return CMsgClientUFsuploadFileResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadfileresponse(o CMsgClientUFsuploadFileResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadfileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsuploadFileResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsuploadfileresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsuploadCommitFile {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
app_id u32
has_app_id bool
sha_file []byte
has_sha_file bool
cub_file u32
has_cub_file bool
file_name string
has_file_name bool
}
pub fn (o &CMsgClientUFsuploadCommitFile) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

if o.has_sha_file {
res << vproto.pack_bytes_field(o.sha_file, 3)
}

if o.has_cub_file {
res << vproto.pack_uint32_field(o.cub_file, 4)
}

if o.has_file_name {
res << vproto.pack_string_field(o.file_name, 5)
}

return res
}

pub fn cmsgclientufsuploadcommitfile_unpack(buf []byte) ?CMsgClientUFsuploadCommitFile {
mut res := CMsgClientUFsuploadCommitFile{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

3 {
res.has_sha_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_file = v
i = ii
}

4 {
res.has_cub_file = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cub_file = v
i = ii
}

5 {
res.has_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadcommitfile() CMsgClientUFsuploadCommitFile {
return CMsgClientUFsuploadCommitFile{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadcommitfile(o CMsgClientUFsuploadCommitFile, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadcommitfile(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsuploadCommitFile) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsuploadcommitfile_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsuploadCommit {
mut:
unknown_fields []vproto.UnknownField
pub mut:
files []CMsgClientUFsuploadCommitFile
}
pub fn (o &CMsgClientUFsuploadCommit) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.files {
res << zzz_vproto_internal_pack_cmsgclientufsuploadcommitfile(x, 1)
}

return res
}

pub fn cmsgclientufsuploadcommit_unpack(buf []byte) ?CMsgClientUFsuploadCommit {
mut res := CMsgClientUFsuploadCommit{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientufsuploadcommitfile(cur_buf, tag_wiretype.wire_type)?
res.files << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadcommit() CMsgClientUFsuploadCommit {
return CMsgClientUFsuploadCommit{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadcommit(o CMsgClientUFsuploadCommit, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadcommit(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsuploadCommit) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsuploadcommit_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsuploadCommitResponseFile {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
app_id u32
has_app_id bool
sha_file []byte
has_sha_file bool
}
pub fn (o &CMsgClientUFsuploadCommitResponseFile) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

if o.has_sha_file {
res << vproto.pack_bytes_field(o.sha_file, 3)
}

return res
}

pub fn cmsgclientufsuploadcommitresponsefile_unpack(buf []byte) ?CMsgClientUFsuploadCommitResponseFile {
mut res := CMsgClientUFsuploadCommitResponseFile{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

3 {
res.has_sha_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_file = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadcommitresponsefile() CMsgClientUFsuploadCommitResponseFile {
return CMsgClientUFsuploadCommitResponseFile{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadcommitresponsefile(o CMsgClientUFsuploadCommitResponseFile, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadcommitresponsefile(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsuploadCommitResponseFile) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsuploadcommitresponsefile_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsuploadCommitResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
files []CMsgClientUFsuploadCommitResponseFile
}
pub fn (o &CMsgClientUFsuploadCommitResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.files {
res << zzz_vproto_internal_pack_cmsgclientufsuploadcommitresponsefile(x, 1)
}

return res
}

pub fn cmsgclientufsuploadcommitresponse_unpack(buf []byte) ?CMsgClientUFsuploadCommitResponse {
mut res := CMsgClientUFsuploadCommitResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientufsuploadcommitresponsefile(cur_buf, tag_wiretype.wire_type)?
res.files << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadcommitresponse() CMsgClientUFsuploadCommitResponse {
return CMsgClientUFsuploadCommitResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadcommitresponse(o CMsgClientUFsuploadCommitResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadcommitresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsuploadCommitResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsuploadcommitresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsfileChunk {
mut:
unknown_fields []vproto.UnknownField
pub mut:
sha_file []byte
has_sha_file bool
file_start u32
has_file_start bool
data []byte
has_data bool
}
pub fn (o &CMsgClientUFsfileChunk) pack() []byte {
mut res := []byte{}
if o.has_sha_file {
res << vproto.pack_bytes_field(o.sha_file, 1)
}

if o.has_file_start {
res << vproto.pack_uint32_field(o.file_start, 2)
}

if o.has_data {
res << vproto.pack_bytes_field(o.data, 3)
}

return res
}

pub fn cmsgclientufsfilechunk_unpack(buf []byte) ?CMsgClientUFsfileChunk {
mut res := CMsgClientUFsfileChunk{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_sha_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_file = v
i = ii
}

2 {
res.has_file_start = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.file_start = v
i = ii
}

3 {
res.has_data = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.data = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsfilechunk() CMsgClientUFsfileChunk {
return CMsgClientUFsfileChunk{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsfilechunk(o CMsgClientUFsfileChunk, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsfilechunk(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsfileChunk) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsfilechunk_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFstransferHeartbeat {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CMsgClientUFstransferHeartbeat) pack() []byte {
res := []byte{}
return res
}

pub fn cmsgclientufstransferheartbeat_unpack(buf []byte) ?CMsgClientUFstransferHeartbeat {
res := CMsgClientUFstransferHeartbeat{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufstransferheartbeat() CMsgClientUFstransferHeartbeat {
return CMsgClientUFstransferHeartbeat{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufstransferheartbeat(o CMsgClientUFstransferHeartbeat, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufstransferheartbeat(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFstransferHeartbeat) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufstransferheartbeat_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsuploadFileFinished {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
sha_file []byte
has_sha_file bool
}
pub fn (o &CMsgClientUFsuploadFileFinished) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_sha_file {
res << vproto.pack_bytes_field(o.sha_file, 2)
}

return res
}

pub fn cmsgclientufsuploadfilefinished_unpack(buf []byte) ?CMsgClientUFsuploadFileFinished {
mut res := CMsgClientUFsuploadFileFinished{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_sha_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_file = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadfilefinished() CMsgClientUFsuploadFileFinished {
return CMsgClientUFsuploadFileFinished{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadfilefinished(o CMsgClientUFsuploadFileFinished, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadfilefinished(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsuploadFileFinished) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsuploadfilefinished_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsdeleteFileRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
file_name string
has_file_name bool
is_explicit_delete bool
has_is_explicit_delete bool
}
pub fn (o &CMsgClientUFsdeleteFileRequest) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_file_name {
res << vproto.pack_string_field(o.file_name, 2)
}

if o.has_is_explicit_delete {
res << vproto.pack_bool_field(o.is_explicit_delete, 3)
}

return res
}

pub fn cmsgclientufsdeletefilerequest_unpack(buf []byte) ?CMsgClientUFsdeleteFileRequest {
mut res := CMsgClientUFsdeleteFileRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_name = v
i = ii
}

3 {
res.has_is_explicit_delete = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_explicit_delete = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsdeletefilerequest() CMsgClientUFsdeleteFileRequest {
return CMsgClientUFsdeleteFileRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsdeletefilerequest(o CMsgClientUFsdeleteFileRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsdeletefilerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsdeleteFileRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsdeletefilerequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsdeleteFileResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
file_name string
has_file_name bool
}
pub fn (o &CMsgClientUFsdeleteFileResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_file_name {
res << vproto.pack_string_field(o.file_name, 2)
}

return res
}

pub fn cmsgclientufsdeletefileresponse_unpack(buf []byte) ?CMsgClientUFsdeleteFileResponse {
mut res := CMsgClientUFsdeleteFileResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsdeletefileresponse() CMsgClientUFsdeleteFileResponse {
return CMsgClientUFsdeleteFileResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsdeletefileresponse(o CMsgClientUFsdeleteFileResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsdeletefileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsdeleteFileResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsdeletefileresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsgetFileListForApp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
apps_to_query []u32
send_path_prefixes bool
has_send_path_prefixes bool
}
pub fn (o &CMsgClientUFsgetFileListForApp) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.apps_to_query {
res << vproto.pack_uint32_field(x, 1)
}

if o.has_send_path_prefixes {
res << vproto.pack_bool_field(o.send_path_prefixes, 2)
}

return res
}

pub fn cmsgclientufsgetfilelistforapp_unpack(buf []byte) ?CMsgClientUFsgetFileListForApp {
mut res := CMsgClientUFsgetFileListForApp{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.apps_to_query << v
i = ii
}

2 {
res.has_send_path_prefixes = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.send_path_prefixes = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetfilelistforapp() CMsgClientUFsgetFileListForApp {
return CMsgClientUFsgetFileListForApp{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetfilelistforapp(o CMsgClientUFsgetFileListForApp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetfilelistforapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsgetFileListForApp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsgetfilelistforapp_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsgetFileListForAppResponseFile {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
file_name string
has_file_name bool
sha_file []byte
has_sha_file bool
time_stamp u64
has_time_stamp bool
raw_file_size u32
has_raw_file_size bool
is_explicit_delete bool
has_is_explicit_delete bool
platforms_to_sync u32
has_platforms_to_sync bool
path_prefix_index u32
has_path_prefix_index bool
}
pub fn (o &CMsgClientUFsgetFileListForAppResponseFile) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_file_name {
res << vproto.pack_string_field(o.file_name, 2)
}

if o.has_sha_file {
res << vproto.pack_bytes_field(o.sha_file, 3)
}

if o.has_time_stamp {
res << vproto.pack_uint64_field(o.time_stamp, 4)
}

if o.has_raw_file_size {
res << vproto.pack_uint32_field(o.raw_file_size, 5)
}

if o.has_is_explicit_delete {
res << vproto.pack_bool_field(o.is_explicit_delete, 6)
}

if o.has_platforms_to_sync {
res << vproto.pack_uint32_field(o.platforms_to_sync, 7)
}

if o.has_path_prefix_index {
res << vproto.pack_uint32_field(o.path_prefix_index, 8)
}

return res
}

pub fn cmsgclientufsgetfilelistforappresponsefile_unpack(buf []byte) ?CMsgClientUFsgetFileListForAppResponseFile {
mut res := CMsgClientUFsgetFileListForAppResponseFile{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_name = v
i = ii
}

3 {
res.has_sha_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_file = v
i = ii
}

4 {
res.has_time_stamp = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.time_stamp = v
i = ii
}

5 {
res.has_raw_file_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.raw_file_size = v
i = ii
}

6 {
res.has_is_explicit_delete = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_explicit_delete = v
i = ii
}

7 {
res.has_platforms_to_sync = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.platforms_to_sync = v
i = ii
}

8 {
res.has_path_prefix_index = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.path_prefix_index = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetfilelistforappresponsefile() CMsgClientUFsgetFileListForAppResponseFile {
return CMsgClientUFsgetFileListForAppResponseFile{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetfilelistforappresponsefile(o CMsgClientUFsgetFileListForAppResponseFile, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetfilelistforappresponsefile(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsgetFileListForAppResponseFile) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsgetfilelistforappresponsefile_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsgetFileListForAppResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
files []CMsgClientUFsgetFileListForAppResponseFile
path_prefixes []string
}
pub fn (o &CMsgClientUFsgetFileListForAppResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.files {
res << zzz_vproto_internal_pack_cmsgclientufsgetfilelistforappresponsefile(x, 1)
}

// [packed=false]
for _, x in o.path_prefixes {
res << vproto.pack_string_field(x, 2)
}

return res
}

pub fn cmsgclientufsgetfilelistforappresponse_unpack(buf []byte) ?CMsgClientUFsgetFileListForAppResponse {
mut res := CMsgClientUFsgetFileListForAppResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientufsgetfilelistforappresponsefile(cur_buf, tag_wiretype.wire_type)?
res.files << v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.path_prefixes << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetfilelistforappresponse() CMsgClientUFsgetFileListForAppResponse {
return CMsgClientUFsgetFileListForAppResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetfilelistforappresponse(o CMsgClientUFsgetFileListForAppResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetfilelistforappresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsgetFileListForAppResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsgetfilelistforappresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsdownloadRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
file_name string
has_file_name bool
can_handle_http bool
has_can_handle_http bool
}
pub fn (o &CMsgClientUFsdownloadRequest) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_file_name {
res << vproto.pack_string_field(o.file_name, 2)
}

if o.has_can_handle_http {
res << vproto.pack_bool_field(o.can_handle_http, 3)
}

return res
}

pub fn cmsgclientufsdownloadrequest_unpack(buf []byte) ?CMsgClientUFsdownloadRequest {
mut res := CMsgClientUFsdownloadRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_name = v
i = ii
}

3 {
res.has_can_handle_http = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.can_handle_http = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsdownloadrequest() CMsgClientUFsdownloadRequest {
return CMsgClientUFsdownloadRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsdownloadrequest(o CMsgClientUFsdownloadRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsdownloadrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsdownloadRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsdownloadrequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsdownloadResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
app_id u32
has_app_id bool
file_size u32
has_file_size bool
raw_file_size u32
has_raw_file_size bool
sha_file []byte
has_sha_file bool
time_stamp u64
has_time_stamp bool
is_explicit_delete bool
has_is_explicit_delete bool
use_http bool
has_use_http bool
http_host string
has_http_host bool
http_url string
has_http_url bool
kv_headers []byte
has_kv_headers bool
use_https bool
has_use_https bool
encrypted bool
has_encrypted bool
}
pub fn (o &CMsgClientUFsdownloadResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

if o.has_file_size {
res << vproto.pack_uint32_field(o.file_size, 3)
}

if o.has_raw_file_size {
res << vproto.pack_uint32_field(o.raw_file_size, 4)
}

if o.has_sha_file {
res << vproto.pack_bytes_field(o.sha_file, 5)
}

if o.has_time_stamp {
res << vproto.pack_uint64_field(o.time_stamp, 6)
}

if o.has_is_explicit_delete {
res << vproto.pack_bool_field(o.is_explicit_delete, 7)
}

if o.has_use_http {
res << vproto.pack_bool_field(o.use_http, 8)
}

if o.has_http_host {
res << vproto.pack_string_field(o.http_host, 9)
}

if o.has_http_url {
res << vproto.pack_string_field(o.http_url, 10)
}

if o.has_kv_headers {
res << vproto.pack_bytes_field(o.kv_headers, 11)
}

if o.has_use_https {
res << vproto.pack_bool_field(o.use_https, 12)
}

if o.has_encrypted {
res << vproto.pack_bool_field(o.encrypted, 13)
}

return res
}

pub fn cmsgclientufsdownloadresponse_unpack(buf []byte) ?CMsgClientUFsdownloadResponse {
mut res := CMsgClientUFsdownloadResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

3 {
res.has_file_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.file_size = v
i = ii
}

4 {
res.has_raw_file_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.raw_file_size = v
i = ii
}

5 {
res.has_sha_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_file = v
i = ii
}

6 {
res.has_time_stamp = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.time_stamp = v
i = ii
}

7 {
res.has_is_explicit_delete = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_explicit_delete = v
i = ii
}

8 {
res.has_use_http = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.use_http = v
i = ii
}

9 {
res.has_http_host = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.http_host = v
i = ii
}

10 {
res.has_http_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.http_url = v
i = ii
}

11 {
res.has_kv_headers = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.kv_headers = v
i = ii
}

12 {
res.has_use_https = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.use_https = v
i = ii
}

13 {
res.has_encrypted = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.encrypted = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsdownloadresponse() CMsgClientUFsdownloadResponse {
return CMsgClientUFsdownloadResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsdownloadresponse(o CMsgClientUFsdownloadResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsdownloadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsdownloadResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsdownloadresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsloginRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
protocol_version u32
has_protocol_version bool
am_session_token u64
has_am_session_token bool
apps []u32
}
pub fn (o &CMsgClientUFsloginRequest) pack() []byte {
mut res := []byte{}
if o.has_protocol_version {
res << vproto.pack_uint32_field(o.protocol_version, 1)
}

if o.has_am_session_token {
res << vproto.pack_uint64_field(o.am_session_token, 2)
}

// [packed=false]
for _, x in o.apps {
res << vproto.pack_uint32_field(x, 3)
}

return res
}

pub fn cmsgclientufsloginrequest_unpack(buf []byte) ?CMsgClientUFsloginRequest {
mut res := CMsgClientUFsloginRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_protocol_version = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.protocol_version = v
i = ii
}

2 {
res.has_am_session_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.am_session_token = v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.apps << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsloginrequest() CMsgClientUFsloginRequest {
return CMsgClientUFsloginRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsloginrequest(o CMsgClientUFsloginRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsloginrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsloginRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsloginrequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsloginResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
}
pub fn (o &CMsgClientUFsloginResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

return res
}

pub fn cmsgclientufsloginresponse_unpack(buf []byte) ?CMsgClientUFsloginResponse {
mut res := CMsgClientUFsloginResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsloginresponse() CMsgClientUFsloginResponse {
return CMsgClientUFsloginResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsloginresponse(o CMsgClientUFsloginResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsloginresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsloginResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsloginresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestEncryptedAppTicket {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
userdata []byte
has_userdata bool
}
pub fn (o &CMsgClientRequestEncryptedAppTicket) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_userdata {
res << vproto.pack_bytes_field(o.userdata, 2)
}

return res
}

pub fn cmsgclientrequestencryptedappticket_unpack(buf []byte) ?CMsgClientRequestEncryptedAppTicket {
mut res := CMsgClientRequestEncryptedAppTicket{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_userdata = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.userdata = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestencryptedappticket() CMsgClientRequestEncryptedAppTicket {
return CMsgClientRequestEncryptedAppTicket{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestencryptedappticket(o CMsgClientRequestEncryptedAppTicket, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestencryptedappticket(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestEncryptedAppTicket) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestencryptedappticket_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestEncryptedAppTicketResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
eresult int
has_eresult bool
encrypted_app_ticket EncryptedAppTicket
has_encrypted_app_ticket bool
}
pub fn (o &CMsgClientRequestEncryptedAppTicketResponse) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 2)
}

if o.has_encrypted_app_ticket {
res << zzz_vproto_internal_pack_encryptedappticket(o.encrypted_app_ticket, 3)
}

return res
}

pub fn cmsgclientrequestencryptedappticketresponse_unpack(buf []byte) ?CMsgClientRequestEncryptedAppTicketResponse {
mut res := CMsgClientRequestEncryptedAppTicketResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

3 {
res.has_encrypted_app_ticket = true
ii, v := zzz_vproto_internal_unpack_encryptedappticket(cur_buf, tag_wiretype.wire_type)?
res.encrypted_app_ticket = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestencryptedappticketresponse() CMsgClientRequestEncryptedAppTicketResponse {
return CMsgClientRequestEncryptedAppTicketResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestencryptedappticketresponse(o CMsgClientRequestEncryptedAppTicketResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestencryptedappticketresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestEncryptedAppTicketResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestencryptedappticketresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientWalletInfoUpdate {
mut:
unknown_fields []vproto.UnknownField
pub mut:
has_wallet bool
has_has_wallet bool
balance int
has_balance bool
currency int
has_currency bool
balance_delayed int
has_balance_delayed bool
balance64 i64
has_balance64 bool
balance64_delayed i64
has_balance64_delayed bool
}
pub fn (o &CMsgClientWalletInfoUpdate) pack() []byte {
mut res := []byte{}
if o.has_has_wallet {
res << vproto.pack_bool_field(o.has_wallet, 1)
}

if o.has_balance {
res << vproto.pack_int32_field(o.balance, 2)
}

if o.has_currency {
res << vproto.pack_int32_field(o.currency, 3)
}

if o.has_balance_delayed {
res << vproto.pack_int32_field(o.balance_delayed, 4)
}

if o.has_balance64 {
res << vproto.pack_int64_field(o.balance64, 5)
}

if o.has_balance64_delayed {
res << vproto.pack_int64_field(o.balance64_delayed, 6)
}

return res
}

pub fn cmsgclientwalletinfoupdate_unpack(buf []byte) ?CMsgClientWalletInfoUpdate {
mut res := CMsgClientWalletInfoUpdate{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_has_wallet = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.has_wallet = v
i = ii
}

2 {
res.has_balance = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.balance = v
i = ii
}

3 {
res.has_currency = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.currency = v
i = ii
}

4 {
res.has_balance_delayed = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.balance_delayed = v
i = ii
}

5 {
res.has_balance64 = true
ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
res.balance64 = v
i = ii
}

6 {
res.has_balance64_delayed = true
ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
res.balance64_delayed = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientwalletinfoupdate() CMsgClientWalletInfoUpdate {
return CMsgClientWalletInfoUpdate{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientwalletinfoupdate(o CMsgClientWalletInfoUpdate, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientwalletinfoupdate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWalletInfoUpdate) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientwalletinfoupdate_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAppInfoUpdate {
mut:
unknown_fields []vproto.UnknownField
pub mut:
last_changenumber u32
has_last_changenumber bool
send_changelist bool
has_send_changelist bool
}
pub fn (o &CMsgClientAppInfoUpdate) pack() []byte {
mut res := []byte{}
if o.has_last_changenumber {
res << vproto.pack_uint32_field(o.last_changenumber, 1)
}

if o.has_send_changelist {
res << vproto.pack_bool_field(o.send_changelist, 2)
}

return res
}

pub fn cmsgclientappinfoupdate_unpack(buf []byte) ?CMsgClientAppInfoUpdate {
mut res := CMsgClientAppInfoUpdate{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_last_changenumber = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_changenumber = v
i = ii
}

2 {
res.has_send_changelist = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.send_changelist = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinfoupdate() CMsgClientAppInfoUpdate {
return CMsgClientAppInfoUpdate{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinfoupdate(o CMsgClientAppInfoUpdate, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinfoupdate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoUpdate) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientappinfoupdate_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAppInfoChanges {
mut:
unknown_fields []vproto.UnknownField
pub mut:
current_change_number u32
has_current_change_number bool
force_full_update bool
has_force_full_update bool
appids []u32
}
pub fn (o &CMsgClientAppInfoChanges) pack() []byte {
mut res := []byte{}
if o.has_current_change_number {
res << vproto.pack_uint32_field(o.current_change_number, 1)
}

if o.has_force_full_update {
res << vproto.pack_bool_field(o.force_full_update, 2)
}

// [packed=false]
for _, x in o.appids {
res << vproto.pack_uint32_field(x, 3)
}

return res
}

pub fn cmsgclientappinfochanges_unpack(buf []byte) ?CMsgClientAppInfoChanges {
mut res := CMsgClientAppInfoChanges{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_current_change_number = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.current_change_number = v
i = ii
}

2 {
res.has_force_full_update = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.force_full_update = v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinfochanges() CMsgClientAppInfoChanges {
return CMsgClientAppInfoChanges{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinfochanges(o CMsgClientAppInfoChanges, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinfochanges(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoChanges) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientappinfochanges_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAppInfoRequestApp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
section_flags u32
has_section_flags bool
section_crc []u32
}
pub fn (o &CMsgClientAppInfoRequestApp) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_section_flags {
res << vproto.pack_uint32_field(o.section_flags, 2)
}

// [packed=false]
for _, x in o.section_crc {
res << vproto.pack_uint32_field(x, 3)
}

return res
}

pub fn cmsgclientappinforequestapp_unpack(buf []byte) ?CMsgClientAppInfoRequestApp {
mut res := CMsgClientAppInfoRequestApp{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_section_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.section_flags = v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.section_crc << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinforequestapp() CMsgClientAppInfoRequestApp {
return CMsgClientAppInfoRequestApp{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinforequestapp(o CMsgClientAppInfoRequestApp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinforequestapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoRequestApp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientappinforequestapp_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAppInfoRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
apps []CMsgClientAppInfoRequestApp
supports_batches bool
has_supports_batches bool
}
pub fn (o &CMsgClientAppInfoRequest) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.apps {
res << zzz_vproto_internal_pack_cmsgclientappinforequestapp(x, 1)
}

if o.has_supports_batches {
res << vproto.pack_bool_field(o.supports_batches, 2)
}

return res
}

pub fn cmsgclientappinforequest_unpack(buf []byte) ?CMsgClientAppInfoRequest {
mut res := CMsgClientAppInfoRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientappinforequestapp(cur_buf, tag_wiretype.wire_type)?
res.apps << v
i = ii
}

2 {
res.has_supports_batches = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.supports_batches = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinforequest() CMsgClientAppInfoRequest {
return CMsgClientAppInfoRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinforequest(o CMsgClientAppInfoRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientappinforequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAppInfoResponseAppSection {
mut:
unknown_fields []vproto.UnknownField
pub mut:
section_id u32
has_section_id bool
section_kv []byte
has_section_kv bool
}
pub fn (o &CMsgClientAppInfoResponseAppSection) pack() []byte {
mut res := []byte{}
if o.has_section_id {
res << vproto.pack_uint32_field(o.section_id, 1)
}

if o.has_section_kv {
res << vproto.pack_bytes_field(o.section_kv, 2)
}

return res
}

pub fn cmsgclientappinforesponseappsection_unpack(buf []byte) ?CMsgClientAppInfoResponseAppSection {
mut res := CMsgClientAppInfoResponseAppSection{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_section_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.section_id = v
i = ii
}

2 {
res.has_section_kv = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.section_kv = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinforesponseappsection() CMsgClientAppInfoResponseAppSection {
return CMsgClientAppInfoResponseAppSection{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinforesponseappsection(o CMsgClientAppInfoResponseAppSection, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinforesponseappsection(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoResponseAppSection) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientappinforesponseappsection_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAppInfoResponseApp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
change_number u32
has_change_number bool
sections []CMsgClientAppInfoResponseAppSection
}
pub fn (o &CMsgClientAppInfoResponseApp) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_change_number {
res << vproto.pack_uint32_field(o.change_number, 2)
}

// [packed=false]
for _, x in o.sections {
res << zzz_vproto_internal_pack_cmsgclientappinforesponseappsection(x, 3)
}

return res
}

pub fn cmsgclientappinforesponseapp_unpack(buf []byte) ?CMsgClientAppInfoResponseApp {
mut res := CMsgClientAppInfoResponseApp{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_change_number = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.change_number = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientappinforesponseappsection(cur_buf, tag_wiretype.wire_type)?
res.sections << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinforesponseapp() CMsgClientAppInfoResponseApp {
return CMsgClientAppInfoResponseApp{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinforesponseapp(o CMsgClientAppInfoResponseApp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinforesponseapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoResponseApp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientappinforesponseapp_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAppInfoResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
apps []CMsgClientAppInfoResponseApp
apps_unknown []u32
apps_pending u32
has_apps_pending bool
}
pub fn (o &CMsgClientAppInfoResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.apps {
res << zzz_vproto_internal_pack_cmsgclientappinforesponseapp(x, 1)
}

// [packed=false]
for _, x in o.apps_unknown {
res << vproto.pack_uint32_field(x, 2)
}

if o.has_apps_pending {
res << vproto.pack_uint32_field(o.apps_pending, 3)
}

return res
}

pub fn cmsgclientappinforesponse_unpack(buf []byte) ?CMsgClientAppInfoResponse {
mut res := CMsgClientAppInfoResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientappinforesponseapp(cur_buf, tag_wiretype.wire_type)?
res.apps << v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.apps_unknown << v
i = ii
}

3 {
res.has_apps_pending = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.apps_pending = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinforesponse() CMsgClientAppInfoResponse {
return CMsgClientAppInfoResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinforesponse(o CMsgClientAppInfoResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientappinforesponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPackageInfoRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
package_ids []u32
meta_data_only bool
has_meta_data_only bool
}
pub fn (o &CMsgClientPackageInfoRequest) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.package_ids {
res << vproto.pack_uint32_field(x, 1)
}

if o.has_meta_data_only {
res << vproto.pack_bool_field(o.meta_data_only, 2)
}

return res
}

pub fn cmsgclientpackageinforequest_unpack(buf []byte) ?CMsgClientPackageInfoRequest {
mut res := CMsgClientPackageInfoRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.package_ids << v
i = ii
}

2 {
res.has_meta_data_only = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.meta_data_only = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpackageinforequest() CMsgClientPackageInfoRequest {
return CMsgClientPackageInfoRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpackageinforequest(o CMsgClientPackageInfoRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpackageinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPackageInfoRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpackageinforequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPackageInfoResponsePackage {
mut:
unknown_fields []vproto.UnknownField
pub mut:
package_id u32
has_package_id bool
change_number u32
has_change_number bool
sha []byte
has_sha bool
buffer []byte
has_buffer bool
}
pub fn (o &CMsgClientPackageInfoResponsePackage) pack() []byte {
mut res := []byte{}
if o.has_package_id {
res << vproto.pack_uint32_field(o.package_id, 1)
}

if o.has_change_number {
res << vproto.pack_uint32_field(o.change_number, 2)
}

if o.has_sha {
res << vproto.pack_bytes_field(o.sha, 3)
}

if o.has_buffer {
res << vproto.pack_bytes_field(o.buffer, 4)
}

return res
}

pub fn cmsgclientpackageinforesponsepackage_unpack(buf []byte) ?CMsgClientPackageInfoResponsePackage {
mut res := CMsgClientPackageInfoResponsePackage{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_package_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.package_id = v
i = ii
}

2 {
res.has_change_number = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.change_number = v
i = ii
}

3 {
res.has_sha = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha = v
i = ii
}

4 {
res.has_buffer = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.buffer = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpackageinforesponsepackage() CMsgClientPackageInfoResponsePackage {
return CMsgClientPackageInfoResponsePackage{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpackageinforesponsepackage(o CMsgClientPackageInfoResponsePackage, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpackageinforesponsepackage(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPackageInfoResponsePackage) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpackageinforesponsepackage_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPackageInfoResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
packages []CMsgClientPackageInfoResponsePackage
packages_unknown []u32
packages_pending u32
has_packages_pending bool
}
pub fn (o &CMsgClientPackageInfoResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.packages {
res << zzz_vproto_internal_pack_cmsgclientpackageinforesponsepackage(x, 1)
}

// [packed=false]
for _, x in o.packages_unknown {
res << vproto.pack_uint32_field(x, 2)
}

if o.has_packages_pending {
res << vproto.pack_uint32_field(o.packages_pending, 3)
}

return res
}

pub fn cmsgclientpackageinforesponse_unpack(buf []byte) ?CMsgClientPackageInfoResponse {
mut res := CMsgClientPackageInfoResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientpackageinforesponsepackage(cur_buf, tag_wiretype.wire_type)?
res.packages << v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.packages_unknown << v
i = ii
}

3 {
res.has_packages_pending = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.packages_pending = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpackageinforesponse() CMsgClientPackageInfoResponse {
return CMsgClientPackageInfoResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpackageinforesponse(o CMsgClientPackageInfoResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpackageinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPackageInfoResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpackageinforesponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcschangesSinceRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
since_change_number u32
has_since_change_number bool
send_app_info_changes bool
has_send_app_info_changes bool
send_package_info_changes bool
has_send_package_info_changes bool
num_app_info_cached u32
has_num_app_info_cached bool
num_package_info_cached u32
has_num_package_info_cached bool
}
pub fn (o &CMsgClientPIcschangesSinceRequest) pack() []byte {
mut res := []byte{}
if o.has_since_change_number {
res << vproto.pack_uint32_field(o.since_change_number, 1)
}

if o.has_send_app_info_changes {
res << vproto.pack_bool_field(o.send_app_info_changes, 2)
}

if o.has_send_package_info_changes {
res << vproto.pack_bool_field(o.send_package_info_changes, 3)
}

if o.has_num_app_info_cached {
res << vproto.pack_uint32_field(o.num_app_info_cached, 4)
}

if o.has_num_package_info_cached {
res << vproto.pack_uint32_field(o.num_package_info_cached, 5)
}

return res
}

pub fn cmsgclientpicschangessincerequest_unpack(buf []byte) ?CMsgClientPIcschangesSinceRequest {
mut res := CMsgClientPIcschangesSinceRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_since_change_number = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.since_change_number = v
i = ii
}

2 {
res.has_send_app_info_changes = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.send_app_info_changes = v
i = ii
}

3 {
res.has_send_package_info_changes = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.send_package_info_changes = v
i = ii
}

4 {
res.has_num_app_info_cached = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.num_app_info_cached = v
i = ii
}

5 {
res.has_num_package_info_cached = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.num_package_info_cached = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicschangessincerequest() CMsgClientPIcschangesSinceRequest {
return CMsgClientPIcschangesSinceRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicschangessincerequest(o CMsgClientPIcschangesSinceRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicschangessincerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcschangesSinceRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicschangessincerequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcschangesSinceResponsePackageChange {
mut:
unknown_fields []vproto.UnknownField
pub mut:
packageid u32
has_packageid bool
change_number u32
has_change_number bool
needs_token bool
has_needs_token bool
}
pub fn (o &CMsgClientPIcschangesSinceResponsePackageChange) pack() []byte {
mut res := []byte{}
if o.has_packageid {
res << vproto.pack_uint32_field(o.packageid, 1)
}

if o.has_change_number {
res << vproto.pack_uint32_field(o.change_number, 2)
}

if o.has_needs_token {
res << vproto.pack_bool_field(o.needs_token, 3)
}

return res
}

pub fn cmsgclientpicschangessinceresponsepackagechange_unpack(buf []byte) ?CMsgClientPIcschangesSinceResponsePackageChange {
mut res := CMsgClientPIcschangesSinceResponsePackageChange{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_packageid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.packageid = v
i = ii
}

2 {
res.has_change_number = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.change_number = v
i = ii
}

3 {
res.has_needs_token = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.needs_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicschangessinceresponsepackagechange() CMsgClientPIcschangesSinceResponsePackageChange {
return CMsgClientPIcschangesSinceResponsePackageChange{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicschangessinceresponsepackagechange(o CMsgClientPIcschangesSinceResponsePackageChange, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponsepackagechange(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcschangesSinceResponsePackageChange) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicschangessinceresponsepackagechange_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcschangesSinceResponseAppChange {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
change_number u32
has_change_number bool
needs_token bool
has_needs_token bool
}
pub fn (o &CMsgClientPIcschangesSinceResponseAppChange) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_change_number {
res << vproto.pack_uint32_field(o.change_number, 2)
}

if o.has_needs_token {
res << vproto.pack_bool_field(o.needs_token, 3)
}

return res
}

pub fn cmsgclientpicschangessinceresponseappchange_unpack(buf []byte) ?CMsgClientPIcschangesSinceResponseAppChange {
mut res := CMsgClientPIcschangesSinceResponseAppChange{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_change_number = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.change_number = v
i = ii
}

3 {
res.has_needs_token = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.needs_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicschangessinceresponseappchange() CMsgClientPIcschangesSinceResponseAppChange {
return CMsgClientPIcschangesSinceResponseAppChange{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicschangessinceresponseappchange(o CMsgClientPIcschangesSinceResponseAppChange, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponseappchange(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcschangesSinceResponseAppChange) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicschangessinceresponseappchange_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcschangesSinceResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
current_change_number u32
has_current_change_number bool
since_change_number u32
has_since_change_number bool
force_full_update bool
has_force_full_update bool
package_changes []CMsgClientPIcschangesSinceResponsePackageChange
app_changes []CMsgClientPIcschangesSinceResponseAppChange
force_full_app_update bool
has_force_full_app_update bool
force_full_package_update bool
has_force_full_package_update bool
}
pub fn (o &CMsgClientPIcschangesSinceResponse) pack() []byte {
mut res := []byte{}
if o.has_current_change_number {
res << vproto.pack_uint32_field(o.current_change_number, 1)
}

if o.has_since_change_number {
res << vproto.pack_uint32_field(o.since_change_number, 2)
}

if o.has_force_full_update {
res << vproto.pack_bool_field(o.force_full_update, 3)
}

// [packed=false]
for _, x in o.package_changes {
res << zzz_vproto_internal_pack_cmsgclientpicschangessinceresponsepackagechange(x, 4)
}

// [packed=false]
for _, x in o.app_changes {
res << zzz_vproto_internal_pack_cmsgclientpicschangessinceresponseappchange(x, 5)
}

if o.has_force_full_app_update {
res << vproto.pack_bool_field(o.force_full_app_update, 6)
}

if o.has_force_full_package_update {
res << vproto.pack_bool_field(o.force_full_package_update, 7)
}

return res
}

pub fn cmsgclientpicschangessinceresponse_unpack(buf []byte) ?CMsgClientPIcschangesSinceResponse {
mut res := CMsgClientPIcschangesSinceResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_current_change_number = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.current_change_number = v
i = ii
}

2 {
res.has_since_change_number = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.since_change_number = v
i = ii
}

3 {
res.has_force_full_update = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.force_full_update = v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponsepackagechange(cur_buf, tag_wiretype.wire_type)?
res.package_changes << v
i = ii
}

5 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponseappchange(cur_buf, tag_wiretype.wire_type)?
res.app_changes << v
i = ii
}

6 {
res.has_force_full_app_update = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.force_full_app_update = v
i = ii
}

7 {
res.has_force_full_package_update = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.force_full_package_update = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicschangessinceresponse() CMsgClientPIcschangesSinceResponse {
return CMsgClientPIcschangesSinceResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicschangessinceresponse(o CMsgClientPIcschangesSinceResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcschangesSinceResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicschangessinceresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcsproductInfoRequestAppInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
access_token u64
has_access_token bool
only_public bool
has_only_public bool
}
pub fn (o &CMsgClientPIcsproductInfoRequestAppInfo) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_access_token {
res << vproto.pack_uint64_field(o.access_token, 2)
}

if o.has_only_public {
res << vproto.pack_bool_field(o.only_public, 3)
}

return res
}

pub fn cmsgclientpicsproductinforequestappinfo_unpack(buf []byte) ?CMsgClientPIcsproductInfoRequestAppInfo {
mut res := CMsgClientPIcsproductInfoRequestAppInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_access_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.access_token = v
i = ii
}

3 {
res.has_only_public = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.only_public = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforequestappinfo() CMsgClientPIcsproductInfoRequestAppInfo {
return CMsgClientPIcsproductInfoRequestAppInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforequestappinfo(o CMsgClientPIcsproductInfoRequestAppInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforequestappinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcsproductInfoRequestAppInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicsproductinforequestappinfo_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcsproductInfoRequestPackageInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
packageid u32
has_packageid bool
access_token u64
has_access_token bool
}
pub fn (o &CMsgClientPIcsproductInfoRequestPackageInfo) pack() []byte {
mut res := []byte{}
if o.has_packageid {
res << vproto.pack_uint32_field(o.packageid, 1)
}

if o.has_access_token {
res << vproto.pack_uint64_field(o.access_token, 2)
}

return res
}

pub fn cmsgclientpicsproductinforequestpackageinfo_unpack(buf []byte) ?CMsgClientPIcsproductInfoRequestPackageInfo {
mut res := CMsgClientPIcsproductInfoRequestPackageInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_packageid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.packageid = v
i = ii
}

2 {
res.has_access_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.access_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforequestpackageinfo() CMsgClientPIcsproductInfoRequestPackageInfo {
return CMsgClientPIcsproductInfoRequestPackageInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforequestpackageinfo(o CMsgClientPIcsproductInfoRequestPackageInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforequestpackageinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcsproductInfoRequestPackageInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicsproductinforequestpackageinfo_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcsproductInfoRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
packages []CMsgClientPIcsproductInfoRequestPackageInfo
apps []CMsgClientPIcsproductInfoRequestAppInfo
meta_data_only bool
has_meta_data_only bool
num_prev_failed u32
has_num_prev_failed bool
supports_package_tokens u32
has_supports_package_tokens bool
}
pub fn (o &CMsgClientPIcsproductInfoRequest) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.packages {
res << zzz_vproto_internal_pack_cmsgclientpicsproductinforequestpackageinfo(x, 1)
}

// [packed=false]
for _, x in o.apps {
res << zzz_vproto_internal_pack_cmsgclientpicsproductinforequestappinfo(x, 2)
}

if o.has_meta_data_only {
res << vproto.pack_bool_field(o.meta_data_only, 3)
}

if o.has_num_prev_failed {
res << vproto.pack_uint32_field(o.num_prev_failed, 4)
}

if o.has_supports_package_tokens {
res << vproto.pack_uint32_field(o.supports_package_tokens, 5)
}

return res
}

pub fn cmsgclientpicsproductinforequest_unpack(buf []byte) ?CMsgClientPIcsproductInfoRequest {
mut res := CMsgClientPIcsproductInfoRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientpicsproductinforequestpackageinfo(cur_buf, tag_wiretype.wire_type)?
res.packages << v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientpicsproductinforequestappinfo(cur_buf, tag_wiretype.wire_type)?
res.apps << v
i = ii
}

3 {
res.has_meta_data_only = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.meta_data_only = v
i = ii
}

4 {
res.has_num_prev_failed = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.num_prev_failed = v
i = ii
}

5 {
res.has_supports_package_tokens = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.supports_package_tokens = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforequest() CMsgClientPIcsproductInfoRequest {
return CMsgClientPIcsproductInfoRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforequest(o CMsgClientPIcsproductInfoRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcsproductInfoRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicsproductinforequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcsproductInfoResponseAppInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
change_number u32
has_change_number bool
missing_token bool
has_missing_token bool
sha []byte
has_sha bool
buffer []byte
has_buffer bool
only_public bool
has_only_public bool
size u32
has_size bool
}
pub fn (o &CMsgClientPIcsproductInfoResponseAppInfo) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_change_number {
res << vproto.pack_uint32_field(o.change_number, 2)
}

if o.has_missing_token {
res << vproto.pack_bool_field(o.missing_token, 3)
}

if o.has_sha {
res << vproto.pack_bytes_field(o.sha, 4)
}

if o.has_buffer {
res << vproto.pack_bytes_field(o.buffer, 5)
}

if o.has_only_public {
res << vproto.pack_bool_field(o.only_public, 6)
}

if o.has_size {
res << vproto.pack_uint32_field(o.size, 7)
}

return res
}

pub fn cmsgclientpicsproductinforesponseappinfo_unpack(buf []byte) ?CMsgClientPIcsproductInfoResponseAppInfo {
mut res := CMsgClientPIcsproductInfoResponseAppInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_change_number = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.change_number = v
i = ii
}

3 {
res.has_missing_token = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.missing_token = v
i = ii
}

4 {
res.has_sha = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha = v
i = ii
}

5 {
res.has_buffer = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.buffer = v
i = ii
}

6 {
res.has_only_public = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.only_public = v
i = ii
}

7 {
res.has_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.size = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforesponseappinfo() CMsgClientPIcsproductInfoResponseAppInfo {
return CMsgClientPIcsproductInfoResponseAppInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforesponseappinfo(o CMsgClientPIcsproductInfoResponseAppInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponseappinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcsproductInfoResponseAppInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicsproductinforesponseappinfo_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcsproductInfoResponsePackageInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
packageid u32
has_packageid bool
change_number u32
has_change_number bool
missing_token bool
has_missing_token bool
sha []byte
has_sha bool
buffer []byte
has_buffer bool
size u32
has_size bool
}
pub fn (o &CMsgClientPIcsproductInfoResponsePackageInfo) pack() []byte {
mut res := []byte{}
if o.has_packageid {
res << vproto.pack_uint32_field(o.packageid, 1)
}

if o.has_change_number {
res << vproto.pack_uint32_field(o.change_number, 2)
}

if o.has_missing_token {
res << vproto.pack_bool_field(o.missing_token, 3)
}

if o.has_sha {
res << vproto.pack_bytes_field(o.sha, 4)
}

if o.has_buffer {
res << vproto.pack_bytes_field(o.buffer, 5)
}

if o.has_size {
res << vproto.pack_uint32_field(o.size, 6)
}

return res
}

pub fn cmsgclientpicsproductinforesponsepackageinfo_unpack(buf []byte) ?CMsgClientPIcsproductInfoResponsePackageInfo {
mut res := CMsgClientPIcsproductInfoResponsePackageInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_packageid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.packageid = v
i = ii
}

2 {
res.has_change_number = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.change_number = v
i = ii
}

3 {
res.has_missing_token = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.missing_token = v
i = ii
}

4 {
res.has_sha = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha = v
i = ii
}

5 {
res.has_buffer = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.buffer = v
i = ii
}

6 {
res.has_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.size = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforesponsepackageinfo() CMsgClientPIcsproductInfoResponsePackageInfo {
return CMsgClientPIcsproductInfoResponsePackageInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforesponsepackageinfo(o CMsgClientPIcsproductInfoResponsePackageInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponsepackageinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcsproductInfoResponsePackageInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicsproductinforesponsepackageinfo_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcsproductInfoResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
apps []CMsgClientPIcsproductInfoResponseAppInfo
unknown_appids []u32
packages []CMsgClientPIcsproductInfoResponsePackageInfo
unknown_packageids []u32
meta_data_only bool
has_meta_data_only bool
response_pending bool
has_response_pending bool
http_min_size u32
has_http_min_size bool
http_host string
has_http_host bool
}
pub fn (o &CMsgClientPIcsproductInfoResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.apps {
res << zzz_vproto_internal_pack_cmsgclientpicsproductinforesponseappinfo(x, 1)
}

// [packed=false]
for _, x in o.unknown_appids {
res << vproto.pack_uint32_field(x, 2)
}

// [packed=false]
for _, x in o.packages {
res << zzz_vproto_internal_pack_cmsgclientpicsproductinforesponsepackageinfo(x, 3)
}

// [packed=false]
for _, x in o.unknown_packageids {
res << vproto.pack_uint32_field(x, 4)
}

if o.has_meta_data_only {
res << vproto.pack_bool_field(o.meta_data_only, 5)
}

if o.has_response_pending {
res << vproto.pack_bool_field(o.response_pending, 6)
}

if o.has_http_min_size {
res << vproto.pack_uint32_field(o.http_min_size, 7)
}

if o.has_http_host {
res << vproto.pack_string_field(o.http_host, 8)
}

return res
}

pub fn cmsgclientpicsproductinforesponse_unpack(buf []byte) ?CMsgClientPIcsproductInfoResponse {
mut res := CMsgClientPIcsproductInfoResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponseappinfo(cur_buf, tag_wiretype.wire_type)?
res.apps << v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.unknown_appids << v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponsepackageinfo(cur_buf, tag_wiretype.wire_type)?
res.packages << v
i = ii
}

4 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.unknown_packageids << v
i = ii
}

5 {
res.has_meta_data_only = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.meta_data_only = v
i = ii
}

6 {
res.has_response_pending = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.response_pending = v
i = ii
}

7 {
res.has_http_min_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.http_min_size = v
i = ii
}

8 {
res.has_http_host = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.http_host = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforesponse() CMsgClientPIcsproductInfoResponse {
return CMsgClientPIcsproductInfoResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforesponse(o CMsgClientPIcsproductInfoResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcsproductInfoResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicsproductinforesponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcsaccessTokenRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
packageids []u32
appids []u32
}
pub fn (o &CMsgClientPIcsaccessTokenRequest) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.packageids {
res << vproto.pack_uint32_field(x, 1)
}

// [packed=false]
for _, x in o.appids {
res << vproto.pack_uint32_field(x, 2)
}

return res
}

pub fn cmsgclientpicsaccesstokenrequest_unpack(buf []byte) ?CMsgClientPIcsaccessTokenRequest {
mut res := CMsgClientPIcsaccessTokenRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.packageids << v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsaccesstokenrequest() CMsgClientPIcsaccessTokenRequest {
return CMsgClientPIcsaccessTokenRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsaccesstokenrequest(o CMsgClientPIcsaccessTokenRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcsaccessTokenRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicsaccesstokenrequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcsaccessTokenResponsePackageToken {
mut:
unknown_fields []vproto.UnknownField
pub mut:
packageid u32
has_packageid bool
access_token u64
has_access_token bool
}
pub fn (o &CMsgClientPIcsaccessTokenResponsePackageToken) pack() []byte {
mut res := []byte{}
if o.has_packageid {
res << vproto.pack_uint32_field(o.packageid, 1)
}

if o.has_access_token {
res << vproto.pack_uint64_field(o.access_token, 2)
}

return res
}

pub fn cmsgclientpicsaccesstokenresponsepackagetoken_unpack(buf []byte) ?CMsgClientPIcsaccessTokenResponsePackageToken {
mut res := CMsgClientPIcsaccessTokenResponsePackageToken{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_packageid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.packageid = v
i = ii
}

2 {
res.has_access_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.access_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsaccesstokenresponsepackagetoken() CMsgClientPIcsaccessTokenResponsePackageToken {
return CMsgClientPIcsaccessTokenResponsePackageToken{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponsepackagetoken(o CMsgClientPIcsaccessTokenResponsePackageToken, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponsepackagetoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcsaccessTokenResponsePackageToken) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicsaccesstokenresponsepackagetoken_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcsaccessTokenResponseAppToken {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
access_token u64
has_access_token bool
}
pub fn (o &CMsgClientPIcsaccessTokenResponseAppToken) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_access_token {
res << vproto.pack_uint64_field(o.access_token, 2)
}

return res
}

pub fn cmsgclientpicsaccesstokenresponseapptoken_unpack(buf []byte) ?CMsgClientPIcsaccessTokenResponseAppToken {
mut res := CMsgClientPIcsaccessTokenResponseAppToken{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_access_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.access_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsaccesstokenresponseapptoken() CMsgClientPIcsaccessTokenResponseAppToken {
return CMsgClientPIcsaccessTokenResponseAppToken{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponseapptoken(o CMsgClientPIcsaccessTokenResponseAppToken, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponseapptoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcsaccessTokenResponseAppToken) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicsaccesstokenresponseapptoken_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPIcsaccessTokenResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
package_access_tokens []CMsgClientPIcsaccessTokenResponsePackageToken
package_denied_tokens []u32
app_access_tokens []CMsgClientPIcsaccessTokenResponseAppToken
app_denied_tokens []u32
}
pub fn (o &CMsgClientPIcsaccessTokenResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.package_access_tokens {
res << zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponsepackagetoken(x, 1)
}

// [packed=false]
for _, x in o.package_denied_tokens {
res << vproto.pack_uint32_field(x, 2)
}

// [packed=false]
for _, x in o.app_access_tokens {
res << zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponseapptoken(x, 3)
}

// [packed=false]
for _, x in o.app_denied_tokens {
res << vproto.pack_uint32_field(x, 4)
}

return res
}

pub fn cmsgclientpicsaccesstokenresponse_unpack(buf []byte) ?CMsgClientPIcsaccessTokenResponse {
mut res := CMsgClientPIcsaccessTokenResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponsepackagetoken(cur_buf, tag_wiretype.wire_type)?
res.package_access_tokens << v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.package_denied_tokens << v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponseapptoken(cur_buf, tag_wiretype.wire_type)?
res.app_access_tokens << v
i = ii
}

4 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_denied_tokens << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsaccesstokenresponse() CMsgClientPIcsaccessTokenResponse {
return CMsgClientPIcsaccessTokenResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponse(o CMsgClientPIcsaccessTokenResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPIcsaccessTokenResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpicsaccesstokenresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsgetUGcdetails {
mut:
unknown_fields []vproto.UnknownField
pub mut:
hcontent u64
has_hcontent bool
}
pub fn (o &CMsgClientUFsgetUGcdetails) pack() []byte {
mut res := []byte{}
if o.has_hcontent {
res << vproto.pack_64bit_field(o.hcontent, 1)
}

return res
}

pub fn cmsgclientufsgetugcdetails_unpack(buf []byte) ?CMsgClientUFsgetUGcdetails {
mut res := CMsgClientUFsgetUGcdetails{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_hcontent = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.hcontent = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetugcdetails() CMsgClientUFsgetUGcdetails {
return CMsgClientUFsgetUGcdetails{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetugcdetails(o CMsgClientUFsgetUGcdetails, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetugcdetails(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsgetUGcdetails) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsgetugcdetails_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsgetUGcdetailsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
url string
has_url bool
app_id u32
has_app_id bool
filename string
has_filename bool
steamid_creator u64
has_steamid_creator bool
file_size u32
has_file_size bool
compressed_file_size u32
has_compressed_file_size bool
rangecheck_host string
has_rangecheck_host bool
file_encoded_sha1 string
has_file_encoded_sha1 bool
}
pub fn (o &CMsgClientUFsgetUGcdetailsResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_url {
res << vproto.pack_string_field(o.url, 2)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 3)
}

if o.has_filename {
res << vproto.pack_string_field(o.filename, 4)
}

if o.has_steamid_creator {
res << vproto.pack_64bit_field(o.steamid_creator, 5)
}

if o.has_file_size {
res << vproto.pack_uint32_field(o.file_size, 6)
}

if o.has_compressed_file_size {
res << vproto.pack_uint32_field(o.compressed_file_size, 7)
}

if o.has_rangecheck_host {
res << vproto.pack_string_field(o.rangecheck_host, 8)
}

if o.has_file_encoded_sha1 {
res << vproto.pack_string_field(o.file_encoded_sha1, 9)
}

return res
}

pub fn cmsgclientufsgetugcdetailsresponse_unpack(buf []byte) ?CMsgClientUFsgetUGcdetailsResponse {
mut res := CMsgClientUFsgetUGcdetailsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.url = v
i = ii
}

3 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

4 {
res.has_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename = v
i = ii
}

5 {
res.has_steamid_creator = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid_creator = v
i = ii
}

6 {
res.has_file_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.file_size = v
i = ii
}

7 {
res.has_compressed_file_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.compressed_file_size = v
i = ii
}

8 {
res.has_rangecheck_host = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.rangecheck_host = v
i = ii
}

9 {
res.has_file_encoded_sha1 = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_encoded_sha1 = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetugcdetailsresponse() CMsgClientUFsgetUGcdetailsResponse {
return CMsgClientUFsgetUGcdetailsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetugcdetailsresponse(o CMsgClientUFsgetUGcdetailsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetugcdetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsgetUGcdetailsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsgetugcdetailsresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsgetSingleFileInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
file_name string
has_file_name bool
}
pub fn (o &CMsgClientUFsgetSingleFileInfo) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_file_name {
res << vproto.pack_string_field(o.file_name, 2)
}

return res
}

pub fn cmsgclientufsgetsinglefileinfo_unpack(buf []byte) ?CMsgClientUFsgetSingleFileInfo {
mut res := CMsgClientUFsgetSingleFileInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetsinglefileinfo() CMsgClientUFsgetSingleFileInfo {
return CMsgClientUFsgetSingleFileInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetsinglefileinfo(o CMsgClientUFsgetSingleFileInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetsinglefileinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsgetSingleFileInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsgetsinglefileinfo_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsgetSingleFileInfoResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
app_id u32
has_app_id bool
file_name string
has_file_name bool
sha_file []byte
has_sha_file bool
time_stamp u64
has_time_stamp bool
raw_file_size u32
has_raw_file_size bool
is_explicit_delete bool
has_is_explicit_delete bool
}
pub fn (o &CMsgClientUFsgetSingleFileInfoResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

if o.has_file_name {
res << vproto.pack_string_field(o.file_name, 3)
}

if o.has_sha_file {
res << vproto.pack_bytes_field(o.sha_file, 4)
}

if o.has_time_stamp {
res << vproto.pack_uint64_field(o.time_stamp, 5)
}

if o.has_raw_file_size {
res << vproto.pack_uint32_field(o.raw_file_size, 6)
}

if o.has_is_explicit_delete {
res << vproto.pack_bool_field(o.is_explicit_delete, 7)
}

return res
}

pub fn cmsgclientufsgetsinglefileinforesponse_unpack(buf []byte) ?CMsgClientUFsgetSingleFileInfoResponse {
mut res := CMsgClientUFsgetSingleFileInfoResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

3 {
res.has_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_name = v
i = ii
}

4 {
res.has_sha_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_file = v
i = ii
}

5 {
res.has_time_stamp = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.time_stamp = v
i = ii
}

6 {
res.has_raw_file_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.raw_file_size = v
i = ii
}

7 {
res.has_is_explicit_delete = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_explicit_delete = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetsinglefileinforesponse() CMsgClientUFsgetSingleFileInfoResponse {
return CMsgClientUFsgetSingleFileInfoResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetsinglefileinforesponse(o CMsgClientUFsgetSingleFileInfoResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetsinglefileinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsgetSingleFileInfoResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufsgetsinglefileinforesponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsshareFile {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
file_name string
has_file_name bool
}
pub fn (o &CMsgClientUFsshareFile) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_file_name {
res << vproto.pack_string_field(o.file_name, 2)
}

return res
}

pub fn cmsgclientufssharefile_unpack(buf []byte) ?CMsgClientUFsshareFile {
mut res := CMsgClientUFsshareFile{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufssharefile() CMsgClientUFsshareFile {
return CMsgClientUFsshareFile{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufssharefile(o CMsgClientUFsshareFile, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufssharefile(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsshareFile) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufssharefile_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUFsshareFileResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
hcontent u64
has_hcontent bool
}
pub fn (o &CMsgClientUFsshareFileResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_hcontent {
res << vproto.pack_64bit_field(o.hcontent, 2)
}

return res
}

pub fn cmsgclientufssharefileresponse_unpack(buf []byte) ?CMsgClientUFsshareFileResponse {
mut res := CMsgClientUFsshareFileResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_hcontent = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.hcontent = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufssharefileresponse() CMsgClientUFsshareFileResponse {
return CMsgClientUFsshareFileResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufssharefileresponse(o CMsgClientUFsshareFileResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufssharefileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFsshareFileResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientufssharefileresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAMgetClanOfficers {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid_clan u64
has_steamid_clan bool
}
pub fn (o &CMsgClientAMgetClanOfficers) pack() []byte {
mut res := []byte{}
if o.has_steamid_clan {
res << vproto.pack_64bit_field(o.steamid_clan, 1)
}

return res
}

pub fn cmsgclientamgetclanofficers_unpack(buf []byte) ?CMsgClientAMgetClanOfficers {
mut res := CMsgClientAMgetClanOfficers{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid_clan = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid_clan = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetclanofficers() CMsgClientAMgetClanOfficers {
return CMsgClientAMgetClanOfficers{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetclanofficers(o CMsgClientAMgetClanOfficers, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetclanofficers(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMgetClanOfficers) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientamgetclanofficers_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAMgetClanOfficersResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
steamid_clan u64
has_steamid_clan bool
officer_count int
has_officer_count bool
}
pub fn (o &CMsgClientAMgetClanOfficersResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_steamid_clan {
res << vproto.pack_64bit_field(o.steamid_clan, 2)
}

if o.has_officer_count {
res << vproto.pack_int32_field(o.officer_count, 3)
}

return res
}

pub fn cmsgclientamgetclanofficersresponse_unpack(buf []byte) ?CMsgClientAMgetClanOfficersResponse {
mut res := CMsgClientAMgetClanOfficersResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_steamid_clan = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid_clan = v
i = ii
}

3 {
res.has_officer_count = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.officer_count = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetclanofficersresponse() CMsgClientAMgetClanOfficersResponse {
return CMsgClientAMgetClanOfficersResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetclanofficersresponse(o CMsgClientAMgetClanOfficersResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetclanofficersresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMgetClanOfficersResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientamgetclanofficersresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAMgetPersonaNameHistoryIdInstance {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
}
pub fn (o &CMsgClientAMgetPersonaNameHistoryIdInstance) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

return res
}

pub fn cmsgclientamgetpersonanamehistoryidinstance_unpack(buf []byte) ?CMsgClientAMgetPersonaNameHistoryIdInstance {
mut res := CMsgClientAMgetPersonaNameHistoryIdInstance{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistoryidinstance() CMsgClientAMgetPersonaNameHistoryIdInstance {
return CMsgClientAMgetPersonaNameHistoryIdInstance{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryidinstance(o CMsgClientAMgetPersonaNameHistoryIdInstance, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryidinstance(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMgetPersonaNameHistoryIdInstance) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientamgetpersonanamehistoryidinstance_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAMgetPersonaNameHistory {
mut:
unknown_fields []vproto.UnknownField
pub mut:
id_count int
has_id_count bool
ids []CMsgClientAMgetPersonaNameHistoryIdInstance
}
pub fn (o &CMsgClientAMgetPersonaNameHistory) pack() []byte {
mut res := []byte{}
if o.has_id_count {
res << vproto.pack_int32_field(o.id_count, 1)
}

// [packed=false]
for _, x in o.ids {
res << zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryidinstance(x, 2)
}

return res
}

pub fn cmsgclientamgetpersonanamehistory_unpack(buf []byte) ?CMsgClientAMgetPersonaNameHistory {
mut res := CMsgClientAMgetPersonaNameHistory{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_id_count = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.id_count = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryidinstance(cur_buf, tag_wiretype.wire_type)?
res.ids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistory() CMsgClientAMgetPersonaNameHistory {
return CMsgClientAMgetPersonaNameHistory{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistory(o CMsgClientAMgetPersonaNameHistory, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMgetPersonaNameHistory) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientamgetpersonanamehistory_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAMgetPersonaNameHistoryResponseNameTableInstanceNameInstance {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name_since u32
has_name_since bool
name string
has_name bool
}
pub fn (o &CMsgClientAMgetPersonaNameHistoryResponseNameTableInstanceNameInstance) pack() []byte {
mut res := []byte{}
if o.has_name_since {
res << vproto.pack_32bit_field(o.name_since, 1)
}

if o.has_name {
res << vproto.pack_string_field(o.name, 2)
}

return res
}

pub fn cmsgclientamgetpersonanamehistoryresponsenametableinstancenameinstance_unpack(buf []byte) ?CMsgClientAMgetPersonaNameHistoryResponseNameTableInstanceNameInstance {
mut res := CMsgClientAMgetPersonaNameHistoryResponseNameTableInstanceNameInstance{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_name_since = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.name_since = v
i = ii
}

2 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistoryresponsenametableinstancenameinstance() CMsgClientAMgetPersonaNameHistoryResponseNameTableInstanceNameInstance {
return CMsgClientAMgetPersonaNameHistoryResponseNameTableInstanceNameInstance{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponsenametableinstancenameinstance(o CMsgClientAMgetPersonaNameHistoryResponseNameTableInstanceNameInstance, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponsenametableinstancenameinstance(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMgetPersonaNameHistoryResponseNameTableInstanceNameInstance) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientamgetpersonanamehistoryresponsenametableinstancenameinstance_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAMgetPersonaNameHistoryResponseNameTableInstance {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
steamid u64
has_steamid bool
names []CMsgClientAMgetPersonaNameHistoryResponseNameTableInstanceNameInstance
}
pub fn (o &CMsgClientAMgetPersonaNameHistoryResponseNameTableInstance) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 2)
}

// [packed=false]
for _, x in o.names {
res << zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponsenametableinstancenameinstance(x, 3)
}

return res
}

pub fn cmsgclientamgetpersonanamehistoryresponsenametableinstance_unpack(buf []byte) ?CMsgClientAMgetPersonaNameHistoryResponseNameTableInstance {
mut res := CMsgClientAMgetPersonaNameHistoryResponseNameTableInstance{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponsenametableinstancenameinstance(cur_buf, tag_wiretype.wire_type)?
res.names << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistoryresponsenametableinstance() CMsgClientAMgetPersonaNameHistoryResponseNameTableInstance {
return CMsgClientAMgetPersonaNameHistoryResponseNameTableInstance{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponsenametableinstance(o CMsgClientAMgetPersonaNameHistoryResponseNameTableInstance, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponsenametableinstance(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMgetPersonaNameHistoryResponseNameTableInstance) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientamgetpersonanamehistoryresponsenametableinstance_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAMgetPersonaNameHistoryResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
responses []CMsgClientAMgetPersonaNameHistoryResponseNameTableInstance
}
pub fn (o &CMsgClientAMgetPersonaNameHistoryResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.responses {
res << zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponsenametableinstance(x, 2)
}

return res
}

pub fn cmsgclientamgetpersonanamehistoryresponse_unpack(buf []byte) ?CMsgClientAMgetPersonaNameHistoryResponse {
mut res := CMsgClientAMgetPersonaNameHistoryResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponsenametableinstance(cur_buf, tag_wiretype.wire_type)?
res.responses << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistoryresponse() CMsgClientAMgetPersonaNameHistoryResponse {
return CMsgClientAMgetPersonaNameHistoryResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponse(o CMsgClientAMgetPersonaNameHistoryResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMgetPersonaNameHistoryResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientamgetpersonanamehistoryresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientDeregisterWithServer {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eservertype u32
has_eservertype bool
app_id u32
has_app_id bool
}
pub fn (o &CMsgClientDeregisterWithServer) pack() []byte {
mut res := []byte{}
if o.has_eservertype {
res << vproto.pack_uint32_field(o.eservertype, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

return res
}

pub fn cmsgclientderegisterwithserver_unpack(buf []byte) ?CMsgClientDeregisterWithServer {
mut res := CMsgClientDeregisterWithServer{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eservertype = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eservertype = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientderegisterwithserver() CMsgClientDeregisterWithServer {
return CMsgClientDeregisterWithServer{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientderegisterwithserver(o CMsgClientDeregisterWithServer, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientderegisterwithserver(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDeregisterWithServer) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientderegisterwithserver_unpack(v)?
return i, unpacked
}
pub struct CMsgClientClanStateNameInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
clan_name string
has_clan_name bool
sha_avatar []byte
has_sha_avatar bool
}
pub fn (o &CMsgClientClanStateNameInfo) pack() []byte {
mut res := []byte{}
if o.has_clan_name {
res << vproto.pack_string_field(o.clan_name, 1)
}

if o.has_sha_avatar {
res << vproto.pack_bytes_field(o.sha_avatar, 2)
}

return res
}

pub fn cmsgclientclanstatenameinfo_unpack(buf []byte) ?CMsgClientClanStateNameInfo {
mut res := CMsgClientClanStateNameInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_clan_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.clan_name = v
i = ii
}

2 {
res.has_sha_avatar = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_avatar = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientclanstatenameinfo() CMsgClientClanStateNameInfo {
return CMsgClientClanStateNameInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientclanstatenameinfo(o CMsgClientClanStateNameInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientclanstatenameinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientClanStateNameInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientclanstatenameinfo_unpack(v)?
return i, unpacked
}
pub struct CMsgClientClanStateUserCounts {
mut:
unknown_fields []vproto.UnknownField
pub mut:
members u32
has_members bool
online u32
has_online bool
chatting u32
has_chatting bool
in_game u32
has_in_game bool
chat_room_members u32
has_chat_room_members bool
}
pub fn (o &CMsgClientClanStateUserCounts) pack() []byte {
mut res := []byte{}
if o.has_members {
res << vproto.pack_uint32_field(o.members, 1)
}

if o.has_online {
res << vproto.pack_uint32_field(o.online, 2)
}

if o.has_chatting {
res << vproto.pack_uint32_field(o.chatting, 3)
}

if o.has_in_game {
res << vproto.pack_uint32_field(o.in_game, 4)
}

if o.has_chat_room_members {
res << vproto.pack_uint32_field(o.chat_room_members, 5)
}

return res
}

pub fn cmsgclientclanstateusercounts_unpack(buf []byte) ?CMsgClientClanStateUserCounts {
mut res := CMsgClientClanStateUserCounts{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_members = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.members = v
i = ii
}

2 {
res.has_online = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.online = v
i = ii
}

3 {
res.has_chatting = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.chatting = v
i = ii
}

4 {
res.has_in_game = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.in_game = v
i = ii
}

5 {
res.has_chat_room_members = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.chat_room_members = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientclanstateusercounts() CMsgClientClanStateUserCounts {
return CMsgClientClanStateUserCounts{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientclanstateusercounts(o CMsgClientClanStateUserCounts, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientclanstateusercounts(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientClanStateUserCounts) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientclanstateusercounts_unpack(v)?
return i, unpacked
}
pub struct CMsgClientClanStateEvent {
mut:
unknown_fields []vproto.UnknownField
pub mut:
gid u64
has_gid bool
event_time u32
has_event_time bool
headline string
has_headline bool
game_id u64
has_game_id bool
just_posted bool
has_just_posted bool
}
pub fn (o &CMsgClientClanStateEvent) pack() []byte {
mut res := []byte{}
if o.has_gid {
res << vproto.pack_64bit_field(o.gid, 1)
}

if o.has_event_time {
res << vproto.pack_uint32_field(o.event_time, 2)
}

if o.has_headline {
res << vproto.pack_string_field(o.headline, 3)
}

if o.has_game_id {
res << vproto.pack_64bit_field(o.game_id, 4)
}

if o.has_just_posted {
res << vproto.pack_bool_field(o.just_posted, 5)
}

return res
}

pub fn cmsgclientclanstateevent_unpack(buf []byte) ?CMsgClientClanStateEvent {
mut res := CMsgClientClanStateEvent{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_gid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.gid = v
i = ii
}

2 {
res.has_event_time = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.event_time = v
i = ii
}

3 {
res.has_headline = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.headline = v
i = ii
}

4 {
res.has_game_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.game_id = v
i = ii
}

5 {
res.has_just_posted = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.just_posted = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientclanstateevent() CMsgClientClanStateEvent {
return CMsgClientClanStateEvent{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientclanstateevent(o CMsgClientClanStateEvent, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientclanstateevent(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientClanStateEvent) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientclanstateevent_unpack(v)?
return i, unpacked
}
pub struct CMsgClientClanState {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid_clan u64
has_steamid_clan bool
clan_account_flags u32
has_clan_account_flags bool
name_info CMsgClientClanStateNameInfo
has_name_info bool
user_counts CMsgClientClanStateUserCounts
has_user_counts bool
events []CMsgClientClanStateEvent
announcements []CMsgClientClanStateEvent
chat_room_private bool
has_chat_room_private bool
}
pub fn (o &CMsgClientClanState) pack() []byte {
mut res := []byte{}
if o.has_steamid_clan {
res << vproto.pack_64bit_field(o.steamid_clan, 1)
}

if o.has_clan_account_flags {
res << vproto.pack_uint32_field(o.clan_account_flags, 3)
}

if o.has_name_info {
res << zzz_vproto_internal_pack_cmsgclientclanstatenameinfo(o.name_info, 4)
}

if o.has_user_counts {
res << zzz_vproto_internal_pack_cmsgclientclanstateusercounts(o.user_counts, 5)
}

// [packed=false]
for _, x in o.events {
res << zzz_vproto_internal_pack_cmsgclientclanstateevent(x, 6)
}

// [packed=false]
for _, x in o.announcements {
res << zzz_vproto_internal_pack_cmsgclientclanstateevent(x, 7)
}

if o.has_chat_room_private {
res << vproto.pack_bool_field(o.chat_room_private, 8)
}

return res
}

pub fn cmsgclientclanstate_unpack(buf []byte) ?CMsgClientClanState {
mut res := CMsgClientClanState{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid_clan = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid_clan = v
i = ii
}

3 {
res.has_clan_account_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.clan_account_flags = v
i = ii
}

4 {
res.has_name_info = true
ii, v := zzz_vproto_internal_unpack_cmsgclientclanstatenameinfo(cur_buf, tag_wiretype.wire_type)?
res.name_info = v
i = ii
}

5 {
res.has_user_counts = true
ii, v := zzz_vproto_internal_unpack_cmsgclientclanstateusercounts(cur_buf, tag_wiretype.wire_type)?
res.user_counts = v
i = ii
}

6 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientclanstateevent(cur_buf, tag_wiretype.wire_type)?
res.events << v
i = ii
}

7 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientclanstateevent(cur_buf, tag_wiretype.wire_type)?
res.announcements << v
i = ii
}

8 {
res.has_chat_room_private = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.chat_room_private = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientclanstate() CMsgClientClanState {
return CMsgClientClanState{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientclanstate(o CMsgClientClanState, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientclanstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientClanState) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientclanstate_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUnsignedInstallScript {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
file_name string
has_file_name bool
file_size u32
has_file_size bool
signature_broken bool
has_signature_broken bool
depot_id u32
has_depot_id bool
manifest_id u64
has_manifest_id bool
file_flags u32
has_file_flags bool
}
pub fn (o &CMsgClientUnsignedInstallScript) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_file_name {
res << vproto.pack_string_field(o.file_name, 2)
}

if o.has_file_size {
res << vproto.pack_uint32_field(o.file_size, 3)
}

if o.has_signature_broken {
res << vproto.pack_bool_field(o.signature_broken, 4)
}

if o.has_depot_id {
res << vproto.pack_uint32_field(o.depot_id, 5)
}

if o.has_manifest_id {
res << vproto.pack_uint64_field(o.manifest_id, 6)
}

if o.has_file_flags {
res << vproto.pack_uint32_field(o.file_flags, 7)
}

return res
}

pub fn cmsgclientunsignedinstallscript_unpack(buf []byte) ?CMsgClientUnsignedInstallScript {
mut res := CMsgClientUnsignedInstallScript{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_name = v
i = ii
}

3 {
res.has_file_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.file_size = v
i = ii
}

4 {
res.has_signature_broken = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.signature_broken = v
i = ii
}

5 {
res.has_depot_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.depot_id = v
i = ii
}

6 {
res.has_manifest_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.manifest_id = v
i = ii
}

7 {
res.has_file_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.file_flags = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientunsignedinstallscript() CMsgClientUnsignedInstallScript {
return CMsgClientUnsignedInstallScript{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientunsignedinstallscript(o CMsgClientUnsignedInstallScript, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientunsignedinstallscript(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUnsignedInstallScript) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientunsignedinstallscript_unpack(v)?
return i, unpacked
}
