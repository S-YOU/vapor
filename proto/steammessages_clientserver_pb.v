// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EMMSLobbyStatus {
	k_emmslobbystatusinvalid = 0
	k_emmslobbystatusexists = 1
	k_emmslobbystatusdoesnotexist = 2
	k_emmslobbystatusnotamember = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_emmslobbystatus(e EMMSLobbyStatus, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_emmslobbystatus_packed(e []EMMSLobbyStatus, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_emmslobbystatus(buf []byte, tag_wiretype vproto.WireType) ?(int, EMMSLobbyStatus) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EMMSLobbyStatus(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_emmslobbystatus_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EMMSLobbyStatus) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgClientUDSP2PSessionStarted {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	steamid_remote     u64
	has_steamid_remote bool
	appid              int
	has_appid          bool
}

pub fn (o &CMsgClientUDSP2PSessionStarted) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_remote {
		res << vproto.pack_64bit_field(o.steamid_remote, 1)
	}
	if o.has_appid {
		res << vproto.pack_int32_field(o.appid, 2)
	}
	return res
}

pub fn cmsgclientudsp2psessionstarted_unpack(buf []byte) ?CMsgClientUDSP2PSessionStarted {
	mut res := CMsgClientUDSP2PSessionStarted{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_remote = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_remote = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientudsp2psessionstarted() CMsgClientUDSP2PSessionStarted {
	return CMsgClientUDSP2PSessionStarted{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientudsp2psessionstarted(o CMsgClientUDSP2PSessionStarted, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientudsp2psessionstarted(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUDSP2PSessionStarted) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientudsp2psessionstarted_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUDSP2PSessionEnded {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	steamid_remote         u64
	has_steamid_remote     bool
	appid                  int
	has_appid              bool
	session_length_sec     int
	has_session_length_sec bool
	session_error          int
	has_session_error      bool
	nattype                int
	has_nattype            bool
	bytes_recv             int
	has_bytes_recv         bool
	bytes_sent             int
	has_bytes_sent         bool
	bytes_sent_relay       int
	has_bytes_sent_relay   bool
	bytes_recv_relay       int
	has_bytes_recv_relay   bool
	time_to_connect_ms     int
	has_time_to_connect_ms bool
}

pub fn (o &CMsgClientUDSP2PSessionEnded) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_remote {
		res << vproto.pack_64bit_field(o.steamid_remote, 1)
	}
	if o.has_appid {
		res << vproto.pack_int32_field(o.appid, 2)
	}
	if o.has_session_length_sec {
		res << vproto.pack_int32_field(o.session_length_sec, 3)
	}
	if o.has_session_error {
		res << vproto.pack_int32_field(o.session_error, 4)
	}
	if o.has_nattype {
		res << vproto.pack_int32_field(o.nattype, 5)
	}
	if o.has_bytes_recv {
		res << vproto.pack_int32_field(o.bytes_recv, 6)
	}
	if o.has_bytes_sent {
		res << vproto.pack_int32_field(o.bytes_sent, 7)
	}
	if o.has_bytes_sent_relay {
		res << vproto.pack_int32_field(o.bytes_sent_relay, 8)
	}
	if o.has_bytes_recv_relay {
		res << vproto.pack_int32_field(o.bytes_recv_relay, 9)
	}
	if o.has_time_to_connect_ms {
		res << vproto.pack_int32_field(o.time_to_connect_ms, 10)
	}
	return res
}

pub fn cmsgclientudsp2psessionended_unpack(buf []byte) ?CMsgClientUDSP2PSessionEnded {
	mut res := CMsgClientUDSP2PSessionEnded{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_remote = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_remote = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_session_length_sec = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.session_length_sec = v
				i = ii
			}
			4 {
				res.has_session_error = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.session_error = v
				i = ii
			}
			5 {
				res.has_nattype = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.nattype = v
				i = ii
			}
			6 {
				res.has_bytes_recv = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_recv = v
				i = ii
			}
			7 {
				res.has_bytes_sent = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_sent = v
				i = ii
			}
			8 {
				res.has_bytes_sent_relay = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_sent_relay = v
				i = ii
			}
			9 {
				res.has_bytes_recv_relay = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_recv_relay = v
				i = ii
			}
			10 {
				res.has_time_to_connect_ms = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_to_connect_ms = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientudsp2psessionended() CMsgClientUDSP2PSessionEnded {
	return CMsgClientUDSP2PSessionEnded{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientudsp2psessionended(o CMsgClientUDSP2PSessionEnded, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientudsp2psessionended(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUDSP2PSessionEnded) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientudsp2psessionended_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRegisterAuthTicketWithCM {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	protocol_version       u32
	has_protocol_version   bool
	ticket                 []byte
	has_ticket             bool
	client_instance_id     u64
	has_client_instance_id bool
}

pub fn (o &CMsgClientRegisterAuthTicketWithCM) pack() []byte {
	mut res := []byte{}
	if o.has_protocol_version {
		res << vproto.pack_uint32_field(o.protocol_version, 1)
	}
	if o.has_ticket {
		res << vproto.pack_bytes_field(o.ticket, 3)
	}
	if o.has_client_instance_id {
		res << vproto.pack_uint64_field(o.client_instance_id, 4)
	}
	return res
}

pub fn cmsgclientregisterauthticketwithcm_unpack(buf []byte) ?CMsgClientRegisterAuthTicketWithCM {
	mut res := CMsgClientRegisterAuthTicketWithCM{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_protocol_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.protocol_version = v
				i = ii
			}
			3 {
				res.has_ticket = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.ticket = v
				i = ii
			}
			4 {
				res.has_client_instance_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.client_instance_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientregisterauthticketwithcm() CMsgClientRegisterAuthTicketWithCM {
	return CMsgClientRegisterAuthTicketWithCM{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientregisterauthticketwithcm(o CMsgClientRegisterAuthTicketWithCM, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientregisterauthticketwithcm(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRegisterAuthTicketWithCM) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientregisterauthticketwithcm_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientTicketAuthComplete {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	steam_id                   u64
	has_steam_id               bool
	game_id                    u64
	has_game_id                bool
	estate                     u32
	has_estate                 bool
	eauth_session_response     u32
	has_eauth_session_response bool
	deprecated_ticket          []byte
	has_deprecated_ticket      bool
	ticket_crc                 u32
	has_ticket_crc             bool
	ticket_sequence            u32
	has_ticket_sequence        bool
	owner_steam_id             u64
	has_owner_steam_id         bool
}

pub fn (o &CMsgClientTicketAuthComplete) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.has_game_id {
		res << vproto.pack_64bit_field(o.game_id, 2)
	}
	if o.has_estate {
		res << vproto.pack_uint32_field(o.estate, 3)
	}
	if o.has_eauth_session_response {
		res << vproto.pack_uint32_field(o.eauth_session_response, 4)
	}
	if o.has_deprecated_ticket {
		res << vproto.pack_bytes_field(o.deprecated_ticket, 5)
	}
	if o.has_ticket_crc {
		res << vproto.pack_uint32_field(o.ticket_crc, 6)
	}
	if o.has_ticket_sequence {
		res << vproto.pack_uint32_field(o.ticket_sequence, 7)
	}
	if o.has_owner_steam_id {
		res << vproto.pack_64bit_field(o.owner_steam_id, 8)
	}
	return res
}

pub fn cmsgclientticketauthcomplete_unpack(buf []byte) ?CMsgClientTicketAuthComplete {
	mut res := CMsgClientTicketAuthComplete{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			2 {
				res.has_game_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.game_id = v
				i = ii
			}
			3 {
				res.has_estate = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.estate = v
				i = ii
			}
			4 {
				res.has_eauth_session_response = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eauth_session_response = v
				i = ii
			}
			5 {
				res.has_deprecated_ticket = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_ticket = v
				i = ii
			}
			6 {
				res.has_ticket_crc = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ticket_crc = v
				i = ii
			}
			7 {
				res.has_ticket_sequence = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ticket_sequence = v
				i = ii
			}
			8 {
				res.has_owner_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_steam_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientticketauthcomplete() CMsgClientTicketAuthComplete {
	return CMsgClientTicketAuthComplete{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientticketauthcomplete(o CMsgClientTicketAuthComplete, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientticketauthcomplete(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientTicketAuthComplete) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientticketauthcomplete_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientCMList {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	cm_addresses                     []u32
	cm_ports                         []u32
	cm_websocket_addresses           []string
	percent_default_to_websocket     u32
	has_percent_default_to_websocket bool
}

pub fn (o &CMsgClientCMList) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.cm_addresses {
		res << vproto.pack_uint32_field(x, 1)
	}
	// [packed=false]
	for _, x in o.cm_ports {
		res << vproto.pack_uint32_field(x, 2)
	}
	// [packed=false]
	for _, x in o.cm_websocket_addresses {
		res << vproto.pack_string_field(x, 3)
	}
	if o.has_percent_default_to_websocket {
		res << vproto.pack_uint32_field(o.percent_default_to_websocket, 4)
	}
	return res
}

pub fn cmsgclientcmlist_unpack(buf []byte) ?CMsgClientCMList {
	mut res := CMsgClientCMList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cm_addresses << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cm_ports << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cm_websocket_addresses << v
				i = ii
			}
			4 {
				res.has_percent_default_to_websocket = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.percent_default_to_websocket = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcmlist() CMsgClientCMList {
	return CMsgClientCMList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcmlist(o CMsgClientCMList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcmlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCMList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientcmlist_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientP2PConnectionInfo {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steam_id_dest         u64
	has_steam_id_dest     bool
	steam_id_src          u64
	has_steam_id_src      bool
	app_id                u32
	has_app_id            bool
	candidate             []byte
	has_candidate         bool
	connection_id_src     u64
	has_connection_id_src bool
	rendezvous            []byte
	has_rendezvous        bool
}

pub fn (o &CMsgClientP2PConnectionInfo) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id_dest {
		res << vproto.pack_64bit_field(o.steam_id_dest, 1)
	}
	if o.has_steam_id_src {
		res << vproto.pack_64bit_field(o.steam_id_src, 2)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 3)
	}
	if o.has_candidate {
		res << vproto.pack_bytes_field(o.candidate, 4)
	}
	if o.has_connection_id_src {
		res << vproto.pack_64bit_field(o.connection_id_src, 5)
	}
	if o.has_rendezvous {
		res << vproto.pack_bytes_field(o.rendezvous, 6)
	}
	return res
}

pub fn cmsgclientp2pconnectioninfo_unpack(buf []byte) ?CMsgClientP2PConnectionInfo {
	mut res := CMsgClientP2PConnectionInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id_dest = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_dest = v
				i = ii
			}
			2 {
				res.has_steam_id_src = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_src = v
				i = ii
			}
			3 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			4 {
				res.has_candidate = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.candidate = v
				i = ii
			}
			5 {
				res.has_connection_id_src = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_id_src = v
				i = ii
			}
			6 {
				res.has_rendezvous = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.rendezvous = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientp2pconnectioninfo() CMsgClientP2PConnectionInfo {
	return CMsgClientP2PConnectionInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientp2pconnectioninfo(o CMsgClientP2PConnectionInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientp2pconnectioninfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientP2PConnectionInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientp2pconnectioninfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientP2PConnectionFailInfo {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	steam_id_dest          u64
	has_steam_id_dest      bool
	steam_id_src           u64
	has_steam_id_src       bool
	app_id                 u32
	has_app_id             bool
	ep2p_session_error     u32
	has_ep2p_session_error bool
	connection_id_dest     u64
	has_connection_id_dest bool
	close_reason           u32
	has_close_reason       bool
	close_message          string
	has_close_message      bool
}

pub fn (o &CMsgClientP2PConnectionFailInfo) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id_dest {
		res << vproto.pack_64bit_field(o.steam_id_dest, 1)
	}
	if o.has_steam_id_src {
		res << vproto.pack_64bit_field(o.steam_id_src, 2)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 3)
	}
	if o.has_ep2p_session_error {
		res << vproto.pack_uint32_field(o.ep2p_session_error, 4)
	}
	if o.has_connection_id_dest {
		res << vproto.pack_64bit_field(o.connection_id_dest, 5)
	}
	if o.has_close_reason {
		res << vproto.pack_uint32_field(o.close_reason, 7)
	}
	if o.has_close_message {
		res << vproto.pack_string_field(o.close_message, 8)
	}
	return res
}

pub fn cmsgclientp2pconnectionfailinfo_unpack(buf []byte) ?CMsgClientP2PConnectionFailInfo {
	mut res := CMsgClientP2PConnectionFailInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id_dest = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_dest = v
				i = ii
			}
			2 {
				res.has_steam_id_src = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_src = v
				i = ii
			}
			3 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			4 {
				res.has_ep2p_session_error = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ep2p_session_error = v
				i = ii
			}
			5 {
				res.has_connection_id_dest = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_id_dest = v
				i = ii
			}
			7 {
				res.has_close_reason = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.close_reason = v
				i = ii
			}
			8 {
				res.has_close_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.close_message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientp2pconnectionfailinfo() CMsgClientP2PConnectionFailInfo {
	return CMsgClientP2PConnectionFailInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientp2pconnectionfailinfo(o CMsgClientP2PConnectionFailInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientp2pconnectionfailinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientP2PConnectionFailInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientp2pconnectionfailinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientNetworkingCertRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key_data       []byte
	has_key_data   bool
	app_id         u32
	has_app_id     bool
}

pub fn (o &CMsgClientNetworkingCertRequest) pack() []byte {
	mut res := []byte{}
	if o.has_key_data {
		res << vproto.pack_bytes_field(o.key_data, 2)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 3)
	}
	return res
}

pub fn cmsgclientnetworkingcertrequest_unpack(buf []byte) ?CMsgClientNetworkingCertRequest {
	mut res := CMsgClientNetworkingCertRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				res.has_key_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.key_data = v
				i = ii
			}
			3 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientnetworkingcertrequest() CMsgClientNetworkingCertRequest {
	return CMsgClientNetworkingCertRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientnetworkingcertrequest(o CMsgClientNetworkingCertRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientnetworkingcertrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNetworkingCertRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientnetworkingcertrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientNetworkingCertReply {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	cert             []byte
	has_cert         bool
	ca_key_id        u64
	has_ca_key_id    bool
	ca_signature     []byte
	has_ca_signature bool
}

pub fn (o &CMsgClientNetworkingCertReply) pack() []byte {
	mut res := []byte{}
	if o.has_cert {
		res << vproto.pack_bytes_field(o.cert, 4)
	}
	if o.has_ca_key_id {
		res << vproto.pack_64bit_field(o.ca_key_id, 5)
	}
	if o.has_ca_signature {
		res << vproto.pack_bytes_field(o.ca_signature, 6)
	}
	return res
}

pub fn cmsgclientnetworkingcertreply_unpack(buf []byte) ?CMsgClientNetworkingCertReply {
	mut res := CMsgClientNetworkingCertReply{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			4 {
				res.has_cert = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.cert = v
				i = ii
			}
			5 {
				res.has_ca_key_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ca_key_id = v
				i = ii
			}
			6 {
				res.has_ca_signature = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.ca_signature = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientnetworkingcertreply() CMsgClientNetworkingCertReply {
	return CMsgClientNetworkingCertReply{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientnetworkingcertreply(o CMsgClientNetworkingCertReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientnetworkingcertreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNetworkingCertReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientnetworkingcertreply_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientNetworkingMobileCertRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	has_app_id     bool
}

pub fn (o &CMsgClientNetworkingMobileCertRequest) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	return res
}

pub fn cmsgclientnetworkingmobilecertrequest_unpack(buf []byte) ?CMsgClientNetworkingMobileCertRequest {
	mut res := CMsgClientNetworkingMobileCertRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientnetworkingmobilecertrequest() CMsgClientNetworkingMobileCertRequest {
	return CMsgClientNetworkingMobileCertRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientnetworkingmobilecertrequest(o CMsgClientNetworkingMobileCertRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientnetworkingmobilecertrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNetworkingMobileCertRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientnetworkingmobilecertrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientNetworkingMobileCertReply {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	encoded_cert     string
	has_encoded_cert bool
}

pub fn (o &CMsgClientNetworkingMobileCertReply) pack() []byte {
	mut res := []byte{}
	if o.has_encoded_cert {
		res << vproto.pack_string_field(o.encoded_cert, 1)
	}
	return res
}

pub fn cmsgclientnetworkingmobilecertreply_unpack(buf []byte) ?CMsgClientNetworkingMobileCertReply {
	mut res := CMsgClientNetworkingMobileCertReply{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_encoded_cert = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.encoded_cert = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientnetworkingmobilecertreply() CMsgClientNetworkingMobileCertReply {
	return CMsgClientNetworkingMobileCertReply{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientnetworkingmobilecertreply(o CMsgClientNetworkingMobileCertReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientnetworkingmobilecertreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNetworkingMobileCertReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientnetworkingmobilecertreply_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetAppOwnershipTicket {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	has_app_id     bool
}

pub fn (o &CMsgClientGetAppOwnershipTicket) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	return res
}

pub fn cmsgclientgetappownershipticket_unpack(buf []byte) ?CMsgClientGetAppOwnershipTicket {
	mut res := CMsgClientGetAppOwnershipTicket{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetappownershipticket() CMsgClientGetAppOwnershipTicket {
	return CMsgClientGetAppOwnershipTicket{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetappownershipticket(o CMsgClientGetAppOwnershipTicket, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetappownershipticket(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetAppOwnershipTicket) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetappownershipticket_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetAppOwnershipTicketResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
	has_eresult    bool
	app_id         u32
	has_app_id     bool
	ticket         []byte
	has_ticket     bool
}

pub fn (o &CMsgClientGetAppOwnershipTicketResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.has_ticket {
		res << vproto.pack_bytes_field(o.ticket, 3)
	}
	return res
}

pub fn cmsgclientgetappownershipticketresponse_unpack(buf []byte) ?CMsgClientGetAppOwnershipTicketResponse {
	mut res := CMsgClientGetAppOwnershipTicketResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			3 {
				res.has_ticket = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.ticket = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetappownershipticketresponse() CMsgClientGetAppOwnershipTicketResponse {
	return CMsgClientGetAppOwnershipTicketResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetappownershipticketresponse(o CMsgClientGetAppOwnershipTicketResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetappownershipticketresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetAppOwnershipTicketResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetappownershipticketresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientSessionToken {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	token          u64
	has_token      bool
}

pub fn (o &CMsgClientSessionToken) pack() []byte {
	mut res := []byte{}
	if o.has_token {
		res << vproto.pack_uint64_field(o.token, 1)
	}
	return res
}

pub fn cmsgclientsessiontoken_unpack(buf []byte) ?CMsgClientSessionToken {
	mut res := CMsgClientSessionToken{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsessiontoken() CMsgClientSessionToken {
	return CMsgClientSessionToken{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsessiontoken(o CMsgClientSessionToken, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsessiontoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSessionToken) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientsessiontoken_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGameConnectTokens {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	max_tokens_to_keep     u32
	has_max_tokens_to_keep bool
	tokens                 [][]byte
}

pub fn (o &CMsgClientGameConnectTokens) pack() []byte {
	mut res := []byte{}
	if o.has_max_tokens_to_keep {
		res << vproto.pack_uint32_field(o.max_tokens_to_keep, 1)
	}
	// [packed=false]
	for _, x in o.tokens {
		res << vproto.pack_bytes_field(x, 2)
	}
	return res
}

pub fn cmsgclientgameconnecttokens_unpack(buf []byte) ?CMsgClientGameConnectTokens {
	mut res := CMsgClientGameConnectTokens{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_max_tokens_to_keep = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_tokens_to_keep = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.tokens << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgameconnecttokens() CMsgClientGameConnectTokens {
	return CMsgClientGameConnectTokens{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgameconnecttokens(o CMsgClientGameConnectTokens, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgameconnecttokens(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGameConnectTokens) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgameconnecttokens_unpack(v)?
	return i, unpacked
}

pub struct CMsgGSServerType {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	app_id_served                  u32
	has_app_id_served              bool
	flags                          u32
	has_flags                      bool
	deprecated_game_ip_address     u32
	has_deprecated_game_ip_address bool
	game_port                      u32
	has_game_port                  bool
	game_dir                       string
	has_game_dir                   bool
	game_version                   string
	has_game_version               bool
	game_query_port                u32
	has_game_query_port            bool
}

pub fn (o &CMsgGSServerType) pack() []byte {
	mut res := []byte{}
	if o.has_app_id_served {
		res << vproto.pack_uint32_field(o.app_id_served, 1)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 2)
	}
	if o.has_deprecated_game_ip_address {
		res << vproto.pack_uint32_field(o.deprecated_game_ip_address, 3)
	}
	if o.has_game_port {
		res << vproto.pack_uint32_field(o.game_port, 4)
	}
	if o.has_game_dir {
		res << vproto.pack_string_field(o.game_dir, 5)
	}
	if o.has_game_version {
		res << vproto.pack_string_field(o.game_version, 6)
	}
	if o.has_game_query_port {
		res << vproto.pack_uint32_field(o.game_query_port, 7)
	}
	return res
}

pub fn cmsggsservertype_unpack(buf []byte) ?CMsgGSServerType {
	mut res := CMsgGSServerType{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id_served = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id_served = v
				i = ii
			}
			2 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			3 {
				res.has_deprecated_game_ip_address = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_game_ip_address = v
				i = ii
			}
			4 {
				res.has_game_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_port = v
				i = ii
			}
			5 {
				res.has_game_dir = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_dir = v
				i = ii
			}
			6 {
				res.has_game_version = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_version = v
				i = ii
			}
			7 {
				res.has_game_query_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_query_port = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsservertype() CMsgGSServerType {
	return CMsgGSServerType{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsservertype(o CMsgGSServerType, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsservertype(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSServerType) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggsservertype_unpack(v)?
	return i, unpacked
}

pub struct CMsgGSStatusReply {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	is_secure      bool
	has_is_secure  bool
}

pub fn (o &CMsgGSStatusReply) pack() []byte {
	mut res := []byte{}
	if o.has_is_secure {
		res << vproto.pack_bool_field(o.is_secure, 1)
	}
	return res
}

pub fn cmsggsstatusreply_unpack(buf []byte) ?CMsgGSStatusReply {
	mut res := CMsgGSStatusReply{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_is_secure = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_secure = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsstatusreply() CMsgGSStatusReply {
	return CMsgGSStatusReply{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsstatusreply(o CMsgGSStatusReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsstatusreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSStatusReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggsstatusreply_unpack(v)?
	return i, unpacked
}

pub struct CMsgGSPlayerList_Player {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	steam_id                 u64
	has_steam_id             bool
	deprecated_public_ip     u32
	has_deprecated_public_ip bool
	token                    []byte
	has_token                bool
	public_ip                CMsgIPAddress
	has_public_ip            bool
}

pub fn (o &CMsgGSPlayerList_Player) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_uint64_field(o.steam_id, 1)
	}
	if o.has_deprecated_public_ip {
		res << vproto.pack_uint32_field(o.deprecated_public_ip, 2)
	}
	if o.has_token {
		res << vproto.pack_bytes_field(o.token, 3)
	}
	if o.has_public_ip {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 4)
	}
	return res
}

pub fn cmsggsplayerlist_player_unpack(buf []byte) ?CMsgGSPlayerList_Player {
	mut res := CMsgGSPlayerList_Player{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			2 {
				res.has_deprecated_public_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_public_ip = v
				i = ii
			}
			3 {
				res.has_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			4 {
				res.has_public_ip = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.public_ip = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsplayerlist_player() CMsgGSPlayerList_Player {
	return CMsgGSPlayerList_Player{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsplayerlist_player(o CMsgGSPlayerList_Player, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsplayerlist_player(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSPlayerList_Player) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggsplayerlist_player_unpack(v)?
	return i, unpacked
}

pub struct CMsgGSPlayerList {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	players        []CMsgGSPlayerList_Player
}

pub fn (o &CMsgGSPlayerList) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.players {
		res << zzz_vproto_internal_pack_cmsggsplayerlist_player(x, 1)
	}
	return res
}

pub fn cmsggsplayerlist_unpack(buf []byte) ?CMsgGSPlayerList {
	mut res := CMsgGSPlayerList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsggsplayerlist_player(cur_buf, tag_wiretype.wire_type)?
				res.players << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsplayerlist() CMsgGSPlayerList {
	return CMsgGSPlayerList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsplayerlist(o CMsgGSPlayerList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsplayerlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSPlayerList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggsplayerlist_unpack(v)?
	return i, unpacked
}

pub struct CMsgGSUserPlaying {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	steam_id                 u64
	has_steam_id             bool
	deprecated_public_ip     u32
	has_deprecated_public_ip bool
	token                    []byte
	has_token                bool
	public_ip                CMsgIPAddress
	has_public_ip            bool
}

pub fn (o &CMsgGSUserPlaying) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.has_deprecated_public_ip {
		res << vproto.pack_uint32_field(o.deprecated_public_ip, 2)
	}
	if o.has_token {
		res << vproto.pack_bytes_field(o.token, 3)
	}
	if o.has_public_ip {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 4)
	}
	return res
}

pub fn cmsggsuserplaying_unpack(buf []byte) ?CMsgGSUserPlaying {
	mut res := CMsgGSUserPlaying{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			2 {
				res.has_deprecated_public_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_public_ip = v
				i = ii
			}
			3 {
				res.has_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			4 {
				res.has_public_ip = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.public_ip = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsuserplaying() CMsgGSUserPlaying {
	return CMsgGSUserPlaying{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsuserplaying(o CMsgGSUserPlaying, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsuserplaying(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSUserPlaying) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggsuserplaying_unpack(v)?
	return i, unpacked
}

pub struct CMsgGSDisconnectNotice {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	has_steam_id   bool
}

pub fn (o &CMsgGSDisconnectNotice) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	return res
}

pub fn cmsggsdisconnectnotice_unpack(buf []byte) ?CMsgGSDisconnectNotice {
	mut res := CMsgGSDisconnectNotice{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsdisconnectnotice() CMsgGSDisconnectNotice {
	return CMsgGSDisconnectNotice{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsdisconnectnotice(o CMsgGSDisconnectNotice, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsdisconnectnotice(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSDisconnectNotice) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggsdisconnectnotice_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGamesPlayed_GamePlayed {
mut:
	unknown_fields                       []vproto.UnknownField
pub mut:
	steam_id_gs                          u64
	has_steam_id_gs                      bool
	game_id                              u64
	has_game_id                          bool
	deprecated_game_ip_address           u32
	has_deprecated_game_ip_address       bool
	game_port                            u32
	has_game_port                        bool
	is_secure                            bool
	has_is_secure                        bool
	token                                []byte
	has_token                            bool
	game_extra_info                      string
	has_game_extra_info                  bool
	game_data_blob                       []byte
	has_game_data_blob                   bool
	process_id                           u32
	has_process_id                       bool
	streaming_provider_id                u32
	has_streaming_provider_id            bool
	game_flags                           u32
	has_game_flags                       bool
	owner_id                             u32
	has_owner_id                         bool
	vr_hmd_vendor                        string
	has_vr_hmd_vendor                    bool
	vr_hmd_model                         string
	has_vr_hmd_model                     bool
	launch_option_type                   u32
	has_launch_option_type               bool
	primary_controller_type              int
	has_primary_controller_type          bool
	primary_steam_controller_serial      string
	has_primary_steam_controller_serial  bool
	total_steam_controller_count         u32
	has_total_steam_controller_count     bool
	total_non_steam_controller_count     u32
	has_total_non_steam_controller_count bool
	controller_workshop_file_id          u64
	has_controller_workshop_file_id      bool
	launch_source                        u32
	has_launch_source                    bool
	vr_hmd_runtime                       u32
	has_vr_hmd_runtime                   bool
	game_ip_address                      CMsgIPAddress
	has_game_ip_address                  bool
	controller_connection_type           u32
	has_controller_connection_type       bool
}

pub fn (o &CMsgClientGamesPlayed_GamePlayed) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id_gs {
		res << vproto.pack_uint64_field(o.steam_id_gs, 1)
	}
	if o.has_game_id {
		res << vproto.pack_64bit_field(o.game_id, 2)
	}
	if o.has_deprecated_game_ip_address {
		res << vproto.pack_uint32_field(o.deprecated_game_ip_address, 3)
	}
	if o.has_game_port {
		res << vproto.pack_uint32_field(o.game_port, 4)
	}
	if o.has_is_secure {
		res << vproto.pack_bool_field(o.is_secure, 5)
	}
	if o.has_token {
		res << vproto.pack_bytes_field(o.token, 6)
	}
	if o.has_game_extra_info {
		res << vproto.pack_string_field(o.game_extra_info, 7)
	}
	if o.has_game_data_blob {
		res << vproto.pack_bytes_field(o.game_data_blob, 8)
	}
	if o.has_process_id {
		res << vproto.pack_uint32_field(o.process_id, 9)
	}
	if o.has_streaming_provider_id {
		res << vproto.pack_uint32_field(o.streaming_provider_id, 10)
	}
	if o.has_game_flags {
		res << vproto.pack_uint32_field(o.game_flags, 11)
	}
	if o.has_owner_id {
		res << vproto.pack_uint32_field(o.owner_id, 12)
	}
	if o.has_vr_hmd_vendor {
		res << vproto.pack_string_field(o.vr_hmd_vendor, 13)
	}
	if o.has_vr_hmd_model {
		res << vproto.pack_string_field(o.vr_hmd_model, 14)
	}
	if o.has_launch_option_type {
		res << vproto.pack_uint32_field(o.launch_option_type, 15)
	}
	if o.has_primary_controller_type {
		res << vproto.pack_int32_field(o.primary_controller_type, 16)
	}
	if o.has_primary_steam_controller_serial {
		res << vproto.pack_string_field(o.primary_steam_controller_serial, 17)
	}
	if o.has_total_steam_controller_count {
		res << vproto.pack_uint32_field(o.total_steam_controller_count, 18)
	}
	if o.has_total_non_steam_controller_count {
		res << vproto.pack_uint32_field(o.total_non_steam_controller_count, 19)
	}
	if o.has_controller_workshop_file_id {
		res << vproto.pack_uint64_field(o.controller_workshop_file_id, 20)
	}
	if o.has_launch_source {
		res << vproto.pack_uint32_field(o.launch_source, 21)
	}
	if o.has_vr_hmd_runtime {
		res << vproto.pack_uint32_field(o.vr_hmd_runtime, 22)
	}
	if o.has_game_ip_address {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.game_ip_address, 23)
	}
	if o.has_controller_connection_type {
		res << vproto.pack_uint32_field(o.controller_connection_type, 24)
	}
	return res
}

pub fn cmsgclientgamesplayed_gameplayed_unpack(buf []byte) ?CMsgClientGamesPlayed_GamePlayed {
	mut res := CMsgClientGamesPlayed_GamePlayed{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id_gs = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_gs = v
				i = ii
			}
			2 {
				res.has_game_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.game_id = v
				i = ii
			}
			3 {
				res.has_deprecated_game_ip_address = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_game_ip_address = v
				i = ii
			}
			4 {
				res.has_game_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_port = v
				i = ii
			}
			5 {
				res.has_is_secure = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_secure = v
				i = ii
			}
			6 {
				res.has_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			7 {
				res.has_game_extra_info = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_extra_info = v
				i = ii
			}
			8 {
				res.has_game_data_blob = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.game_data_blob = v
				i = ii
			}
			9 {
				res.has_process_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.process_id = v
				i = ii
			}
			10 {
				res.has_streaming_provider_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.streaming_provider_id = v
				i = ii
			}
			11 {
				res.has_game_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_flags = v
				i = ii
			}
			12 {
				res.has_owner_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_id = v
				i = ii
			}
			13 {
				res.has_vr_hmd_vendor = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.vr_hmd_vendor = v
				i = ii
			}
			14 {
				res.has_vr_hmd_model = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.vr_hmd_model = v
				i = ii
			}
			15 {
				res.has_launch_option_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.launch_option_type = v
				i = ii
			}
			16 {
				res.has_primary_controller_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.primary_controller_type = v
				i = ii
			}
			17 {
				res.has_primary_steam_controller_serial = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.primary_steam_controller_serial = v
				i = ii
			}
			18 {
				res.has_total_steam_controller_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_steam_controller_count = v
				i = ii
			}
			19 {
				res.has_total_non_steam_controller_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_non_steam_controller_count = v
				i = ii
			}
			20 {
				res.has_controller_workshop_file_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_workshop_file_id = v
				i = ii
			}
			21 {
				res.has_launch_source = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.launch_source = v
				i = ii
			}
			22 {
				res.has_vr_hmd_runtime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.vr_hmd_runtime = v
				i = ii
			}
			23 {
				res.has_game_ip_address = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.game_ip_address = v
				i = ii
			}
			24 {
				res.has_controller_connection_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_connection_type = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgamesplayed_gameplayed() CMsgClientGamesPlayed_GamePlayed {
	return CMsgClientGamesPlayed_GamePlayed{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgamesplayed_gameplayed(o CMsgClientGamesPlayed_GamePlayed, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgamesplayed_gameplayed(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGamesPlayed_GamePlayed) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgamesplayed_gameplayed_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGamesPlayed {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	games_played              []CMsgClientGamesPlayed_GamePlayed
	client_os_type            u32
	has_client_os_type        bool
	cloud_gaming_platform     u32
	has_cloud_gaming_platform bool
}

pub fn (o &CMsgClientGamesPlayed) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.games_played {
		res << zzz_vproto_internal_pack_cmsgclientgamesplayed_gameplayed(x, 1)
	}
	if o.has_client_os_type {
		res << vproto.pack_uint32_field(o.client_os_type, 2)
	}
	if o.has_cloud_gaming_platform {
		res << vproto.pack_uint32_field(o.cloud_gaming_platform, 3)
	}
	return res
}

pub fn cmsgclientgamesplayed_unpack(buf []byte) ?CMsgClientGamesPlayed {
	mut res := CMsgClientGamesPlayed{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientgamesplayed_gameplayed(cur_buf,
					tag_wiretype.wire_type)?
				res.games_played << v
				i = ii
			}
			2 {
				res.has_client_os_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_os_type = v
				i = ii
			}
			3 {
				res.has_cloud_gaming_platform = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cloud_gaming_platform = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgamesplayed() CMsgClientGamesPlayed {
	return CMsgClientGamesPlayed{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgamesplayed(o CMsgClientGamesPlayed, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgamesplayed(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGamesPlayed) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgamesplayed_unpack(v)?
	return i, unpacked
}

pub struct CMsgGSApprove {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	steam_id           u64
	has_steam_id       bool
	owner_steam_id     u64
	has_owner_steam_id bool
}

pub fn (o &CMsgGSApprove) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.has_owner_steam_id {
		res << vproto.pack_64bit_field(o.owner_steam_id, 2)
	}
	return res
}

pub fn cmsggsapprove_unpack(buf []byte) ?CMsgGSApprove {
	mut res := CMsgGSApprove{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			2 {
				res.has_owner_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_steam_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsapprove() CMsgGSApprove {
	return CMsgGSApprove{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsapprove(o CMsgGSApprove, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsapprove(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSApprove) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggsapprove_unpack(v)?
	return i, unpacked
}

pub struct CMsgGSDeny {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steam_id         u64
	has_steam_id     bool
	edeny_reason     int
	has_edeny_reason bool
	deny_string      string
	has_deny_string  bool
}

pub fn (o &CMsgGSDeny) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.has_edeny_reason {
		res << vproto.pack_int32_field(o.edeny_reason, 2)
	}
	if o.has_deny_string {
		res << vproto.pack_string_field(o.deny_string, 3)
	}
	return res
}

pub fn cmsggsdeny_unpack(buf []byte) ?CMsgGSDeny {
	mut res := CMsgGSDeny{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			2 {
				res.has_edeny_reason = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.edeny_reason = v
				i = ii
			}
			3 {
				res.has_deny_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.deny_string = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsdeny() CMsgGSDeny {
	return CMsgGSDeny{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsdeny(o CMsgGSDeny, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsdeny(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSDeny) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggsdeny_unpack(v)?
	return i, unpacked
}

pub struct CMsgGSKick {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steam_id         u64
	has_steam_id     bool
	edeny_reason     int
	has_edeny_reason bool
}

pub fn (o &CMsgGSKick) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.has_edeny_reason {
		res << vproto.pack_int32_field(o.edeny_reason, 2)
	}
	return res
}

pub fn cmsggskick_unpack(buf []byte) ?CMsgGSKick {
	mut res := CMsgGSKick{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			2 {
				res.has_edeny_reason = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.edeny_reason = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggskick() CMsgGSKick {
	return CMsgGSKick{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggskick(o CMsgGSKick, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggskick(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSKick) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggskick_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAuthList {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	tokens_left                      u32
	has_tokens_left                  bool
	last_request_seq                 u32
	has_last_request_seq             bool
	last_request_seq_from_server     u32
	has_last_request_seq_from_server bool
	tickets                          []CMsgAuthTicket
	app_ids                          []u32
	message_sequence                 u32
	has_message_sequence             bool
}

pub fn (o &CMsgClientAuthList) pack() []byte {
	mut res := []byte{}
	if o.has_tokens_left {
		res << vproto.pack_uint32_field(o.tokens_left, 1)
	}
	if o.has_last_request_seq {
		res << vproto.pack_uint32_field(o.last_request_seq, 2)
	}
	if o.has_last_request_seq_from_server {
		res << vproto.pack_uint32_field(o.last_request_seq_from_server, 3)
	}
	// [packed=false]
	for _, x in o.tickets {
		res << zzz_vproto_internal_pack_cmsgauthticket(x, 4)
	}
	// [packed=false]
	for _, x in o.app_ids {
		res << vproto.pack_uint32_field(x, 5)
	}
	if o.has_message_sequence {
		res << vproto.pack_uint32_field(o.message_sequence, 6)
	}
	return res
}

pub fn cmsgclientauthlist_unpack(buf []byte) ?CMsgClientAuthList {
	mut res := CMsgClientAuthList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_tokens_left = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tokens_left = v
				i = ii
			}
			2 {
				res.has_last_request_seq = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_request_seq = v
				i = ii
			}
			3 {
				res.has_last_request_seq_from_server = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_request_seq_from_server = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgauthticket(cur_buf, tag_wiretype.wire_type)?
				res.tickets << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_ids << v
				i = ii
			}
			6 {
				res.has_message_sequence = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.message_sequence = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientauthlist() CMsgClientAuthList {
	return CMsgClientAuthList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientauthlist(o CMsgClientAuthList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientauthlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAuthList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientauthlist_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAuthListAck {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	ticket_crc           []u32
	app_ids              []u32
	message_sequence     u32
	has_message_sequence bool
}

pub fn (o &CMsgClientAuthListAck) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.ticket_crc {
		res << vproto.pack_uint32_field(x, 1)
	}
	// [packed=false]
	for _, x in o.app_ids {
		res << vproto.pack_uint32_field(x, 2)
	}
	if o.has_message_sequence {
		res << vproto.pack_uint32_field(o.message_sequence, 3)
	}
	return res
}

pub fn cmsgclientauthlistack_unpack(buf []byte) ?CMsgClientAuthListAck {
	mut res := CMsgClientAuthListAck{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ticket_crc << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_ids << v
				i = ii
			}
			3 {
				res.has_message_sequence = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.message_sequence = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientauthlistack() CMsgClientAuthListAck {
	return CMsgClientAuthListAck{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientauthlistack(o CMsgClientAuthListAck, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientauthlistack(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAuthListAck) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientauthlistack_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLicenseList_License {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	package_id                u32
	has_package_id            bool
	time_created              u32
	has_time_created          bool
	time_next_process         u32
	has_time_next_process     bool
	minute_limit              int
	has_minute_limit          bool
	minutes_used              int
	has_minutes_used          bool
	payment_method            u32
	has_payment_method        bool
	flags                     u32
	has_flags                 bool
	purchase_country_code     string
	has_purchase_country_code bool
	license_type              u32
	has_license_type          bool
	territory_code            int
	has_territory_code        bool
	change_number             int
	has_change_number         bool
	owner_id                  u32
	has_owner_id              bool
	initial_period            u32
	has_initial_period        bool
	initial_time_unit         u32
	has_initial_time_unit     bool
	renewal_period            u32
	has_renewal_period        bool
	renewal_time_unit         u32
	has_renewal_time_unit     bool
	access_token              u64
	has_access_token          bool
	master_package_id         u32
	has_master_package_id     bool
}

pub fn (o &CMsgClientLicenseList_License) pack() []byte {
	mut res := []byte{}
	if o.has_package_id {
		res << vproto.pack_uint32_field(o.package_id, 1)
	}
	if o.has_time_created {
		res << vproto.pack_32bit_field(o.time_created, 2)
	}
	if o.has_time_next_process {
		res << vproto.pack_32bit_field(o.time_next_process, 3)
	}
	if o.has_minute_limit {
		res << vproto.pack_int32_field(o.minute_limit, 4)
	}
	if o.has_minutes_used {
		res << vproto.pack_int32_field(o.minutes_used, 5)
	}
	if o.has_payment_method {
		res << vproto.pack_uint32_field(o.payment_method, 6)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 7)
	}
	if o.has_purchase_country_code {
		res << vproto.pack_string_field(o.purchase_country_code, 8)
	}
	if o.has_license_type {
		res << vproto.pack_uint32_field(o.license_type, 9)
	}
	if o.has_territory_code {
		res << vproto.pack_int32_field(o.territory_code, 10)
	}
	if o.has_change_number {
		res << vproto.pack_int32_field(o.change_number, 11)
	}
	if o.has_owner_id {
		res << vproto.pack_uint32_field(o.owner_id, 12)
	}
	if o.has_initial_period {
		res << vproto.pack_uint32_field(o.initial_period, 13)
	}
	if o.has_initial_time_unit {
		res << vproto.pack_uint32_field(o.initial_time_unit, 14)
	}
	if o.has_renewal_period {
		res << vproto.pack_uint32_field(o.renewal_period, 15)
	}
	if o.has_renewal_time_unit {
		res << vproto.pack_uint32_field(o.renewal_time_unit, 16)
	}
	if o.has_access_token {
		res << vproto.pack_uint64_field(o.access_token, 17)
	}
	if o.has_master_package_id {
		res << vproto.pack_uint32_field(o.master_package_id, 18)
	}
	return res
}

pub fn cmsgclientlicenselist_license_unpack(buf []byte) ?CMsgClientLicenseList_License {
	mut res := CMsgClientLicenseList_License{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_package_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.package_id = v
				i = ii
			}
			2 {
				res.has_time_created = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			3 {
				res.has_time_next_process = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.time_next_process = v
				i = ii
			}
			4 {
				res.has_minute_limit = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.minute_limit = v
				i = ii
			}
			5 {
				res.has_minutes_used = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.minutes_used = v
				i = ii
			}
			6 {
				res.has_payment_method = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.payment_method = v
				i = ii
			}
			7 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			8 {
				res.has_purchase_country_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.purchase_country_code = v
				i = ii
			}
			9 {
				res.has_license_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.license_type = v
				i = ii
			}
			10 {
				res.has_territory_code = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.territory_code = v
				i = ii
			}
			11 {
				res.has_change_number = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.change_number = v
				i = ii
			}
			12 {
				res.has_owner_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_id = v
				i = ii
			}
			13 {
				res.has_initial_period = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_period = v
				i = ii
			}
			14 {
				res.has_initial_time_unit = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_time_unit = v
				i = ii
			}
			15 {
				res.has_renewal_period = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.renewal_period = v
				i = ii
			}
			16 {
				res.has_renewal_time_unit = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.renewal_time_unit = v
				i = ii
			}
			17 {
				res.has_access_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.access_token = v
				i = ii
			}
			18 {
				res.has_master_package_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.master_package_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlicenselist_license() CMsgClientLicenseList_License {
	return CMsgClientLicenseList_License{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlicenselist_license(o CMsgClientLicenseList_License, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlicenselist_license(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLicenseList_License) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlicenselist_license_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLicenseList {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
	licenses       []CMsgClientLicenseList_License
}

pub fn (o &CMsgClientLicenseList) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	// [packed=false]
	for _, x in o.licenses {
		res << zzz_vproto_internal_pack_cmsgclientlicenselist_license(x, 2)
	}
	return res
}

pub fn cmsgclientlicenselist_unpack(buf []byte) ?CMsgClientLicenseList {
	mut res := CMsgClientLicenseList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientlicenselist_license(cur_buf,
					tag_wiretype.wire_type)?
				res.licenses << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlicenselist() CMsgClientLicenseList {
	return CMsgClientLicenseList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlicenselist(o CMsgClientLicenseList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlicenselist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLicenseList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlicenselist_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLBSSetScore {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	app_id                  u32
	has_app_id              bool
	leaderboard_id          int
	has_leaderboard_id      bool
	score                   int
	has_score               bool
	details                 []byte
	has_details             bool
	upload_score_method     int
	has_upload_score_method bool
}

pub fn (o &CMsgClientLBSSetScore) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_leaderboard_id {
		res << vproto.pack_int32_field(o.leaderboard_id, 2)
	}
	if o.has_score {
		res << vproto.pack_int32_field(o.score, 3)
	}
	if o.has_details {
		res << vproto.pack_bytes_field(o.details, 4)
	}
	if o.has_upload_score_method {
		res << vproto.pack_int32_field(o.upload_score_method, 5)
	}
	return res
}

pub fn cmsgclientlbssetscore_unpack(buf []byte) ?CMsgClientLBSSetScore {
	mut res := CMsgClientLBSSetScore{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_leaderboard_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_id = v
				i = ii
			}
			3 {
				res.has_score = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.score = v
				i = ii
			}
			4 {
				res.has_details = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.details = v
				i = ii
			}
			5 {
				res.has_upload_score_method = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_score_method = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbssetscore() CMsgClientLBSSetScore {
	return CMsgClientLBSSetScore{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbssetscore(o CMsgClientLBSSetScore, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbssetscore(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSSetScore) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlbssetscore_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLBSSetScoreResponse {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	eresult                     int
	has_eresult                 bool
	leaderboard_entry_count     int
	has_leaderboard_entry_count bool
	score_changed               bool
	has_score_changed           bool
	global_rank_previous        int
	has_global_rank_previous    bool
	global_rank_new             int
	has_global_rank_new         bool
}

pub fn (o &CMsgClientLBSSetScoreResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_leaderboard_entry_count {
		res << vproto.pack_int32_field(o.leaderboard_entry_count, 2)
	}
	if o.has_score_changed {
		res << vproto.pack_bool_field(o.score_changed, 3)
	}
	if o.has_global_rank_previous {
		res << vproto.pack_int32_field(o.global_rank_previous, 4)
	}
	if o.has_global_rank_new {
		res << vproto.pack_int32_field(o.global_rank_new, 5)
	}
	return res
}

pub fn cmsgclientlbssetscoreresponse_unpack(buf []byte) ?CMsgClientLBSSetScoreResponse {
	mut res := CMsgClientLBSSetScoreResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_leaderboard_entry_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_entry_count = v
				i = ii
			}
			3 {
				res.has_score_changed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.score_changed = v
				i = ii
			}
			4 {
				res.has_global_rank_previous = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.global_rank_previous = v
				i = ii
			}
			5 {
				res.has_global_rank_new = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.global_rank_new = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbssetscoreresponse() CMsgClientLBSSetScoreResponse {
	return CMsgClientLBSSetScoreResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbssetscoreresponse(o CMsgClientLBSSetScoreResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbssetscoreresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSSetScoreResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlbssetscoreresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLBSSetUGC {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	has_app_id         bool
	leaderboard_id     int
	has_leaderboard_id bool
	ugc_id             u64
	has_ugc_id         bool
}

pub fn (o &CMsgClientLBSSetUGC) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_leaderboard_id {
		res << vproto.pack_int32_field(o.leaderboard_id, 2)
	}
	if o.has_ugc_id {
		res << vproto.pack_64bit_field(o.ugc_id, 3)
	}
	return res
}

pub fn cmsgclientlbssetugc_unpack(buf []byte) ?CMsgClientLBSSetUGC {
	mut res := CMsgClientLBSSetUGC{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_leaderboard_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_id = v
				i = ii
			}
			3 {
				res.has_ugc_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ugc_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbssetugc() CMsgClientLBSSetUGC {
	return CMsgClientLBSSetUGC{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbssetugc(o CMsgClientLBSSetUGC, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbssetugc(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSSetUGC) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlbssetugc_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLBSSetUGCResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
}

pub fn (o &CMsgClientLBSSetUGCResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientlbssetugcresponse_unpack(buf []byte) ?CMsgClientLBSSetUGCResponse {
	mut res := CMsgClientLBSSetUGCResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbssetugcresponse() CMsgClientLBSSetUGCResponse {
	return CMsgClientLBSSetUGCResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbssetugcresponse(o CMsgClientLBSSetUGCResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbssetugcresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSSetUGCResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlbssetugcresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLBSFindOrCreateLB {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	app_id                       u32
	has_app_id                   bool
	leaderboard_sort_method      int
	has_leaderboard_sort_method  bool
	leaderboard_display_type     int
	has_leaderboard_display_type bool
	create_if_not_found          bool
	has_create_if_not_found      bool
	leaderboard_name             string
	has_leaderboard_name         bool
}

pub fn (o &CMsgClientLBSFindOrCreateLB) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_leaderboard_sort_method {
		res << vproto.pack_int32_field(o.leaderboard_sort_method, 2)
	}
	if o.has_leaderboard_display_type {
		res << vproto.pack_int32_field(o.leaderboard_display_type, 3)
	}
	if o.has_create_if_not_found {
		res << vproto.pack_bool_field(o.create_if_not_found, 4)
	}
	if o.has_leaderboard_name {
		res << vproto.pack_string_field(o.leaderboard_name, 5)
	}
	return res
}

pub fn cmsgclientlbsfindorcreatelb_unpack(buf []byte) ?CMsgClientLBSFindOrCreateLB {
	mut res := CMsgClientLBSFindOrCreateLB{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_leaderboard_sort_method = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_sort_method = v
				i = ii
			}
			3 {
				res.has_leaderboard_display_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_display_type = v
				i = ii
			}
			4 {
				res.has_create_if_not_found = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.create_if_not_found = v
				i = ii
			}
			5 {
				res.has_leaderboard_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbsfindorcreatelb() CMsgClientLBSFindOrCreateLB {
	return CMsgClientLBSFindOrCreateLB{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbsfindorcreatelb(o CMsgClientLBSFindOrCreateLB, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbsfindorcreatelb(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSFindOrCreateLB) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlbsfindorcreatelb_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLBSFindOrCreateLBResponse {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	eresult                      int
	has_eresult                  bool
	leaderboard_id               int
	has_leaderboard_id           bool
	leaderboard_entry_count      int
	has_leaderboard_entry_count  bool
	leaderboard_sort_method      int
	has_leaderboard_sort_method  bool
	leaderboard_display_type     int
	has_leaderboard_display_type bool
	leaderboard_name             string
	has_leaderboard_name         bool
}

pub fn (o &CMsgClientLBSFindOrCreateLBResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_leaderboard_id {
		res << vproto.pack_int32_field(o.leaderboard_id, 2)
	}
	if o.has_leaderboard_entry_count {
		res << vproto.pack_int32_field(o.leaderboard_entry_count, 3)
	}
	if o.has_leaderboard_sort_method {
		res << vproto.pack_int32_field(o.leaderboard_sort_method, 4)
	}
	if o.has_leaderboard_display_type {
		res << vproto.pack_int32_field(o.leaderboard_display_type, 5)
	}
	if o.has_leaderboard_name {
		res << vproto.pack_string_field(o.leaderboard_name, 6)
	}
	return res
}

pub fn cmsgclientlbsfindorcreatelbresponse_unpack(buf []byte) ?CMsgClientLBSFindOrCreateLBResponse {
	mut res := CMsgClientLBSFindOrCreateLBResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_leaderboard_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_id = v
				i = ii
			}
			3 {
				res.has_leaderboard_entry_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_entry_count = v
				i = ii
			}
			4 {
				res.has_leaderboard_sort_method = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_sort_method = v
				i = ii
			}
			5 {
				res.has_leaderboard_display_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_display_type = v
				i = ii
			}
			6 {
				res.has_leaderboard_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbsfindorcreatelbresponse() CMsgClientLBSFindOrCreateLBResponse {
	return CMsgClientLBSFindOrCreateLBResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbsfindorcreatelbresponse(o CMsgClientLBSFindOrCreateLBResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbsfindorcreatelbresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSFindOrCreateLBResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlbsfindorcreatelbresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLBSGetLBEntries {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	app_id                       int
	has_app_id                   bool
	leaderboard_id               int
	has_leaderboard_id           bool
	range_start                  int
	has_range_start              bool
	range_end                    int
	has_range_end                bool
	leaderboard_data_request     int
	has_leaderboard_data_request bool
	steamids                     []u64
}

pub fn (o &CMsgClientLBSGetLBEntries) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_int32_field(o.app_id, 1)
	}
	if o.has_leaderboard_id {
		res << vproto.pack_int32_field(o.leaderboard_id, 2)
	}
	if o.has_range_start {
		res << vproto.pack_int32_field(o.range_start, 3)
	}
	if o.has_range_end {
		res << vproto.pack_int32_field(o.range_end, 4)
	}
	if o.has_leaderboard_data_request {
		res << vproto.pack_int32_field(o.leaderboard_data_request, 5)
	}
	// [packed=false]
	for _, x in o.steamids {
		res << vproto.pack_64bit_field(x, 6)
	}
	return res
}

pub fn cmsgclientlbsgetlbentries_unpack(buf []byte) ?CMsgClientLBSGetLBEntries {
	mut res := CMsgClientLBSGetLBEntries{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_leaderboard_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_id = v
				i = ii
			}
			3 {
				res.has_range_start = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.range_start = v
				i = ii
			}
			4 {
				res.has_range_end = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.range_end = v
				i = ii
			}
			5 {
				res.has_leaderboard_data_request = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_data_request = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbsgetlbentries() CMsgClientLBSGetLBEntries {
	return CMsgClientLBSGetLBEntries{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbsgetlbentries(o CMsgClientLBSGetLBEntries, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbsgetlbentries(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSGetLBEntries) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlbsgetlbentries_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLBSGetLBEntriesResponse_Entry {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	steam_id_user     u64
	has_steam_id_user bool
	global_rank       int
	has_global_rank   bool
	score             int
	has_score         bool
	details           []byte
	has_details       bool
	ugc_id            u64
	has_ugc_id        bool
}

pub fn (o &CMsgClientLBSGetLBEntriesResponse_Entry) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id_user {
		res << vproto.pack_64bit_field(o.steam_id_user, 1)
	}
	if o.has_global_rank {
		res << vproto.pack_int32_field(o.global_rank, 2)
	}
	if o.has_score {
		res << vproto.pack_int32_field(o.score, 3)
	}
	if o.has_details {
		res << vproto.pack_bytes_field(o.details, 4)
	}
	if o.has_ugc_id {
		res << vproto.pack_64bit_field(o.ugc_id, 5)
	}
	return res
}

pub fn cmsgclientlbsgetlbentriesresponse_entry_unpack(buf []byte) ?CMsgClientLBSGetLBEntriesResponse_Entry {
	mut res := CMsgClientLBSGetLBEntriesResponse_Entry{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id_user = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_user = v
				i = ii
			}
			2 {
				res.has_global_rank = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.global_rank = v
				i = ii
			}
			3 {
				res.has_score = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.score = v
				i = ii
			}
			4 {
				res.has_details = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.details = v
				i = ii
			}
			5 {
				res.has_ugc_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ugc_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbsgetlbentriesresponse_entry() CMsgClientLBSGetLBEntriesResponse_Entry {
	return CMsgClientLBSGetLBEntriesResponse_Entry{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbsgetlbentriesresponse_entry(o CMsgClientLBSGetLBEntriesResponse_Entry, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbsgetlbentriesresponse_entry(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSGetLBEntriesResponse_Entry) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlbsgetlbentriesresponse_entry_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLBSGetLBEntriesResponse {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	eresult                     int
	has_eresult                 bool
	leaderboard_entry_count     int
	has_leaderboard_entry_count bool
	entries                     []CMsgClientLBSGetLBEntriesResponse_Entry
}

pub fn (o &CMsgClientLBSGetLBEntriesResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_leaderboard_entry_count {
		res << vproto.pack_int32_field(o.leaderboard_entry_count, 2)
	}
	// [packed=false]
	for _, x in o.entries {
		res << zzz_vproto_internal_pack_cmsgclientlbsgetlbentriesresponse_entry(x, 3)
	}
	return res
}

pub fn cmsgclientlbsgetlbentriesresponse_unpack(buf []byte) ?CMsgClientLBSGetLBEntriesResponse {
	mut res := CMsgClientLBSGetLBEntriesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_leaderboard_entry_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.leaderboard_entry_count = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientlbsgetlbentriesresponse_entry(cur_buf,
					tag_wiretype.wire_type)?
				res.entries << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlbsgetlbentriesresponse() CMsgClientLBSGetLBEntriesResponse {
	return CMsgClientLBSGetLBEntriesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlbsgetlbentriesresponse(o CMsgClientLBSGetLBEntriesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlbsgetlbentriesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLBSGetLBEntriesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlbsgetlbentriesresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	has_app_id         bool
	forever            int
	has_forever        bool
	last_two_weeks     int
	has_last_two_weeks bool
}

pub fn (o &CMsgClientAppMinutesPlayedData_AppMinutesPlayedData) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_forever {
		res << vproto.pack_int32_field(o.forever, 2)
	}
	if o.has_last_two_weeks {
		res << vproto.pack_int32_field(o.last_two_weeks, 3)
	}
	return res
}

pub fn cmsgclientappminutesplayeddata_appminutesplayeddata_unpack(buf []byte) ?CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
	mut res := CMsgClientAppMinutesPlayedData_AppMinutesPlayedData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_forever = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.forever = v
				i = ii
			}
			3 {
				res.has_last_two_weeks = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_two_weeks = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappminutesplayeddata_appminutesplayeddata() CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
	return CMsgClientAppMinutesPlayedData_AppMinutesPlayedData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappminutesplayeddata_appminutesplayeddata(o CMsgClientAppMinutesPlayedData_AppMinutesPlayedData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappminutesplayeddata_appminutesplayeddata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppMinutesPlayedData_AppMinutesPlayedData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientappminutesplayeddata_appminutesplayeddata_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAppMinutesPlayedData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	minutes_played []CMsgClientAppMinutesPlayedData_AppMinutesPlayedData
}

pub fn (o &CMsgClientAppMinutesPlayedData) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.minutes_played {
		res << zzz_vproto_internal_pack_cmsgclientappminutesplayeddata_appminutesplayeddata(x, 1)
	}
	return res
}

pub fn cmsgclientappminutesplayeddata_unpack(buf []byte) ?CMsgClientAppMinutesPlayedData {
	mut res := CMsgClientAppMinutesPlayedData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientappminutesplayeddata_appminutesplayeddata(cur_buf,
					tag_wiretype.wire_type)?
				res.minutes_played << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappminutesplayeddata() CMsgClientAppMinutesPlayedData {
	return CMsgClientAppMinutesPlayedData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappminutesplayeddata(o CMsgClientAppMinutesPlayedData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappminutesplayeddata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppMinutesPlayedData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientappminutesplayeddata_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientIsLimitedAccount {
mut:
	unknown_fields                                    []vproto.UnknownField
pub mut:
	bis_limited_account                               bool
	has_bis_limited_account                           bool
	bis_community_banned                              bool
	has_bis_community_banned                          bool
	bis_locked_account                                bool
	has_bis_locked_account                            bool
	bis_limited_account_allowed_to_invite_friends     bool
	has_bis_limited_account_allowed_to_invite_friends bool
}

pub fn (o &CMsgClientIsLimitedAccount) pack() []byte {
	mut res := []byte{}
	if o.has_bis_limited_account {
		res << vproto.pack_bool_field(o.bis_limited_account, 1)
	}
	if o.has_bis_community_banned {
		res << vproto.pack_bool_field(o.bis_community_banned, 2)
	}
	if o.has_bis_locked_account {
		res << vproto.pack_bool_field(o.bis_locked_account, 3)
	}
	if o.has_bis_limited_account_allowed_to_invite_friends {
		res << vproto.pack_bool_field(o.bis_limited_account_allowed_to_invite_friends, 4)
	}
	return res
}

pub fn cmsgclientislimitedaccount_unpack(buf []byte) ?CMsgClientIsLimitedAccount {
	mut res := CMsgClientIsLimitedAccount{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_bis_limited_account = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bis_limited_account = v
				i = ii
			}
			2 {
				res.has_bis_community_banned = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bis_community_banned = v
				i = ii
			}
			3 {
				res.has_bis_locked_account = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bis_locked_account = v
				i = ii
			}
			4 {
				res.has_bis_limited_account_allowed_to_invite_friends = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bis_limited_account_allowed_to_invite_friends = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientislimitedaccount() CMsgClientIsLimitedAccount {
	return CMsgClientIsLimitedAccount{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientislimitedaccount(o CMsgClientIsLimitedAccount, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientislimitedaccount(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientIsLimitedAccount) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientislimitedaccount_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestedClientStats_StatsToSend {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	client_stat               u32
	has_client_stat           bool
	stat_aggregate_method     u32
	has_stat_aggregate_method bool
}

pub fn (o &CMsgClientRequestedClientStats_StatsToSend) pack() []byte {
	mut res := []byte{}
	if o.has_client_stat {
		res << vproto.pack_uint32_field(o.client_stat, 1)
	}
	if o.has_stat_aggregate_method {
		res << vproto.pack_uint32_field(o.stat_aggregate_method, 2)
	}
	return res
}

pub fn cmsgclientrequestedclientstats_statstosend_unpack(buf []byte) ?CMsgClientRequestedClientStats_StatsToSend {
	mut res := CMsgClientRequestedClientStats_StatsToSend{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_client_stat = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_stat = v
				i = ii
			}
			2 {
				res.has_stat_aggregate_method = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.stat_aggregate_method = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestedclientstats_statstosend() CMsgClientRequestedClientStats_StatsToSend {
	return CMsgClientRequestedClientStats_StatsToSend{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestedclientstats_statstosend(o CMsgClientRequestedClientStats_StatsToSend, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestedclientstats_statstosend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestedClientStats_StatsToSend) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestedclientstats_statstosend_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestedClientStats {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stats_to_send  []CMsgClientRequestedClientStats_StatsToSend
}

pub fn (o &CMsgClientRequestedClientStats) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.stats_to_send {
		res << zzz_vproto_internal_pack_cmsgclientrequestedclientstats_statstosend(x, 1)
	}
	return res
}

pub fn cmsgclientrequestedclientstats_unpack(buf []byte) ?CMsgClientRequestedClientStats {
	mut res := CMsgClientRequestedClientStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientrequestedclientstats_statstosend(cur_buf,
					tag_wiretype.wire_type)?
				res.stats_to_send << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestedclientstats() CMsgClientRequestedClientStats {
	return CMsgClientRequestedClientStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestedclientstats(o CMsgClientRequestedClientStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestedclientstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestedClientStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestedclientstats_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientStat2_StatDetail {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	client_stat     u32
	has_client_stat bool
	ll_value        i64
	has_ll_value    bool
	time_of_day     u32
	has_time_of_day bool
	cell_id         u32
	has_cell_id     bool
	depot_id        u32
	has_depot_id    bool
	app_id          u32
	has_app_id      bool
}

pub fn (o &CMsgClientStat2_StatDetail) pack() []byte {
	mut res := []byte{}
	if o.has_client_stat {
		res << vproto.pack_uint32_field(o.client_stat, 1)
	}
	if o.has_ll_value {
		res << vproto.pack_int64_field(o.ll_value, 2)
	}
	if o.has_time_of_day {
		res << vproto.pack_uint32_field(o.time_of_day, 3)
	}
	if o.has_cell_id {
		res << vproto.pack_uint32_field(o.cell_id, 4)
	}
	if o.has_depot_id {
		res << vproto.pack_uint32_field(o.depot_id, 5)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 6)
	}
	return res
}

pub fn cmsgclientstat2_statdetail_unpack(buf []byte) ?CMsgClientStat2_StatDetail {
	mut res := CMsgClientStat2_StatDetail{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_client_stat = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_stat = v
				i = ii
			}
			2 {
				res.has_ll_value = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
				res.ll_value = v
				i = ii
			}
			3 {
				res.has_time_of_day = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_of_day = v
				i = ii
			}
			4 {
				res.has_cell_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			5 {
				res.has_depot_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depot_id = v
				i = ii
			}
			6 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstat2_statdetail() CMsgClientStat2_StatDetail {
	return CMsgClientStat2_StatDetail{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstat2_statdetail(o CMsgClientStat2_StatDetail, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstat2_statdetail(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStat2_StatDetail) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientstat2_statdetail_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientStat2 {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stat_detail    []CMsgClientStat2_StatDetail
}

pub fn (o &CMsgClientStat2) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.stat_detail {
		res << zzz_vproto_internal_pack_cmsgclientstat2_statdetail(x, 1)
	}
	return res
}

pub fn cmsgclientstat2_unpack(buf []byte) ?CMsgClientStat2 {
	mut res := CMsgClientStat2{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientstat2_statdetail(cur_buf,
					tag_wiretype.wire_type)?
				res.stat_detail << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstat2() CMsgClientStat2 {
	return CMsgClientStat2{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstat2(o CMsgClientStat2, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstat2(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStat2) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientstat2_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSSetRatelimitPolicyOnClient {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	app_id                           u32
	has_app_id                       bool
	enable_rate_limits               bool
	has_enable_rate_limits           bool
	seconds_per_message              int
	has_seconds_per_message          bool
	milliseconds_per_data_update     int
	has_milliseconds_per_data_update bool
}

pub fn (o &CMsgClientMMSSetRatelimitPolicyOnClient) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_enable_rate_limits {
		res << vproto.pack_bool_field(o.enable_rate_limits, 2)
	}
	if o.has_seconds_per_message {
		res << vproto.pack_int32_field(o.seconds_per_message, 3)
	}
	if o.has_milliseconds_per_data_update {
		res << vproto.pack_int32_field(o.milliseconds_per_data_update, 4)
	}
	return res
}

pub fn cmsgclientmmssetratelimitpolicyonclient_unpack(buf []byte) ?CMsgClientMMSSetRatelimitPolicyOnClient {
	mut res := CMsgClientMMSSetRatelimitPolicyOnClient{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_enable_rate_limits = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_rate_limits = v
				i = ii
			}
			3 {
				res.has_seconds_per_message = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_per_message = v
				i = ii
			}
			4 {
				res.has_milliseconds_per_data_update = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.milliseconds_per_data_update = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetratelimitpolicyonclient() CMsgClientMMSSetRatelimitPolicyOnClient {
	return CMsgClientMMSSetRatelimitPolicyOnClient{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetratelimitpolicyonclient(o CMsgClientMMSSetRatelimitPolicyOnClient, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetratelimitpolicyonclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetRatelimitPolicyOnClient) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmssetratelimitpolicyonclient_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSCreateLobby {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	app_id                   u32
	has_app_id               bool
	max_members              int
	has_max_members          bool
	lobby_type               int
	has_lobby_type           bool
	lobby_flags              int
	has_lobby_flags          bool
	cell_id                  u32
	has_cell_id              bool
	deprecated_public_ip     u32
	has_deprecated_public_ip bool
	metadata                 []byte
	has_metadata             bool
	persona_name_owner       string
	has_persona_name_owner   bool
	public_ip                CMsgIPAddress
	has_public_ip            bool
}

pub fn (o &CMsgClientMMSCreateLobby) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_max_members {
		res << vproto.pack_int32_field(o.max_members, 2)
	}
	if o.has_lobby_type {
		res << vproto.pack_int32_field(o.lobby_type, 3)
	}
	if o.has_lobby_flags {
		res << vproto.pack_int32_field(o.lobby_flags, 4)
	}
	if o.has_cell_id {
		res << vproto.pack_uint32_field(o.cell_id, 5)
	}
	if o.has_deprecated_public_ip {
		res << vproto.pack_uint32_field(o.deprecated_public_ip, 6)
	}
	if o.has_metadata {
		res << vproto.pack_bytes_field(o.metadata, 7)
	}
	if o.has_persona_name_owner {
		res << vproto.pack_string_field(o.persona_name_owner, 8)
	}
	if o.has_public_ip {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 9)
	}
	return res
}

pub fn cmsgclientmmscreatelobby_unpack(buf []byte) ?CMsgClientMMSCreateLobby {
	mut res := CMsgClientMMSCreateLobby{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_max_members = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_members = v
				i = ii
			}
			3 {
				res.has_lobby_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.lobby_type = v
				i = ii
			}
			4 {
				res.has_lobby_flags = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.lobby_flags = v
				i = ii
			}
			5 {
				res.has_cell_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			6 {
				res.has_deprecated_public_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_public_ip = v
				i = ii
			}
			7 {
				res.has_metadata = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.metadata = v
				i = ii
			}
			8 {
				res.has_persona_name_owner = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_name_owner = v
				i = ii
			}
			9 {
				res.has_public_ip = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.public_ip = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmscreatelobby() CMsgClientMMSCreateLobby {
	return CMsgClientMMSCreateLobby{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmscreatelobby(o CMsgClientMMSCreateLobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmscreatelobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSCreateLobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmscreatelobby_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSCreateLobbyResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	has_app_id         bool
	steam_id_lobby     u64
	has_steam_id_lobby bool
	eresult            int
	has_eresult        bool
}

pub fn (o &CMsgClientMMSCreateLobbyResponse) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 3)
	}
	return res
}

pub fn cmsgclientmmscreatelobbyresponse_unpack(buf []byte) ?CMsgClientMMSCreateLobbyResponse {
	mut res := CMsgClientMMSCreateLobbyResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmscreatelobbyresponse() CMsgClientMMSCreateLobbyResponse {
	return CMsgClientMMSCreateLobbyResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmscreatelobbyresponse(o CMsgClientMMSCreateLobbyResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmscreatelobbyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSCreateLobbyResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmscreatelobbyresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSJoinLobby {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	has_app_id         bool
	steam_id_lobby     u64
	has_steam_id_lobby bool
	persona_name       string
	has_persona_name   bool
}

pub fn (o &CMsgClientMMSJoinLobby) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_persona_name {
		res << vproto.pack_string_field(o.persona_name, 3)
	}
	return res
}

pub fn cmsgclientmmsjoinlobby_unpack(buf []byte) ?CMsgClientMMSJoinLobby {
	mut res := CMsgClientMMSJoinLobby{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_persona_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsjoinlobby() CMsgClientMMSJoinLobby {
	return CMsgClientMMSJoinLobby{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsjoinlobby(o CMsgClientMMSJoinLobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsjoinlobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSJoinLobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsjoinlobby_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSJoinLobbyResponse_Member {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steam_id         u64
	has_steam_id     bool
	persona_name     string
	has_persona_name bool
	metadata         []byte
	has_metadata     bool
}

pub fn (o &CMsgClientMMSJoinLobbyResponse_Member) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.has_persona_name {
		res << vproto.pack_string_field(o.persona_name, 2)
	}
	if o.has_metadata {
		res << vproto.pack_bytes_field(o.metadata, 3)
	}
	return res
}

pub fn cmsgclientmmsjoinlobbyresponse_member_unpack(buf []byte) ?CMsgClientMMSJoinLobbyResponse_Member {
	mut res := CMsgClientMMSJoinLobbyResponse_Member{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			2 {
				res.has_persona_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_name = v
				i = ii
			}
			3 {
				res.has_metadata = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.metadata = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsjoinlobbyresponse_member() CMsgClientMMSJoinLobbyResponse_Member {
	return CMsgClientMMSJoinLobbyResponse_Member{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsjoinlobbyresponse_member(o CMsgClientMMSJoinLobbyResponse_Member, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsjoinlobbyresponse_member(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSJoinLobbyResponse_Member) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsjoinlobbyresponse_member_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSJoinLobbyResponse {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	app_id                       u32
	has_app_id                   bool
	steam_id_lobby               u64
	has_steam_id_lobby           bool
	chat_room_enter_response     int
	has_chat_room_enter_response bool
	max_members                  int
	has_max_members              bool
	lobby_type                   int
	has_lobby_type               bool
	lobby_flags                  int
	has_lobby_flags              bool
	steam_id_owner               u64
	has_steam_id_owner           bool
	metadata                     []byte
	has_metadata                 bool
	members                      []CMsgClientMMSJoinLobbyResponse_Member
}

pub fn (o &CMsgClientMMSJoinLobbyResponse) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_chat_room_enter_response {
		res << vproto.pack_int32_field(o.chat_room_enter_response, 3)
	}
	if o.has_max_members {
		res << vproto.pack_int32_field(o.max_members, 4)
	}
	if o.has_lobby_type {
		res << vproto.pack_int32_field(o.lobby_type, 5)
	}
	if o.has_lobby_flags {
		res << vproto.pack_int32_field(o.lobby_flags, 6)
	}
	if o.has_steam_id_owner {
		res << vproto.pack_64bit_field(o.steam_id_owner, 7)
	}
	if o.has_metadata {
		res << vproto.pack_bytes_field(o.metadata, 8)
	}
	// [packed=false]
	for _, x in o.members {
		res << zzz_vproto_internal_pack_cmsgclientmmsjoinlobbyresponse_member(x, 9)
	}
	return res
}

pub fn cmsgclientmmsjoinlobbyresponse_unpack(buf []byte) ?CMsgClientMMSJoinLobbyResponse {
	mut res := CMsgClientMMSJoinLobbyResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_chat_room_enter_response = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_room_enter_response = v
				i = ii
			}
			4 {
				res.has_max_members = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_members = v
				i = ii
			}
			5 {
				res.has_lobby_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.lobby_type = v
				i = ii
			}
			6 {
				res.has_lobby_flags = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.lobby_flags = v
				i = ii
			}
			7 {
				res.has_steam_id_owner = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_owner = v
				i = ii
			}
			8 {
				res.has_metadata = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.metadata = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientmmsjoinlobbyresponse_member(cur_buf,
					tag_wiretype.wire_type)?
				res.members << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsjoinlobbyresponse() CMsgClientMMSJoinLobbyResponse {
	return CMsgClientMMSJoinLobbyResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsjoinlobbyresponse(o CMsgClientMMSJoinLobbyResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsjoinlobbyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSJoinLobbyResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsjoinlobbyresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSLeaveLobby {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	has_app_id         bool
	steam_id_lobby     u64
	has_steam_id_lobby bool
}

pub fn (o &CMsgClientMMSLeaveLobby) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	return res
}

pub fn cmsgclientmmsleavelobby_unpack(buf []byte) ?CMsgClientMMSLeaveLobby {
	mut res := CMsgClientMMSLeaveLobby{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsleavelobby() CMsgClientMMSLeaveLobby {
	return CMsgClientMMSLeaveLobby{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsleavelobby(o CMsgClientMMSLeaveLobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsleavelobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSLeaveLobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsleavelobby_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSLeaveLobbyResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	has_app_id         bool
	steam_id_lobby     u64
	has_steam_id_lobby bool
	eresult            int
	has_eresult        bool
}

pub fn (o &CMsgClientMMSLeaveLobbyResponse) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 3)
	}
	return res
}

pub fn cmsgclientmmsleavelobbyresponse_unpack(buf []byte) ?CMsgClientMMSLeaveLobbyResponse {
	mut res := CMsgClientMMSLeaveLobbyResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsleavelobbyresponse() CMsgClientMMSLeaveLobbyResponse {
	return CMsgClientMMSLeaveLobbyResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsleavelobbyresponse(o CMsgClientMMSLeaveLobbyResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsleavelobbyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSLeaveLobbyResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsleavelobbyresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyList_Filter {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	key             string
	has_key         bool
	value           string
	has_value       bool
	comparision     int
	has_comparision bool
	filter_type     int
	has_filter_type bool
}

pub fn (o &CMsgClientMMSGetLobbyList_Filter) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	if o.has_comparision {
		res << vproto.pack_int32_field(o.comparision, 3)
	}
	if o.has_filter_type {
		res << vproto.pack_int32_field(o.filter_type, 4)
	}
	return res
}

pub fn cmsgclientmmsgetlobbylist_filter_unpack(buf []byte) ?CMsgClientMMSGetLobbyList_Filter {
	mut res := CMsgClientMMSGetLobbyList_Filter{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			3 {
				res.has_comparision = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.comparision = v
				i = ii
			}
			4 {
				res.has_filter_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.filter_type = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbylist_filter() CMsgClientMMSGetLobbyList_Filter {
	return CMsgClientMMSGetLobbyList_Filter{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbylist_filter(o CMsgClientMMSGetLobbyList_Filter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylist_filter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyList_Filter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsgetlobbylist_filter_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyList {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	app_id                    u32
	has_app_id                bool
	num_lobbies_requested     int
	has_num_lobbies_requested bool
	cell_id                   u32
	has_cell_id               bool
	deprecated_public_ip      u32
	has_deprecated_public_ip  bool
	filters                   []CMsgClientMMSGetLobbyList_Filter
	public_ip                 CMsgIPAddress
	has_public_ip             bool
}

pub fn (o &CMsgClientMMSGetLobbyList) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_num_lobbies_requested {
		res << vproto.pack_int32_field(o.num_lobbies_requested, 3)
	}
	if o.has_cell_id {
		res << vproto.pack_uint32_field(o.cell_id, 4)
	}
	if o.has_deprecated_public_ip {
		res << vproto.pack_uint32_field(o.deprecated_public_ip, 5)
	}
	// [packed=false]
	for _, x in o.filters {
		res << zzz_vproto_internal_pack_cmsgclientmmsgetlobbylist_filter(x, 6)
	}
	if o.has_public_ip {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 7)
	}
	return res
}

pub fn cmsgclientmmsgetlobbylist_unpack(buf []byte) ?CMsgClientMMSGetLobbyList {
	mut res := CMsgClientMMSGetLobbyList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			3 {
				res.has_num_lobbies_requested = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_lobbies_requested = v
				i = ii
			}
			4 {
				res.has_cell_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			5 {
				res.has_deprecated_public_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_public_ip = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylist_filter(cur_buf,
					tag_wiretype.wire_type)?
				res.filters << v
				i = ii
			}
			7 {
				res.has_public_ip = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.public_ip = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbylist() CMsgClientMMSGetLobbyList {
	return CMsgClientMMSGetLobbyList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbylist(o CMsgClientMMSGetLobbyList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsgetlobbylist_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyListResponse_Lobby {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	steam_id        u64
	has_steam_id    bool
	max_members     int
	has_max_members bool
	lobby_type      int
	has_lobby_type  bool
	lobby_flags     int
	has_lobby_flags bool
	metadata        []byte
	has_metadata    bool
	num_members     int
	has_num_members bool
	distance        f32
	has_distance    bool
	weight          i64
	has_weight      bool
}

pub fn (o &CMsgClientMMSGetLobbyListResponse_Lobby) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.has_max_members {
		res << vproto.pack_int32_field(o.max_members, 2)
	}
	if o.has_lobby_type {
		res << vproto.pack_int32_field(o.lobby_type, 3)
	}
	if o.has_lobby_flags {
		res << vproto.pack_int32_field(o.lobby_flags, 4)
	}
	if o.has_metadata {
		res << vproto.pack_bytes_field(o.metadata, 5)
	}
	if o.has_num_members {
		res << vproto.pack_int32_field(o.num_members, 6)
	}
	if o.has_distance {
		res << vproto.pack_float_field(o.distance, 7)
	}
	if o.has_weight {
		res << vproto.pack_int64_field(o.weight, 8)
	}
	return res
}

pub fn cmsgclientmmsgetlobbylistresponse_lobby_unpack(buf []byte) ?CMsgClientMMSGetLobbyListResponse_Lobby {
	mut res := CMsgClientMMSGetLobbyListResponse_Lobby{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			2 {
				res.has_max_members = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_members = v
				i = ii
			}
			3 {
				res.has_lobby_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.lobby_type = v
				i = ii
			}
			4 {
				res.has_lobby_flags = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.lobby_flags = v
				i = ii
			}
			5 {
				res.has_metadata = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.metadata = v
				i = ii
			}
			6 {
				res.has_num_members = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_members = v
				i = ii
			}
			7 {
				res.has_distance = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.distance = v
				i = ii
			}
			8 {
				res.has_weight = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
				res.weight = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbylistresponse_lobby() CMsgClientMMSGetLobbyListResponse_Lobby {
	return CMsgClientMMSGetLobbyListResponse_Lobby{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbylistresponse_lobby(o CMsgClientMMSGetLobbyListResponse_Lobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylistresponse_lobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyListResponse_Lobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsgetlobbylistresponse_lobby_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyListResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	has_app_id     bool
	eresult        int
	has_eresult    bool
	lobbies        []CMsgClientMMSGetLobbyListResponse_Lobby
}

pub fn (o &CMsgClientMMSGetLobbyListResponse) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 3)
	}
	// [packed=false]
	for _, x in o.lobbies {
		res << zzz_vproto_internal_pack_cmsgclientmmsgetlobbylistresponse_lobby(x, 4)
	}
	return res
}

pub fn cmsgclientmmsgetlobbylistresponse_unpack(buf []byte) ?CMsgClientMMSGetLobbyListResponse {
	mut res := CMsgClientMMSGetLobbyListResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			3 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylistresponse_lobby(cur_buf,
					tag_wiretype.wire_type)?
				res.lobbies << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbylistresponse() CMsgClientMMSGetLobbyListResponse {
	return CMsgClientMMSGetLobbyListResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbylistresponse(o CMsgClientMMSGetLobbyListResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbylistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyListResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsgetlobbylistresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSSetLobbyData {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	app_id              u32
	has_app_id          bool
	steam_id_lobby      u64
	has_steam_id_lobby  bool
	steam_id_member     u64
	has_steam_id_member bool
	max_members         int
	has_max_members     bool
	lobby_type          int
	has_lobby_type      bool
	lobby_flags         int
	has_lobby_flags     bool
	metadata            []byte
	has_metadata        bool
}

pub fn (o &CMsgClientMMSSetLobbyData) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_steam_id_member {
		res << vproto.pack_64bit_field(o.steam_id_member, 3)
	}
	if o.has_max_members {
		res << vproto.pack_int32_field(o.max_members, 4)
	}
	if o.has_lobby_type {
		res << vproto.pack_int32_field(o.lobby_type, 5)
	}
	if o.has_lobby_flags {
		res << vproto.pack_int32_field(o.lobby_flags, 6)
	}
	if o.has_metadata {
		res << vproto.pack_bytes_field(o.metadata, 7)
	}
	return res
}

pub fn cmsgclientmmssetlobbydata_unpack(buf []byte) ?CMsgClientMMSSetLobbyData {
	mut res := CMsgClientMMSSetLobbyData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_steam_id_member = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_member = v
				i = ii
			}
			4 {
				res.has_max_members = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_members = v
				i = ii
			}
			5 {
				res.has_lobby_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.lobby_type = v
				i = ii
			}
			6 {
				res.has_lobby_flags = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.lobby_flags = v
				i = ii
			}
			7 {
				res.has_metadata = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.metadata = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbydata() CMsgClientMMSSetLobbyData {
	return CMsgClientMMSSetLobbyData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbydata(o CMsgClientMMSSetLobbyData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbydata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetLobbyData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmssetlobbydata_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSSetLobbyDataResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	has_app_id         bool
	steam_id_lobby     u64
	has_steam_id_lobby bool
	eresult            int
	has_eresult        bool
}

pub fn (o &CMsgClientMMSSetLobbyDataResponse) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 3)
	}
	return res
}

pub fn cmsgclientmmssetlobbydataresponse_unpack(buf []byte) ?CMsgClientMMSSetLobbyDataResponse {
	mut res := CMsgClientMMSSetLobbyDataResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbydataresponse() CMsgClientMMSSetLobbyDataResponse {
	return CMsgClientMMSSetLobbyDataResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbydataresponse(o CMsgClientMMSSetLobbyDataResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbydataresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetLobbyDataResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmssetlobbydataresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyData {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	has_app_id         bool
	steam_id_lobby     u64
	has_steam_id_lobby bool
}

pub fn (o &CMsgClientMMSGetLobbyData) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	return res
}

pub fn cmsgclientmmsgetlobbydata_unpack(buf []byte) ?CMsgClientMMSGetLobbyData {
	mut res := CMsgClientMMSGetLobbyData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbydata() CMsgClientMMSGetLobbyData {
	return CMsgClientMMSGetLobbyData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbydata(o CMsgClientMMSGetLobbyData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbydata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsgetlobbydata_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSLobbyData_Member {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steam_id         u64
	has_steam_id     bool
	persona_name     string
	has_persona_name bool
	metadata         []byte
	has_metadata     bool
}

pub fn (o &CMsgClientMMSLobbyData_Member) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.has_persona_name {
		res << vproto.pack_string_field(o.persona_name, 2)
	}
	if o.has_metadata {
		res << vproto.pack_bytes_field(o.metadata, 3)
	}
	return res
}

pub fn cmsgclientmmslobbydata_member_unpack(buf []byte) ?CMsgClientMMSLobbyData_Member {
	mut res := CMsgClientMMSLobbyData_Member{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			2 {
				res.has_persona_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_name = v
				i = ii
			}
			3 {
				res.has_metadata = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.metadata = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmslobbydata_member() CMsgClientMMSLobbyData_Member {
	return CMsgClientMMSLobbyData_Member{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmslobbydata_member(o CMsgClientMMSLobbyData_Member, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmslobbydata_member(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSLobbyData_Member) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmslobbydata_member_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSLobbyData {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	app_id                          u32
	has_app_id                      bool
	steam_id_lobby                  u64
	has_steam_id_lobby              bool
	num_members                     int
	has_num_members                 bool
	max_members                     int
	has_max_members                 bool
	lobby_type                      int
	has_lobby_type                  bool
	lobby_flags                     int
	has_lobby_flags                 bool
	steam_id_owner                  u64
	has_steam_id_owner              bool
	metadata                        []byte
	has_metadata                    bool
	members                         []CMsgClientMMSLobbyData_Member
	lobby_cellid                    u32
	has_lobby_cellid                bool
	owner_should_accept_changes     bool
	has_owner_should_accept_changes bool
}

pub fn (o &CMsgClientMMSLobbyData) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_num_members {
		res << vproto.pack_int32_field(o.num_members, 3)
	}
	if o.has_max_members {
		res << vproto.pack_int32_field(o.max_members, 4)
	}
	if o.has_lobby_type {
		res << vproto.pack_int32_field(o.lobby_type, 5)
	}
	if o.has_lobby_flags {
		res << vproto.pack_int32_field(o.lobby_flags, 6)
	}
	if o.has_steam_id_owner {
		res << vproto.pack_64bit_field(o.steam_id_owner, 7)
	}
	if o.has_metadata {
		res << vproto.pack_bytes_field(o.metadata, 8)
	}
	// [packed=false]
	for _, x in o.members {
		res << zzz_vproto_internal_pack_cmsgclientmmslobbydata_member(x, 9)
	}
	if o.has_lobby_cellid {
		res << vproto.pack_uint32_field(o.lobby_cellid, 10)
	}
	if o.has_owner_should_accept_changes {
		res << vproto.pack_bool_field(o.owner_should_accept_changes, 11)
	}
	return res
}

pub fn cmsgclientmmslobbydata_unpack(buf []byte) ?CMsgClientMMSLobbyData {
	mut res := CMsgClientMMSLobbyData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_num_members = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_members = v
				i = ii
			}
			4 {
				res.has_max_members = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_members = v
				i = ii
			}
			5 {
				res.has_lobby_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.lobby_type = v
				i = ii
			}
			6 {
				res.has_lobby_flags = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.lobby_flags = v
				i = ii
			}
			7 {
				res.has_steam_id_owner = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_owner = v
				i = ii
			}
			8 {
				res.has_metadata = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.metadata = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientmmslobbydata_member(cur_buf,
					tag_wiretype.wire_type)?
				res.members << v
				i = ii
			}
			10 {
				res.has_lobby_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.lobby_cellid = v
				i = ii
			}
			11 {
				res.has_owner_should_accept_changes = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_should_accept_changes = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmslobbydata() CMsgClientMMSLobbyData {
	return CMsgClientMMSLobbyData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmslobbydata(o CMsgClientMMSLobbyData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmslobbydata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSLobbyData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmslobbydata_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSSendLobbyChatMsg {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	app_id              u32
	has_app_id          bool
	steam_id_lobby      u64
	has_steam_id_lobby  bool
	steam_id_target     u64
	has_steam_id_target bool
	lobby_message       []byte
	has_lobby_message   bool
}

pub fn (o &CMsgClientMMSSendLobbyChatMsg) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_steam_id_target {
		res << vproto.pack_64bit_field(o.steam_id_target, 3)
	}
	if o.has_lobby_message {
		res << vproto.pack_bytes_field(o.lobby_message, 4)
	}
	return res
}

pub fn cmsgclientmmssendlobbychatmsg_unpack(buf []byte) ?CMsgClientMMSSendLobbyChatMsg {
	mut res := CMsgClientMMSSendLobbyChatMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_steam_id_target = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_target = v
				i = ii
			}
			4 {
				res.has_lobby_message = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.lobby_message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssendlobbychatmsg() CMsgClientMMSSendLobbyChatMsg {
	return CMsgClientMMSSendLobbyChatMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssendlobbychatmsg(o CMsgClientMMSSendLobbyChatMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssendlobbychatmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSendLobbyChatMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmssendlobbychatmsg_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSLobbyChatMsg {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	app_id              u32
	has_app_id          bool
	steam_id_lobby      u64
	has_steam_id_lobby  bool
	steam_id_sender     u64
	has_steam_id_sender bool
	lobby_message       []byte
	has_lobby_message   bool
}

pub fn (o &CMsgClientMMSLobbyChatMsg) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_steam_id_sender {
		res << vproto.pack_64bit_field(o.steam_id_sender, 3)
	}
	if o.has_lobby_message {
		res << vproto.pack_bytes_field(o.lobby_message, 4)
	}
	return res
}

pub fn cmsgclientmmslobbychatmsg_unpack(buf []byte) ?CMsgClientMMSLobbyChatMsg {
	mut res := CMsgClientMMSLobbyChatMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_steam_id_sender = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_sender = v
				i = ii
			}
			4 {
				res.has_lobby_message = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.lobby_message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmslobbychatmsg() CMsgClientMMSLobbyChatMsg {
	return CMsgClientMMSLobbyChatMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmslobbychatmsg(o CMsgClientMMSLobbyChatMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmslobbychatmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSLobbyChatMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmslobbychatmsg_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSSetLobbyOwner {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	app_id                 u32
	has_app_id             bool
	steam_id_lobby         u64
	has_steam_id_lobby     bool
	steam_id_new_owner     u64
	has_steam_id_new_owner bool
}

pub fn (o &CMsgClientMMSSetLobbyOwner) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_steam_id_new_owner {
		res << vproto.pack_64bit_field(o.steam_id_new_owner, 3)
	}
	return res
}

pub fn cmsgclientmmssetlobbyowner_unpack(buf []byte) ?CMsgClientMMSSetLobbyOwner {
	mut res := CMsgClientMMSSetLobbyOwner{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_steam_id_new_owner = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_new_owner = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbyowner() CMsgClientMMSSetLobbyOwner {
	return CMsgClientMMSSetLobbyOwner{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbyowner(o CMsgClientMMSSetLobbyOwner, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbyowner(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetLobbyOwner) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmssetlobbyowner_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSSetLobbyOwnerResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	has_app_id         bool
	steam_id_lobby     u64
	has_steam_id_lobby bool
	eresult            int
	has_eresult        bool
}

pub fn (o &CMsgClientMMSSetLobbyOwnerResponse) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 3)
	}
	return res
}

pub fn cmsgclientmmssetlobbyownerresponse_unpack(buf []byte) ?CMsgClientMMSSetLobbyOwnerResponse {
	mut res := CMsgClientMMSSetLobbyOwnerResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbyownerresponse() CMsgClientMMSSetLobbyOwnerResponse {
	return CMsgClientMMSSetLobbyOwnerResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbyownerresponse(o CMsgClientMMSSetLobbyOwnerResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbyownerresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetLobbyOwnerResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmssetlobbyownerresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSSetLobbyLinked {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	app_id              u32
	has_app_id          bool
	steam_id_lobby      u64
	has_steam_id_lobby  bool
	steam_id_lobby2     u64
	has_steam_id_lobby2 bool
}

pub fn (o &CMsgClientMMSSetLobbyLinked) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_steam_id_lobby2 {
		res << vproto.pack_64bit_field(o.steam_id_lobby2, 3)
	}
	return res
}

pub fn cmsgclientmmssetlobbylinked_unpack(buf []byte) ?CMsgClientMMSSetLobbyLinked {
	mut res := CMsgClientMMSSetLobbyLinked{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_steam_id_lobby2 = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby2 = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbylinked() CMsgClientMMSSetLobbyLinked {
	return CMsgClientMMSSetLobbyLinked{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbylinked(o CMsgClientMMSSetLobbyLinked, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbylinked(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetLobbyLinked) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmssetlobbylinked_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSSetLobbyGameServer {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	app_id                        u32
	has_app_id                    bool
	steam_id_lobby                u64
	has_steam_id_lobby            bool
	deprecated_game_server_ip     u32
	has_deprecated_game_server_ip bool
	game_server_port              u32
	has_game_server_port          bool
	game_server_steam_id          u64
	has_game_server_steam_id      bool
	game_server_ip                CMsgIPAddress
	has_game_server_ip            bool
}

pub fn (o &CMsgClientMMSSetLobbyGameServer) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_deprecated_game_server_ip {
		res << vproto.pack_uint32_field(o.deprecated_game_server_ip, 3)
	}
	if o.has_game_server_port {
		res << vproto.pack_uint32_field(o.game_server_port, 4)
	}
	if o.has_game_server_steam_id {
		res << vproto.pack_64bit_field(o.game_server_steam_id, 5)
	}
	if o.has_game_server_ip {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.game_server_ip, 6)
	}
	return res
}

pub fn cmsgclientmmssetlobbygameserver_unpack(buf []byte) ?CMsgClientMMSSetLobbyGameServer {
	mut res := CMsgClientMMSSetLobbyGameServer{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_deprecated_game_server_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_game_server_ip = v
				i = ii
			}
			4 {
				res.has_game_server_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_server_port = v
				i = ii
			}
			5 {
				res.has_game_server_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.game_server_steam_id = v
				i = ii
			}
			6 {
				res.has_game_server_ip = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.game_server_ip = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmssetlobbygameserver() CMsgClientMMSSetLobbyGameServer {
	return CMsgClientMMSSetLobbyGameServer{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmssetlobbygameserver(o CMsgClientMMSSetLobbyGameServer, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmssetlobbygameserver(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSSetLobbyGameServer) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmssetlobbygameserver_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSLobbyGameServerSet {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	app_id                        u32
	has_app_id                    bool
	steam_id_lobby                u64
	has_steam_id_lobby            bool
	deprecated_game_server_ip     u32
	has_deprecated_game_server_ip bool
	game_server_port              u32
	has_game_server_port          bool
	game_server_steam_id          u64
	has_game_server_steam_id      bool
	game_server_ip                CMsgIPAddress
	has_game_server_ip            bool
}

pub fn (o &CMsgClientMMSLobbyGameServerSet) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_deprecated_game_server_ip {
		res << vproto.pack_uint32_field(o.deprecated_game_server_ip, 3)
	}
	if o.has_game_server_port {
		res << vproto.pack_uint32_field(o.game_server_port, 4)
	}
	if o.has_game_server_steam_id {
		res << vproto.pack_64bit_field(o.game_server_steam_id, 5)
	}
	if o.has_game_server_ip {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.game_server_ip, 6)
	}
	return res
}

pub fn cmsgclientmmslobbygameserverset_unpack(buf []byte) ?CMsgClientMMSLobbyGameServerSet {
	mut res := CMsgClientMMSLobbyGameServerSet{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_deprecated_game_server_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_game_server_ip = v
				i = ii
			}
			4 {
				res.has_game_server_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_server_port = v
				i = ii
			}
			5 {
				res.has_game_server_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.game_server_steam_id = v
				i = ii
			}
			6 {
				res.has_game_server_ip = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.game_server_ip = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmslobbygameserverset() CMsgClientMMSLobbyGameServerSet {
	return CMsgClientMMSLobbyGameServerSet{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmslobbygameserverset(o CMsgClientMMSLobbyGameServerSet, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmslobbygameserverset(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSLobbyGameServerSet) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmslobbygameserverset_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSUserJoinedLobby {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	has_app_id         bool
	steam_id_lobby     u64
	has_steam_id_lobby bool
	steam_id_user      u64
	has_steam_id_user  bool
	persona_name       string
	has_persona_name   bool
}

pub fn (o &CMsgClientMMSUserJoinedLobby) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_steam_id_user {
		res << vproto.pack_64bit_field(o.steam_id_user, 3)
	}
	if o.has_persona_name {
		res << vproto.pack_string_field(o.persona_name, 4)
	}
	return res
}

pub fn cmsgclientmmsuserjoinedlobby_unpack(buf []byte) ?CMsgClientMMSUserJoinedLobby {
	mut res := CMsgClientMMSUserJoinedLobby{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_steam_id_user = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_user = v
				i = ii
			}
			4 {
				res.has_persona_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsuserjoinedlobby() CMsgClientMMSUserJoinedLobby {
	return CMsgClientMMSUserJoinedLobby{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsuserjoinedlobby(o CMsgClientMMSUserJoinedLobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsuserjoinedlobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSUserJoinedLobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsuserjoinedlobby_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSUserLeftLobby {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	has_app_id         bool
	steam_id_lobby     u64
	has_steam_id_lobby bool
	steam_id_user      u64
	has_steam_id_user  bool
	persona_name       string
	has_persona_name   bool
}

pub fn (o &CMsgClientMMSUserLeftLobby) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_steam_id_user {
		res << vproto.pack_64bit_field(o.steam_id_user, 3)
	}
	if o.has_persona_name {
		res << vproto.pack_string_field(o.persona_name, 4)
	}
	return res
}

pub fn cmsgclientmmsuserleftlobby_unpack(buf []byte) ?CMsgClientMMSUserLeftLobby {
	mut res := CMsgClientMMSUserLeftLobby{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_steam_id_user = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_user = v
				i = ii
			}
			4 {
				res.has_persona_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsuserleftlobby() CMsgClientMMSUserLeftLobby {
	return CMsgClientMMSUserLeftLobby{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsuserleftlobby(o CMsgClientMMSUserLeftLobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsuserleftlobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSUserLeftLobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsuserleftlobby_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSInviteToLobby {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	app_id                    u32
	has_app_id                bool
	steam_id_lobby            u64
	has_steam_id_lobby        bool
	steam_id_user_invited     u64
	has_steam_id_user_invited bool
}

pub fn (o &CMsgClientMMSInviteToLobby) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_steam_id_user_invited {
		res << vproto.pack_64bit_field(o.steam_id_user_invited, 3)
	}
	return res
}

pub fn cmsgclientmmsinvitetolobby_unpack(buf []byte) ?CMsgClientMMSInviteToLobby {
	mut res := CMsgClientMMSInviteToLobby{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_steam_id_user_invited = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_user_invited = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsinvitetolobby() CMsgClientMMSInviteToLobby {
	return CMsgClientMMSInviteToLobby{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsinvitetolobby(o CMsgClientMMSInviteToLobby, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsinvitetolobby(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSInviteToLobby) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsinvitetolobby_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyStatus {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	app_id               u32
	has_app_id           bool
	steam_id_lobby       u64
	has_steam_id_lobby   bool
	claim_membership     bool
	has_claim_membership bool
	claim_ownership      bool
	has_claim_ownership  bool
}

pub fn (o &CMsgClientMMSGetLobbyStatus) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_claim_membership {
		res << vproto.pack_bool_field(o.claim_membership, 3)
	}
	if o.has_claim_ownership {
		res << vproto.pack_bool_field(o.claim_ownership, 4)
	}
	return res
}

pub fn cmsgclientmmsgetlobbystatus_unpack(buf []byte) ?CMsgClientMMSGetLobbyStatus {
	mut res := CMsgClientMMSGetLobbyStatus{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_claim_membership = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.claim_membership = v
				i = ii
			}
			4 {
				res.has_claim_ownership = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.claim_ownership = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbystatus() CMsgClientMMSGetLobbyStatus {
	return CMsgClientMMSGetLobbyStatus{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbystatus(o CMsgClientMMSGetLobbyStatus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbystatus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyStatus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsgetlobbystatus_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientMMSGetLobbyStatusResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	app_id             u32
	has_app_id         bool
	steam_id_lobby     u64
	has_steam_id_lobby bool
	lobby_status       EMMSLobbyStatus
	has_lobby_status   bool
}

pub fn (o &CMsgClientMMSGetLobbyStatusResponse) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steam_id_lobby {
		res << vproto.pack_64bit_field(o.steam_id_lobby, 2)
	}
	if o.has_lobby_status {
		res << zzz_vproto_internal_pack_emmslobbystatus(o.lobby_status, 3)
	}
	return res
}

pub fn cmsgclientmmsgetlobbystatusresponse_unpack(buf []byte) ?CMsgClientMMSGetLobbyStatusResponse {
	mut res := CMsgClientMMSGetLobbyStatusResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steam_id_lobby = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_lobby = v
				i = ii
			}
			3 {
				res.has_lobby_status = true
				ii, v := zzz_vproto_internal_unpack_emmslobbystatus(cur_buf, tag_wiretype.wire_type)?
				res.lobby_status = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmmsgetlobbystatusresponse() CMsgClientMMSGetLobbyStatusResponse {
	return CMsgClientMMSGetLobbyStatusResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmmsgetlobbystatusresponse(o CMsgClientMMSGetLobbyStatusResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmmsgetlobbystatusresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientMMSGetLobbyStatusResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmmsgetlobbystatusresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientInviteToGame {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	steam_id_dest      u64
	has_steam_id_dest  bool
	steam_id_src       u64
	has_steam_id_src   bool
	connect_string     string
	has_connect_string bool
	remote_play        string
	has_remote_play    bool
}

pub fn (o &CMsgClientInviteToGame) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id_dest {
		res << vproto.pack_64bit_field(o.steam_id_dest, 1)
	}
	if o.has_steam_id_src {
		res << vproto.pack_64bit_field(o.steam_id_src, 2)
	}
	if o.has_connect_string {
		res << vproto.pack_string_field(o.connect_string, 3)
	}
	if o.has_remote_play {
		res << vproto.pack_string_field(o.remote_play, 4)
	}
	return res
}

pub fn cmsgclientinvitetogame_unpack(buf []byte) ?CMsgClientInviteToGame {
	mut res := CMsgClientInviteToGame{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id_dest = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_dest = v
				i = ii
			}
			2 {
				res.has_steam_id_src = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_src = v
				i = ii
			}
			3 {
				res.has_connect_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.connect_string = v
				i = ii
			}
			4 {
				res.has_remote_play = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.remote_play = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientinvitetogame() CMsgClientInviteToGame {
	return CMsgClientInviteToGame{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientinvitetogame(o CMsgClientInviteToGame, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientinvitetogame(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientInviteToGame) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientinvitetogame_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientChatInvite {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	steam_id_invited         u64
	has_steam_id_invited     bool
	steam_id_chat            u64
	has_steam_id_chat        bool
	steam_id_patron          u64
	has_steam_id_patron      bool
	chatroom_type            int
	has_chatroom_type        bool
	steam_id_friend_chat     u64
	has_steam_id_friend_chat bool
	chat_name                string
	has_chat_name            bool
	game_id                  u64
	has_game_id              bool
}

pub fn (o &CMsgClientChatInvite) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id_invited {
		res << vproto.pack_64bit_field(o.steam_id_invited, 1)
	}
	if o.has_steam_id_chat {
		res << vproto.pack_64bit_field(o.steam_id_chat, 2)
	}
	if o.has_steam_id_patron {
		res << vproto.pack_64bit_field(o.steam_id_patron, 3)
	}
	if o.has_chatroom_type {
		res << vproto.pack_int32_field(o.chatroom_type, 4)
	}
	if o.has_steam_id_friend_chat {
		res << vproto.pack_64bit_field(o.steam_id_friend_chat, 5)
	}
	if o.has_chat_name {
		res << vproto.pack_string_field(o.chat_name, 6)
	}
	if o.has_game_id {
		res << vproto.pack_64bit_field(o.game_id, 7)
	}
	return res
}

pub fn cmsgclientchatinvite_unpack(buf []byte) ?CMsgClientChatInvite {
	mut res := CMsgClientChatInvite{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id_invited = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_invited = v
				i = ii
			}
			2 {
				res.has_steam_id_chat = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_chat = v
				i = ii
			}
			3 {
				res.has_steam_id_patron = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_patron = v
				i = ii
			}
			4 {
				res.has_chatroom_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chatroom_type = v
				i = ii
			}
			5 {
				res.has_steam_id_friend_chat = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_friend_chat = v
				i = ii
			}
			6 {
				res.has_chat_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_name = v
				i = ii
			}
			7 {
				res.has_game_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.game_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientchatinvite() CMsgClientChatInvite {
	return CMsgClientChatInvite{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientchatinvite(o CMsgClientChatInvite, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientchatinvite(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChatInvite) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientchatinvite_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientConnectionStats_Stats_Logon {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	connect_attempts         int
	has_connect_attempts     bool
	connect_successes        int
	has_connect_successes    bool
	connect_failures         int
	has_connect_failures     bool
	connections_dropped      int
	has_connections_dropped  bool
	seconds_running          u32
	has_seconds_running      bool
	msec_tologonthistime     u32
	has_msec_tologonthistime bool
	count_bad_cms            u32
	has_count_bad_cms        bool
}

pub fn (o &CMsgClientConnectionStats_Stats_Logon) pack() []byte {
	mut res := []byte{}
	if o.has_connect_attempts {
		res << vproto.pack_int32_field(o.connect_attempts, 1)
	}
	if o.has_connect_successes {
		res << vproto.pack_int32_field(o.connect_successes, 2)
	}
	if o.has_connect_failures {
		res << vproto.pack_int32_field(o.connect_failures, 3)
	}
	if o.has_connections_dropped {
		res << vproto.pack_int32_field(o.connections_dropped, 4)
	}
	if o.has_seconds_running {
		res << vproto.pack_uint32_field(o.seconds_running, 5)
	}
	if o.has_msec_tologonthistime {
		res << vproto.pack_uint32_field(o.msec_tologonthistime, 6)
	}
	if o.has_count_bad_cms {
		res << vproto.pack_uint32_field(o.count_bad_cms, 7)
	}
	return res
}

pub fn cmsgclientconnectionstats_stats_logon_unpack(buf []byte) ?CMsgClientConnectionStats_Stats_Logon {
	mut res := CMsgClientConnectionStats_Stats_Logon{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_connect_attempts = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.connect_attempts = v
				i = ii
			}
			2 {
				res.has_connect_successes = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.connect_successes = v
				i = ii
			}
			3 {
				res.has_connect_failures = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.connect_failures = v
				i = ii
			}
			4 {
				res.has_connections_dropped = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.connections_dropped = v
				i = ii
			}
			5 {
				res.has_seconds_running = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_running = v
				i = ii
			}
			6 {
				res.has_msec_tologonthistime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.msec_tologonthistime = v
				i = ii
			}
			7 {
				res.has_count_bad_cms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count_bad_cms = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientconnectionstats_stats_logon() CMsgClientConnectionStats_Stats_Logon {
	return CMsgClientConnectionStats_Stats_Logon{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientconnectionstats_stats_logon(o CMsgClientConnectionStats_Stats_Logon, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientconnectionstats_stats_logon(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientConnectionStats_Stats_Logon) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientconnectionstats_stats_logon_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientConnectionStats_Stats_UDP {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	pkts_sent          u64
	has_pkts_sent      bool
	bytes_sent         u64
	has_bytes_sent     bool
	pkts_recv          u64
	has_pkts_recv      bool
	pkts_processed     u64
	has_pkts_processed bool
	bytes_recv         u64
	has_bytes_recv     bool
}

pub fn (o &CMsgClientConnectionStats_Stats_UDP) pack() []byte {
	mut res := []byte{}
	if o.has_pkts_sent {
		res << vproto.pack_uint64_field(o.pkts_sent, 1)
	}
	if o.has_bytes_sent {
		res << vproto.pack_uint64_field(o.bytes_sent, 2)
	}
	if o.has_pkts_recv {
		res << vproto.pack_uint64_field(o.pkts_recv, 3)
	}
	if o.has_pkts_processed {
		res << vproto.pack_uint64_field(o.pkts_processed, 4)
	}
	if o.has_bytes_recv {
		res << vproto.pack_uint64_field(o.bytes_recv, 5)
	}
	return res
}

pub fn cmsgclientconnectionstats_stats_udp_unpack(buf []byte) ?CMsgClientConnectionStats_Stats_UDP {
	mut res := CMsgClientConnectionStats_Stats_UDP{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_pkts_sent = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.pkts_sent = v
				i = ii
			}
			2 {
				res.has_bytes_sent = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_sent = v
				i = ii
			}
			3 {
				res.has_pkts_recv = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.pkts_recv = v
				i = ii
			}
			4 {
				res.has_pkts_processed = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.pkts_processed = v
				i = ii
			}
			5 {
				res.has_bytes_recv = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_recv = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientconnectionstats_stats_udp() CMsgClientConnectionStats_Stats_UDP {
	return CMsgClientConnectionStats_Stats_UDP{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientconnectionstats_stats_udp(o CMsgClientConnectionStats_Stats_UDP, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientconnectionstats_stats_udp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientConnectionStats_Stats_UDP) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientconnectionstats_stats_udp_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientConnectionStats_Stats_VConn {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	connections_udp               u32
	has_connections_udp           bool
	connections_tcp               u32
	has_connections_tcp           bool
	stats_udp                     CMsgClientConnectionStats_Stats_UDP
	has_stats_udp                 bool
	pkts_abandoned                u64
	has_pkts_abandoned            bool
	conn_req_received             u64
	has_conn_req_received         bool
	pkts_resent                   u64
	has_pkts_resent               bool
	msgs_sent                     u64
	has_msgs_sent                 bool
	msgs_sent_failed              u64
	has_msgs_sent_failed          bool
	msgs_recv                     u64
	has_msgs_recv                 bool
	datagrams_sent                u64
	has_datagrams_sent            bool
	datagrams_recv                u64
	has_datagrams_recv            bool
	bad_pkts_recv                 u64
	has_bad_pkts_recv             bool
	unknown_conn_pkts_recv        u64
	has_unknown_conn_pkts_recv    bool
	missed_pkts_recv              u64
	has_missed_pkts_recv          bool
	dup_pkts_recv                 u64
	has_dup_pkts_recv             bool
	failed_connect_challenges     u64
	has_failed_connect_challenges bool
	micro_sec_avg_latency         u32
	has_micro_sec_avg_latency     bool
	micro_sec_min_latency         u32
	has_micro_sec_min_latency     bool
	micro_sec_max_latency         u32
	has_micro_sec_max_latency     bool
	mem_pool_msg_in_use           u32
	has_mem_pool_msg_in_use       bool
}

pub fn (o &CMsgClientConnectionStats_Stats_VConn) pack() []byte {
	mut res := []byte{}
	if o.has_connections_udp {
		res << vproto.pack_uint32_field(o.connections_udp, 1)
	}
	if o.has_connections_tcp {
		res << vproto.pack_uint32_field(o.connections_tcp, 2)
	}
	if o.has_stats_udp {
		res << zzz_vproto_internal_pack_cmsgclientconnectionstats_stats_udp(o.stats_udp, 3)
	}
	if o.has_pkts_abandoned {
		res << vproto.pack_uint64_field(o.pkts_abandoned, 4)
	}
	if o.has_conn_req_received {
		res << vproto.pack_uint64_field(o.conn_req_received, 5)
	}
	if o.has_pkts_resent {
		res << vproto.pack_uint64_field(o.pkts_resent, 6)
	}
	if o.has_msgs_sent {
		res << vproto.pack_uint64_field(o.msgs_sent, 7)
	}
	if o.has_msgs_sent_failed {
		res << vproto.pack_uint64_field(o.msgs_sent_failed, 8)
	}
	if o.has_msgs_recv {
		res << vproto.pack_uint64_field(o.msgs_recv, 9)
	}
	if o.has_datagrams_sent {
		res << vproto.pack_uint64_field(o.datagrams_sent, 10)
	}
	if o.has_datagrams_recv {
		res << vproto.pack_uint64_field(o.datagrams_recv, 11)
	}
	if o.has_bad_pkts_recv {
		res << vproto.pack_uint64_field(o.bad_pkts_recv, 12)
	}
	if o.has_unknown_conn_pkts_recv {
		res << vproto.pack_uint64_field(o.unknown_conn_pkts_recv, 13)
	}
	if o.has_missed_pkts_recv {
		res << vproto.pack_uint64_field(o.missed_pkts_recv, 14)
	}
	if o.has_dup_pkts_recv {
		res << vproto.pack_uint64_field(o.dup_pkts_recv, 15)
	}
	if o.has_failed_connect_challenges {
		res << vproto.pack_uint64_field(o.failed_connect_challenges, 16)
	}
	if o.has_micro_sec_avg_latency {
		res << vproto.pack_uint32_field(o.micro_sec_avg_latency, 17)
	}
	if o.has_micro_sec_min_latency {
		res << vproto.pack_uint32_field(o.micro_sec_min_latency, 18)
	}
	if o.has_micro_sec_max_latency {
		res << vproto.pack_uint32_field(o.micro_sec_max_latency, 19)
	}
	if o.has_mem_pool_msg_in_use {
		res << vproto.pack_uint32_field(o.mem_pool_msg_in_use, 20)
	}
	return res
}

pub fn cmsgclientconnectionstats_stats_vconn_unpack(buf []byte) ?CMsgClientConnectionStats_Stats_VConn {
	mut res := CMsgClientConnectionStats_Stats_VConn{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_connections_udp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.connections_udp = v
				i = ii
			}
			2 {
				res.has_connections_tcp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.connections_tcp = v
				i = ii
			}
			3 {
				res.has_stats_udp = true
				ii, v := zzz_vproto_internal_unpack_cmsgclientconnectionstats_stats_udp(cur_buf,
					tag_wiretype.wire_type)?
				res.stats_udp = v
				i = ii
			}
			4 {
				res.has_pkts_abandoned = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.pkts_abandoned = v
				i = ii
			}
			5 {
				res.has_conn_req_received = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.conn_req_received = v
				i = ii
			}
			6 {
				res.has_pkts_resent = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.pkts_resent = v
				i = ii
			}
			7 {
				res.has_msgs_sent = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.msgs_sent = v
				i = ii
			}
			8 {
				res.has_msgs_sent_failed = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.msgs_sent_failed = v
				i = ii
			}
			9 {
				res.has_msgs_recv = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.msgs_recv = v
				i = ii
			}
			10 {
				res.has_datagrams_sent = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.datagrams_sent = v
				i = ii
			}
			11 {
				res.has_datagrams_recv = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.datagrams_recv = v
				i = ii
			}
			12 {
				res.has_bad_pkts_recv = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bad_pkts_recv = v
				i = ii
			}
			13 {
				res.has_unknown_conn_pkts_recv = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.unknown_conn_pkts_recv = v
				i = ii
			}
			14 {
				res.has_missed_pkts_recv = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.missed_pkts_recv = v
				i = ii
			}
			15 {
				res.has_dup_pkts_recv = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.dup_pkts_recv = v
				i = ii
			}
			16 {
				res.has_failed_connect_challenges = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.failed_connect_challenges = v
				i = ii
			}
			17 {
				res.has_micro_sec_avg_latency = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.micro_sec_avg_latency = v
				i = ii
			}
			18 {
				res.has_micro_sec_min_latency = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.micro_sec_min_latency = v
				i = ii
			}
			19 {
				res.has_micro_sec_max_latency = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.micro_sec_max_latency = v
				i = ii
			}
			20 {
				res.has_mem_pool_msg_in_use = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.mem_pool_msg_in_use = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientconnectionstats_stats_vconn() CMsgClientConnectionStats_Stats_VConn {
	return CMsgClientConnectionStats_Stats_VConn{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientconnectionstats_stats_vconn(o CMsgClientConnectionStats_Stats_VConn, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientconnectionstats_stats_vconn(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientConnectionStats_Stats_VConn) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientconnectionstats_stats_vconn_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientConnectionStats {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	stats_logon     CMsgClientConnectionStats_Stats_Logon
	has_stats_logon bool
	stats_vconn     CMsgClientConnectionStats_Stats_VConn
	has_stats_vconn bool
}

pub fn (o &CMsgClientConnectionStats) pack() []byte {
	mut res := []byte{}
	if o.has_stats_logon {
		res << zzz_vproto_internal_pack_cmsgclientconnectionstats_stats_logon(o.stats_logon, 1)
	}
	if o.has_stats_vconn {
		res << zzz_vproto_internal_pack_cmsgclientconnectionstats_stats_vconn(o.stats_vconn, 2)
	}
	return res
}

pub fn cmsgclientconnectionstats_unpack(buf []byte) ?CMsgClientConnectionStats {
	mut res := CMsgClientConnectionStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_stats_logon = true
				ii, v := zzz_vproto_internal_unpack_cmsgclientconnectionstats_stats_logon(cur_buf,
					tag_wiretype.wire_type)?
				res.stats_logon = v
				i = ii
			}
			2 {
				res.has_stats_vconn = true
				ii, v := zzz_vproto_internal_unpack_cmsgclientconnectionstats_stats_vconn(cur_buf,
					tag_wiretype.wire_type)?
				res.stats_vconn = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientconnectionstats() CMsgClientConnectionStats {
	return CMsgClientConnectionStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientconnectionstats(o CMsgClientConnectionStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientconnectionstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientConnectionStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientconnectionstats_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientServersAvailable_Server_Types_Available {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	server         u32
	has_server     bool
	changed        bool
	has_changed    bool
}

pub fn (o &CMsgClientServersAvailable_Server_Types_Available) pack() []byte {
	mut res := []byte{}
	if o.has_server {
		res << vproto.pack_uint32_field(o.server, 1)
	}
	if o.has_changed {
		res << vproto.pack_bool_field(o.changed, 2)
	}
	return res
}

pub fn cmsgclientserversavailable_server_types_available_unpack(buf []byte) ?CMsgClientServersAvailable_Server_Types_Available {
	mut res := CMsgClientServersAvailable_Server_Types_Available{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_server = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.server = v
				i = ii
			}
			2 {
				res.has_changed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.changed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientserversavailable_server_types_available() CMsgClientServersAvailable_Server_Types_Available {
	return CMsgClientServersAvailable_Server_Types_Available{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientserversavailable_server_types_available(o CMsgClientServersAvailable_Server_Types_Available, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientserversavailable_server_types_available(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServersAvailable_Server_Types_Available) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientserversavailable_server_types_available_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientServersAvailable {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	server_types_available            []CMsgClientServersAvailable_Server_Types_Available
	server_type_for_auth_services     u32
	has_server_type_for_auth_services bool
}

pub fn (o &CMsgClientServersAvailable) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.server_types_available {
		res << zzz_vproto_internal_pack_cmsgclientserversavailable_server_types_available(x, 1)
	}
	if o.has_server_type_for_auth_services {
		res << vproto.pack_uint32_field(o.server_type_for_auth_services, 2)
	}
	return res
}

pub fn cmsgclientserversavailable_unpack(buf []byte) ?CMsgClientServersAvailable {
	mut res := CMsgClientServersAvailable{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientserversavailable_server_types_available(cur_buf,
					tag_wiretype.wire_type)?
				res.server_types_available << v
				i = ii
			}
			2 {
				res.has_server_type_for_auth_services = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.server_type_for_auth_services = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientserversavailable() CMsgClientServersAvailable {
	return CMsgClientServersAvailable{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientserversavailable(o CMsgClientServersAvailable, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientserversavailable(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServersAvailable) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientserversavailable_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetUserStats {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	game_id                  u64
	has_game_id              bool
	crc_stats                u32
	has_crc_stats            bool
	schema_local_version     int
	has_schema_local_version bool
	steam_id_for_user        u64
	has_steam_id_for_user    bool
}

pub fn (o &CMsgClientGetUserStats) pack() []byte {
	mut res := []byte{}
	if o.has_game_id {
		res << vproto.pack_64bit_field(o.game_id, 1)
	}
	if o.has_crc_stats {
		res << vproto.pack_uint32_field(o.crc_stats, 2)
	}
	if o.has_schema_local_version {
		res << vproto.pack_int32_field(o.schema_local_version, 3)
	}
	if o.has_steam_id_for_user {
		res << vproto.pack_64bit_field(o.steam_id_for_user, 4)
	}
	return res
}

pub fn cmsgclientgetuserstats_unpack(buf []byte) ?CMsgClientGetUserStats {
	mut res := CMsgClientGetUserStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_game_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.game_id = v
				i = ii
			}
			2 {
				res.has_crc_stats = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.crc_stats = v
				i = ii
			}
			3 {
				res.has_schema_local_version = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.schema_local_version = v
				i = ii
			}
			4 {
				res.has_steam_id_for_user = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_for_user = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetuserstats() CMsgClientGetUserStats {
	return CMsgClientGetUserStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetuserstats(o CMsgClientGetUserStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetuserstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetUserStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetuserstats_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetUserStatsResponse_Stats {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stat_id        u32
	has_stat_id    bool
	stat_value     u32
	has_stat_value bool
}

pub fn (o &CMsgClientGetUserStatsResponse_Stats) pack() []byte {
	mut res := []byte{}
	if o.has_stat_id {
		res << vproto.pack_uint32_field(o.stat_id, 1)
	}
	if o.has_stat_value {
		res << vproto.pack_uint32_field(o.stat_value, 2)
	}
	return res
}

pub fn cmsgclientgetuserstatsresponse_stats_unpack(buf []byte) ?CMsgClientGetUserStatsResponse_Stats {
	mut res := CMsgClientGetUserStatsResponse_Stats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_stat_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.stat_id = v
				i = ii
			}
			2 {
				res.has_stat_value = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.stat_value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetuserstatsresponse_stats() CMsgClientGetUserStatsResponse_Stats {
	return CMsgClientGetUserStatsResponse_Stats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetuserstatsresponse_stats(o CMsgClientGetUserStatsResponse_Stats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponse_stats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetUserStatsResponse_Stats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetuserstatsresponse_stats_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetUserStatsResponse_Achievement_Blocks {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	achievement_id     u32
	has_achievement_id bool
	unlock_time        []u32
}

pub fn (o &CMsgClientGetUserStatsResponse_Achievement_Blocks) pack() []byte {
	mut res := []byte{}
	if o.has_achievement_id {
		res << vproto.pack_uint32_field(o.achievement_id, 1)
	}
	// [packed=false]
	for _, x in o.unlock_time {
		res << vproto.pack_32bit_field(x, 2)
	}
	return res
}

pub fn cmsgclientgetuserstatsresponse_achievement_blocks_unpack(buf []byte) ?CMsgClientGetUserStatsResponse_Achievement_Blocks {
	mut res := CMsgClientGetUserStatsResponse_Achievement_Blocks{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_achievement_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.achievement_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.unlock_time << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetuserstatsresponse_achievement_blocks() CMsgClientGetUserStatsResponse_Achievement_Blocks {
	return CMsgClientGetUserStatsResponse_Achievement_Blocks{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetuserstatsresponse_achievement_blocks(o CMsgClientGetUserStatsResponse_Achievement_Blocks, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponse_achievement_blocks(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetUserStatsResponse_Achievement_Blocks) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetuserstatsresponse_achievement_blocks_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetUserStatsResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	game_id            u64
	has_game_id        bool
	eresult            int
	has_eresult        bool
	crc_stats          u32
	has_crc_stats      bool
	schema             []byte
	has_schema         bool
	stats              []CMsgClientGetUserStatsResponse_Stats
	achievement_blocks []CMsgClientGetUserStatsResponse_Achievement_Blocks
}

pub fn (o &CMsgClientGetUserStatsResponse) pack() []byte {
	mut res := []byte{}
	if o.has_game_id {
		res << vproto.pack_64bit_field(o.game_id, 1)
	}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 2)
	}
	if o.has_crc_stats {
		res << vproto.pack_uint32_field(o.crc_stats, 3)
	}
	if o.has_schema {
		res << vproto.pack_bytes_field(o.schema, 4)
	}
	// [packed=false]
	for _, x in o.stats {
		res << zzz_vproto_internal_pack_cmsgclientgetuserstatsresponse_stats(x, 5)
	}
	// [packed=false]
	for _, x in o.achievement_blocks {
		res << zzz_vproto_internal_pack_cmsgclientgetuserstatsresponse_achievement_blocks(x, 6)
	}
	return res
}

pub fn cmsgclientgetuserstatsresponse_unpack(buf []byte) ?CMsgClientGetUserStatsResponse {
	mut res := CMsgClientGetUserStatsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_game_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.game_id = v
				i = ii
			}
			2 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			3 {
				res.has_crc_stats = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.crc_stats = v
				i = ii
			}
			4 {
				res.has_schema = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.schema = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponse_stats(cur_buf,
					tag_wiretype.wire_type)?
				res.stats << v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponse_achievement_blocks(cur_buf,
					tag_wiretype.wire_type)?
				res.achievement_blocks << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetuserstatsresponse() CMsgClientGetUserStatsResponse {
	return CMsgClientGetUserStatsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetuserstatsresponse(o CMsgClientGetUserStatsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetuserstatsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetUserStatsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetuserstatsresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	stat_id                 u32
	has_stat_id             bool
	reverted_stat_value     u32
	has_reverted_stat_value bool
}

pub fn (o &CMsgClientStoreUserStatsResponse_Stats_Failed_Validation) pack() []byte {
	mut res := []byte{}
	if o.has_stat_id {
		res << vproto.pack_uint32_field(o.stat_id, 1)
	}
	if o.has_reverted_stat_value {
		res << vproto.pack_uint32_field(o.reverted_stat_value, 2)
	}
	return res
}

pub fn cmsgclientstoreuserstatsresponse_stats_failed_validation_unpack(buf []byte) ?CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
	mut res := CMsgClientStoreUserStatsResponse_Stats_Failed_Validation{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_stat_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.stat_id = v
				i = ii
			}
			2 {
				res.has_reverted_stat_value = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.reverted_stat_value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstatsresponse_stats_failed_validation() CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
	return CMsgClientStoreUserStatsResponse_Stats_Failed_Validation{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstatsresponse_stats_failed_validation(o CMsgClientStoreUserStatsResponse_Stats_Failed_Validation, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstatsresponse_stats_failed_validation(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStatsResponse_Stats_Failed_Validation) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientstoreuserstatsresponse_stats_failed_validation_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientStoreUserStatsResponse {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	game_id                 u64
	has_game_id             bool
	eresult                 int
	has_eresult             bool
	crc_stats               u32
	has_crc_stats           bool
	stats_failed_validation []CMsgClientStoreUserStatsResponse_Stats_Failed_Validation
	stats_out_of_date       bool
	has_stats_out_of_date   bool
}

pub fn (o &CMsgClientStoreUserStatsResponse) pack() []byte {
	mut res := []byte{}
	if o.has_game_id {
		res << vproto.pack_64bit_field(o.game_id, 1)
	}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 2)
	}
	if o.has_crc_stats {
		res << vproto.pack_uint32_field(o.crc_stats, 3)
	}
	// [packed=false]
	for _, x in o.stats_failed_validation {
		res <<
			zzz_vproto_internal_pack_cmsgclientstoreuserstatsresponse_stats_failed_validation(x, 4)
	}
	if o.has_stats_out_of_date {
		res << vproto.pack_bool_field(o.stats_out_of_date, 5)
	}
	return res
}

pub fn cmsgclientstoreuserstatsresponse_unpack(buf []byte) ?CMsgClientStoreUserStatsResponse {
	mut res := CMsgClientStoreUserStatsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_game_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.game_id = v
				i = ii
			}
			2 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			3 {
				res.has_crc_stats = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.crc_stats = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientstoreuserstatsresponse_stats_failed_validation(cur_buf,
					tag_wiretype.wire_type)?
				res.stats_failed_validation << v
				i = ii
			}
			5 {
				res.has_stats_out_of_date = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.stats_out_of_date = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstatsresponse() CMsgClientStoreUserStatsResponse {
	return CMsgClientStoreUserStatsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstatsresponse(o CMsgClientStoreUserStatsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstatsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStatsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientstoreuserstatsresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientStoreUserStats2_Stats {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stat_id        u32
	has_stat_id    bool
	stat_value     u32
	has_stat_value bool
}

pub fn (o &CMsgClientStoreUserStats2_Stats) pack() []byte {
	mut res := []byte{}
	if o.has_stat_id {
		res << vproto.pack_uint32_field(o.stat_id, 1)
	}
	if o.has_stat_value {
		res << vproto.pack_uint32_field(o.stat_value, 2)
	}
	return res
}

pub fn cmsgclientstoreuserstats2_stats_unpack(buf []byte) ?CMsgClientStoreUserStats2_Stats {
	mut res := CMsgClientStoreUserStats2_Stats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_stat_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.stat_id = v
				i = ii
			}
			2 {
				res.has_stat_value = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.stat_value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstats2_stats() CMsgClientStoreUserStats2_Stats {
	return CMsgClientStoreUserStats2_Stats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstats2_stats(o CMsgClientStoreUserStats2_Stats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstats2_stats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStats2_Stats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientstoreuserstats2_stats_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientStoreUserStats2 {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	game_id             u64
	has_game_id         bool
	settor_steam_id     u64
	has_settor_steam_id bool
	settee_steam_id     u64
	has_settee_steam_id bool
	crc_stats           u32
	has_crc_stats       bool
	explicit_reset      bool
	has_explicit_reset  bool
	stats               []CMsgClientStoreUserStats2_Stats
}

pub fn (o &CMsgClientStoreUserStats2) pack() []byte {
	mut res := []byte{}
	if o.has_game_id {
		res << vproto.pack_64bit_field(o.game_id, 1)
	}
	if o.has_settor_steam_id {
		res << vproto.pack_64bit_field(o.settor_steam_id, 2)
	}
	if o.has_settee_steam_id {
		res << vproto.pack_64bit_field(o.settee_steam_id, 3)
	}
	if o.has_crc_stats {
		res << vproto.pack_uint32_field(o.crc_stats, 4)
	}
	if o.has_explicit_reset {
		res << vproto.pack_bool_field(o.explicit_reset, 5)
	}
	// [packed=false]
	for _, x in o.stats {
		res << zzz_vproto_internal_pack_cmsgclientstoreuserstats2_stats(x, 6)
	}
	return res
}

pub fn cmsgclientstoreuserstats2_unpack(buf []byte) ?CMsgClientStoreUserStats2 {
	mut res := CMsgClientStoreUserStats2{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_game_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.game_id = v
				i = ii
			}
			2 {
				res.has_settor_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.settor_steam_id = v
				i = ii
			}
			3 {
				res.has_settee_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.settee_steam_id = v
				i = ii
			}
			4 {
				res.has_crc_stats = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.crc_stats = v
				i = ii
			}
			5 {
				res.has_explicit_reset = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.explicit_reset = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientstoreuserstats2_stats(cur_buf,
					tag_wiretype.wire_type)?
				res.stats << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstats2() CMsgClientStoreUserStats2 {
	return CMsgClientStoreUserStats2{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstats2(o CMsgClientStoreUserStats2, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstats2(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStats2) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientstoreuserstats2_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientStatsUpdated_Updated_Stats {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stat_id        u32
	has_stat_id    bool
	stat_value     u32
	has_stat_value bool
}

pub fn (o &CMsgClientStatsUpdated_Updated_Stats) pack() []byte {
	mut res := []byte{}
	if o.has_stat_id {
		res << vproto.pack_uint32_field(o.stat_id, 1)
	}
	if o.has_stat_value {
		res << vproto.pack_uint32_field(o.stat_value, 2)
	}
	return res
}

pub fn cmsgclientstatsupdated_updated_stats_unpack(buf []byte) ?CMsgClientStatsUpdated_Updated_Stats {
	mut res := CMsgClientStatsUpdated_Updated_Stats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_stat_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.stat_id = v
				i = ii
			}
			2 {
				res.has_stat_value = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.stat_value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstatsupdated_updated_stats() CMsgClientStatsUpdated_Updated_Stats {
	return CMsgClientStatsUpdated_Updated_Stats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstatsupdated_updated_stats(o CMsgClientStatsUpdated_Updated_Stats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstatsupdated_updated_stats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStatsUpdated_Updated_Stats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientstatsupdated_updated_stats_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientStatsUpdated {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	has_steam_id   bool
	game_id        u64
	has_game_id    bool
	crc_stats      u32
	has_crc_stats  bool
	updated_stats  []CMsgClientStatsUpdated_Updated_Stats
}

pub fn (o &CMsgClientStatsUpdated) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.has_game_id {
		res << vproto.pack_64bit_field(o.game_id, 2)
	}
	if o.has_crc_stats {
		res << vproto.pack_uint32_field(o.crc_stats, 3)
	}
	// [packed=false]
	for _, x in o.updated_stats {
		res << zzz_vproto_internal_pack_cmsgclientstatsupdated_updated_stats(x, 4)
	}
	return res
}

pub fn cmsgclientstatsupdated_unpack(buf []byte) ?CMsgClientStatsUpdated {
	mut res := CMsgClientStatsUpdated{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			2 {
				res.has_game_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.game_id = v
				i = ii
			}
			3 {
				res.has_crc_stats = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.crc_stats = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientstatsupdated_updated_stats(cur_buf,
					tag_wiretype.wire_type)?
				res.updated_stats << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstatsupdated() CMsgClientStatsUpdated {
	return CMsgClientStatsUpdated{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstatsupdated(o CMsgClientStatsUpdated, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstatsupdated(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStatsUpdated) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientstatsupdated_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientStoreUserStats_Stats_To_Store {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stat_id        u32
	has_stat_id    bool
	stat_value     u32
	has_stat_value bool
}

pub fn (o &CMsgClientStoreUserStats_Stats_To_Store) pack() []byte {
	mut res := []byte{}
	if o.has_stat_id {
		res << vproto.pack_uint32_field(o.stat_id, 1)
	}
	if o.has_stat_value {
		res << vproto.pack_uint32_field(o.stat_value, 2)
	}
	return res
}

pub fn cmsgclientstoreuserstats_stats_to_store_unpack(buf []byte) ?CMsgClientStoreUserStats_Stats_To_Store {
	mut res := CMsgClientStoreUserStats_Stats_To_Store{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_stat_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.stat_id = v
				i = ii
			}
			2 {
				res.has_stat_value = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.stat_value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstats_stats_to_store() CMsgClientStoreUserStats_Stats_To_Store {
	return CMsgClientStoreUserStats_Stats_To_Store{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstats_stats_to_store(o CMsgClientStoreUserStats_Stats_To_Store, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstats_stats_to_store(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStats_Stats_To_Store) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientstoreuserstats_stats_to_store_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientStoreUserStats {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	game_id            u64
	has_game_id        bool
	explicit_reset     bool
	has_explicit_reset bool
	stats_to_store     []CMsgClientStoreUserStats_Stats_To_Store
}

pub fn (o &CMsgClientStoreUserStats) pack() []byte {
	mut res := []byte{}
	if o.has_game_id {
		res << vproto.pack_64bit_field(o.game_id, 1)
	}
	if o.has_explicit_reset {
		res << vproto.pack_bool_field(o.explicit_reset, 2)
	}
	// [packed=false]
	for _, x in o.stats_to_store {
		res << zzz_vproto_internal_pack_cmsgclientstoreuserstats_stats_to_store(x, 3)
	}
	return res
}

pub fn cmsgclientstoreuserstats_unpack(buf []byte) ?CMsgClientStoreUserStats {
	mut res := CMsgClientStoreUserStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_game_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.game_id = v
				i = ii
			}
			2 {
				res.has_explicit_reset = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.explicit_reset = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientstoreuserstats_stats_to_store(cur_buf,
					tag_wiretype.wire_type)?
				res.stats_to_store << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientstoreuserstats() CMsgClientStoreUserStats {
	return CMsgClientStoreUserStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientstoreuserstats(o CMsgClientStoreUserStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientstoreuserstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientStoreUserStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientstoreuserstats_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetClientDetails {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientGetClientDetails) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientgetclientdetails_unpack(buf []byte) ?CMsgClientGetClientDetails {
	res := CMsgClientGetClientDetails{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientdetails() CMsgClientGetClientDetails {
	return CMsgClientGetClientDetails{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientdetails(o CMsgClientGetClientDetails, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientdetails(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientDetails) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetclientdetails_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientReportOverlayDetourFailure {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	failure_strings []string
}

pub fn (o &CMsgClientReportOverlayDetourFailure) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.failure_strings {
		res << vproto.pack_string_field(x, 1)
	}
	return res
}

pub fn cmsgclientreportoverlaydetourfailure_unpack(buf []byte) ?CMsgClientReportOverlayDetourFailure {
	mut res := CMsgClientReportOverlayDetourFailure{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.failure_strings << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientreportoverlaydetourfailure() CMsgClientReportOverlayDetourFailure {
	return CMsgClientReportOverlayDetourFailure{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientreportoverlaydetourfailure(o CMsgClientReportOverlayDetourFailure, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientreportoverlaydetourfailure(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientReportOverlayDetourFailure) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientreportoverlaydetourfailure_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetClientDetailsResponse_Game {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	appid                u32
	has_appid            bool
	extra_info           string
	has_extra_info       bool
	time_running_sec     u32
	has_time_running_sec bool
}

pub fn (o &CMsgClientGetClientDetailsResponse_Game) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_extra_info {
		res << vproto.pack_string_field(o.extra_info, 2)
	}
	if o.has_time_running_sec {
		res << vproto.pack_uint32_field(o.time_running_sec, 3)
	}
	return res
}

pub fn cmsgclientgetclientdetailsresponse_game_unpack(buf []byte) ?CMsgClientGetClientDetailsResponse_Game {
	mut res := CMsgClientGetClientDetailsResponse_Game{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_extra_info = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.extra_info = v
				i = ii
			}
			3 {
				res.has_time_running_sec = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_running_sec = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientdetailsresponse_game() CMsgClientGetClientDetailsResponse_Game {
	return CMsgClientGetClientDetailsResponse_Game{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientdetailsresponse_game(o CMsgClientGetClientDetailsResponse_Game, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientdetailsresponse_game(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientDetailsResponse_Game) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetclientdetailsresponse_game_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetClientDetailsResponse {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	package_version      u32
	has_package_version  bool
	protocol_version     u32
	has_protocol_version bool
	os                   string
	has_os               bool
	machine_name         string
	has_machine_name     bool
	ip_public            string
	has_ip_public        bool
	ip_private           string
	has_ip_private       bool
	bytes_available      u64
	has_bytes_available  bool
	games_running        []CMsgClientGetClientDetailsResponse_Game
}

pub fn (o &CMsgClientGetClientDetailsResponse) pack() []byte {
	mut res := []byte{}
	if o.has_package_version {
		res << vproto.pack_uint32_field(o.package_version, 1)
	}
	if o.has_protocol_version {
		res << vproto.pack_uint32_field(o.protocol_version, 8)
	}
	if o.has_os {
		res << vproto.pack_string_field(o.os, 2)
	}
	if o.has_machine_name {
		res << vproto.pack_string_field(o.machine_name, 3)
	}
	if o.has_ip_public {
		res << vproto.pack_string_field(o.ip_public, 4)
	}
	if o.has_ip_private {
		res << vproto.pack_string_field(o.ip_private, 5)
	}
	if o.has_bytes_available {
		res << vproto.pack_uint64_field(o.bytes_available, 7)
	}
	// [packed=false]
	for _, x in o.games_running {
		res << zzz_vproto_internal_pack_cmsgclientgetclientdetailsresponse_game(x, 6)
	}
	return res
}

pub fn cmsgclientgetclientdetailsresponse_unpack(buf []byte) ?CMsgClientGetClientDetailsResponse {
	mut res := CMsgClientGetClientDetailsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_package_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.package_version = v
				i = ii
			}
			8 {
				res.has_protocol_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.protocol_version = v
				i = ii
			}
			2 {
				res.has_os = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.os = v
				i = ii
			}
			3 {
				res.has_machine_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.machine_name = v
				i = ii
			}
			4 {
				res.has_ip_public = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.ip_public = v
				i = ii
			}
			5 {
				res.has_ip_private = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.ip_private = v
				i = ii
			}
			7 {
				res.has_bytes_available = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_available = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientgetclientdetailsresponse_game(cur_buf,
					tag_wiretype.wire_type)?
				res.games_running << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientdetailsresponse() CMsgClientGetClientDetailsResponse {
	return CMsgClientGetClientDetailsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientdetailsresponse(o CMsgClientGetClientDetailsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientdetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientDetailsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetclientdetailsresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetClientAppList {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	media              bool
	has_media          bool
	tools              bool
	has_tools          bool
	games              bool
	has_games          bool
	only_installed     bool
	has_only_installed bool
	only_changing      bool
	has_only_changing  bool
	comics             bool
	has_comics         bool
}

pub fn (o &CMsgClientGetClientAppList) pack() []byte {
	mut res := []byte{}
	if o.has_media {
		res << vproto.pack_bool_field(o.media, 1)
	}
	if o.has_tools {
		res << vproto.pack_bool_field(o.tools, 2)
	}
	if o.has_games {
		res << vproto.pack_bool_field(o.games, 3)
	}
	if o.has_only_installed {
		res << vproto.pack_bool_field(o.only_installed, 4)
	}
	if o.has_only_changing {
		res << vproto.pack_bool_field(o.only_changing, 5)
	}
	if o.has_comics {
		res << vproto.pack_bool_field(o.comics, 6)
	}
	return res
}

pub fn cmsgclientgetclientapplist_unpack(buf []byte) ?CMsgClientGetClientAppList {
	mut res := CMsgClientGetClientAppList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_media = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.media = v
				i = ii
			}
			2 {
				res.has_tools = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.tools = v
				i = ii
			}
			3 {
				res.has_games = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.games = v
				i = ii
			}
			4 {
				res.has_only_installed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.only_installed = v
				i = ii
			}
			5 {
				res.has_only_changing = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.only_changing = v
				i = ii
			}
			6 {
				res.has_comics = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.comics = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientapplist() CMsgClientGetClientAppList {
	return CMsgClientGetClientAppList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientapplist(o CMsgClientGetClientAppList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientapplist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientAppList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetclientapplist_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetClientAppListResponseApp_DLC {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	installed      bool
	has_installed  bool
}

pub fn (o &CMsgClientGetClientAppListResponseApp_DLC) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_installed {
		res << vproto.pack_bool_field(o.installed, 2)
	}
	return res
}

pub fn cmsgclientgetclientapplistresponseapp_dlc_unpack(buf []byte) ?CMsgClientGetClientAppListResponseApp_DLC {
	mut res := CMsgClientGetClientAppListResponseApp_DLC{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_installed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.installed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientapplistresponseapp_dlc() CMsgClientGetClientAppListResponseApp_DLC {
	return CMsgClientGetClientAppListResponseApp_DLC{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientapplistresponseapp_dlc(o CMsgClientGetClientAppListResponseApp_DLC, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponseapp_dlc(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientAppListResponseApp_DLC) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetclientapplistresponseapp_dlc_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetClientAppListResponse_App {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	appid                     u32
	has_appid                 bool
	category                  string
	has_category              bool
	app_type                  string
	has_app_type              bool
	favorite                  bool
	has_favorite              bool
	installed                 bool
	has_installed             bool
	auto_update               bool
	has_auto_update           bool
	bytes_downloaded          u64
	has_bytes_downloaded      bool
	bytes_needed              u64
	has_bytes_needed          bool
	bytes_download_rate       u32
	has_bytes_download_rate   bool
	download_paused           bool
	has_download_paused       bool
	num_downloading           u32
	has_num_downloading       bool
	num_paused                u32
	has_num_paused            bool
	changing                  bool
	has_changing              bool
	available_on_platform     bool
	has_available_on_platform bool
	dlcs                      []CMsgClientGetClientAppListResponseApp_DLC
}

pub fn (o &CMsgClientGetClientAppListResponse_App) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_category {
		res << vproto.pack_string_field(o.category, 2)
	}
	if o.has_app_type {
		res << vproto.pack_string_field(o.app_type, 10)
	}
	if o.has_favorite {
		res << vproto.pack_bool_field(o.favorite, 3)
	}
	if o.has_installed {
		res << vproto.pack_bool_field(o.installed, 4)
	}
	if o.has_auto_update {
		res << vproto.pack_bool_field(o.auto_update, 5)
	}
	if o.has_bytes_downloaded {
		res << vproto.pack_uint64_field(o.bytes_downloaded, 6)
	}
	if o.has_bytes_needed {
		res << vproto.pack_uint64_field(o.bytes_needed, 7)
	}
	if o.has_bytes_download_rate {
		res << vproto.pack_uint32_field(o.bytes_download_rate, 8)
	}
	if o.has_download_paused {
		res << vproto.pack_bool_field(o.download_paused, 11)
	}
	if o.has_num_downloading {
		res << vproto.pack_uint32_field(o.num_downloading, 12)
	}
	if o.has_num_paused {
		res << vproto.pack_uint32_field(o.num_paused, 13)
	}
	if o.has_changing {
		res << vproto.pack_bool_field(o.changing, 14)
	}
	if o.has_available_on_platform {
		res << vproto.pack_bool_field(o.available_on_platform, 15)
	}
	// [packed=false]
	for _, x in o.dlcs {
		res << zzz_vproto_internal_pack_cmsgclientgetclientapplistresponseapp_dlc(x, 9)
	}
	return res
}

pub fn cmsgclientgetclientapplistresponse_app_unpack(buf []byte) ?CMsgClientGetClientAppListResponse_App {
	mut res := CMsgClientGetClientAppListResponse_App{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_category = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.category = v
				i = ii
			}
			10 {
				res.has_app_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.app_type = v
				i = ii
			}
			3 {
				res.has_favorite = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.favorite = v
				i = ii
			}
			4 {
				res.has_installed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.installed = v
				i = ii
			}
			5 {
				res.has_auto_update = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.auto_update = v
				i = ii
			}
			6 {
				res.has_bytes_downloaded = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_downloaded = v
				i = ii
			}
			7 {
				res.has_bytes_needed = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_needed = v
				i = ii
			}
			8 {
				res.has_bytes_download_rate = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_download_rate = v
				i = ii
			}
			11 {
				res.has_download_paused = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.download_paused = v
				i = ii
			}
			12 {
				res.has_num_downloading = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_downloading = v
				i = ii
			}
			13 {
				res.has_num_paused = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_paused = v
				i = ii
			}
			14 {
				res.has_changing = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.changing = v
				i = ii
			}
			15 {
				res.has_available_on_platform = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.available_on_platform = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponseapp_dlc(cur_buf,
					tag_wiretype.wire_type)?
				res.dlcs << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientapplistresponse_app() CMsgClientGetClientAppListResponse_App {
	return CMsgClientGetClientAppListResponse_App{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientapplistresponse_app(o CMsgClientGetClientAppListResponse_App, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponse_app(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientAppListResponse_App) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetclientapplistresponse_app_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetClientAppListResponse {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	apps                []CMsgClientGetClientAppListResponse_App
	bytes_available     u64
	has_bytes_available bool
}

pub fn (o &CMsgClientGetClientAppListResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_cmsgclientgetclientapplistresponse_app(x, 1)
	}
	if o.has_bytes_available {
		res << vproto.pack_uint64_field(o.bytes_available, 2)
	}
	return res
}

pub fn cmsgclientgetclientapplistresponse_unpack(buf []byte) ?CMsgClientGetClientAppListResponse {
	mut res := CMsgClientGetClientAppListResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponse_app(cur_buf,
					tag_wiretype.wire_type)?
				res.apps << v
				i = ii
			}
			2 {
				res.has_bytes_available = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_available = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclientapplistresponse() CMsgClientGetClientAppListResponse {
	return CMsgClientGetClientAppListResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclientapplistresponse(o CMsgClientGetClientAppListResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclientapplistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClientAppListResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetclientapplistresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientInstallClientApp {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
}

pub fn (o &CMsgClientInstallClientApp) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cmsgclientinstallclientapp_unpack(buf []byte) ?CMsgClientInstallClientApp {
	mut res := CMsgClientInstallClientApp{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientinstallclientapp() CMsgClientInstallClientApp {
	return CMsgClientInstallClientApp{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientinstallclientapp(o CMsgClientInstallClientApp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientinstallclientapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientInstallClientApp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientinstallclientapp_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientInstallClientAppResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         u32
	has_result     bool
}

pub fn (o &CMsgClientInstallClientAppResponse) pack() []byte {
	mut res := []byte{}
	if o.has_result {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	return res
}

pub fn cmsgclientinstallclientappresponse_unpack(buf []byte) ?CMsgClientInstallClientAppResponse {
	mut res := CMsgClientInstallClientAppResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientinstallclientappresponse() CMsgClientInstallClientAppResponse {
	return CMsgClientInstallClientAppResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientinstallclientappresponse(o CMsgClientInstallClientAppResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientinstallclientappresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientInstallClientAppResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientinstallclientappresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUninstallClientApp {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
}

pub fn (o &CMsgClientUninstallClientApp) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cmsgclientuninstallclientapp_unpack(buf []byte) ?CMsgClientUninstallClientApp {
	mut res := CMsgClientUninstallClientApp{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientuninstallclientapp() CMsgClientUninstallClientApp {
	return CMsgClientUninstallClientApp{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientuninstallclientapp(o CMsgClientUninstallClientApp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientuninstallclientapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUninstallClientApp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientuninstallclientapp_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUninstallClientAppResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         u32
	has_result     bool
}

pub fn (o &CMsgClientUninstallClientAppResponse) pack() []byte {
	mut res := []byte{}
	if o.has_result {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	return res
}

pub fn cmsgclientuninstallclientappresponse_unpack(buf []byte) ?CMsgClientUninstallClientAppResponse {
	mut res := CMsgClientUninstallClientAppResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientuninstallclientappresponse() CMsgClientUninstallClientAppResponse {
	return CMsgClientUninstallClientAppResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientuninstallclientappresponse(o CMsgClientUninstallClientAppResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientuninstallclientappresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUninstallClientAppResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientuninstallclientappresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientSetClientAppUpdateState {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	update         bool
	has_update     bool
}

pub fn (o &CMsgClientSetClientAppUpdateState) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_update {
		res << vproto.pack_bool_field(o.update, 2)
	}
	return res
}

pub fn cmsgclientsetclientappupdatestate_unpack(buf []byte) ?CMsgClientSetClientAppUpdateState {
	mut res := CMsgClientSetClientAppUpdateState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_update = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.update = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsetclientappupdatestate() CMsgClientSetClientAppUpdateState {
	return CMsgClientSetClientAppUpdateState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsetclientappupdatestate(o CMsgClientSetClientAppUpdateState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsetclientappupdatestate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSetClientAppUpdateState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientsetclientappupdatestate_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientSetClientAppUpdateStateResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         u32
	has_result     bool
}

pub fn (o &CMsgClientSetClientAppUpdateStateResponse) pack() []byte {
	mut res := []byte{}
	if o.has_result {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	return res
}

pub fn cmsgclientsetclientappupdatestateresponse_unpack(buf []byte) ?CMsgClientSetClientAppUpdateStateResponse {
	mut res := CMsgClientSetClientAppUpdateStateResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsetclientappupdatestateresponse() CMsgClientSetClientAppUpdateStateResponse {
	return CMsgClientSetClientAppUpdateStateResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsetclientappupdatestateresponse(o CMsgClientSetClientAppUpdateStateResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsetclientappupdatestateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSetClientAppUpdateStateResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientsetclientappupdatestateresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSUploadFileRequest {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	app_id                           u32
	has_app_id                       bool
	file_size                        u32
	has_file_size                    bool
	raw_file_size                    u32
	has_raw_file_size                bool
	sha_file                         []byte
	has_sha_file                     bool
	time_stamp                       u64
	has_time_stamp                   bool
	file_name                        string
	has_file_name                    bool
	platforms_to_sync_deprecated     u32
	has_platforms_to_sync_deprecated bool
	platforms_to_sync                u32
	has_platforms_to_sync            bool
	cell_id                          u32
	has_cell_id                      bool
	can_encrypt                      bool
	has_can_encrypt                  bool
}

pub fn (o &CMsgClientUFSUploadFileRequest) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 2)
	}
	if o.has_raw_file_size {
		res << vproto.pack_uint32_field(o.raw_file_size, 3)
	}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 4)
	}
	if o.has_time_stamp {
		res << vproto.pack_uint64_field(o.time_stamp, 5)
	}
	if o.has_file_name {
		res << vproto.pack_string_field(o.file_name, 6)
	}
	if o.has_platforms_to_sync_deprecated {
		res << vproto.pack_uint32_field(o.platforms_to_sync_deprecated, 7)
	}
	if o.has_platforms_to_sync {
		res << vproto.pack_uint32_field(o.platforms_to_sync, 8)
	}
	if o.has_cell_id {
		res << vproto.pack_uint32_field(o.cell_id, 9)
	}
	if o.has_can_encrypt {
		res << vproto.pack_bool_field(o.can_encrypt, 10)
	}
	return res
}

pub fn cmsgclientufsuploadfilerequest_unpack(buf []byte) ?CMsgClientUFSUploadFileRequest {
	mut res := CMsgClientUFSUploadFileRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			3 {
				res.has_raw_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.raw_file_size = v
				i = ii
			}
			4 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			5 {
				res.has_time_stamp = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.time_stamp = v
				i = ii
			}
			6 {
				res.has_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_name = v
				i = ii
			}
			7 {
				res.has_platforms_to_sync_deprecated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.platforms_to_sync_deprecated = v
				i = ii
			}
			8 {
				res.has_platforms_to_sync = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.platforms_to_sync = v
				i = ii
			}
			9 {
				res.has_cell_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			10 {
				res.has_can_encrypt = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_encrypt = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadfilerequest() CMsgClientUFSUploadFileRequest {
	return CMsgClientUFSUploadFileRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadfilerequest(o CMsgClientUFSUploadFileRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadfilerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadFileRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsuploadfilerequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSUploadFileResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	eresult          int
	has_eresult      bool
	sha_file         []byte
	has_sha_file     bool
	use_http         bool
	has_use_http     bool
	http_host        string
	has_http_host    bool
	http_url         string
	has_http_url     bool
	kv_headers       []byte
	has_kv_headers   bool
	use_https        bool
	has_use_https    bool
	encrypt_file     bool
	has_encrypt_file bool
}

pub fn (o &CMsgClientUFSUploadFileResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 2)
	}
	if o.has_use_http {
		res << vproto.pack_bool_field(o.use_http, 3)
	}
	if o.has_http_host {
		res << vproto.pack_string_field(o.http_host, 4)
	}
	if o.has_http_url {
		res << vproto.pack_string_field(o.http_url, 5)
	}
	if o.has_kv_headers {
		res << vproto.pack_bytes_field(o.kv_headers, 6)
	}
	if o.has_use_https {
		res << vproto.pack_bool_field(o.use_https, 7)
	}
	if o.has_encrypt_file {
		res << vproto.pack_bool_field(o.encrypt_file, 8)
	}
	return res
}

pub fn cmsgclientufsuploadfileresponse_unpack(buf []byte) ?CMsgClientUFSUploadFileResponse {
	mut res := CMsgClientUFSUploadFileResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			3 {
				res.has_use_http = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_http = v
				i = ii
			}
			4 {
				res.has_http_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.http_host = v
				i = ii
			}
			5 {
				res.has_http_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.http_url = v
				i = ii
			}
			6 {
				res.has_kv_headers = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.kv_headers = v
				i = ii
			}
			7 {
				res.has_use_https = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_https = v
				i = ii
			}
			8 {
				res.has_encrypt_file = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.encrypt_file = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadfileresponse() CMsgClientUFSUploadFileResponse {
	return CMsgClientUFSUploadFileResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadfileresponse(o CMsgClientUFSUploadFileResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadfileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadFileResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsuploadfileresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSUploadCommit_File {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
	app_id         u32
	has_app_id     bool
	sha_file       []byte
	has_sha_file   bool
	cub_file       u32
	has_cub_file   bool
	file_name      string
	has_file_name  bool
}

pub fn (o &CMsgClientUFSUploadCommit_File) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 3)
	}
	if o.has_cub_file {
		res << vproto.pack_uint32_field(o.cub_file, 4)
	}
	if o.has_file_name {
		res << vproto.pack_string_field(o.file_name, 5)
	}
	return res
}

pub fn cmsgclientufsuploadcommit_file_unpack(buf []byte) ?CMsgClientUFSUploadCommit_File {
	mut res := CMsgClientUFSUploadCommit_File{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			3 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			4 {
				res.has_cub_file = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cub_file = v
				i = ii
			}
			5 {
				res.has_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadcommit_file() CMsgClientUFSUploadCommit_File {
	return CMsgClientUFSUploadCommit_File{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadcommit_file(o CMsgClientUFSUploadCommit_File, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadcommit_file(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadCommit_File) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsuploadcommit_file_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSUploadCommit {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	files          []CMsgClientUFSUploadCommit_File
}

pub fn (o &CMsgClientUFSUploadCommit) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.files {
		res << zzz_vproto_internal_pack_cmsgclientufsuploadcommit_file(x, 1)
	}
	return res
}

pub fn cmsgclientufsuploadcommit_unpack(buf []byte) ?CMsgClientUFSUploadCommit {
	mut res := CMsgClientUFSUploadCommit{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientufsuploadcommit_file(cur_buf,
					tag_wiretype.wire_type)?
				res.files << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadcommit() CMsgClientUFSUploadCommit {
	return CMsgClientUFSUploadCommit{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadcommit(o CMsgClientUFSUploadCommit, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadcommit(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadCommit) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsuploadcommit_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSUploadCommitResponse_File {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
	app_id         u32
	has_app_id     bool
	sha_file       []byte
	has_sha_file   bool
}

pub fn (o &CMsgClientUFSUploadCommitResponse_File) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 3)
	}
	return res
}

pub fn cmsgclientufsuploadcommitresponse_file_unpack(buf []byte) ?CMsgClientUFSUploadCommitResponse_File {
	mut res := CMsgClientUFSUploadCommitResponse_File{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			3 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadcommitresponse_file() CMsgClientUFSUploadCommitResponse_File {
	return CMsgClientUFSUploadCommitResponse_File{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadcommitresponse_file(o CMsgClientUFSUploadCommitResponse_File, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadcommitresponse_file(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadCommitResponse_File) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsuploadcommitresponse_file_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSUploadCommitResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	files          []CMsgClientUFSUploadCommitResponse_File
}

pub fn (o &CMsgClientUFSUploadCommitResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.files {
		res << zzz_vproto_internal_pack_cmsgclientufsuploadcommitresponse_file(x, 1)
	}
	return res
}

pub fn cmsgclientufsuploadcommitresponse_unpack(buf []byte) ?CMsgClientUFSUploadCommitResponse {
	mut res := CMsgClientUFSUploadCommitResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientufsuploadcommitresponse_file(cur_buf,
					tag_wiretype.wire_type)?
				res.files << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadcommitresponse() CMsgClientUFSUploadCommitResponse {
	return CMsgClientUFSUploadCommitResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadcommitresponse(o CMsgClientUFSUploadCommitResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadcommitresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadCommitResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsuploadcommitresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSFileChunk {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sha_file       []byte
	has_sha_file   bool
	file_start     u32
	has_file_start bool
	data           []byte
	has_data       bool
}

pub fn (o &CMsgClientUFSFileChunk) pack() []byte {
	mut res := []byte{}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 1)
	}
	if o.has_file_start {
		res << vproto.pack_uint32_field(o.file_start, 2)
	}
	if o.has_data {
		res << vproto.pack_bytes_field(o.data, 3)
	}
	return res
}

pub fn cmsgclientufsfilechunk_unpack(buf []byte) ?CMsgClientUFSFileChunk {
	mut res := CMsgClientUFSFileChunk{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			2 {
				res.has_file_start = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_start = v
				i = ii
			}
			3 {
				res.has_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsfilechunk() CMsgClientUFSFileChunk {
	return CMsgClientUFSFileChunk{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsfilechunk(o CMsgClientUFSFileChunk, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsfilechunk(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSFileChunk) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsfilechunk_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSTransferHeartbeat {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientUFSTransferHeartbeat) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientufstransferheartbeat_unpack(buf []byte) ?CMsgClientUFSTransferHeartbeat {
	res := CMsgClientUFSTransferHeartbeat{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufstransferheartbeat() CMsgClientUFSTransferHeartbeat {
	return CMsgClientUFSTransferHeartbeat{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufstransferheartbeat(o CMsgClientUFSTransferHeartbeat, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufstransferheartbeat(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSTransferHeartbeat) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufstransferheartbeat_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSUploadFileFinished {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
	sha_file       []byte
	has_sha_file   bool
}

pub fn (o &CMsgClientUFSUploadFileFinished) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 2)
	}
	return res
}

pub fn cmsgclientufsuploadfilefinished_unpack(buf []byte) ?CMsgClientUFSUploadFileFinished {
	mut res := CMsgClientUFSUploadFileFinished{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsuploadfilefinished() CMsgClientUFSUploadFileFinished {
	return CMsgClientUFSUploadFileFinished{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsuploadfilefinished(o CMsgClientUFSUploadFileFinished, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsuploadfilefinished(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSUploadFileFinished) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsuploadfilefinished_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSDeleteFileRequest {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	app_id                 u32
	has_app_id             bool
	file_name              string
	has_file_name          bool
	is_explicit_delete     bool
	has_is_explicit_delete bool
}

pub fn (o &CMsgClientUFSDeleteFileRequest) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_file_name {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	if o.has_is_explicit_delete {
		res << vproto.pack_bool_field(o.is_explicit_delete, 3)
	}
	return res
}

pub fn cmsgclientufsdeletefilerequest_unpack(buf []byte) ?CMsgClientUFSDeleteFileRequest {
	mut res := CMsgClientUFSDeleteFileRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_name = v
				i = ii
			}
			3 {
				res.has_is_explicit_delete = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_explicit_delete = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsdeletefilerequest() CMsgClientUFSDeleteFileRequest {
	return CMsgClientUFSDeleteFileRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsdeletefilerequest(o CMsgClientUFSDeleteFileRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsdeletefilerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSDeleteFileRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsdeletefilerequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSDeleteFileResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
	file_name      string
	has_file_name  bool
}

pub fn (o &CMsgClientUFSDeleteFileResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_file_name {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	return res
}

pub fn cmsgclientufsdeletefileresponse_unpack(buf []byte) ?CMsgClientUFSDeleteFileResponse {
	mut res := CMsgClientUFSDeleteFileResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsdeletefileresponse() CMsgClientUFSDeleteFileResponse {
	return CMsgClientUFSDeleteFileResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsdeletefileresponse(o CMsgClientUFSDeleteFileResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsdeletefileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSDeleteFileResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsdeletefileresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSGetFileListForApp {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	apps_to_query          []u32
	send_path_prefixes     bool
	has_send_path_prefixes bool
}

pub fn (o &CMsgClientUFSGetFileListForApp) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.apps_to_query {
		res << vproto.pack_uint32_field(x, 1)
	}
	if o.has_send_path_prefixes {
		res << vproto.pack_bool_field(o.send_path_prefixes, 2)
	}
	return res
}

pub fn cmsgclientufsgetfilelistforapp_unpack(buf []byte) ?CMsgClientUFSGetFileListForApp {
	mut res := CMsgClientUFSGetFileListForApp{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.apps_to_query << v
				i = ii
			}
			2 {
				res.has_send_path_prefixes = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.send_path_prefixes = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetfilelistforapp() CMsgClientUFSGetFileListForApp {
	return CMsgClientUFSGetFileListForApp{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetfilelistforapp(o CMsgClientUFSGetFileListForApp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetfilelistforapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetFileListForApp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsgetfilelistforapp_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSGetFileListForAppResponse_File {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	app_id                 u32
	has_app_id             bool
	file_name              string
	has_file_name          bool
	sha_file               []byte
	has_sha_file           bool
	time_stamp             u64
	has_time_stamp         bool
	raw_file_size          u32
	has_raw_file_size      bool
	is_explicit_delete     bool
	has_is_explicit_delete bool
	platforms_to_sync      u32
	has_platforms_to_sync  bool
	path_prefix_index      u32
	has_path_prefix_index  bool
}

pub fn (o &CMsgClientUFSGetFileListForAppResponse_File) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_file_name {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 3)
	}
	if o.has_time_stamp {
		res << vproto.pack_uint64_field(o.time_stamp, 4)
	}
	if o.has_raw_file_size {
		res << vproto.pack_uint32_field(o.raw_file_size, 5)
	}
	if o.has_is_explicit_delete {
		res << vproto.pack_bool_field(o.is_explicit_delete, 6)
	}
	if o.has_platforms_to_sync {
		res << vproto.pack_uint32_field(o.platforms_to_sync, 7)
	}
	if o.has_path_prefix_index {
		res << vproto.pack_uint32_field(o.path_prefix_index, 8)
	}
	return res
}

pub fn cmsgclientufsgetfilelistforappresponse_file_unpack(buf []byte) ?CMsgClientUFSGetFileListForAppResponse_File {
	mut res := CMsgClientUFSGetFileListForAppResponse_File{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_name = v
				i = ii
			}
			3 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			4 {
				res.has_time_stamp = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.time_stamp = v
				i = ii
			}
			5 {
				res.has_raw_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.raw_file_size = v
				i = ii
			}
			6 {
				res.has_is_explicit_delete = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_explicit_delete = v
				i = ii
			}
			7 {
				res.has_platforms_to_sync = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.platforms_to_sync = v
				i = ii
			}
			8 {
				res.has_path_prefix_index = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.path_prefix_index = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetfilelistforappresponse_file() CMsgClientUFSGetFileListForAppResponse_File {
	return CMsgClientUFSGetFileListForAppResponse_File{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetfilelistforappresponse_file(o CMsgClientUFSGetFileListForAppResponse_File, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetfilelistforappresponse_file(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetFileListForAppResponse_File) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsgetfilelistforappresponse_file_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSGetFileListForAppResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	files          []CMsgClientUFSGetFileListForAppResponse_File
	path_prefixes  []string
}

pub fn (o &CMsgClientUFSGetFileListForAppResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.files {
		res << zzz_vproto_internal_pack_cmsgclientufsgetfilelistforappresponse_file(x, 1)
	}
	// [packed=false]
	for _, x in o.path_prefixes {
		res << vproto.pack_string_field(x, 2)
	}
	return res
}

pub fn cmsgclientufsgetfilelistforappresponse_unpack(buf []byte) ?CMsgClientUFSGetFileListForAppResponse {
	mut res := CMsgClientUFSGetFileListForAppResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientufsgetfilelistforappresponse_file(cur_buf,
					tag_wiretype.wire_type)?
				res.files << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.path_prefixes << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetfilelistforappresponse() CMsgClientUFSGetFileListForAppResponse {
	return CMsgClientUFSGetFileListForAppResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetfilelistforappresponse(o CMsgClientUFSGetFileListForAppResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetfilelistforappresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetFileListForAppResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsgetfilelistforappresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSDownloadRequest {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	app_id              u32
	has_app_id          bool
	file_name           string
	has_file_name       bool
	can_handle_http     bool
	has_can_handle_http bool
}

pub fn (o &CMsgClientUFSDownloadRequest) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_file_name {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	if o.has_can_handle_http {
		res << vproto.pack_bool_field(o.can_handle_http, 3)
	}
	return res
}

pub fn cmsgclientufsdownloadrequest_unpack(buf []byte) ?CMsgClientUFSDownloadRequest {
	mut res := CMsgClientUFSDownloadRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_name = v
				i = ii
			}
			3 {
				res.has_can_handle_http = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_handle_http = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsdownloadrequest() CMsgClientUFSDownloadRequest {
	return CMsgClientUFSDownloadRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsdownloadrequest(o CMsgClientUFSDownloadRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsdownloadrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSDownloadRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsdownloadrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSDownloadResponse {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	eresult                int
	has_eresult            bool
	app_id                 u32
	has_app_id             bool
	file_size              u32
	has_file_size          bool
	raw_file_size          u32
	has_raw_file_size      bool
	sha_file               []byte
	has_sha_file           bool
	time_stamp             u64
	has_time_stamp         bool
	is_explicit_delete     bool
	has_is_explicit_delete bool
	use_http               bool
	has_use_http           bool
	http_host              string
	has_http_host          bool
	http_url               string
	has_http_url           bool
	kv_headers             []byte
	has_kv_headers         bool
	use_https              bool
	has_use_https          bool
	encrypted              bool
	has_encrypted          bool
}

pub fn (o &CMsgClientUFSDownloadResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 3)
	}
	if o.has_raw_file_size {
		res << vproto.pack_uint32_field(o.raw_file_size, 4)
	}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 5)
	}
	if o.has_time_stamp {
		res << vproto.pack_uint64_field(o.time_stamp, 6)
	}
	if o.has_is_explicit_delete {
		res << vproto.pack_bool_field(o.is_explicit_delete, 7)
	}
	if o.has_use_http {
		res << vproto.pack_bool_field(o.use_http, 8)
	}
	if o.has_http_host {
		res << vproto.pack_string_field(o.http_host, 9)
	}
	if o.has_http_url {
		res << vproto.pack_string_field(o.http_url, 10)
	}
	if o.has_kv_headers {
		res << vproto.pack_bytes_field(o.kv_headers, 11)
	}
	if o.has_use_https {
		res << vproto.pack_bool_field(o.use_https, 12)
	}
	if o.has_encrypted {
		res << vproto.pack_bool_field(o.encrypted, 13)
	}
	return res
}

pub fn cmsgclientufsdownloadresponse_unpack(buf []byte) ?CMsgClientUFSDownloadResponse {
	mut res := CMsgClientUFSDownloadResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			3 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			4 {
				res.has_raw_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.raw_file_size = v
				i = ii
			}
			5 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			6 {
				res.has_time_stamp = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.time_stamp = v
				i = ii
			}
			7 {
				res.has_is_explicit_delete = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_explicit_delete = v
				i = ii
			}
			8 {
				res.has_use_http = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_http = v
				i = ii
			}
			9 {
				res.has_http_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.http_host = v
				i = ii
			}
			10 {
				res.has_http_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.http_url = v
				i = ii
			}
			11 {
				res.has_kv_headers = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.kv_headers = v
				i = ii
			}
			12 {
				res.has_use_https = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_https = v
				i = ii
			}
			13 {
				res.has_encrypted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.encrypted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsdownloadresponse() CMsgClientUFSDownloadResponse {
	return CMsgClientUFSDownloadResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsdownloadresponse(o CMsgClientUFSDownloadResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsdownloadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSDownloadResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsdownloadresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSLoginRequest {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	protocol_version     u32
	has_protocol_version bool
	am_session_token     u64
	has_am_session_token bool
	apps                 []u32
}

pub fn (o &CMsgClientUFSLoginRequest) pack() []byte {
	mut res := []byte{}
	if o.has_protocol_version {
		res << vproto.pack_uint32_field(o.protocol_version, 1)
	}
	if o.has_am_session_token {
		res << vproto.pack_uint64_field(o.am_session_token, 2)
	}
	// [packed=false]
	for _, x in o.apps {
		res << vproto.pack_uint32_field(x, 3)
	}
	return res
}

pub fn cmsgclientufsloginrequest_unpack(buf []byte) ?CMsgClientUFSLoginRequest {
	mut res := CMsgClientUFSLoginRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_protocol_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.protocol_version = v
				i = ii
			}
			2 {
				res.has_am_session_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.am_session_token = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.apps << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsloginrequest() CMsgClientUFSLoginRequest {
	return CMsgClientUFSLoginRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsloginrequest(o CMsgClientUFSLoginRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsloginrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSLoginRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsloginrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSLoginResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
}

pub fn (o &CMsgClientUFSLoginResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientufsloginresponse_unpack(buf []byte) ?CMsgClientUFSLoginResponse {
	mut res := CMsgClientUFSLoginResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsloginresponse() CMsgClientUFSLoginResponse {
	return CMsgClientUFSLoginResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsloginresponse(o CMsgClientUFSLoginResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsloginresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSLoginResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsloginresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestEncryptedAppTicket {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	has_app_id     bool
	userdata       []byte
	has_userdata   bool
}

pub fn (o &CMsgClientRequestEncryptedAppTicket) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_userdata {
		res << vproto.pack_bytes_field(o.userdata, 2)
	}
	return res
}

pub fn cmsgclientrequestencryptedappticket_unpack(buf []byte) ?CMsgClientRequestEncryptedAppTicket {
	mut res := CMsgClientRequestEncryptedAppTicket{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_userdata = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.userdata = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestencryptedappticket() CMsgClientRequestEncryptedAppTicket {
	return CMsgClientRequestEncryptedAppTicket{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestencryptedappticket(o CMsgClientRequestEncryptedAppTicket, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestencryptedappticket(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestEncryptedAppTicket) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestencryptedappticket_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestEncryptedAppTicketResponse {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	app_id                   u32
	has_app_id               bool
	eresult                  int
	has_eresult              bool
	encrypted_app_ticket     EncryptedAppTicket
	has_encrypted_app_ticket bool
}

pub fn (o &CMsgClientRequestEncryptedAppTicketResponse) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 2)
	}
	if o.has_encrypted_app_ticket {
		res << zzz_vproto_internal_pack_encryptedappticket(o.encrypted_app_ticket, 3)
	}
	return res
}

pub fn cmsgclientrequestencryptedappticketresponse_unpack(buf []byte) ?CMsgClientRequestEncryptedAppTicketResponse {
	mut res := CMsgClientRequestEncryptedAppTicketResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			3 {
				res.has_encrypted_app_ticket = true
				ii, v := zzz_vproto_internal_unpack_encryptedappticket(cur_buf, tag_wiretype.wire_type)?
				res.encrypted_app_ticket = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestencryptedappticketresponse() CMsgClientRequestEncryptedAppTicketResponse {
	return CMsgClientRequestEncryptedAppTicketResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestencryptedappticketresponse(o CMsgClientRequestEncryptedAppTicketResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestencryptedappticketresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestEncryptedAppTicketResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestencryptedappticketresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientWalletInfoUpdate {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	has_wallet            bool
	has_has_wallet        bool
	balance               int
	has_balance           bool
	currency              int
	has_currency          bool
	balance_delayed       int
	has_balance_delayed   bool
	balance64             i64
	has_balance64         bool
	balance64_delayed     i64
	has_balance64_delayed bool
}

pub fn (o &CMsgClientWalletInfoUpdate) pack() []byte {
	mut res := []byte{}
	if o.has_has_wallet {
		res << vproto.pack_bool_field(o.has_wallet, 1)
	}
	if o.has_balance {
		res << vproto.pack_int32_field(o.balance, 2)
	}
	if o.has_currency {
		res << vproto.pack_int32_field(o.currency, 3)
	}
	if o.has_balance_delayed {
		res << vproto.pack_int32_field(o.balance_delayed, 4)
	}
	if o.has_balance64 {
		res << vproto.pack_int64_field(o.balance64, 5)
	}
	if o.has_balance64_delayed {
		res << vproto.pack_int64_field(o.balance64_delayed, 6)
	}
	return res
}

pub fn cmsgclientwalletinfoupdate_unpack(buf []byte) ?CMsgClientWalletInfoUpdate {
	mut res := CMsgClientWalletInfoUpdate{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_has_wallet = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.has_wallet = v
				i = ii
			}
			2 {
				res.has_balance = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.balance = v
				i = ii
			}
			3 {
				res.has_currency = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.currency = v
				i = ii
			}
			4 {
				res.has_balance_delayed = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.balance_delayed = v
				i = ii
			}
			5 {
				res.has_balance64 = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
				res.balance64 = v
				i = ii
			}
			6 {
				res.has_balance64_delayed = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
				res.balance64_delayed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientwalletinfoupdate() CMsgClientWalletInfoUpdate {
	return CMsgClientWalletInfoUpdate{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientwalletinfoupdate(o CMsgClientWalletInfoUpdate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientwalletinfoupdate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWalletInfoUpdate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientwalletinfoupdate_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAppInfoUpdate {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	last_changenumber     u32
	has_last_changenumber bool
	send_changelist       bool
	has_send_changelist   bool
}

pub fn (o &CMsgClientAppInfoUpdate) pack() []byte {
	mut res := []byte{}
	if o.has_last_changenumber {
		res << vproto.pack_uint32_field(o.last_changenumber, 1)
	}
	if o.has_send_changelist {
		res << vproto.pack_bool_field(o.send_changelist, 2)
	}
	return res
}

pub fn cmsgclientappinfoupdate_unpack(buf []byte) ?CMsgClientAppInfoUpdate {
	mut res := CMsgClientAppInfoUpdate{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_last_changenumber = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_changenumber = v
				i = ii
			}
			2 {
				res.has_send_changelist = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.send_changelist = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinfoupdate() CMsgClientAppInfoUpdate {
	return CMsgClientAppInfoUpdate{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinfoupdate(o CMsgClientAppInfoUpdate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinfoupdate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoUpdate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientappinfoupdate_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAppInfoChanges {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	current_change_number     u32
	has_current_change_number bool
	force_full_update         bool
	has_force_full_update     bool
	appids                    []u32
}

pub fn (o &CMsgClientAppInfoChanges) pack() []byte {
	mut res := []byte{}
	if o.has_current_change_number {
		res << vproto.pack_uint32_field(o.current_change_number, 1)
	}
	if o.has_force_full_update {
		res << vproto.pack_bool_field(o.force_full_update, 2)
	}
	// [packed=false]
	for _, x in o.appids {
		res << vproto.pack_uint32_field(x, 3)
	}
	return res
}

pub fn cmsgclientappinfochanges_unpack(buf []byte) ?CMsgClientAppInfoChanges {
	mut res := CMsgClientAppInfoChanges{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_current_change_number = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.current_change_number = v
				i = ii
			}
			2 {
				res.has_force_full_update = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.force_full_update = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinfochanges() CMsgClientAppInfoChanges {
	return CMsgClientAppInfoChanges{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinfochanges(o CMsgClientAppInfoChanges, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinfochanges(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoChanges) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientappinfochanges_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAppInfoRequest_App {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	app_id            u32
	has_app_id        bool
	section_flags     u32
	has_section_flags bool
	section_crc       []u32
}

pub fn (o &CMsgClientAppInfoRequest_App) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_section_flags {
		res << vproto.pack_uint32_field(o.section_flags, 2)
	}
	// [packed=false]
	for _, x in o.section_crc {
		res << vproto.pack_uint32_field(x, 3)
	}
	return res
}

pub fn cmsgclientappinforequest_app_unpack(buf []byte) ?CMsgClientAppInfoRequest_App {
	mut res := CMsgClientAppInfoRequest_App{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_section_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.section_flags = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.section_crc << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinforequest_app() CMsgClientAppInfoRequest_App {
	return CMsgClientAppInfoRequest_App{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinforequest_app(o CMsgClientAppInfoRequest_App, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinforequest_app(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoRequest_App) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientappinforequest_app_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAppInfoRequest {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	apps                 []CMsgClientAppInfoRequest_App
	supports_batches     bool
	has_supports_batches bool
}

pub fn (o &CMsgClientAppInfoRequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_cmsgclientappinforequest_app(x, 1)
	}
	if o.has_supports_batches {
		res << vproto.pack_bool_field(o.supports_batches, 2)
	}
	return res
}

pub fn cmsgclientappinforequest_unpack(buf []byte) ?CMsgClientAppInfoRequest {
	mut res := CMsgClientAppInfoRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientappinforequest_app(cur_buf,
					tag_wiretype.wire_type)?
				res.apps << v
				i = ii
			}
			2 {
				res.has_supports_batches = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.supports_batches = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinforequest() CMsgClientAppInfoRequest {
	return CMsgClientAppInfoRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinforequest(o CMsgClientAppInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientappinforequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAppInfoResponseApp_Section {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	section_id     u32
	has_section_id bool
	section_kv     []byte
	has_section_kv bool
}

pub fn (o &CMsgClientAppInfoResponseApp_Section) pack() []byte {
	mut res := []byte{}
	if o.has_section_id {
		res << vproto.pack_uint32_field(o.section_id, 1)
	}
	if o.has_section_kv {
		res << vproto.pack_bytes_field(o.section_kv, 2)
	}
	return res
}

pub fn cmsgclientappinforesponseapp_section_unpack(buf []byte) ?CMsgClientAppInfoResponseApp_Section {
	mut res := CMsgClientAppInfoResponseApp_Section{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_section_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.section_id = v
				i = ii
			}
			2 {
				res.has_section_kv = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.section_kv = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinforesponseapp_section() CMsgClientAppInfoResponseApp_Section {
	return CMsgClientAppInfoResponseApp_Section{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinforesponseapp_section(o CMsgClientAppInfoResponseApp_Section, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinforesponseapp_section(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoResponseApp_Section) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientappinforesponseapp_section_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAppInfoResponse_App {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	app_id            u32
	has_app_id        bool
	change_number     u32
	has_change_number bool
	sections          []CMsgClientAppInfoResponseApp_Section
}

pub fn (o &CMsgClientAppInfoResponse_App) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_change_number {
		res << vproto.pack_uint32_field(o.change_number, 2)
	}
	// [packed=false]
	for _, x in o.sections {
		res << zzz_vproto_internal_pack_cmsgclientappinforesponseapp_section(x, 3)
	}
	return res
}

pub fn cmsgclientappinforesponse_app_unpack(buf []byte) ?CMsgClientAppInfoResponse_App {
	mut res := CMsgClientAppInfoResponse_App{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_change_number = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.change_number = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientappinforesponseapp_section(cur_buf,
					tag_wiretype.wire_type)?
				res.sections << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinforesponse_app() CMsgClientAppInfoResponse_App {
	return CMsgClientAppInfoResponse_App{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinforesponse_app(o CMsgClientAppInfoResponse_App, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinforesponse_app(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoResponse_App) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientappinforesponse_app_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAppInfoResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	apps             []CMsgClientAppInfoResponse_App
	apps_unknown     []u32
	apps_pending     u32
	has_apps_pending bool
}

pub fn (o &CMsgClientAppInfoResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_cmsgclientappinforesponse_app(x, 1)
	}
	// [packed=false]
	for _, x in o.apps_unknown {
		res << vproto.pack_uint32_field(x, 2)
	}
	if o.has_apps_pending {
		res << vproto.pack_uint32_field(o.apps_pending, 3)
	}
	return res
}

pub fn cmsgclientappinforesponse_unpack(buf []byte) ?CMsgClientAppInfoResponse {
	mut res := CMsgClientAppInfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientappinforesponse_app(cur_buf,
					tag_wiretype.wire_type)?
				res.apps << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.apps_unknown << v
				i = ii
			}
			3 {
				res.has_apps_pending = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.apps_pending = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientappinforesponse() CMsgClientAppInfoResponse {
	return CMsgClientAppInfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientappinforesponse(o CMsgClientAppInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientappinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAppInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientappinforesponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPackageInfoRequest {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	package_ids        []u32
	meta_data_only     bool
	has_meta_data_only bool
}

pub fn (o &CMsgClientPackageInfoRequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.package_ids {
		res << vproto.pack_uint32_field(x, 1)
	}
	if o.has_meta_data_only {
		res << vproto.pack_bool_field(o.meta_data_only, 2)
	}
	return res
}

pub fn cmsgclientpackageinforequest_unpack(buf []byte) ?CMsgClientPackageInfoRequest {
	mut res := CMsgClientPackageInfoRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.package_ids << v
				i = ii
			}
			2 {
				res.has_meta_data_only = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.meta_data_only = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpackageinforequest() CMsgClientPackageInfoRequest {
	return CMsgClientPackageInfoRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpackageinforequest(o CMsgClientPackageInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpackageinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPackageInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpackageinforequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPackageInfoResponse_Package {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	package_id        u32
	has_package_id    bool
	change_number     u32
	has_change_number bool
	sha               []byte
	has_sha           bool
	buffer            []byte
	has_buffer        bool
}

pub fn (o &CMsgClientPackageInfoResponse_Package) pack() []byte {
	mut res := []byte{}
	if o.has_package_id {
		res << vproto.pack_uint32_field(o.package_id, 1)
	}
	if o.has_change_number {
		res << vproto.pack_uint32_field(o.change_number, 2)
	}
	if o.has_sha {
		res << vproto.pack_bytes_field(o.sha, 3)
	}
	if o.has_buffer {
		res << vproto.pack_bytes_field(o.buffer, 4)
	}
	return res
}

pub fn cmsgclientpackageinforesponse_package_unpack(buf []byte) ?CMsgClientPackageInfoResponse_Package {
	mut res := CMsgClientPackageInfoResponse_Package{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_package_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.package_id = v
				i = ii
			}
			2 {
				res.has_change_number = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.change_number = v
				i = ii
			}
			3 {
				res.has_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha = v
				i = ii
			}
			4 {
				res.has_buffer = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.buffer = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpackageinforesponse_package() CMsgClientPackageInfoResponse_Package {
	return CMsgClientPackageInfoResponse_Package{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpackageinforesponse_package(o CMsgClientPackageInfoResponse_Package, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpackageinforesponse_package(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPackageInfoResponse_Package) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpackageinforesponse_package_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPackageInfoResponse {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	packages             []CMsgClientPackageInfoResponse_Package
	packages_unknown     []u32
	packages_pending     u32
	has_packages_pending bool
}

pub fn (o &CMsgClientPackageInfoResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.packages {
		res << zzz_vproto_internal_pack_cmsgclientpackageinforesponse_package(x, 1)
	}
	// [packed=false]
	for _, x in o.packages_unknown {
		res << vproto.pack_uint32_field(x, 2)
	}
	if o.has_packages_pending {
		res << vproto.pack_uint32_field(o.packages_pending, 3)
	}
	return res
}

pub fn cmsgclientpackageinforesponse_unpack(buf []byte) ?CMsgClientPackageInfoResponse {
	mut res := CMsgClientPackageInfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpackageinforesponse_package(cur_buf,
					tag_wiretype.wire_type)?
				res.packages << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.packages_unknown << v
				i = ii
			}
			3 {
				res.has_packages_pending = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.packages_pending = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpackageinforesponse() CMsgClientPackageInfoResponse {
	return CMsgClientPackageInfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpackageinforesponse(o CMsgClientPackageInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpackageinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPackageInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpackageinforesponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSChangesSinceRequest {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	since_change_number           u32
	has_since_change_number       bool
	send_app_info_changes         bool
	has_send_app_info_changes     bool
	send_package_info_changes     bool
	has_send_package_info_changes bool
	num_app_info_cached           u32
	has_num_app_info_cached       bool
	num_package_info_cached       u32
	has_num_package_info_cached   bool
}

pub fn (o &CMsgClientPICSChangesSinceRequest) pack() []byte {
	mut res := []byte{}
	if o.has_since_change_number {
		res << vproto.pack_uint32_field(o.since_change_number, 1)
	}
	if o.has_send_app_info_changes {
		res << vproto.pack_bool_field(o.send_app_info_changes, 2)
	}
	if o.has_send_package_info_changes {
		res << vproto.pack_bool_field(o.send_package_info_changes, 3)
	}
	if o.has_num_app_info_cached {
		res << vproto.pack_uint32_field(o.num_app_info_cached, 4)
	}
	if o.has_num_package_info_cached {
		res << vproto.pack_uint32_field(o.num_package_info_cached, 5)
	}
	return res
}

pub fn cmsgclientpicschangessincerequest_unpack(buf []byte) ?CMsgClientPICSChangesSinceRequest {
	mut res := CMsgClientPICSChangesSinceRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_since_change_number = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.since_change_number = v
				i = ii
			}
			2 {
				res.has_send_app_info_changes = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.send_app_info_changes = v
				i = ii
			}
			3 {
				res.has_send_package_info_changes = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.send_package_info_changes = v
				i = ii
			}
			4 {
				res.has_num_app_info_cached = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_app_info_cached = v
				i = ii
			}
			5 {
				res.has_num_package_info_cached = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_package_info_cached = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicschangessincerequest() CMsgClientPICSChangesSinceRequest {
	return CMsgClientPICSChangesSinceRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicschangessincerequest(o CMsgClientPICSChangesSinceRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicschangessincerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSChangesSinceRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicschangessincerequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSChangesSinceResponse_PackageChange {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	packageid         u32
	has_packageid     bool
	change_number     u32
	has_change_number bool
	needs_token       bool
	has_needs_token   bool
}

pub fn (o &CMsgClientPICSChangesSinceResponse_PackageChange) pack() []byte {
	mut res := []byte{}
	if o.has_packageid {
		res << vproto.pack_uint32_field(o.packageid, 1)
	}
	if o.has_change_number {
		res << vproto.pack_uint32_field(o.change_number, 2)
	}
	if o.has_needs_token {
		res << vproto.pack_bool_field(o.needs_token, 3)
	}
	return res
}

pub fn cmsgclientpicschangessinceresponse_packagechange_unpack(buf []byte) ?CMsgClientPICSChangesSinceResponse_PackageChange {
	mut res := CMsgClientPICSChangesSinceResponse_PackageChange{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_packageid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.packageid = v
				i = ii
			}
			2 {
				res.has_change_number = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.change_number = v
				i = ii
			}
			3 {
				res.has_needs_token = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.needs_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicschangessinceresponse_packagechange() CMsgClientPICSChangesSinceResponse_PackageChange {
	return CMsgClientPICSChangesSinceResponse_PackageChange{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicschangessinceresponse_packagechange(o CMsgClientPICSChangesSinceResponse_PackageChange, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponse_packagechange(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSChangesSinceResponse_PackageChange) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicschangessinceresponse_packagechange_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSChangesSinceResponse_AppChange {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	appid             u32
	has_appid         bool
	change_number     u32
	has_change_number bool
	needs_token       bool
	has_needs_token   bool
}

pub fn (o &CMsgClientPICSChangesSinceResponse_AppChange) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_change_number {
		res << vproto.pack_uint32_field(o.change_number, 2)
	}
	if o.has_needs_token {
		res << vproto.pack_bool_field(o.needs_token, 3)
	}
	return res
}

pub fn cmsgclientpicschangessinceresponse_appchange_unpack(buf []byte) ?CMsgClientPICSChangesSinceResponse_AppChange {
	mut res := CMsgClientPICSChangesSinceResponse_AppChange{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_change_number = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.change_number = v
				i = ii
			}
			3 {
				res.has_needs_token = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.needs_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicschangessinceresponse_appchange() CMsgClientPICSChangesSinceResponse_AppChange {
	return CMsgClientPICSChangesSinceResponse_AppChange{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicschangessinceresponse_appchange(o CMsgClientPICSChangesSinceResponse_AppChange, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponse_appchange(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSChangesSinceResponse_AppChange) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicschangessinceresponse_appchange_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSChangesSinceResponse {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	current_change_number         u32
	has_current_change_number     bool
	since_change_number           u32
	has_since_change_number       bool
	force_full_update             bool
	has_force_full_update         bool
	package_changes               []CMsgClientPICSChangesSinceResponse_PackageChange
	app_changes                   []CMsgClientPICSChangesSinceResponse_AppChange
	force_full_app_update         bool
	has_force_full_app_update     bool
	force_full_package_update     bool
	has_force_full_package_update bool
}

pub fn (o &CMsgClientPICSChangesSinceResponse) pack() []byte {
	mut res := []byte{}
	if o.has_current_change_number {
		res << vproto.pack_uint32_field(o.current_change_number, 1)
	}
	if o.has_since_change_number {
		res << vproto.pack_uint32_field(o.since_change_number, 2)
	}
	if o.has_force_full_update {
		res << vproto.pack_bool_field(o.force_full_update, 3)
	}
	// [packed=false]
	for _, x in o.package_changes {
		res << zzz_vproto_internal_pack_cmsgclientpicschangessinceresponse_packagechange(x, 4)
	}
	// [packed=false]
	for _, x in o.app_changes {
		res << zzz_vproto_internal_pack_cmsgclientpicschangessinceresponse_appchange(x, 5)
	}
	if o.has_force_full_app_update {
		res << vproto.pack_bool_field(o.force_full_app_update, 6)
	}
	if o.has_force_full_package_update {
		res << vproto.pack_bool_field(o.force_full_package_update, 7)
	}
	return res
}

pub fn cmsgclientpicschangessinceresponse_unpack(buf []byte) ?CMsgClientPICSChangesSinceResponse {
	mut res := CMsgClientPICSChangesSinceResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_current_change_number = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.current_change_number = v
				i = ii
			}
			2 {
				res.has_since_change_number = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.since_change_number = v
				i = ii
			}
			3 {
				res.has_force_full_update = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.force_full_update = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponse_packagechange(cur_buf,
					tag_wiretype.wire_type)?
				res.package_changes << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponse_appchange(cur_buf,
					tag_wiretype.wire_type)?
				res.app_changes << v
				i = ii
			}
			6 {
				res.has_force_full_app_update = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.force_full_app_update = v
				i = ii
			}
			7 {
				res.has_force_full_package_update = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.force_full_package_update = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicschangessinceresponse() CMsgClientPICSChangesSinceResponse {
	return CMsgClientPICSChangesSinceResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicschangessinceresponse(o CMsgClientPICSChangesSinceResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicschangessinceresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSChangesSinceResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicschangessinceresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSProductInfoRequest_AppInfo {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	has_appid        bool
	access_token     u64
	has_access_token bool
	only_public      bool
	has_only_public  bool
}

pub fn (o &CMsgClientPICSProductInfoRequest_AppInfo) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_access_token {
		res << vproto.pack_uint64_field(o.access_token, 2)
	}
	if o.has_only_public {
		res << vproto.pack_bool_field(o.only_public, 3)
	}
	return res
}

pub fn cmsgclientpicsproductinforequest_appinfo_unpack(buf []byte) ?CMsgClientPICSProductInfoRequest_AppInfo {
	mut res := CMsgClientPICSProductInfoRequest_AppInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_access_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.access_token = v
				i = ii
			}
			3 {
				res.has_only_public = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.only_public = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforequest_appinfo() CMsgClientPICSProductInfoRequest_AppInfo {
	return CMsgClientPICSProductInfoRequest_AppInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforequest_appinfo(o CMsgClientPICSProductInfoRequest_AppInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforequest_appinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSProductInfoRequest_AppInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicsproductinforequest_appinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSProductInfoRequest_PackageInfo {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	packageid        u32
	has_packageid    bool
	access_token     u64
	has_access_token bool
}

pub fn (o &CMsgClientPICSProductInfoRequest_PackageInfo) pack() []byte {
	mut res := []byte{}
	if o.has_packageid {
		res << vproto.pack_uint32_field(o.packageid, 1)
	}
	if o.has_access_token {
		res << vproto.pack_uint64_field(o.access_token, 2)
	}
	return res
}

pub fn cmsgclientpicsproductinforequest_packageinfo_unpack(buf []byte) ?CMsgClientPICSProductInfoRequest_PackageInfo {
	mut res := CMsgClientPICSProductInfoRequest_PackageInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_packageid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.packageid = v
				i = ii
			}
			2 {
				res.has_access_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.access_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforequest_packageinfo() CMsgClientPICSProductInfoRequest_PackageInfo {
	return CMsgClientPICSProductInfoRequest_PackageInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforequest_packageinfo(o CMsgClientPICSProductInfoRequest_PackageInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforequest_packageinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSProductInfoRequest_PackageInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicsproductinforequest_packageinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSProductInfoRequest {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	packages                    []CMsgClientPICSProductInfoRequest_PackageInfo
	apps                        []CMsgClientPICSProductInfoRequest_AppInfo
	meta_data_only              bool
	has_meta_data_only          bool
	num_prev_failed             u32
	has_num_prev_failed         bool
	supports_package_tokens     u32
	has_supports_package_tokens bool
}

pub fn (o &CMsgClientPICSProductInfoRequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.packages {
		res << zzz_vproto_internal_pack_cmsgclientpicsproductinforequest_packageinfo(x, 1)
	}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_cmsgclientpicsproductinforequest_appinfo(x, 2)
	}
	if o.has_meta_data_only {
		res << vproto.pack_bool_field(o.meta_data_only, 3)
	}
	if o.has_num_prev_failed {
		res << vproto.pack_uint32_field(o.num_prev_failed, 4)
	}
	if o.has_supports_package_tokens {
		res << vproto.pack_uint32_field(o.supports_package_tokens, 5)
	}
	return res
}

pub fn cmsgclientpicsproductinforequest_unpack(buf []byte) ?CMsgClientPICSProductInfoRequest {
	mut res := CMsgClientPICSProductInfoRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicsproductinforequest_packageinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.packages << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicsproductinforequest_appinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.apps << v
				i = ii
			}
			3 {
				res.has_meta_data_only = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.meta_data_only = v
				i = ii
			}
			4 {
				res.has_num_prev_failed = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_prev_failed = v
				i = ii
			}
			5 {
				res.has_supports_package_tokens = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.supports_package_tokens = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforequest() CMsgClientPICSProductInfoRequest {
	return CMsgClientPICSProductInfoRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforequest(o CMsgClientPICSProductInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSProductInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicsproductinforequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSProductInfoResponse_AppInfo {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	appid             u32
	has_appid         bool
	change_number     u32
	has_change_number bool
	missing_token     bool
	has_missing_token bool
	sha               []byte
	has_sha           bool
	buffer            []byte
	has_buffer        bool
	only_public       bool
	has_only_public   bool
	size              u32
	has_size          bool
}

pub fn (o &CMsgClientPICSProductInfoResponse_AppInfo) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_change_number {
		res << vproto.pack_uint32_field(o.change_number, 2)
	}
	if o.has_missing_token {
		res << vproto.pack_bool_field(o.missing_token, 3)
	}
	if o.has_sha {
		res << vproto.pack_bytes_field(o.sha, 4)
	}
	if o.has_buffer {
		res << vproto.pack_bytes_field(o.buffer, 5)
	}
	if o.has_only_public {
		res << vproto.pack_bool_field(o.only_public, 6)
	}
	if o.has_size {
		res << vproto.pack_uint32_field(o.size, 7)
	}
	return res
}

pub fn cmsgclientpicsproductinforesponse_appinfo_unpack(buf []byte) ?CMsgClientPICSProductInfoResponse_AppInfo {
	mut res := CMsgClientPICSProductInfoResponse_AppInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_change_number = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.change_number = v
				i = ii
			}
			3 {
				res.has_missing_token = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.missing_token = v
				i = ii
			}
			4 {
				res.has_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha = v
				i = ii
			}
			5 {
				res.has_buffer = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.buffer = v
				i = ii
			}
			6 {
				res.has_only_public = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.only_public = v
				i = ii
			}
			7 {
				res.has_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.size = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforesponse_appinfo() CMsgClientPICSProductInfoResponse_AppInfo {
	return CMsgClientPICSProductInfoResponse_AppInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforesponse_appinfo(o CMsgClientPICSProductInfoResponse_AppInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponse_appinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSProductInfoResponse_AppInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicsproductinforesponse_appinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSProductInfoResponse_PackageInfo {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	packageid         u32
	has_packageid     bool
	change_number     u32
	has_change_number bool
	missing_token     bool
	has_missing_token bool
	sha               []byte
	has_sha           bool
	buffer            []byte
	has_buffer        bool
	size              u32
	has_size          bool
}

pub fn (o &CMsgClientPICSProductInfoResponse_PackageInfo) pack() []byte {
	mut res := []byte{}
	if o.has_packageid {
		res << vproto.pack_uint32_field(o.packageid, 1)
	}
	if o.has_change_number {
		res << vproto.pack_uint32_field(o.change_number, 2)
	}
	if o.has_missing_token {
		res << vproto.pack_bool_field(o.missing_token, 3)
	}
	if o.has_sha {
		res << vproto.pack_bytes_field(o.sha, 4)
	}
	if o.has_buffer {
		res << vproto.pack_bytes_field(o.buffer, 5)
	}
	if o.has_size {
		res << vproto.pack_uint32_field(o.size, 6)
	}
	return res
}

pub fn cmsgclientpicsproductinforesponse_packageinfo_unpack(buf []byte) ?CMsgClientPICSProductInfoResponse_PackageInfo {
	mut res := CMsgClientPICSProductInfoResponse_PackageInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_packageid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.packageid = v
				i = ii
			}
			2 {
				res.has_change_number = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.change_number = v
				i = ii
			}
			3 {
				res.has_missing_token = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.missing_token = v
				i = ii
			}
			4 {
				res.has_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha = v
				i = ii
			}
			5 {
				res.has_buffer = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.buffer = v
				i = ii
			}
			6 {
				res.has_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.size = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforesponse_packageinfo() CMsgClientPICSProductInfoResponse_PackageInfo {
	return CMsgClientPICSProductInfoResponse_PackageInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforesponse_packageinfo(o CMsgClientPICSProductInfoResponse_PackageInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponse_packageinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSProductInfoResponse_PackageInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicsproductinforesponse_packageinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSProductInfoResponse {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	apps                 []CMsgClientPICSProductInfoResponse_AppInfo
	unknown_appids       []u32
	packages             []CMsgClientPICSProductInfoResponse_PackageInfo
	unknown_packageids   []u32
	meta_data_only       bool
	has_meta_data_only   bool
	response_pending     bool
	has_response_pending bool
	http_min_size        u32
	has_http_min_size    bool
	http_host            string
	has_http_host        bool
}

pub fn (o &CMsgClientPICSProductInfoResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_cmsgclientpicsproductinforesponse_appinfo(x, 1)
	}
	// [packed=false]
	for _, x in o.unknown_appids {
		res << vproto.pack_uint32_field(x, 2)
	}
	// [packed=false]
	for _, x in o.packages {
		res << zzz_vproto_internal_pack_cmsgclientpicsproductinforesponse_packageinfo(x, 3)
	}
	// [packed=false]
	for _, x in o.unknown_packageids {
		res << vproto.pack_uint32_field(x, 4)
	}
	if o.has_meta_data_only {
		res << vproto.pack_bool_field(o.meta_data_only, 5)
	}
	if o.has_response_pending {
		res << vproto.pack_bool_field(o.response_pending, 6)
	}
	if o.has_http_min_size {
		res << vproto.pack_uint32_field(o.http_min_size, 7)
	}
	if o.has_http_host {
		res << vproto.pack_string_field(o.http_host, 8)
	}
	return res
}

pub fn cmsgclientpicsproductinforesponse_unpack(buf []byte) ?CMsgClientPICSProductInfoResponse {
	mut res := CMsgClientPICSProductInfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponse_appinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.apps << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.unknown_appids << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponse_packageinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.packages << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.unknown_packageids << v
				i = ii
			}
			5 {
				res.has_meta_data_only = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.meta_data_only = v
				i = ii
			}
			6 {
				res.has_response_pending = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.response_pending = v
				i = ii
			}
			7 {
				res.has_http_min_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.http_min_size = v
				i = ii
			}
			8 {
				res.has_http_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.http_host = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsproductinforesponse() CMsgClientPICSProductInfoResponse {
	return CMsgClientPICSProductInfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsproductinforesponse(o CMsgClientPICSProductInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsproductinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSProductInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicsproductinforesponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSAccessTokenRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	packageids     []u32
	appids         []u32
}

pub fn (o &CMsgClientPICSAccessTokenRequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.packageids {
		res << vproto.pack_uint32_field(x, 1)
	}
	// [packed=false]
	for _, x in o.appids {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cmsgclientpicsaccesstokenrequest_unpack(buf []byte) ?CMsgClientPICSAccessTokenRequest {
	mut res := CMsgClientPICSAccessTokenRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.packageids << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsaccesstokenrequest() CMsgClientPICSAccessTokenRequest {
	return CMsgClientPICSAccessTokenRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsaccesstokenrequest(o CMsgClientPICSAccessTokenRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSAccessTokenRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicsaccesstokenrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSAccessTokenResponse_PackageToken {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	packageid        u32
	has_packageid    bool
	access_token     u64
	has_access_token bool
}

pub fn (o &CMsgClientPICSAccessTokenResponse_PackageToken) pack() []byte {
	mut res := []byte{}
	if o.has_packageid {
		res << vproto.pack_uint32_field(o.packageid, 1)
	}
	if o.has_access_token {
		res << vproto.pack_uint64_field(o.access_token, 2)
	}
	return res
}

pub fn cmsgclientpicsaccesstokenresponse_packagetoken_unpack(buf []byte) ?CMsgClientPICSAccessTokenResponse_PackageToken {
	mut res := CMsgClientPICSAccessTokenResponse_PackageToken{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_packageid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.packageid = v
				i = ii
			}
			2 {
				res.has_access_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.access_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsaccesstokenresponse_packagetoken() CMsgClientPICSAccessTokenResponse_PackageToken {
	return CMsgClientPICSAccessTokenResponse_PackageToken{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponse_packagetoken(o CMsgClientPICSAccessTokenResponse_PackageToken, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponse_packagetoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSAccessTokenResponse_PackageToken) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicsaccesstokenresponse_packagetoken_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSAccessTokenResponse_AppToken {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	has_appid        bool
	access_token     u64
	has_access_token bool
}

pub fn (o &CMsgClientPICSAccessTokenResponse_AppToken) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_access_token {
		res << vproto.pack_uint64_field(o.access_token, 2)
	}
	return res
}

pub fn cmsgclientpicsaccesstokenresponse_apptoken_unpack(buf []byte) ?CMsgClientPICSAccessTokenResponse_AppToken {
	mut res := CMsgClientPICSAccessTokenResponse_AppToken{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_access_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.access_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsaccesstokenresponse_apptoken() CMsgClientPICSAccessTokenResponse_AppToken {
	return CMsgClientPICSAccessTokenResponse_AppToken{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponse_apptoken(o CMsgClientPICSAccessTokenResponse_AppToken, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponse_apptoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSAccessTokenResponse_AppToken) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicsaccesstokenresponse_apptoken_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPICSAccessTokenResponse {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	package_access_tokens []CMsgClientPICSAccessTokenResponse_PackageToken
	package_denied_tokens []u32
	app_access_tokens     []CMsgClientPICSAccessTokenResponse_AppToken
	app_denied_tokens     []u32
}

pub fn (o &CMsgClientPICSAccessTokenResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.package_access_tokens {
		res << zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponse_packagetoken(x, 1)
	}
	// [packed=false]
	for _, x in o.package_denied_tokens {
		res << vproto.pack_uint32_field(x, 2)
	}
	// [packed=false]
	for _, x in o.app_access_tokens {
		res << zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponse_apptoken(x, 3)
	}
	// [packed=false]
	for _, x in o.app_denied_tokens {
		res << vproto.pack_uint32_field(x, 4)
	}
	return res
}

pub fn cmsgclientpicsaccesstokenresponse_unpack(buf []byte) ?CMsgClientPICSAccessTokenResponse {
	mut res := CMsgClientPICSAccessTokenResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponse_packagetoken(cur_buf,
					tag_wiretype.wire_type)?
				res.package_access_tokens << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.package_denied_tokens << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponse_apptoken(cur_buf,
					tag_wiretype.wire_type)?
				res.app_access_tokens << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_denied_tokens << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpicsaccesstokenresponse() CMsgClientPICSAccessTokenResponse {
	return CMsgClientPICSAccessTokenResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpicsaccesstokenresponse(o CMsgClientPICSAccessTokenResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpicsaccesstokenresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPICSAccessTokenResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpicsaccesstokenresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSGetUGCDetails {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	hcontent       u64
	has_hcontent   bool
}

pub fn (o &CMsgClientUFSGetUGCDetails) pack() []byte {
	mut res := []byte{}
	if o.has_hcontent {
		res << vproto.pack_64bit_field(o.hcontent, 1)
	}
	return res
}

pub fn cmsgclientufsgetugcdetails_unpack(buf []byte) ?CMsgClientUFSGetUGCDetails {
	mut res := CMsgClientUFSGetUGCDetails{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_hcontent = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.hcontent = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetugcdetails() CMsgClientUFSGetUGCDetails {
	return CMsgClientUFSGetUGCDetails{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetugcdetails(o CMsgClientUFSGetUGCDetails, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetugcdetails(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetUGCDetails) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsgetugcdetails_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSGetUGCDetailsResponse {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	eresult                  int
	has_eresult              bool
	url                      string
	has_url                  bool
	app_id                   u32
	has_app_id               bool
	filename                 string
	has_filename             bool
	steamid_creator          u64
	has_steamid_creator      bool
	file_size                u32
	has_file_size            bool
	compressed_file_size     u32
	has_compressed_file_size bool
	rangecheck_host          string
	has_rangecheck_host      bool
	file_encoded_sha1        string
	has_file_encoded_sha1    bool
}

pub fn (o &CMsgClientUFSGetUGCDetailsResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 3)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 4)
	}
	if o.has_steamid_creator {
		res << vproto.pack_64bit_field(o.steamid_creator, 5)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 6)
	}
	if o.has_compressed_file_size {
		res << vproto.pack_uint32_field(o.compressed_file_size, 7)
	}
	if o.has_rangecheck_host {
		res << vproto.pack_string_field(o.rangecheck_host, 8)
	}
	if o.has_file_encoded_sha1 {
		res << vproto.pack_string_field(o.file_encoded_sha1, 9)
	}
	return res
}

pub fn cmsgclientufsgetugcdetailsresponse_unpack(buf []byte) ?CMsgClientUFSGetUGCDetailsResponse {
	mut res := CMsgClientUFSGetUGCDetailsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			4 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			5 {
				res.has_steamid_creator = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_creator = v
				i = ii
			}
			6 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			7 {
				res.has_compressed_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.compressed_file_size = v
				i = ii
			}
			8 {
				res.has_rangecheck_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.rangecheck_host = v
				i = ii
			}
			9 {
				res.has_file_encoded_sha1 = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_encoded_sha1 = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetugcdetailsresponse() CMsgClientUFSGetUGCDetailsResponse {
	return CMsgClientUFSGetUGCDetailsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetugcdetailsresponse(o CMsgClientUFSGetUGCDetailsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetugcdetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetUGCDetailsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsgetugcdetailsresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSGetSingleFileInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	has_app_id     bool
	file_name      string
	has_file_name  bool
}

pub fn (o &CMsgClientUFSGetSingleFileInfo) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_file_name {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	return res
}

pub fn cmsgclientufsgetsinglefileinfo_unpack(buf []byte) ?CMsgClientUFSGetSingleFileInfo {
	mut res := CMsgClientUFSGetSingleFileInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetsinglefileinfo() CMsgClientUFSGetSingleFileInfo {
	return CMsgClientUFSGetSingleFileInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetsinglefileinfo(o CMsgClientUFSGetSingleFileInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetsinglefileinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetSingleFileInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsgetsinglefileinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSGetSingleFileInfoResponse {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	eresult                int
	has_eresult            bool
	app_id                 u32
	has_app_id             bool
	file_name              string
	has_file_name          bool
	sha_file               []byte
	has_sha_file           bool
	time_stamp             u64
	has_time_stamp         bool
	raw_file_size          u32
	has_raw_file_size      bool
	is_explicit_delete     bool
	has_is_explicit_delete bool
}

pub fn (o &CMsgClientUFSGetSingleFileInfoResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.has_file_name {
		res << vproto.pack_string_field(o.file_name, 3)
	}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 4)
	}
	if o.has_time_stamp {
		res << vproto.pack_uint64_field(o.time_stamp, 5)
	}
	if o.has_raw_file_size {
		res << vproto.pack_uint32_field(o.raw_file_size, 6)
	}
	if o.has_is_explicit_delete {
		res << vproto.pack_bool_field(o.is_explicit_delete, 7)
	}
	return res
}

pub fn cmsgclientufsgetsinglefileinforesponse_unpack(buf []byte) ?CMsgClientUFSGetSingleFileInfoResponse {
	mut res := CMsgClientUFSGetSingleFileInfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			3 {
				res.has_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_name = v
				i = ii
			}
			4 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			5 {
				res.has_time_stamp = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.time_stamp = v
				i = ii
			}
			6 {
				res.has_raw_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.raw_file_size = v
				i = ii
			}
			7 {
				res.has_is_explicit_delete = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_explicit_delete = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufsgetsinglefileinforesponse() CMsgClientUFSGetSingleFileInfoResponse {
	return CMsgClientUFSGetSingleFileInfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufsgetsinglefileinforesponse(o CMsgClientUFSGetSingleFileInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufsgetsinglefileinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSGetSingleFileInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufsgetsinglefileinforesponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSShareFile {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	has_app_id     bool
	file_name      string
	has_file_name  bool
}

pub fn (o &CMsgClientUFSShareFile) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_file_name {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	return res
}

pub fn cmsgclientufssharefile_unpack(buf []byte) ?CMsgClientUFSShareFile {
	mut res := CMsgClientUFSShareFile{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufssharefile() CMsgClientUFSShareFile {
	return CMsgClientUFSShareFile{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufssharefile(o CMsgClientUFSShareFile, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufssharefile(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSShareFile) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufssharefile_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUFSShareFileResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
	hcontent       u64
	has_hcontent   bool
}

pub fn (o &CMsgClientUFSShareFileResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_hcontent {
		res << vproto.pack_64bit_field(o.hcontent, 2)
	}
	return res
}

pub fn cmsgclientufssharefileresponse_unpack(buf []byte) ?CMsgClientUFSShareFileResponse {
	mut res := CMsgClientUFSShareFileResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_hcontent = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.hcontent = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientufssharefileresponse() CMsgClientUFSShareFileResponse {
	return CMsgClientUFSShareFileResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientufssharefileresponse(o CMsgClientUFSShareFileResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientufssharefileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUFSShareFileResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientufssharefileresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAMGetClanOfficers {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid_clan     u64
	has_steamid_clan bool
}

pub fn (o &CMsgClientAMGetClanOfficers) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_clan {
		res << vproto.pack_64bit_field(o.steamid_clan, 1)
	}
	return res
}

pub fn cmsgclientamgetclanofficers_unpack(buf []byte) ?CMsgClientAMGetClanOfficers {
	mut res := CMsgClientAMGetClanOfficers{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_clan = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_clan = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetclanofficers() CMsgClientAMGetClanOfficers {
	return CMsgClientAMGetClanOfficers{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetclanofficers(o CMsgClientAMGetClanOfficers, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetclanofficers(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetClanOfficers) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientamgetclanofficers_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAMGetClanOfficersResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	eresult           int
	has_eresult       bool
	steamid_clan      u64
	has_steamid_clan  bool
	officer_count     int
	has_officer_count bool
}

pub fn (o &CMsgClientAMGetClanOfficersResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_steamid_clan {
		res << vproto.pack_64bit_field(o.steamid_clan, 2)
	}
	if o.has_officer_count {
		res << vproto.pack_int32_field(o.officer_count, 3)
	}
	return res
}

pub fn cmsgclientamgetclanofficersresponse_unpack(buf []byte) ?CMsgClientAMGetClanOfficersResponse {
	mut res := CMsgClientAMGetClanOfficersResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_steamid_clan = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_clan = v
				i = ii
			}
			3 {
				res.has_officer_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.officer_count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetclanofficersresponse() CMsgClientAMGetClanOfficersResponse {
	return CMsgClientAMGetClanOfficersResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetclanofficersresponse(o CMsgClientAMGetClanOfficersResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetclanofficersresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetClanOfficersResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientamgetclanofficersresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAMGetPersonaNameHistory_IdInstance {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CMsgClientAMGetPersonaNameHistory_IdInstance) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cmsgclientamgetpersonanamehistory_idinstance_unpack(buf []byte) ?CMsgClientAMGetPersonaNameHistory_IdInstance {
	mut res := CMsgClientAMGetPersonaNameHistory_IdInstance{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistory_idinstance() CMsgClientAMGetPersonaNameHistory_IdInstance {
	return CMsgClientAMGetPersonaNameHistory_IdInstance{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistory_idinstance(o CMsgClientAMGetPersonaNameHistory_IdInstance, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistory_idinstance(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetPersonaNameHistory_IdInstance) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientamgetpersonanamehistory_idinstance_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAMGetPersonaNameHistory {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	id_count       int
	has_id_count   bool
	ids            []CMsgClientAMGetPersonaNameHistory_IdInstance
}

pub fn (o &CMsgClientAMGetPersonaNameHistory) pack() []byte {
	mut res := []byte{}
	if o.has_id_count {
		res << vproto.pack_int32_field(o.id_count, 1)
	}
	// [packed=false]
	for _, x in o.ids {
		res << zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistory_idinstance(x, 2)
	}
	return res
}

pub fn cmsgclientamgetpersonanamehistory_unpack(buf []byte) ?CMsgClientAMGetPersonaNameHistory {
	mut res := CMsgClientAMGetPersonaNameHistory{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_id_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.id_count = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistory_idinstance(cur_buf,
					tag_wiretype.wire_type)?
				res.ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistory() CMsgClientAMGetPersonaNameHistory {
	return CMsgClientAMGetPersonaNameHistory{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistory(o CMsgClientAMGetPersonaNameHistory, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetPersonaNameHistory) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientamgetpersonanamehistory_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name_since     u32
	has_name_since bool
	name           string
	has_name       bool
}

pub fn (o &CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance) pack() []byte {
	mut res := []byte{}
	if o.has_name_since {
		res << vproto.pack_32bit_field(o.name_since, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	return res
}

pub fn cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance_unpack(buf []byte) ?CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance {
	mut res := CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name_since = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.name_since = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance() CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance {
	return CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance(o CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
	steamid        u64
	has_steamid    bool
	names          []CMsgClientAMGetPersonaNameHistoryResponseNameTableInstance_NameInstance
}

pub fn (o &CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	// [packed=false]
	for _, x in o.names {
		res <<
			zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance(x, 3)
	}
	return res
}

pub fn cmsgclientamgetpersonanamehistoryresponse_nametableinstance_unpack(buf []byte) ?CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
	mut res := CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponsenametableinstance_nameinstance(cur_buf,
					tag_wiretype.wire_type)?
				res.names << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistoryresponse_nametableinstance() CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
	return CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponse_nametableinstance(o CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponse_nametableinstance(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientamgetpersonanamehistoryresponse_nametableinstance_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAMGetPersonaNameHistoryResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	responses      []CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance
}

pub fn (o &CMsgClientAMGetPersonaNameHistoryResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.responses {
		res <<
			zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponse_nametableinstance(x, 2)
	}
	return res
}

pub fn cmsgclientamgetpersonanamehistoryresponse_unpack(buf []byte) ?CMsgClientAMGetPersonaNameHistoryResponse {
	mut res := CMsgClientAMGetPersonaNameHistoryResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponse_nametableinstance(cur_buf,
					tag_wiretype.wire_type)?
				res.responses << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientamgetpersonanamehistoryresponse() CMsgClientAMGetPersonaNameHistoryResponse {
	return CMsgClientAMGetPersonaNameHistoryResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientamgetpersonanamehistoryresponse(o CMsgClientAMGetPersonaNameHistoryResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientamgetpersonanamehistoryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAMGetPersonaNameHistoryResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientamgetpersonanamehistoryresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientDeregisterWithServer {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	eservertype     u32
	has_eservertype bool
	app_id          u32
	has_app_id      bool
}

pub fn (o &CMsgClientDeregisterWithServer) pack() []byte {
	mut res := []byte{}
	if o.has_eservertype {
		res << vproto.pack_uint32_field(o.eservertype, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	return res
}

pub fn cmsgclientderegisterwithserver_unpack(buf []byte) ?CMsgClientDeregisterWithServer {
	mut res := CMsgClientDeregisterWithServer{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eservertype = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eservertype = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientderegisterwithserver() CMsgClientDeregisterWithServer {
	return CMsgClientDeregisterWithServer{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientderegisterwithserver(o CMsgClientDeregisterWithServer, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientderegisterwithserver(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDeregisterWithServer) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientderegisterwithserver_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientClanState_NameInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	clan_name      string
	has_clan_name  bool
	sha_avatar     []byte
	has_sha_avatar bool
}

pub fn (o &CMsgClientClanState_NameInfo) pack() []byte {
	mut res := []byte{}
	if o.has_clan_name {
		res << vproto.pack_string_field(o.clan_name, 1)
	}
	if o.has_sha_avatar {
		res << vproto.pack_bytes_field(o.sha_avatar, 2)
	}
	return res
}

pub fn cmsgclientclanstate_nameinfo_unpack(buf []byte) ?CMsgClientClanState_NameInfo {
	mut res := CMsgClientClanState_NameInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_clan_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.clan_name = v
				i = ii
			}
			2 {
				res.has_sha_avatar = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_avatar = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientclanstate_nameinfo() CMsgClientClanState_NameInfo {
	return CMsgClientClanState_NameInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientclanstate_nameinfo(o CMsgClientClanState_NameInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientclanstate_nameinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientClanState_NameInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientclanstate_nameinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientClanState_UserCounts {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	members               u32
	has_members           bool
	online                u32
	has_online            bool
	chatting              u32
	has_chatting          bool
	in_game               u32
	has_in_game           bool
	chat_room_members     u32
	has_chat_room_members bool
}

pub fn (o &CMsgClientClanState_UserCounts) pack() []byte {
	mut res := []byte{}
	if o.has_members {
		res << vproto.pack_uint32_field(o.members, 1)
	}
	if o.has_online {
		res << vproto.pack_uint32_field(o.online, 2)
	}
	if o.has_chatting {
		res << vproto.pack_uint32_field(o.chatting, 3)
	}
	if o.has_in_game {
		res << vproto.pack_uint32_field(o.in_game, 4)
	}
	if o.has_chat_room_members {
		res << vproto.pack_uint32_field(o.chat_room_members, 5)
	}
	return res
}

pub fn cmsgclientclanstate_usercounts_unpack(buf []byte) ?CMsgClientClanState_UserCounts {
	mut res := CMsgClientClanState_UserCounts{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_members = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.members = v
				i = ii
			}
			2 {
				res.has_online = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.online = v
				i = ii
			}
			3 {
				res.has_chatting = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.chatting = v
				i = ii
			}
			4 {
				res.has_in_game = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.in_game = v
				i = ii
			}
			5 {
				res.has_chat_room_members = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_room_members = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientclanstate_usercounts() CMsgClientClanState_UserCounts {
	return CMsgClientClanState_UserCounts{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientclanstate_usercounts(o CMsgClientClanState_UserCounts, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientclanstate_usercounts(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientClanState_UserCounts) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientclanstate_usercounts_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientClanState_Event {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	gid             u64
	has_gid         bool
	event_time      u32
	has_event_time  bool
	headline        string
	has_headline    bool
	game_id         u64
	has_game_id     bool
	just_posted     bool
	has_just_posted bool
}

pub fn (o &CMsgClientClanState_Event) pack() []byte {
	mut res := []byte{}
	if o.has_gid {
		res << vproto.pack_64bit_field(o.gid, 1)
	}
	if o.has_event_time {
		res << vproto.pack_uint32_field(o.event_time, 2)
	}
	if o.has_headline {
		res << vproto.pack_string_field(o.headline, 3)
	}
	if o.has_game_id {
		res << vproto.pack_64bit_field(o.game_id, 4)
	}
	if o.has_just_posted {
		res << vproto.pack_bool_field(o.just_posted, 5)
	}
	return res
}

pub fn cmsgclientclanstate_event_unpack(buf []byte) ?CMsgClientClanState_Event {
	mut res := CMsgClientClanState_Event{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_gid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.gid = v
				i = ii
			}
			2 {
				res.has_event_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.event_time = v
				i = ii
			}
			3 {
				res.has_headline = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.headline = v
				i = ii
			}
			4 {
				res.has_game_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.game_id = v
				i = ii
			}
			5 {
				res.has_just_posted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.just_posted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientclanstate_event() CMsgClientClanState_Event {
	return CMsgClientClanState_Event{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientclanstate_event(o CMsgClientClanState_Event, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientclanstate_event(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientClanState_Event) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientclanstate_event_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientClanState {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	steamid_clan           u64
	has_steamid_clan       bool
	clan_account_flags     u32
	has_clan_account_flags bool
	name_info              CMsgClientClanState_NameInfo
	has_name_info          bool
	user_counts            CMsgClientClanState_UserCounts
	has_user_counts        bool
	events                 []CMsgClientClanState_Event
	announcements          []CMsgClientClanState_Event
	chat_room_private      bool
	has_chat_room_private  bool
}

pub fn (o &CMsgClientClanState) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_clan {
		res << vproto.pack_64bit_field(o.steamid_clan, 1)
	}
	if o.has_clan_account_flags {
		res << vproto.pack_uint32_field(o.clan_account_flags, 3)
	}
	if o.has_name_info {
		res << zzz_vproto_internal_pack_cmsgclientclanstate_nameinfo(o.name_info, 4)
	}
	if o.has_user_counts {
		res << zzz_vproto_internal_pack_cmsgclientclanstate_usercounts(o.user_counts, 5)
	}
	// [packed=false]
	for _, x in o.events {
		res << zzz_vproto_internal_pack_cmsgclientclanstate_event(x, 6)
	}
	// [packed=false]
	for _, x in o.announcements {
		res << zzz_vproto_internal_pack_cmsgclientclanstate_event(x, 7)
	}
	if o.has_chat_room_private {
		res << vproto.pack_bool_field(o.chat_room_private, 8)
	}
	return res
}

pub fn cmsgclientclanstate_unpack(buf []byte) ?CMsgClientClanState {
	mut res := CMsgClientClanState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_clan = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_clan = v
				i = ii
			}
			3 {
				res.has_clan_account_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.clan_account_flags = v
				i = ii
			}
			4 {
				res.has_name_info = true
				ii, v := zzz_vproto_internal_unpack_cmsgclientclanstate_nameinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.name_info = v
				i = ii
			}
			5 {
				res.has_user_counts = true
				ii, v := zzz_vproto_internal_unpack_cmsgclientclanstate_usercounts(cur_buf,
					tag_wiretype.wire_type)?
				res.user_counts = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientclanstate_event(cur_buf,
					tag_wiretype.wire_type)?
				res.events << v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientclanstate_event(cur_buf,
					tag_wiretype.wire_type)?
				res.announcements << v
				i = ii
			}
			8 {
				res.has_chat_room_private = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_room_private = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientclanstate() CMsgClientClanState {
	return CMsgClientClanState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientclanstate(o CMsgClientClanState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientclanstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientClanState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientclanstate_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUnsignedInstallScript {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	app_id               u32
	has_app_id           bool
	file_name            string
	has_file_name        bool
	file_size            u32
	has_file_size        bool
	signature_broken     bool
	has_signature_broken bool
	depot_id             u32
	has_depot_id         bool
	manifest_id          u64
	has_manifest_id      bool
	file_flags           u32
	has_file_flags       bool
}

pub fn (o &CMsgClientUnsignedInstallScript) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_file_name {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 3)
	}
	if o.has_signature_broken {
		res << vproto.pack_bool_field(o.signature_broken, 4)
	}
	if o.has_depot_id {
		res << vproto.pack_uint32_field(o.depot_id, 5)
	}
	if o.has_manifest_id {
		res << vproto.pack_uint64_field(o.manifest_id, 6)
	}
	if o.has_file_flags {
		res << vproto.pack_uint32_field(o.file_flags, 7)
	}
	return res
}

pub fn cmsgclientunsignedinstallscript_unpack(buf []byte) ?CMsgClientUnsignedInstallScript {
	mut res := CMsgClientUnsignedInstallScript{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_name = v
				i = ii
			}
			3 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			4 {
				res.has_signature_broken = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.signature_broken = v
				i = ii
			}
			5 {
				res.has_depot_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depot_id = v
				i = ii
			}
			6 {
				res.has_manifest_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.manifest_id = v
				i = ii
			}
			7 {
				res.has_file_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_flags = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientunsignedinstallscript() CMsgClientUnsignedInstallScript {
	return CMsgClientUnsignedInstallScript{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientunsignedinstallscript(o CMsgClientUnsignedInstallScript, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientunsignedinstallscript(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUnsignedInstallScript) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientunsignedinstallscript_unpack(v)?
	return i, unpacked
}
