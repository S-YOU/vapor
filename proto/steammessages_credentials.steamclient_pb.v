// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CCredentials_TestAvailablePassword_Request {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	password                string
	has_password            bool
	sha_digest_password     []byte
	has_sha_digest_password bool
	account_name            string
	has_account_name        bool
}

pub fn (o &CCredentials_TestAvailablePassword_Request) pack() []byte {
	mut res := []byte{}
	if o.has_password {
		res << vproto.pack_string_field(o.password, 1)
	}
	if o.has_sha_digest_password {
		res << vproto.pack_bytes_field(o.sha_digest_password, 2)
	}
	if o.has_account_name {
		res << vproto.pack_string_field(o.account_name, 3)
	}
	return res
}

pub fn ccredentials_testavailablepassword_request_unpack(buf []byte) ?CCredentials_TestAvailablePassword_Request {
	mut res := CCredentials_TestAvailablePassword_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_password = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.password = v
				i = ii
			}
			2 {
				res.has_sha_digest_password = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_digest_password = v
				i = ii
			}
			3 {
				res.has_account_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.account_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_testavailablepassword_request() CCredentials_TestAvailablePassword_Request {
	return CCredentials_TestAvailablePassword_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_testavailablepassword_request(o CCredentials_TestAvailablePassword_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_testavailablepassword_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_TestAvailablePassword_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_testavailablepassword_request_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_TestAvailablePassword_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	is_valid       bool
	has_is_valid   bool
}

pub fn (o &CCredentials_TestAvailablePassword_Response) pack() []byte {
	mut res := []byte{}
	if o.has_is_valid {
		res << vproto.pack_bool_field(o.is_valid, 3)
	}
	return res
}

pub fn ccredentials_testavailablepassword_response_unpack(buf []byte) ?CCredentials_TestAvailablePassword_Response {
	mut res := CCredentials_TestAvailablePassword_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			3 {
				res.has_is_valid = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_valid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_testavailablepassword_response() CCredentials_TestAvailablePassword_Response {
	return CCredentials_TestAvailablePassword_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_testavailablepassword_response(o CCredentials_TestAvailablePassword_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_testavailablepassword_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_TestAvailablePassword_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_testavailablepassword_response_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_GetSteamGuardDetails_Request {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	include_new_authentications     bool
	has_include_new_authentications bool
	webcookie                       string
	has_webcookie                   bool
	timestamp_minimum_wanted        u32
	has_timestamp_minimum_wanted    bool
	ipaddress                       int
	has_ipaddress                   bool
}

pub fn (o &CCredentials_GetSteamGuardDetails_Request) pack() []byte {
	mut res := []byte{}
	if o.has_include_new_authentications {
		res << vproto.pack_bool_field(o.include_new_authentications, 1)
	}
	if o.has_webcookie {
		res << vproto.pack_string_field(o.webcookie, 2)
	}
	if o.has_timestamp_minimum_wanted {
		res << vproto.pack_32bit_field(o.timestamp_minimum_wanted, 3)
	}
	if o.has_ipaddress {
		res << vproto.pack_int32_field(o.ipaddress, 4)
	}
	return res
}

pub fn ccredentials_getsteamguarddetails_request_unpack(buf []byte) ?CCredentials_GetSteamGuardDetails_Request {
	mut res := CCredentials_GetSteamGuardDetails_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_include_new_authentications = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_new_authentications = v
				i = ii
			}
			2 {
				res.has_webcookie = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.webcookie = v
				i = ii
			}
			3 {
				res.has_timestamp_minimum_wanted = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_minimum_wanted = v
				i = ii
			}
			4 {
				res.has_ipaddress = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ipaddress = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_getsteamguarddetails_request() CCredentials_GetSteamGuardDetails_Request {
	return CCredentials_GetSteamGuardDetails_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_request(o CCredentials_GetSteamGuardDetails_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_GetSteamGuardDetails_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_getsteamguarddetails_request_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_GetSteamGuardDetails_Response_NewAuthentication {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	timestamp_steamguard_enabled     u32
	has_timestamp_steamguard_enabled bool
	is_web_cookie                    bool
	has_is_web_cookie                bool
	ipaddress                        int
	has_ipaddress                    bool
	geoloc_info                      string
	has_geoloc_info                  bool
	is_remembered                    bool
	has_is_remembered                bool
	machine_name_user_supplied       string
	has_machine_name_user_supplied   bool
	status                           int
	has_status                       bool
}

pub fn (o &CCredentials_GetSteamGuardDetails_Response_NewAuthentication) pack() []byte {
	mut res := []byte{}
	if o.has_timestamp_steamguard_enabled {
		res << vproto.pack_32bit_field(o.timestamp_steamguard_enabled, 1)
	}
	if o.has_is_web_cookie {
		res << vproto.pack_bool_field(o.is_web_cookie, 2)
	}
	if o.has_ipaddress {
		res << vproto.pack_int32_field(o.ipaddress, 3)
	}
	if o.has_geoloc_info {
		res << vproto.pack_string_field(o.geoloc_info, 4)
	}
	if o.has_is_remembered {
		res << vproto.pack_bool_field(o.is_remembered, 5)
	}
	if o.has_machine_name_user_supplied {
		res << vproto.pack_string_field(o.machine_name_user_supplied, 6)
	}
	if o.has_status {
		res << vproto.pack_int32_field(o.status, 7)
	}
	return res
}

pub fn ccredentials_getsteamguarddetails_response_newauthentication_unpack(buf []byte) ?CCredentials_GetSteamGuardDetails_Response_NewAuthentication {
	mut res := CCredentials_GetSteamGuardDetails_Response_NewAuthentication{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_timestamp_steamguard_enabled = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_steamguard_enabled = v
				i = ii
			}
			2 {
				res.has_is_web_cookie = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_web_cookie = v
				i = ii
			}
			3 {
				res.has_ipaddress = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ipaddress = v
				i = ii
			}
			4 {
				res.has_geoloc_info = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.geoloc_info = v
				i = ii
			}
			5 {
				res.has_is_remembered = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_remembered = v
				i = ii
			}
			6 {
				res.has_machine_name_user_supplied = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.machine_name_user_supplied = v
				i = ii
			}
			7 {
				res.has_status = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.status = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_getsteamguarddetails_response_newauthentication() CCredentials_GetSteamGuardDetails_Response_NewAuthentication {
	return CCredentials_GetSteamGuardDetails_Response_NewAuthentication{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_response_newauthentication(o CCredentials_GetSteamGuardDetails_Response_NewAuthentication, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_response_newauthentication(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_GetSteamGuardDetails_Response_NewAuthentication) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_getsteamguarddetails_response_newauthentication_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_GetSteamGuardDetails_Response_SessionData {
mut:
	unknown_fields                                        []vproto.UnknownField
pub mut:
	machine_id                                            u64
	has_machine_id                                        bool
	machine_name_userchosen                               string
	has_machine_name_userchosen                           bool
	timestamp_machine_steamguard_enabled                  u32
	has_timestamp_machine_steamguard_enabled              bool
	authentication_exists_from_geoloc_before_mintime      bool
	has_authentication_exists_from_geoloc_before_mintime  bool
	newauthentication                                     []CCredentials_GetSteamGuardDetails_Response_NewAuthentication
	authentication_exists_from_same_ip_before_mintime     bool
	has_authentication_exists_from_same_ip_before_mintime bool
	public_ipv4                                           u32
	has_public_ipv4                                       bool
	public_ip_address                                     string
	has_public_ip_address                                 bool
}

pub fn (o &CCredentials_GetSteamGuardDetails_Response_SessionData) pack() []byte {
	mut res := []byte{}
	if o.has_machine_id {
		res << vproto.pack_uint64_field(o.machine_id, 1)
	}
	if o.has_machine_name_userchosen {
		res << vproto.pack_string_field(o.machine_name_userchosen, 2)
	}
	if o.has_timestamp_machine_steamguard_enabled {
		res << vproto.pack_32bit_field(o.timestamp_machine_steamguard_enabled, 3)
	}
	if o.has_authentication_exists_from_geoloc_before_mintime {
		res << vproto.pack_bool_field(o.authentication_exists_from_geoloc_before_mintime, 4)
	}
	// [packed=false]
	for _, x in o.newauthentication {
		res <<
			zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_response_newauthentication(x, 5)
	}
	if o.has_authentication_exists_from_same_ip_before_mintime {
		res << vproto.pack_bool_field(o.authentication_exists_from_same_ip_before_mintime, 6)
	}
	if o.has_public_ipv4 {
		res << vproto.pack_uint32_field(o.public_ipv4, 7)
	}
	if o.has_public_ip_address {
		res << vproto.pack_string_field(o.public_ip_address, 8)
	}
	return res
}

pub fn ccredentials_getsteamguarddetails_response_sessiondata_unpack(buf []byte) ?CCredentials_GetSteamGuardDetails_Response_SessionData {
	mut res := CCredentials_GetSteamGuardDetails_Response_SessionData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_machine_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.machine_id = v
				i = ii
			}
			2 {
				res.has_machine_name_userchosen = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.machine_name_userchosen = v
				i = ii
			}
			3 {
				res.has_timestamp_machine_steamguard_enabled = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_machine_steamguard_enabled = v
				i = ii
			}
			4 {
				res.has_authentication_exists_from_geoloc_before_mintime = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.authentication_exists_from_geoloc_before_mintime = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_response_newauthentication(cur_buf,
					tag_wiretype.wire_type)?
				res.newauthentication << v
				i = ii
			}
			6 {
				res.has_authentication_exists_from_same_ip_before_mintime = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.authentication_exists_from_same_ip_before_mintime = v
				i = ii
			}
			7 {
				res.has_public_ipv4 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.public_ipv4 = v
				i = ii
			}
			8 {
				res.has_public_ip_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.public_ip_address = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_getsteamguarddetails_response_sessiondata() CCredentials_GetSteamGuardDetails_Response_SessionData {
	return CCredentials_GetSteamGuardDetails_Response_SessionData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_response_sessiondata(o CCredentials_GetSteamGuardDetails_Response_SessionData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_response_sessiondata(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_GetSteamGuardDetails_Response_SessionData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_getsteamguarddetails_response_sessiondata_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_GetSteamGuardDetails_Response {
mut:
	unknown_fields                                                  []vproto.UnknownField
pub mut:
	is_steamguard_enabled                                           bool
	has_is_steamguard_enabled                                       bool
	timestamp_steamguard_enabled                                    u32
	has_timestamp_steamguard_enabled                                bool
	deprecated_newauthentication                                    []CCredentials_GetSteamGuardDetails_Response_NewAuthentication
	deprecated_machine_name_userchosen                              string
	has_deprecated_machine_name_userchosen                          bool
	deprecated_timestamp_machine_steamguard_enabled                 u32
	has_deprecated_timestamp_machine_steamguard_enabled             bool
	deprecated_authentication_exists_from_geoloc_before_mintime     bool
	has_deprecated_authentication_exists_from_geoloc_before_mintime bool
	deprecated_machine_id                                           u64
	has_deprecated_machine_id                                       bool
	session_data                                                    []CCredentials_GetSteamGuardDetails_Response_SessionData
	is_twofactor_enabled                                            bool
	has_is_twofactor_enabled                                        bool
	timestamp_twofactor_enabled                                     u32
	has_timestamp_twofactor_enabled                                 bool
	is_phone_verified                                               bool
	has_is_phone_verified                                           bool
}

pub fn (o &CCredentials_GetSteamGuardDetails_Response) pack() []byte {
	mut res := []byte{}
	if o.has_is_steamguard_enabled {
		res << vproto.pack_bool_field(o.is_steamguard_enabled, 1)
	}
	if o.has_timestamp_steamguard_enabled {
		res << vproto.pack_32bit_field(o.timestamp_steamguard_enabled, 2)
	}
	// [packed=false]
	for _, x in o.deprecated_newauthentication {
		res <<
			zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_response_newauthentication(x, 3)
	}
	if o.has_deprecated_machine_name_userchosen {
		res << vproto.pack_string_field(o.deprecated_machine_name_userchosen, 4)
	}
	if o.has_deprecated_timestamp_machine_steamguard_enabled {
		res << vproto.pack_32bit_field(o.deprecated_timestamp_machine_steamguard_enabled, 5)
	}
	if o.has_deprecated_authentication_exists_from_geoloc_before_mintime {
		res <<
			vproto.pack_bool_field(o.deprecated_authentication_exists_from_geoloc_before_mintime, 6)
	}
	if o.has_deprecated_machine_id {
		res << vproto.pack_uint64_field(o.deprecated_machine_id, 7)
	}
	// [packed=false]
	for _, x in o.session_data {
		res <<
			zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_response_sessiondata(x, 8)
	}
	if o.has_is_twofactor_enabled {
		res << vproto.pack_bool_field(o.is_twofactor_enabled, 9)
	}
	if o.has_timestamp_twofactor_enabled {
		res << vproto.pack_32bit_field(o.timestamp_twofactor_enabled, 10)
	}
	if o.has_is_phone_verified {
		res << vproto.pack_bool_field(o.is_phone_verified, 11)
	}
	return res
}

pub fn ccredentials_getsteamguarddetails_response_unpack(buf []byte) ?CCredentials_GetSteamGuardDetails_Response {
	mut res := CCredentials_GetSteamGuardDetails_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_is_steamguard_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_steamguard_enabled = v
				i = ii
			}
			2 {
				res.has_timestamp_steamguard_enabled = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_steamguard_enabled = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_response_newauthentication(cur_buf,
					tag_wiretype.wire_type)?
				res.deprecated_newauthentication << v
				i = ii
			}
			4 {
				res.has_deprecated_machine_name_userchosen = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_machine_name_userchosen = v
				i = ii
			}
			5 {
				res.has_deprecated_timestamp_machine_steamguard_enabled = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_timestamp_machine_steamguard_enabled = v
				i = ii
			}
			6 {
				res.has_deprecated_authentication_exists_from_geoloc_before_mintime = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_authentication_exists_from_geoloc_before_mintime = v
				i = ii
			}
			7 {
				res.has_deprecated_machine_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_machine_id = v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_response_sessiondata(cur_buf,
					tag_wiretype.wire_type)?
				res.session_data << v
				i = ii
			}
			9 {
				res.has_is_twofactor_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_twofactor_enabled = v
				i = ii
			}
			10 {
				res.has_timestamp_twofactor_enabled = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_twofactor_enabled = v
				i = ii
			}
			11 {
				res.has_is_phone_verified = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_phone_verified = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_getsteamguarddetails_response() CCredentials_GetSteamGuardDetails_Response {
	return CCredentials_GetSteamGuardDetails_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_getsteamguarddetails_response(o CCredentials_GetSteamGuardDetails_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_getsteamguarddetails_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_GetSteamGuardDetails_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_getsteamguarddetails_response_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_NewMachineNotificationDialog_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	is_approved            bool
	has_is_approved        bool
	is_wizard_complete     bool
	has_is_wizard_complete bool
}

pub fn (o &CCredentials_NewMachineNotificationDialog_Request) pack() []byte {
	mut res := []byte{}
	if o.has_is_approved {
		res << vproto.pack_bool_field(o.is_approved, 1)
	}
	if o.has_is_wizard_complete {
		res << vproto.pack_bool_field(o.is_wizard_complete, 2)
	}
	return res
}

pub fn ccredentials_newmachinenotificationdialog_request_unpack(buf []byte) ?CCredentials_NewMachineNotificationDialog_Request {
	mut res := CCredentials_NewMachineNotificationDialog_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_is_approved = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_approved = v
				i = ii
			}
			2 {
				res.has_is_wizard_complete = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_wizard_complete = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_newmachinenotificationdialog_request() CCredentials_NewMachineNotificationDialog_Request {
	return CCredentials_NewMachineNotificationDialog_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_newmachinenotificationdialog_request(o CCredentials_NewMachineNotificationDialog_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_newmachinenotificationdialog_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_NewMachineNotificationDialog_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_newmachinenotificationdialog_request_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_NewMachineNotificationDialog_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CCredentials_NewMachineNotificationDialog_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn ccredentials_newmachinenotificationdialog_response_unpack(buf []byte) ?CCredentials_NewMachineNotificationDialog_Response {
	res := CCredentials_NewMachineNotificationDialog_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_newmachinenotificationdialog_response() CCredentials_NewMachineNotificationDialog_Response {
	return CCredentials_NewMachineNotificationDialog_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_newmachinenotificationdialog_response(o CCredentials_NewMachineNotificationDialog_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_newmachinenotificationdialog_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_NewMachineNotificationDialog_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_newmachinenotificationdialog_response_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_ValidateEmailAddress_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stoken         string
	has_stoken     bool
}

pub fn (o &CCredentials_ValidateEmailAddress_Request) pack() []byte {
	mut res := []byte{}
	if o.has_stoken {
		res << vproto.pack_string_field(o.stoken, 1)
	}
	return res
}

pub fn ccredentials_validateemailaddress_request_unpack(buf []byte) ?CCredentials_ValidateEmailAddress_Request {
	mut res := CCredentials_ValidateEmailAddress_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_stoken = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.stoken = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_validateemailaddress_request() CCredentials_ValidateEmailAddress_Request {
	return CCredentials_ValidateEmailAddress_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_validateemailaddress_request(o CCredentials_ValidateEmailAddress_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_validateemailaddress_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_ValidateEmailAddress_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_validateemailaddress_request_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_ValidateEmailAddress_Response {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	was_validated     bool
	has_was_validated bool
}

pub fn (o &CCredentials_ValidateEmailAddress_Response) pack() []byte {
	mut res := []byte{}
	if o.has_was_validated {
		res << vproto.pack_bool_field(o.was_validated, 1)
	}
	return res
}

pub fn ccredentials_validateemailaddress_response_unpack(buf []byte) ?CCredentials_ValidateEmailAddress_Response {
	mut res := CCredentials_ValidateEmailAddress_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_was_validated = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.was_validated = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_validateemailaddress_response() CCredentials_ValidateEmailAddress_Response {
	return CCredentials_ValidateEmailAddress_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_validateemailaddress_response(o CCredentials_ValidateEmailAddress_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_validateemailaddress_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_ValidateEmailAddress_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_validateemailaddress_response_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_SteamGuardPhishingReport_Request {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	param_string         string
	has_param_string     bool
	ipaddress_actual     u32
	has_ipaddress_actual bool
}

pub fn (o &CCredentials_SteamGuardPhishingReport_Request) pack() []byte {
	mut res := []byte{}
	if o.has_param_string {
		res << vproto.pack_string_field(o.param_string, 1)
	}
	if o.has_ipaddress_actual {
		res << vproto.pack_uint32_field(o.ipaddress_actual, 2)
	}
	return res
}

pub fn ccredentials_steamguardphishingreport_request_unpack(buf []byte) ?CCredentials_SteamGuardPhishingReport_Request {
	mut res := CCredentials_SteamGuardPhishingReport_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_param_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.param_string = v
				i = ii
			}
			2 {
				res.has_ipaddress_actual = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ipaddress_actual = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_steamguardphishingreport_request() CCredentials_SteamGuardPhishingReport_Request {
	return CCredentials_SteamGuardPhishingReport_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_steamguardphishingreport_request(o CCredentials_SteamGuardPhishingReport_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_steamguardphishingreport_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_SteamGuardPhishingReport_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_steamguardphishingreport_request_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_SteamGuardPhishingReport_Response {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	ipaddress_loginattempt       u32
	has_ipaddress_loginattempt   bool
	countryname_loginattempt     string
	has_countryname_loginattempt bool
	statename_loginattempt       string
	has_statename_loginattempt   bool
	cityname_loginattempt        string
	has_cityname_loginattempt    bool
	ipaddress_actual             u32
	has_ipaddress_actual         bool
	countryname_actual           string
	has_countryname_actual       bool
	statename_actual             string
	has_statename_actual         bool
	cityname_actual              string
	has_cityname_actual          bool
	steamguard_code              string
	has_steamguard_code          bool
}

pub fn (o &CCredentials_SteamGuardPhishingReport_Response) pack() []byte {
	mut res := []byte{}
	if o.has_ipaddress_loginattempt {
		res << vproto.pack_uint32_field(o.ipaddress_loginattempt, 1)
	}
	if o.has_countryname_loginattempt {
		res << vproto.pack_string_field(o.countryname_loginattempt, 2)
	}
	if o.has_statename_loginattempt {
		res << vproto.pack_string_field(o.statename_loginattempt, 3)
	}
	if o.has_cityname_loginattempt {
		res << vproto.pack_string_field(o.cityname_loginattempt, 4)
	}
	if o.has_ipaddress_actual {
		res << vproto.pack_uint32_field(o.ipaddress_actual, 5)
	}
	if o.has_countryname_actual {
		res << vproto.pack_string_field(o.countryname_actual, 6)
	}
	if o.has_statename_actual {
		res << vproto.pack_string_field(o.statename_actual, 7)
	}
	if o.has_cityname_actual {
		res << vproto.pack_string_field(o.cityname_actual, 8)
	}
	if o.has_steamguard_code {
		res << vproto.pack_string_field(o.steamguard_code, 9)
	}
	return res
}

pub fn ccredentials_steamguardphishingreport_response_unpack(buf []byte) ?CCredentials_SteamGuardPhishingReport_Response {
	mut res := CCredentials_SteamGuardPhishingReport_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ipaddress_loginattempt = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ipaddress_loginattempt = v
				i = ii
			}
			2 {
				res.has_countryname_loginattempt = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.countryname_loginattempt = v
				i = ii
			}
			3 {
				res.has_statename_loginattempt = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.statename_loginattempt = v
				i = ii
			}
			4 {
				res.has_cityname_loginattempt = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cityname_loginattempt = v
				i = ii
			}
			5 {
				res.has_ipaddress_actual = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ipaddress_actual = v
				i = ii
			}
			6 {
				res.has_countryname_actual = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.countryname_actual = v
				i = ii
			}
			7 {
				res.has_statename_actual = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.statename_actual = v
				i = ii
			}
			8 {
				res.has_cityname_actual = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cityname_actual = v
				i = ii
			}
			9 {
				res.has_steamguard_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.steamguard_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_steamguardphishingreport_response() CCredentials_SteamGuardPhishingReport_Response {
	return CCredentials_SteamGuardPhishingReport_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_steamguardphishingreport_response(o CCredentials_SteamGuardPhishingReport_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_steamguardphishingreport_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_SteamGuardPhishingReport_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_steamguardphishingreport_response_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_LastCredentialChangeTime_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	user_changes_only     bool
	has_user_changes_only bool
}

pub fn (o &CCredentials_LastCredentialChangeTime_Request) pack() []byte {
	mut res := []byte{}
	if o.has_user_changes_only {
		res << vproto.pack_bool_field(o.user_changes_only, 1)
	}
	return res
}

pub fn ccredentials_lastcredentialchangetime_request_unpack(buf []byte) ?CCredentials_LastCredentialChangeTime_Request {
	mut res := CCredentials_LastCredentialChangeTime_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_user_changes_only = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.user_changes_only = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_lastcredentialchangetime_request() CCredentials_LastCredentialChangeTime_Request {
	return CCredentials_LastCredentialChangeTime_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_lastcredentialchangetime_request(o CCredentials_LastCredentialChangeTime_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_lastcredentialchangetime_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_LastCredentialChangeTime_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_lastcredentialchangetime_request_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_LastCredentialChangeTime_Response {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	timestamp_last_password_change     u32
	has_timestamp_last_password_change bool
	timestamp_last_email_change        u32
	has_timestamp_last_email_change    bool
	timestamp_last_password_reset      u32
	has_timestamp_last_password_reset  bool
}

pub fn (o &CCredentials_LastCredentialChangeTime_Response) pack() []byte {
	mut res := []byte{}
	if o.has_timestamp_last_password_change {
		res << vproto.pack_32bit_field(o.timestamp_last_password_change, 1)
	}
	if o.has_timestamp_last_email_change {
		res << vproto.pack_32bit_field(o.timestamp_last_email_change, 2)
	}
	if o.has_timestamp_last_password_reset {
		res << vproto.pack_32bit_field(o.timestamp_last_password_reset, 3)
	}
	return res
}

pub fn ccredentials_lastcredentialchangetime_response_unpack(buf []byte) ?CCredentials_LastCredentialChangeTime_Response {
	mut res := CCredentials_LastCredentialChangeTime_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_timestamp_last_password_change = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_last_password_change = v
				i = ii
			}
			2 {
				res.has_timestamp_last_email_change = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_last_email_change = v
				i = ii
			}
			3 {
				res.has_timestamp_last_password_reset = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_last_password_reset = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_lastcredentialchangetime_response() CCredentials_LastCredentialChangeTime_Response {
	return CCredentials_LastCredentialChangeTime_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_lastcredentialchangetime_response(o CCredentials_LastCredentialChangeTime_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_lastcredentialchangetime_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_LastCredentialChangeTime_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_lastcredentialchangetime_response_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_GetAccountAuthSecret_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CCredentials_GetAccountAuthSecret_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn ccredentials_getaccountauthsecret_request_unpack(buf []byte) ?CCredentials_GetAccountAuthSecret_Request {
	res := CCredentials_GetAccountAuthSecret_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_getaccountauthsecret_request() CCredentials_GetAccountAuthSecret_Request {
	return CCredentials_GetAccountAuthSecret_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_getaccountauthsecret_request(o CCredentials_GetAccountAuthSecret_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_getaccountauthsecret_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_GetAccountAuthSecret_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_getaccountauthsecret_request_unpack(v)?
	return i, unpacked
}

pub struct CCredentials_GetAccountAuthSecret_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	secret_id      int
	has_secret_id  bool
	secret         []byte
	has_secret     bool
}

pub fn (o &CCredentials_GetAccountAuthSecret_Response) pack() []byte {
	mut res := []byte{}
	if o.has_secret_id {
		res << vproto.pack_int32_field(o.secret_id, 1)
	}
	if o.has_secret {
		res << vproto.pack_bytes_field(o.secret, 2)
	}
	return res
}

pub fn ccredentials_getaccountauthsecret_response_unpack(buf []byte) ?CCredentials_GetAccountAuthSecret_Response {
	mut res := CCredentials_GetAccountAuthSecret_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_secret_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.secret_id = v
				i = ii
			}
			2 {
				res.has_secret = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.secret = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentials_getaccountauthsecret_response() CCredentials_GetAccountAuthSecret_Response {
	return CCredentials_GetAccountAuthSecret_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentials_getaccountauthsecret_response(o CCredentials_GetAccountAuthSecret_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentials_getaccountauthsecret_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentials_GetAccountAuthSecret_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccredentials_getaccountauthsecret_response_unpack(v)?
	return i, unpacked
}
