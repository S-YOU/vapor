
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


pub struct CCredentialsTestAvailablePasswordRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
password string
has_password bool
sha_digest_password []byte
has_sha_digest_password bool
account_name string
has_account_name bool
}
pub fn (o &CCredentialsTestAvailablePasswordRequest) pack() []byte {
mut res := []byte{}
if o.has_password {
res << vproto.pack_string_field(o.password, 1)
}

if o.has_sha_digest_password {
res << vproto.pack_bytes_field(o.sha_digest_password, 2)
}

if o.has_account_name {
res << vproto.pack_string_field(o.account_name, 3)
}

return res
}

pub fn ccredentialstestavailablepasswordrequest_unpack(buf []byte) ?CCredentialsTestAvailablePasswordRequest {
mut res := CCredentialsTestAvailablePasswordRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_password = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.password = v
i = ii
}

2 {
res.has_sha_digest_password = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_digest_password = v
i = ii
}

3 {
res.has_account_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.account_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialstestavailablepasswordrequest() CCredentialsTestAvailablePasswordRequest {
return CCredentialsTestAvailablePasswordRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialstestavailablepasswordrequest(o CCredentialsTestAvailablePasswordRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialstestavailablepasswordrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsTestAvailablePasswordRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialstestavailablepasswordrequest_unpack(v)?
return i, unpacked
}
pub struct CCredentialsTestAvailablePasswordResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
is_valid bool
has_is_valid bool
}
pub fn (o &CCredentialsTestAvailablePasswordResponse) pack() []byte {
mut res := []byte{}
if o.has_is_valid {
res << vproto.pack_bool_field(o.is_valid, 3)
}

return res
}

pub fn ccredentialstestavailablepasswordresponse_unpack(buf []byte) ?CCredentialsTestAvailablePasswordResponse {
mut res := CCredentialsTestAvailablePasswordResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
3 {
res.has_is_valid = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_valid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialstestavailablepasswordresponse() CCredentialsTestAvailablePasswordResponse {
return CCredentialsTestAvailablePasswordResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialstestavailablepasswordresponse(o CCredentialsTestAvailablePasswordResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialstestavailablepasswordresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsTestAvailablePasswordResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialstestavailablepasswordresponse_unpack(v)?
return i, unpacked
}
pub struct CCredentialsGetSteamGuardDetailsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
include_new_authentications bool
has_include_new_authentications bool
webcookie string
has_webcookie bool
timestamp_minimum_wanted u32
has_timestamp_minimum_wanted bool
ipaddress int
has_ipaddress bool
}
pub fn (o &CCredentialsGetSteamGuardDetailsRequest) pack() []byte {
mut res := []byte{}
if o.has_include_new_authentications {
res << vproto.pack_bool_field(o.include_new_authentications, 1)
}

if o.has_webcookie {
res << vproto.pack_string_field(o.webcookie, 2)
}

if o.has_timestamp_minimum_wanted {
res << vproto.pack_32bit_field(o.timestamp_minimum_wanted, 3)
}

if o.has_ipaddress {
res << vproto.pack_int32_field(o.ipaddress, 4)
}

return res
}

pub fn ccredentialsgetsteamguarddetailsrequest_unpack(buf []byte) ?CCredentialsGetSteamGuardDetailsRequest {
mut res := CCredentialsGetSteamGuardDetailsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_include_new_authentications = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.include_new_authentications = v
i = ii
}

2 {
res.has_webcookie = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.webcookie = v
i = ii
}

3 {
res.has_timestamp_minimum_wanted = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp_minimum_wanted = v
i = ii
}

4 {
res.has_ipaddress = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.ipaddress = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialsgetsteamguarddetailsrequest() CCredentialsGetSteamGuardDetailsRequest {
return CCredentialsGetSteamGuardDetailsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialsgetsteamguarddetailsrequest(o CCredentialsGetSteamGuardDetailsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialsgetsteamguarddetailsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsGetSteamGuardDetailsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialsgetsteamguarddetailsrequest_unpack(v)?
return i, unpacked
}
pub struct CCredentialsGetSteamGuardDetailsResponseNewAuthentication {
mut:
unknown_fields []vproto.UnknownField
pub mut:
timestamp_steamguard_enabled u32
has_timestamp_steamguard_enabled bool
is_web_cookie bool
has_is_web_cookie bool
ipaddress int
has_ipaddress bool
geoloc_info string
has_geoloc_info bool
is_remembered bool
has_is_remembered bool
machine_name_user_supplied string
has_machine_name_user_supplied bool
status int
has_status bool
}
pub fn (o &CCredentialsGetSteamGuardDetailsResponseNewAuthentication) pack() []byte {
mut res := []byte{}
if o.has_timestamp_steamguard_enabled {
res << vproto.pack_32bit_field(o.timestamp_steamguard_enabled, 1)
}

if o.has_is_web_cookie {
res << vproto.pack_bool_field(o.is_web_cookie, 2)
}

if o.has_ipaddress {
res << vproto.pack_int32_field(o.ipaddress, 3)
}

if o.has_geoloc_info {
res << vproto.pack_string_field(o.geoloc_info, 4)
}

if o.has_is_remembered {
res << vproto.pack_bool_field(o.is_remembered, 5)
}

if o.has_machine_name_user_supplied {
res << vproto.pack_string_field(o.machine_name_user_supplied, 6)
}

if o.has_status {
res << vproto.pack_int32_field(o.status, 7)
}

return res
}

pub fn ccredentialsgetsteamguarddetailsresponsenewauthentication_unpack(buf []byte) ?CCredentialsGetSteamGuardDetailsResponseNewAuthentication {
mut res := CCredentialsGetSteamGuardDetailsResponseNewAuthentication{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_timestamp_steamguard_enabled = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp_steamguard_enabled = v
i = ii
}

2 {
res.has_is_web_cookie = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_web_cookie = v
i = ii
}

3 {
res.has_ipaddress = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.ipaddress = v
i = ii
}

4 {
res.has_geoloc_info = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.geoloc_info = v
i = ii
}

5 {
res.has_is_remembered = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_remembered = v
i = ii
}

6 {
res.has_machine_name_user_supplied = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.machine_name_user_supplied = v
i = ii
}

7 {
res.has_status = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.status = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialsgetsteamguarddetailsresponsenewauthentication() CCredentialsGetSteamGuardDetailsResponseNewAuthentication {
return CCredentialsGetSteamGuardDetailsResponseNewAuthentication{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialsgetsteamguarddetailsresponsenewauthentication(o CCredentialsGetSteamGuardDetailsResponseNewAuthentication, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialsgetsteamguarddetailsresponsenewauthentication(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsGetSteamGuardDetailsResponseNewAuthentication) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialsgetsteamguarddetailsresponsenewauthentication_unpack(v)?
return i, unpacked
}
pub struct CCredentialsGetSteamGuardDetailsResponseSessionData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
machine_id u64
has_machine_id bool
machine_name_userchosen string
has_machine_name_userchosen bool
timestamp_machine_steamguard_enabled u32
has_timestamp_machine_steamguard_enabled bool
authentication_exists_from_geoloc_before_mintime bool
has_authentication_exists_from_geoloc_before_mintime bool
newauthentication []CCredentialsGetSteamGuardDetailsResponseNewAuthentication
authentication_exists_from_same_ip_before_mintime bool
has_authentication_exists_from_same_ip_before_mintime bool
public_ipv4 u32
has_public_ipv4 bool
public_ip_address string
has_public_ip_address bool
}
pub fn (o &CCredentialsGetSteamGuardDetailsResponseSessionData) pack() []byte {
mut res := []byte{}
if o.has_machine_id {
res << vproto.pack_uint64_field(o.machine_id, 1)
}

if o.has_machine_name_userchosen {
res << vproto.pack_string_field(o.machine_name_userchosen, 2)
}

if o.has_timestamp_machine_steamguard_enabled {
res << vproto.pack_32bit_field(o.timestamp_machine_steamguard_enabled, 3)
}

if o.has_authentication_exists_from_geoloc_before_mintime {
res << vproto.pack_bool_field(o.authentication_exists_from_geoloc_before_mintime, 4)
}

// [packed=false]
for _, x in o.newauthentication {
res << zzz_vproto_internal_pack_ccredentialsgetsteamguarddetailsresponsenewauthentication(x, 5)
}

if o.has_authentication_exists_from_same_ip_before_mintime {
res << vproto.pack_bool_field(o.authentication_exists_from_same_ip_before_mintime, 6)
}

if o.has_public_ipv4 {
res << vproto.pack_uint32_field(o.public_ipv4, 7)
}

if o.has_public_ip_address {
res << vproto.pack_string_field(o.public_ip_address, 8)
}

return res
}

pub fn ccredentialsgetsteamguarddetailsresponsesessiondata_unpack(buf []byte) ?CCredentialsGetSteamGuardDetailsResponseSessionData {
mut res := CCredentialsGetSteamGuardDetailsResponseSessionData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_machine_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.machine_id = v
i = ii
}

2 {
res.has_machine_name_userchosen = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.machine_name_userchosen = v
i = ii
}

3 {
res.has_timestamp_machine_steamguard_enabled = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp_machine_steamguard_enabled = v
i = ii
}

4 {
res.has_authentication_exists_from_geoloc_before_mintime = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.authentication_exists_from_geoloc_before_mintime = v
i = ii
}

5 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_ccredentialsgetsteamguarddetailsresponsenewauthentication(cur_buf, tag_wiretype.wire_type)?
res.newauthentication << v
i = ii
}

6 {
res.has_authentication_exists_from_same_ip_before_mintime = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.authentication_exists_from_same_ip_before_mintime = v
i = ii
}

7 {
res.has_public_ipv4 = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.public_ipv4 = v
i = ii
}

8 {
res.has_public_ip_address = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.public_ip_address = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialsgetsteamguarddetailsresponsesessiondata() CCredentialsGetSteamGuardDetailsResponseSessionData {
return CCredentialsGetSteamGuardDetailsResponseSessionData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialsgetsteamguarddetailsresponsesessiondata(o CCredentialsGetSteamGuardDetailsResponseSessionData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialsgetsteamguarddetailsresponsesessiondata(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsGetSteamGuardDetailsResponseSessionData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialsgetsteamguarddetailsresponsesessiondata_unpack(v)?
return i, unpacked
}
pub struct CCredentialsGetSteamGuardDetailsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
is_steamguard_enabled bool
has_is_steamguard_enabled bool
timestamp_steamguard_enabled u32
has_timestamp_steamguard_enabled bool
deprecated_newauthentication []CCredentialsGetSteamGuardDetailsResponseNewAuthentication
deprecated_machine_name_userchosen string
has_deprecated_machine_name_userchosen bool
deprecated_timestamp_machine_steamguard_enabled u32
has_deprecated_timestamp_machine_steamguard_enabled bool
deprecated_authentication_exists_from_geoloc_before_mintime bool
has_deprecated_authentication_exists_from_geoloc_before_mintime bool
deprecated_machine_id u64
has_deprecated_machine_id bool
session_data []CCredentialsGetSteamGuardDetailsResponseSessionData
is_twofactor_enabled bool
has_is_twofactor_enabled bool
timestamp_twofactor_enabled u32
has_timestamp_twofactor_enabled bool
is_phone_verified bool
has_is_phone_verified bool
}
pub fn (o &CCredentialsGetSteamGuardDetailsResponse) pack() []byte {
mut res := []byte{}
if o.has_is_steamguard_enabled {
res << vproto.pack_bool_field(o.is_steamguard_enabled, 1)
}

if o.has_timestamp_steamguard_enabled {
res << vproto.pack_32bit_field(o.timestamp_steamguard_enabled, 2)
}

// [packed=false]
for _, x in o.deprecated_newauthentication {
res << zzz_vproto_internal_pack_ccredentialsgetsteamguarddetailsresponsenewauthentication(x, 3)
}

if o.has_deprecated_machine_name_userchosen {
res << vproto.pack_string_field(o.deprecated_machine_name_userchosen, 4)
}

if o.has_deprecated_timestamp_machine_steamguard_enabled {
res << vproto.pack_32bit_field(o.deprecated_timestamp_machine_steamguard_enabled, 5)
}

if o.has_deprecated_authentication_exists_from_geoloc_before_mintime {
res << vproto.pack_bool_field(o.deprecated_authentication_exists_from_geoloc_before_mintime, 6)
}

if o.has_deprecated_machine_id {
res << vproto.pack_uint64_field(o.deprecated_machine_id, 7)
}

// [packed=false]
for _, x in o.session_data {
res << zzz_vproto_internal_pack_ccredentialsgetsteamguarddetailsresponsesessiondata(x, 8)
}

if o.has_is_twofactor_enabled {
res << vproto.pack_bool_field(o.is_twofactor_enabled, 9)
}

if o.has_timestamp_twofactor_enabled {
res << vproto.pack_32bit_field(o.timestamp_twofactor_enabled, 10)
}

if o.has_is_phone_verified {
res << vproto.pack_bool_field(o.is_phone_verified, 11)
}

return res
}

pub fn ccredentialsgetsteamguarddetailsresponse_unpack(buf []byte) ?CCredentialsGetSteamGuardDetailsResponse {
mut res := CCredentialsGetSteamGuardDetailsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_is_steamguard_enabled = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_steamguard_enabled = v
i = ii
}

2 {
res.has_timestamp_steamguard_enabled = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp_steamguard_enabled = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_ccredentialsgetsteamguarddetailsresponsenewauthentication(cur_buf, tag_wiretype.wire_type)?
res.deprecated_newauthentication << v
i = ii
}

4 {
res.has_deprecated_machine_name_userchosen = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_machine_name_userchosen = v
i = ii
}

5 {
res.has_deprecated_timestamp_machine_steamguard_enabled = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_timestamp_machine_steamguard_enabled = v
i = ii
}

6 {
res.has_deprecated_authentication_exists_from_geoloc_before_mintime = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_authentication_exists_from_geoloc_before_mintime = v
i = ii
}

7 {
res.has_deprecated_machine_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_machine_id = v
i = ii
}

8 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_ccredentialsgetsteamguarddetailsresponsesessiondata(cur_buf, tag_wiretype.wire_type)?
res.session_data << v
i = ii
}

9 {
res.has_is_twofactor_enabled = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_twofactor_enabled = v
i = ii
}

10 {
res.has_timestamp_twofactor_enabled = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp_twofactor_enabled = v
i = ii
}

11 {
res.has_is_phone_verified = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_phone_verified = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialsgetsteamguarddetailsresponse() CCredentialsGetSteamGuardDetailsResponse {
return CCredentialsGetSteamGuardDetailsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialsgetsteamguarddetailsresponse(o CCredentialsGetSteamGuardDetailsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialsgetsteamguarddetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsGetSteamGuardDetailsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialsgetsteamguarddetailsresponse_unpack(v)?
return i, unpacked
}
pub struct CCredentialsNewMachineNotificationDialogRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
is_approved bool
has_is_approved bool
is_wizard_complete bool
has_is_wizard_complete bool
}
pub fn (o &CCredentialsNewMachineNotificationDialogRequest) pack() []byte {
mut res := []byte{}
if o.has_is_approved {
res << vproto.pack_bool_field(o.is_approved, 1)
}

if o.has_is_wizard_complete {
res << vproto.pack_bool_field(o.is_wizard_complete, 2)
}

return res
}

pub fn ccredentialsnewmachinenotificationdialogrequest_unpack(buf []byte) ?CCredentialsNewMachineNotificationDialogRequest {
mut res := CCredentialsNewMachineNotificationDialogRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_is_approved = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_approved = v
i = ii
}

2 {
res.has_is_wizard_complete = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_wizard_complete = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialsnewmachinenotificationdialogrequest() CCredentialsNewMachineNotificationDialogRequest {
return CCredentialsNewMachineNotificationDialogRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialsnewmachinenotificationdialogrequest(o CCredentialsNewMachineNotificationDialogRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialsnewmachinenotificationdialogrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsNewMachineNotificationDialogRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialsnewmachinenotificationdialogrequest_unpack(v)?
return i, unpacked
}
pub struct CCredentialsNewMachineNotificationDialogResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CCredentialsNewMachineNotificationDialogResponse) pack() []byte {
res := []byte{}
return res
}

pub fn ccredentialsnewmachinenotificationdialogresponse_unpack(buf []byte) ?CCredentialsNewMachineNotificationDialogResponse {
res := CCredentialsNewMachineNotificationDialogResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialsnewmachinenotificationdialogresponse() CCredentialsNewMachineNotificationDialogResponse {
return CCredentialsNewMachineNotificationDialogResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialsnewmachinenotificationdialogresponse(o CCredentialsNewMachineNotificationDialogResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialsnewmachinenotificationdialogresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsNewMachineNotificationDialogResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialsnewmachinenotificationdialogresponse_unpack(v)?
return i, unpacked
}
pub struct CCredentialsValidateEmailAddressRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
stoken string
has_stoken bool
}
pub fn (o &CCredentialsValidateEmailAddressRequest) pack() []byte {
mut res := []byte{}
if o.has_stoken {
res << vproto.pack_string_field(o.stoken, 1)
}

return res
}

pub fn ccredentialsvalidateemailaddressrequest_unpack(buf []byte) ?CCredentialsValidateEmailAddressRequest {
mut res := CCredentialsValidateEmailAddressRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_stoken = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.stoken = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialsvalidateemailaddressrequest() CCredentialsValidateEmailAddressRequest {
return CCredentialsValidateEmailAddressRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialsvalidateemailaddressrequest(o CCredentialsValidateEmailAddressRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialsvalidateemailaddressrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsValidateEmailAddressRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialsvalidateemailaddressrequest_unpack(v)?
return i, unpacked
}
pub struct CCredentialsValidateEmailAddressResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
was_validated bool
has_was_validated bool
}
pub fn (o &CCredentialsValidateEmailAddressResponse) pack() []byte {
mut res := []byte{}
if o.has_was_validated {
res << vproto.pack_bool_field(o.was_validated, 1)
}

return res
}

pub fn ccredentialsvalidateemailaddressresponse_unpack(buf []byte) ?CCredentialsValidateEmailAddressResponse {
mut res := CCredentialsValidateEmailAddressResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_was_validated = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.was_validated = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialsvalidateemailaddressresponse() CCredentialsValidateEmailAddressResponse {
return CCredentialsValidateEmailAddressResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialsvalidateemailaddressresponse(o CCredentialsValidateEmailAddressResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialsvalidateemailaddressresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsValidateEmailAddressResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialsvalidateemailaddressresponse_unpack(v)?
return i, unpacked
}
pub struct CCredentialsSteamGuardPhishingReportRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
param_string string
has_param_string bool
ipaddress_actual u32
has_ipaddress_actual bool
}
pub fn (o &CCredentialsSteamGuardPhishingReportRequest) pack() []byte {
mut res := []byte{}
if o.has_param_string {
res << vproto.pack_string_field(o.param_string, 1)
}

if o.has_ipaddress_actual {
res << vproto.pack_uint32_field(o.ipaddress_actual, 2)
}

return res
}

pub fn ccredentialssteamguardphishingreportrequest_unpack(buf []byte) ?CCredentialsSteamGuardPhishingReportRequest {
mut res := CCredentialsSteamGuardPhishingReportRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_param_string = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.param_string = v
i = ii
}

2 {
res.has_ipaddress_actual = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ipaddress_actual = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialssteamguardphishingreportrequest() CCredentialsSteamGuardPhishingReportRequest {
return CCredentialsSteamGuardPhishingReportRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialssteamguardphishingreportrequest(o CCredentialsSteamGuardPhishingReportRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialssteamguardphishingreportrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsSteamGuardPhishingReportRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialssteamguardphishingreportrequest_unpack(v)?
return i, unpacked
}
pub struct CCredentialsSteamGuardPhishingReportResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
ipaddress_loginattempt u32
has_ipaddress_loginattempt bool
countryname_loginattempt string
has_countryname_loginattempt bool
statename_loginattempt string
has_statename_loginattempt bool
cityname_loginattempt string
has_cityname_loginattempt bool
ipaddress_actual u32
has_ipaddress_actual bool
countryname_actual string
has_countryname_actual bool
statename_actual string
has_statename_actual bool
cityname_actual string
has_cityname_actual bool
steamguard_code string
has_steamguard_code bool
}
pub fn (o &CCredentialsSteamGuardPhishingReportResponse) pack() []byte {
mut res := []byte{}
if o.has_ipaddress_loginattempt {
res << vproto.pack_uint32_field(o.ipaddress_loginattempt, 1)
}

if o.has_countryname_loginattempt {
res << vproto.pack_string_field(o.countryname_loginattempt, 2)
}

if o.has_statename_loginattempt {
res << vproto.pack_string_field(o.statename_loginattempt, 3)
}

if o.has_cityname_loginattempt {
res << vproto.pack_string_field(o.cityname_loginattempt, 4)
}

if o.has_ipaddress_actual {
res << vproto.pack_uint32_field(o.ipaddress_actual, 5)
}

if o.has_countryname_actual {
res << vproto.pack_string_field(o.countryname_actual, 6)
}

if o.has_statename_actual {
res << vproto.pack_string_field(o.statename_actual, 7)
}

if o.has_cityname_actual {
res << vproto.pack_string_field(o.cityname_actual, 8)
}

if o.has_steamguard_code {
res << vproto.pack_string_field(o.steamguard_code, 9)
}

return res
}

pub fn ccredentialssteamguardphishingreportresponse_unpack(buf []byte) ?CCredentialsSteamGuardPhishingReportResponse {
mut res := CCredentialsSteamGuardPhishingReportResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_ipaddress_loginattempt = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ipaddress_loginattempt = v
i = ii
}

2 {
res.has_countryname_loginattempt = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.countryname_loginattempt = v
i = ii
}

3 {
res.has_statename_loginattempt = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.statename_loginattempt = v
i = ii
}

4 {
res.has_cityname_loginattempt = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.cityname_loginattempt = v
i = ii
}

5 {
res.has_ipaddress_actual = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ipaddress_actual = v
i = ii
}

6 {
res.has_countryname_actual = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.countryname_actual = v
i = ii
}

7 {
res.has_statename_actual = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.statename_actual = v
i = ii
}

8 {
res.has_cityname_actual = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.cityname_actual = v
i = ii
}

9 {
res.has_steamguard_code = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.steamguard_code = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialssteamguardphishingreportresponse() CCredentialsSteamGuardPhishingReportResponse {
return CCredentialsSteamGuardPhishingReportResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialssteamguardphishingreportresponse(o CCredentialsSteamGuardPhishingReportResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialssteamguardphishingreportresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsSteamGuardPhishingReportResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialssteamguardphishingreportresponse_unpack(v)?
return i, unpacked
}
pub struct CCredentialsLastCredentialChangeTimeRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
user_changes_only bool
has_user_changes_only bool
}
pub fn (o &CCredentialsLastCredentialChangeTimeRequest) pack() []byte {
mut res := []byte{}
if o.has_user_changes_only {
res << vproto.pack_bool_field(o.user_changes_only, 1)
}

return res
}

pub fn ccredentialslastcredentialchangetimerequest_unpack(buf []byte) ?CCredentialsLastCredentialChangeTimeRequest {
mut res := CCredentialsLastCredentialChangeTimeRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_user_changes_only = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.user_changes_only = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialslastcredentialchangetimerequest() CCredentialsLastCredentialChangeTimeRequest {
return CCredentialsLastCredentialChangeTimeRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialslastcredentialchangetimerequest(o CCredentialsLastCredentialChangeTimeRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialslastcredentialchangetimerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsLastCredentialChangeTimeRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialslastcredentialchangetimerequest_unpack(v)?
return i, unpacked
}
pub struct CCredentialsLastCredentialChangeTimeResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
timestamp_last_password_change u32
has_timestamp_last_password_change bool
timestamp_last_email_change u32
has_timestamp_last_email_change bool
timestamp_last_password_reset u32
has_timestamp_last_password_reset bool
}
pub fn (o &CCredentialsLastCredentialChangeTimeResponse) pack() []byte {
mut res := []byte{}
if o.has_timestamp_last_password_change {
res << vproto.pack_32bit_field(o.timestamp_last_password_change, 1)
}

if o.has_timestamp_last_email_change {
res << vproto.pack_32bit_field(o.timestamp_last_email_change, 2)
}

if o.has_timestamp_last_password_reset {
res << vproto.pack_32bit_field(o.timestamp_last_password_reset, 3)
}

return res
}

pub fn ccredentialslastcredentialchangetimeresponse_unpack(buf []byte) ?CCredentialsLastCredentialChangeTimeResponse {
mut res := CCredentialsLastCredentialChangeTimeResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_timestamp_last_password_change = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp_last_password_change = v
i = ii
}

2 {
res.has_timestamp_last_email_change = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp_last_email_change = v
i = ii
}

3 {
res.has_timestamp_last_password_reset = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp_last_password_reset = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialslastcredentialchangetimeresponse() CCredentialsLastCredentialChangeTimeResponse {
return CCredentialsLastCredentialChangeTimeResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialslastcredentialchangetimeresponse(o CCredentialsLastCredentialChangeTimeResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialslastcredentialchangetimeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsLastCredentialChangeTimeResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialslastcredentialchangetimeresponse_unpack(v)?
return i, unpacked
}
pub struct CCredentialsGetAccountAuthSecretRequest {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CCredentialsGetAccountAuthSecretRequest) pack() []byte {
res := []byte{}
return res
}

pub fn ccredentialsgetaccountauthsecretrequest_unpack(buf []byte) ?CCredentialsGetAccountAuthSecretRequest {
res := CCredentialsGetAccountAuthSecretRequest{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialsgetaccountauthsecretrequest() CCredentialsGetAccountAuthSecretRequest {
return CCredentialsGetAccountAuthSecretRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialsgetaccountauthsecretrequest(o CCredentialsGetAccountAuthSecretRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialsgetaccountauthsecretrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsGetAccountAuthSecretRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialsgetaccountauthsecretrequest_unpack(v)?
return i, unpacked
}
pub struct CCredentialsGetAccountAuthSecretResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
secret_id int
has_secret_id bool
secret []byte
has_secret bool
}
pub fn (o &CCredentialsGetAccountAuthSecretResponse) pack() []byte {
mut res := []byte{}
if o.has_secret_id {
res << vproto.pack_int32_field(o.secret_id, 1)
}

if o.has_secret {
res << vproto.pack_bytes_field(o.secret, 2)
}

return res
}

pub fn ccredentialsgetaccountauthsecretresponse_unpack(buf []byte) ?CCredentialsGetAccountAuthSecretResponse {
mut res := CCredentialsGetAccountAuthSecretResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_secret_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.secret_id = v
i = ii
}

2 {
res.has_secret = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.secret = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccredentialsgetaccountauthsecretresponse() CCredentialsGetAccountAuthSecretResponse {
return CCredentialsGetAccountAuthSecretResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccredentialsgetaccountauthsecretresponse(o CCredentialsGetAccountAuthSecretResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccredentialsgetaccountauthsecretresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCredentialsGetAccountAuthSecretResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ccredentialsgetaccountauthsecretresponse_unpack(v)?
return i, unpacked
}
