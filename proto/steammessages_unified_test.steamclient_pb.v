// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CMsgTestMessageToClientRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	some_text      string
	has_some_text  bool
}

pub fn (o &CMsgTestMessageToClientRequest) pack() []byte {
	mut res := []byte{}
	if o.has_some_text {
		res << vproto.pack_string_field(o.some_text, 1)
	}
	return res
}

pub fn cmsgtestmessagetoclientrequest_unpack(buf []byte) ?CMsgTestMessageToClientRequest {
	mut res := CMsgTestMessageToClientRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_some_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.some_text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtestmessagetoclientrequest() CMsgTestMessageToClientRequest {
	return CMsgTestMessageToClientRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtestmessagetoclientrequest(o CMsgTestMessageToClientRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtestmessagetoclientrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTestMessageToClientRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgtestmessagetoclientrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgTestMessageToClientResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	some_text      string
	has_some_text  bool
}

pub fn (o &CMsgTestMessageToClientResponse) pack() []byte {
	mut res := []byte{}
	if o.has_some_text {
		res << vproto.pack_string_field(o.some_text, 1)
	}
	return res
}

pub fn cmsgtestmessagetoclientresponse_unpack(buf []byte) ?CMsgTestMessageToClientResponse {
	mut res := CMsgTestMessageToClientResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_some_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.some_text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtestmessagetoclientresponse() CMsgTestMessageToClientResponse {
	return CMsgTestMessageToClientResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtestmessagetoclientresponse(o CMsgTestMessageToClientResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtestmessagetoclientresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTestMessageToClientResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgtestmessagetoclientresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgTestNotifyClientNotification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	some_text      string
	has_some_text  bool
}

pub fn (o &CMsgTestNotifyClientNotification) pack() []byte {
	mut res := []byte{}
	if o.has_some_text {
		res << vproto.pack_string_field(o.some_text, 1)
	}
	return res
}

pub fn cmsgtestnotifyclientnotification_unpack(buf []byte) ?CMsgTestNotifyClientNotification {
	mut res := CMsgTestNotifyClientNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_some_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.some_text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtestnotifyclientnotification() CMsgTestNotifyClientNotification {
	return CMsgTestNotifyClientNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtestnotifyclientnotification(o CMsgTestNotifyClientNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtestnotifyclientnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTestNotifyClientNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgtestnotifyclientnotification_unpack(v)?
	return i, unpacked
}

pub struct CMsgTestMessageToServerRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	some_text      string
	has_some_text  bool
}

pub fn (o &CMsgTestMessageToServerRequest) pack() []byte {
	mut res := []byte{}
	if o.has_some_text {
		res << vproto.pack_string_field(o.some_text, 1)
	}
	return res
}

pub fn cmsgtestmessagetoserverrequest_unpack(buf []byte) ?CMsgTestMessageToServerRequest {
	mut res := CMsgTestMessageToServerRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_some_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.some_text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtestmessagetoserverrequest() CMsgTestMessageToServerRequest {
	return CMsgTestMessageToServerRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtestmessagetoserverrequest(o CMsgTestMessageToServerRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtestmessagetoserverrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTestMessageToServerRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgtestmessagetoserverrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgTestMessageToServerResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	some_text      string
	has_some_text  bool
}

pub fn (o &CMsgTestMessageToServerResponse) pack() []byte {
	mut res := []byte{}
	if o.has_some_text {
		res << vproto.pack_string_field(o.some_text, 1)
	}
	return res
}

pub fn cmsgtestmessagetoserverresponse_unpack(buf []byte) ?CMsgTestMessageToServerResponse {
	mut res := CMsgTestMessageToServerResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_some_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.some_text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtestmessagetoserverresponse() CMsgTestMessageToServerResponse {
	return CMsgTestMessageToServerResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtestmessagetoserverresponse(o CMsgTestMessageToServerResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtestmessagetoserverresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTestMessageToServerResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgtestmessagetoserverresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgTestNotifyServerNotification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	some_text      string
	has_some_text  bool
}

pub fn (o &CMsgTestNotifyServerNotification) pack() []byte {
	mut res := []byte{}
	if o.has_some_text {
		res << vproto.pack_string_field(o.some_text, 1)
	}
	return res
}

pub fn cmsgtestnotifyservernotification_unpack(buf []byte) ?CMsgTestNotifyServerNotification {
	mut res := CMsgTestNotifyServerNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_some_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.some_text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtestnotifyservernotification() CMsgTestNotifyServerNotification {
	return CMsgTestNotifyServerNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtestnotifyservernotification(o CMsgTestNotifyServerNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtestnotifyservernotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTestNotifyServerNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgtestnotifyservernotification_unpack(v)?
	return i, unpacked
}
