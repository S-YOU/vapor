
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


[_allow_multiple_values]
enum EPublishedFileRevision {
k_epublishedfilerevision_default = 0
k_epublishedfilerevision_latest = 1
k_epublishedfilerevision_approvedsnapshot = 2
k_epublishedfilerevision_approvedsnapshot_china = 3
k_epublishedfilerevision_rejectedsnapshot = 4
k_epublishedfilerevision_rejectedsnapshot_china = 5
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_epublishedfilerevision(e EPublishedFileRevision, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_epublishedfilerevision(buf []byte, tag_wiretype vproto.WireType) ?(int, EPublishedFileRevision) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, EPublishedFileRevision(v)
}
[_allow_multiple_values]
enum EPublishedFileForSaleStatus {
k_pffss_notforsale = 0
k_pffss_pendingapproval = 1
k_pffss_approvedforsale = 2
k_pffss_rejectedforsale = 3
k_pffss_nolongerforsale = 4
k_pffss_tentativeapproval = 5
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_epublishedfileforsalestatus(e EPublishedFileForSaleStatus, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_epublishedfileforsalestatus(buf []byte, tag_wiretype vproto.WireType) ?(int, EPublishedFileForSaleStatus) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, EPublishedFileForSaleStatus(v)
}
pub struct CPublishedFileSubscribeRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
list_type u32
has_list_type bool
appid int
has_appid bool
notify_client bool
has_notify_client bool
}
pub fn (o &CPublishedFileSubscribeRequest) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_uint64_field(o.publishedfileid, 1)
}

if o.has_list_type {
res << vproto.pack_uint32_field(o.list_type, 2)
}

if o.has_appid {
res << vproto.pack_int32_field(o.appid, 3)
}

if o.has_notify_client {
res << vproto.pack_bool_field(o.notify_client, 4)
}

return res
}

pub fn cpublishedfilesubscriberequest_unpack(buf []byte) ?CPublishedFileSubscribeRequest {
mut res := CPublishedFileSubscribeRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

2 {
res.has_list_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.list_type = v
i = ii
}

3 {
res.has_appid = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

4 {
res.has_notify_client = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.notify_client = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilesubscriberequest() CPublishedFileSubscribeRequest {
return CPublishedFileSubscribeRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilesubscriberequest(o CPublishedFileSubscribeRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilesubscriberequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileSubscribeRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilesubscriberequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileSubscribeResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPublishedFileSubscribeResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpublishedfilesubscriberesponse_unpack(buf []byte) ?CPublishedFileSubscribeResponse {
res := CPublishedFileSubscribeResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilesubscriberesponse() CPublishedFileSubscribeResponse {
return CPublishedFileSubscribeResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilesubscriberesponse(o CPublishedFileSubscribeResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilesubscriberesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileSubscribeResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilesubscriberesponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileUnsubscribeRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
list_type u32
has_list_type bool
appid int
has_appid bool
notify_client bool
has_notify_client bool
}
pub fn (o &CPublishedFileUnsubscribeRequest) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_uint64_field(o.publishedfileid, 1)
}

if o.has_list_type {
res << vproto.pack_uint32_field(o.list_type, 2)
}

if o.has_appid {
res << vproto.pack_int32_field(o.appid, 3)
}

if o.has_notify_client {
res << vproto.pack_bool_field(o.notify_client, 4)
}

return res
}

pub fn cpublishedfileunsubscriberequest_unpack(buf []byte) ?CPublishedFileUnsubscribeRequest {
mut res := CPublishedFileUnsubscribeRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

2 {
res.has_list_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.list_type = v
i = ii
}

3 {
res.has_appid = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

4 {
res.has_notify_client = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.notify_client = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfileunsubscriberequest() CPublishedFileUnsubscribeRequest {
return CPublishedFileUnsubscribeRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfileunsubscriberequest(o CPublishedFileUnsubscribeRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfileunsubscriberequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileUnsubscribeRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfileunsubscriberequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileUnsubscribeResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPublishedFileUnsubscribeResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpublishedfileunsubscriberesponse_unpack(buf []byte) ?CPublishedFileUnsubscribeResponse {
res := CPublishedFileUnsubscribeResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfileunsubscriberesponse() CPublishedFileUnsubscribeResponse {
return CPublishedFileUnsubscribeResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfileunsubscriberesponse(o CPublishedFileUnsubscribeResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfileunsubscriberesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileUnsubscribeResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfileunsubscriberesponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileCanSubscribeRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
}
pub fn (o &CPublishedFileCanSubscribeRequest) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_uint64_field(o.publishedfileid, 1)
}

return res
}

pub fn cpublishedfilecansubscriberequest_unpack(buf []byte) ?CPublishedFileCanSubscribeRequest {
mut res := CPublishedFileCanSubscribeRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilecansubscriberequest() CPublishedFileCanSubscribeRequest {
return CPublishedFileCanSubscribeRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilecansubscriberequest(o CPublishedFileCanSubscribeRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilecansubscriberequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileCanSubscribeRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilecansubscriberequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileCanSubscribeResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
can_subscribe bool
has_can_subscribe bool
}
pub fn (o &CPublishedFileCanSubscribeResponse) pack() []byte {
mut res := []byte{}
if o.has_can_subscribe {
res << vproto.pack_bool_field(o.can_subscribe, 1)
}

return res
}

pub fn cpublishedfilecansubscriberesponse_unpack(buf []byte) ?CPublishedFileCanSubscribeResponse {
mut res := CPublishedFileCanSubscribeResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_can_subscribe = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.can_subscribe = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilecansubscriberesponse() CPublishedFileCanSubscribeResponse {
return CPublishedFileCanSubscribeResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilecansubscriberesponse(o CPublishedFileCanSubscribeResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilecansubscriberesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileCanSubscribeResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilecansubscriberesponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFilePublishRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
consumer_appid u32
has_consumer_appid bool
cloudfilename string
has_cloudfilename bool
preview_cloudfilename string
has_preview_cloudfilename bool
title string
has_title bool
file_description string
has_file_description bool
file_type u32
has_file_type bool
consumer_shortcut_name string
has_consumer_shortcut_name bool
youtube_username string
has_youtube_username bool
youtube_videoid string
has_youtube_videoid bool
visibility u32
has_visibility bool
redirect_uri string
has_redirect_uri bool
tags []string
collection_type string
has_collection_type bool
game_type string
has_game_type bool
url string
has_url bool
}
pub fn (o &CPublishedFilePublishRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_consumer_appid {
res << vproto.pack_uint32_field(o.consumer_appid, 2)
}

if o.has_cloudfilename {
res << vproto.pack_string_field(o.cloudfilename, 3)
}

if o.has_preview_cloudfilename {
res << vproto.pack_string_field(o.preview_cloudfilename, 4)
}

if o.has_title {
res << vproto.pack_string_field(o.title, 5)
}

if o.has_file_description {
res << vproto.pack_string_field(o.file_description, 6)
}

if o.has_file_type {
res << vproto.pack_uint32_field(o.file_type, 7)
}

if o.has_consumer_shortcut_name {
res << vproto.pack_string_field(o.consumer_shortcut_name, 8)
}

if o.has_youtube_username {
res << vproto.pack_string_field(o.youtube_username, 9)
}

if o.has_youtube_videoid {
res << vproto.pack_string_field(o.youtube_videoid, 10)
}

if o.has_visibility {
res << vproto.pack_uint32_field(o.visibility, 11)
}

if o.has_redirect_uri {
res << vproto.pack_string_field(o.redirect_uri, 12)
}

// [packed=false]
for _, x in o.tags {
res << vproto.pack_string_field(x, 13)
}

if o.has_collection_type {
res << vproto.pack_string_field(o.collection_type, 14)
}

if o.has_game_type {
res << vproto.pack_string_field(o.game_type, 15)
}

if o.has_url {
res << vproto.pack_string_field(o.url, 16)
}

return res
}

pub fn cpublishedfilepublishrequest_unpack(buf []byte) ?CPublishedFilePublishRequest {
mut res := CPublishedFilePublishRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_consumer_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.consumer_appid = v
i = ii
}

3 {
res.has_cloudfilename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.cloudfilename = v
i = ii
}

4 {
res.has_preview_cloudfilename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.preview_cloudfilename = v
i = ii
}

5 {
res.has_title = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.title = v
i = ii
}

6 {
res.has_file_description = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_description = v
i = ii
}

7 {
res.has_file_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.file_type = v
i = ii
}

8 {
res.has_consumer_shortcut_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.consumer_shortcut_name = v
i = ii
}

9 {
res.has_youtube_username = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.youtube_username = v
i = ii
}

10 {
res.has_youtube_videoid = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.youtube_videoid = v
i = ii
}

11 {
res.has_visibility = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.visibility = v
i = ii
}

12 {
res.has_redirect_uri = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.redirect_uri = v
i = ii
}

13 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.tags << v
i = ii
}

14 {
res.has_collection_type = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.collection_type = v
i = ii
}

15 {
res.has_game_type = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.game_type = v
i = ii
}

16 {
res.has_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.url = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilepublishrequest() CPublishedFilePublishRequest {
return CPublishedFilePublishRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilepublishrequest(o CPublishedFilePublishRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilepublishrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFilePublishRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilepublishrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFilePublishResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
redirect_uri string
has_redirect_uri bool
}
pub fn (o &CPublishedFilePublishResponse) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_uint64_field(o.publishedfileid, 1)
}

if o.has_redirect_uri {
res << vproto.pack_string_field(o.redirect_uri, 2)
}

return res
}

pub fn cpublishedfilepublishresponse_unpack(buf []byte) ?CPublishedFilePublishResponse {
mut res := CPublishedFilePublishResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

2 {
res.has_redirect_uri = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.redirect_uri = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilepublishresponse() CPublishedFilePublishResponse {
return CPublishedFilePublishResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilepublishresponse(o CPublishedFilePublishResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilepublishresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFilePublishResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilepublishresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetDetailsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileids []u64
includetags bool
has_includetags bool
includeadditionalpreviews bool
has_includeadditionalpreviews bool
includechildren bool
has_includechildren bool
includekvtags bool
has_includekvtags bool
includevotes bool
has_includevotes bool
short_description bool
has_short_description bool
includeforsaledata bool
has_includeforsaledata bool
includemetadata bool
has_includemetadata bool
language int
has_language bool
return_playtime_stats u32
has_return_playtime_stats bool
appid u32
has_appid bool
strip_description_bbcode bool
has_strip_description_bbcode bool
desired_revision EPublishedFileRevision
has_desired_revision bool
includereactions bool
has_includereactions bool
}
pub fn (o &CPublishedFileGetDetailsRequest) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.publishedfileids {
res << vproto.pack_64bit_field(x, 1)
}

if o.has_includetags {
res << vproto.pack_bool_field(o.includetags, 2)
}

if o.has_includeadditionalpreviews {
res << vproto.pack_bool_field(o.includeadditionalpreviews, 3)
}

if o.has_includechildren {
res << vproto.pack_bool_field(o.includechildren, 4)
}

if o.has_includekvtags {
res << vproto.pack_bool_field(o.includekvtags, 5)
}

if o.has_includevotes {
res << vproto.pack_bool_field(o.includevotes, 6)
}

if o.has_short_description {
res << vproto.pack_bool_field(o.short_description, 8)
}

if o.has_includeforsaledata {
res << vproto.pack_bool_field(o.includeforsaledata, 10)
}

if o.has_includemetadata {
res << vproto.pack_bool_field(o.includemetadata, 11)
}

if o.has_language {
res << vproto.pack_int32_field(o.language, 12)
}

if o.has_return_playtime_stats {
res << vproto.pack_uint32_field(o.return_playtime_stats, 13)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 14)
}

if o.has_strip_description_bbcode {
res << vproto.pack_bool_field(o.strip_description_bbcode, 15)
}

if o.has_desired_revision {
res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 16)
}

if o.has_includereactions {
res << vproto.pack_bool_field(o.includereactions, 17)
}

return res
}

pub fn cpublishedfilegetdetailsrequest_unpack(buf []byte) ?CPublishedFileGetDetailsRequest {
mut res := CPublishedFileGetDetailsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileids << v
i = ii
}

2 {
res.has_includetags = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.includetags = v
i = ii
}

3 {
res.has_includeadditionalpreviews = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.includeadditionalpreviews = v
i = ii
}

4 {
res.has_includechildren = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.includechildren = v
i = ii
}

5 {
res.has_includekvtags = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.includekvtags = v
i = ii
}

6 {
res.has_includevotes = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.includevotes = v
i = ii
}

8 {
res.has_short_description = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.short_description = v
i = ii
}

10 {
res.has_includeforsaledata = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.includeforsaledata = v
i = ii
}

11 {
res.has_includemetadata = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.includemetadata = v
i = ii
}

12 {
res.has_language = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

13 {
res.has_return_playtime_stats = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.return_playtime_stats = v
i = ii
}

14 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

15 {
res.has_strip_description_bbcode = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.strip_description_bbcode = v
i = ii
}

16 {
res.has_desired_revision = true
ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
res.desired_revision = v
i = ii
}

17 {
res.has_includereactions = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.includereactions = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetdetailsrequest() CPublishedFileGetDetailsRequest {
return CPublishedFileGetDetailsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetdetailsrequest(o CPublishedFileGetDetailsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetdetailsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetDetailsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetdetailsrequest_unpack(v)?
return i, unpacked
}
pub struct PublishedFileDetailsTag {
mut:
unknown_fields []vproto.UnknownField
pub mut:
tag string
has_tag bool
adminonly bool
has_adminonly bool
}
pub fn (o &PublishedFileDetailsTag) pack() []byte {
mut res := []byte{}
if o.has_tag {
res << vproto.pack_string_field(o.tag, 1)
}

if o.has_adminonly {
res << vproto.pack_bool_field(o.adminonly, 2)
}

return res
}

pub fn publishedfiledetailstag_unpack(buf []byte) ?PublishedFileDetailsTag {
mut res := PublishedFileDetailsTag{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_tag = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.tag = v
i = ii
}

2 {
res.has_adminonly = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.adminonly = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetailstag() PublishedFileDetailsTag {
return PublishedFileDetailsTag{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetailstag(o PublishedFileDetailsTag, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetailstag(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetailsTag) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := publishedfiledetailstag_unpack(v)?
return i, unpacked
}
pub struct PublishedFileDetailsPreview {
mut:
unknown_fields []vproto.UnknownField
pub mut:
previewid u64
has_previewid bool
sortorder u32
has_sortorder bool
url string
has_url bool
size u32
has_size bool
filename string
has_filename bool
youtubevideoid string
has_youtubevideoid bool
preview_type u32
has_preview_type bool
external_reference string
has_external_reference bool
}
pub fn (o &PublishedFileDetailsPreview) pack() []byte {
mut res := []byte{}
if o.has_previewid {
res << vproto.pack_uint64_field(o.previewid, 1)
}

if o.has_sortorder {
res << vproto.pack_uint32_field(o.sortorder, 2)
}

if o.has_url {
res << vproto.pack_string_field(o.url, 3)
}

if o.has_size {
res << vproto.pack_uint32_field(o.size, 4)
}

if o.has_filename {
res << vproto.pack_string_field(o.filename, 5)
}

if o.has_youtubevideoid {
res << vproto.pack_string_field(o.youtubevideoid, 6)
}

if o.has_preview_type {
res << vproto.pack_uint32_field(o.preview_type, 7)
}

if o.has_external_reference {
res << vproto.pack_string_field(o.external_reference, 8)
}

return res
}

pub fn publishedfiledetailspreview_unpack(buf []byte) ?PublishedFileDetailsPreview {
mut res := PublishedFileDetailsPreview{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_previewid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.previewid = v
i = ii
}

2 {
res.has_sortorder = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.sortorder = v
i = ii
}

3 {
res.has_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.url = v
i = ii
}

4 {
res.has_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.size = v
i = ii
}

5 {
res.has_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename = v
i = ii
}

6 {
res.has_youtubevideoid = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.youtubevideoid = v
i = ii
}

7 {
res.has_preview_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.preview_type = v
i = ii
}

8 {
res.has_external_reference = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.external_reference = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetailspreview() PublishedFileDetailsPreview {
return PublishedFileDetailsPreview{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetailspreview(o PublishedFileDetailsPreview, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetailspreview(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetailsPreview) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := publishedfiledetailspreview_unpack(v)?
return i, unpacked
}
pub struct PublishedFileDetailsChild {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
sortorder u32
has_sortorder bool
file_type u32
has_file_type bool
}
pub fn (o &PublishedFileDetailsChild) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_uint64_field(o.publishedfileid, 1)
}

if o.has_sortorder {
res << vproto.pack_uint32_field(o.sortorder, 2)
}

if o.has_file_type {
res << vproto.pack_uint32_field(o.file_type, 3)
}

return res
}

pub fn publishedfiledetailschild_unpack(buf []byte) ?PublishedFileDetailsChild {
mut res := PublishedFileDetailsChild{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

2 {
res.has_sortorder = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.sortorder = v
i = ii
}

3 {
res.has_file_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.file_type = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetailschild() PublishedFileDetailsChild {
return PublishedFileDetailsChild{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetailschild(o PublishedFileDetailsChild, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetailschild(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetailsChild) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := publishedfiledetailschild_unpack(v)?
return i, unpacked
}
pub struct PublishedFileDetailsKVtag {
mut:
unknown_fields []vproto.UnknownField
pub mut:
key string
has_key bool
value string
has_value bool
}
pub fn (o &PublishedFileDetailsKVtag) pack() []byte {
mut res := []byte{}
if o.has_key {
res << vproto.pack_string_field(o.key, 1)
}

if o.has_value {
res << vproto.pack_string_field(o.value, 2)
}

return res
}

pub fn publishedfiledetailskvtag_unpack(buf []byte) ?PublishedFileDetailsKVtag {
mut res := PublishedFileDetailsKVtag{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_key = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.key = v
i = ii
}

2 {
res.has_value = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.value = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetailskvtag() PublishedFileDetailsKVtag {
return PublishedFileDetailsKVtag{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetailskvtag(o PublishedFileDetailsKVtag, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetailskvtag(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetailsKVtag) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := publishedfiledetailskvtag_unpack(v)?
return i, unpacked
}
pub struct PublishedFileDetailsVoteData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
score f32
has_score bool
votes_up u32
has_votes_up bool
votes_down u32
has_votes_down bool
}
pub fn (o &PublishedFileDetailsVoteData) pack() []byte {
mut res := []byte{}
if o.has_score {
res << vproto.pack_float_field(o.score, 1)
}

if o.has_votes_up {
res << vproto.pack_uint32_field(o.votes_up, 2)
}

if o.has_votes_down {
res << vproto.pack_uint32_field(o.votes_down, 3)
}

return res
}

pub fn publishedfiledetailsvotedata_unpack(buf []byte) ?PublishedFileDetailsVoteData {
mut res := PublishedFileDetailsVoteData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_score = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.score = v
i = ii
}

2 {
res.has_votes_up = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.votes_up = v
i = ii
}

3 {
res.has_votes_down = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.votes_down = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetailsvotedata() PublishedFileDetailsVoteData {
return PublishedFileDetailsVoteData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetailsvotedata(o PublishedFileDetailsVoteData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetailsvotedata(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetailsVoteData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := publishedfiledetailsvotedata_unpack(v)?
return i, unpacked
}
pub struct PublishedFileDetailsForSaleData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
is_for_sale bool
has_is_for_sale bool
price_category u32
has_price_category bool
estatus EPublishedFileForSaleStatus
has_estatus bool
price_category_floor u32
has_price_category_floor bool
price_is_pay_what_you_want bool
has_price_is_pay_what_you_want bool
discount_percentage u32
has_discount_percentage bool
}
pub fn (o &PublishedFileDetailsForSaleData) pack() []byte {
mut res := []byte{}
if o.has_is_for_sale {
res << vproto.pack_bool_field(o.is_for_sale, 1)
}

if o.has_price_category {
res << vproto.pack_uint32_field(o.price_category, 2)
}

if o.has_estatus {
res << zzz_vproto_internal_pack_epublishedfileforsalestatus(o.estatus, 3)
}

if o.has_price_category_floor {
res << vproto.pack_uint32_field(o.price_category_floor, 4)
}

if o.has_price_is_pay_what_you_want {
res << vproto.pack_bool_field(o.price_is_pay_what_you_want, 5)
}

if o.has_discount_percentage {
res << vproto.pack_uint32_field(o.discount_percentage, 6)
}

return res
}

pub fn publishedfiledetailsforsaledata_unpack(buf []byte) ?PublishedFileDetailsForSaleData {
mut res := PublishedFileDetailsForSaleData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_is_for_sale = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_for_sale = v
i = ii
}

2 {
res.has_price_category = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.price_category = v
i = ii
}

3 {
res.has_estatus = true
ii, v := zzz_vproto_internal_unpack_epublishedfileforsalestatus(cur_buf, tag_wiretype.wire_type)?
res.estatus = v
i = ii
}

4 {
res.has_price_category_floor = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.price_category_floor = v
i = ii
}

5 {
res.has_price_is_pay_what_you_want = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.price_is_pay_what_you_want = v
i = ii
}

6 {
res.has_discount_percentage = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.discount_percentage = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetailsforsaledata() PublishedFileDetailsForSaleData {
return PublishedFileDetailsForSaleData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetailsforsaledata(o PublishedFileDetailsForSaleData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetailsforsaledata(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetailsForSaleData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := publishedfiledetailsforsaledata_unpack(v)?
return i, unpacked
}
pub struct PublishedFileDetailsPlaytimeStats {
mut:
unknown_fields []vproto.UnknownField
pub mut:
playtime_seconds u64
has_playtime_seconds bool
num_sessions u64
has_num_sessions bool
}
pub fn (o &PublishedFileDetailsPlaytimeStats) pack() []byte {
mut res := []byte{}
if o.has_playtime_seconds {
res << vproto.pack_uint64_field(o.playtime_seconds, 1)
}

if o.has_num_sessions {
res << vproto.pack_uint64_field(o.num_sessions, 2)
}

return res
}

pub fn publishedfiledetailsplaytimestats_unpack(buf []byte) ?PublishedFileDetailsPlaytimeStats {
mut res := PublishedFileDetailsPlaytimeStats{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_playtime_seconds = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.playtime_seconds = v
i = ii
}

2 {
res.has_num_sessions = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.num_sessions = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetailsplaytimestats() PublishedFileDetailsPlaytimeStats {
return PublishedFileDetailsPlaytimeStats{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetailsplaytimestats(o PublishedFileDetailsPlaytimeStats, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetailsplaytimestats(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetailsPlaytimeStats) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := publishedfiledetailsplaytimestats_unpack(v)?
return i, unpacked
}
pub struct PublishedFileDetailsReaction {
mut:
unknown_fields []vproto.UnknownField
pub mut:
reactionid u32
has_reactionid bool
count u32
has_count bool
}
pub fn (o &PublishedFileDetailsReaction) pack() []byte {
mut res := []byte{}
if o.has_reactionid {
res << vproto.pack_uint32_field(o.reactionid, 1)
}

if o.has_count {
res << vproto.pack_uint32_field(o.count, 2)
}

return res
}

pub fn publishedfiledetailsreaction_unpack(buf []byte) ?PublishedFileDetailsReaction {
mut res := PublishedFileDetailsReaction{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_reactionid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.reactionid = v
i = ii
}

2 {
res.has_count = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.count = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetailsreaction() PublishedFileDetailsReaction {
return PublishedFileDetailsReaction{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetailsreaction(o PublishedFileDetailsReaction, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetailsreaction(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetailsReaction) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := publishedfiledetailsreaction_unpack(v)?
return i, unpacked
}
pub struct PublishedFileDetails {
mut:
unknown_fields []vproto.UnknownField
pub mut:
result u32
has_result bool
publishedfileid u64
has_publishedfileid bool
creator u64
has_creator bool
creator_appid u32
has_creator_appid bool
consumer_appid u32
has_consumer_appid bool
consumer_shortcutid u32
has_consumer_shortcutid bool
filename string
has_filename bool
file_size u64
has_file_size bool
preview_file_size u64
has_preview_file_size bool
file_url string
has_file_url bool
preview_url string
has_preview_url bool
youtubevideoid string
has_youtubevideoid bool
url string
has_url bool
hcontent_file u64
has_hcontent_file bool
hcontent_preview u64
has_hcontent_preview bool
title string
has_title bool
file_description string
has_file_description bool
short_description string
has_short_description bool
time_created u32
has_time_created bool
time_updated u32
has_time_updated bool
visibility u32
has_visibility bool
flags u32
has_flags bool
workshop_file bool
has_workshop_file bool
workshop_accepted bool
has_workshop_accepted bool
show_subscribe_all bool
has_show_subscribe_all bool
num_comments_developer int
has_num_comments_developer bool
num_comments_public int
has_num_comments_public bool
banned bool
has_banned bool
ban_reason string
has_ban_reason bool
banner u64
has_banner bool
can_be_deleted bool
has_can_be_deleted bool
incompatible bool
has_incompatible bool
app_name string
has_app_name bool
file_type u32
has_file_type bool
can_subscribe bool
has_can_subscribe bool
subscriptions u32
has_subscriptions bool
favorited u32
has_favorited bool
followers u32
has_followers bool
lifetime_subscriptions u32
has_lifetime_subscriptions bool
lifetime_favorited u32
has_lifetime_favorited bool
lifetime_followers u32
has_lifetime_followers bool
lifetime_playtime u64
has_lifetime_playtime bool
lifetime_playtime_sessions u64
has_lifetime_playtime_sessions bool
views u32
has_views bool
image_width u32
has_image_width bool
image_height u32
has_image_height bool
image_url string
has_image_url bool
spoiler_tag bool
has_spoiler_tag bool
shortcutid u32
has_shortcutid bool
shortcutname string
has_shortcutname bool
num_children u32
has_num_children bool
num_reports u32
has_num_reports bool
previews []PublishedFileDetailsPreview
tags []PublishedFileDetailsTag
children []PublishedFileDetailsChild
kvtags []PublishedFileDetailsKVtag
vote_data PublishedFileDetailsVoteData
has_vote_data bool
playtime_stats PublishedFileDetailsPlaytimeStats
has_playtime_stats bool
time_subscribed u32
has_time_subscribed bool
for_sale_data PublishedFileDetailsForSaleData
has_for_sale_data bool
metadata string
has_metadata bool
language int
has_language bool
maybe_inappropriate_sex bool
has_maybe_inappropriate_sex bool
maybe_inappropriate_violence bool
has_maybe_inappropriate_violence bool
revision_change_number u64
has_revision_change_number bool
revision EPublishedFileRevision
has_revision bool
available_revisions []EPublishedFileRevision
reactions []PublishedFileDetailsReaction
}
pub fn (o &PublishedFileDetails) pack() []byte {
mut res := []byte{}
if o.has_result {
res << vproto.pack_uint32_field(o.result, 1)
}

if o.has_publishedfileid {
res << vproto.pack_uint64_field(o.publishedfileid, 2)
}

if o.has_creator {
res << vproto.pack_64bit_field(o.creator, 3)
}

if o.has_creator_appid {
res << vproto.pack_uint32_field(o.creator_appid, 4)
}

if o.has_consumer_appid {
res << vproto.pack_uint32_field(o.consumer_appid, 5)
}

if o.has_consumer_shortcutid {
res << vproto.pack_uint32_field(o.consumer_shortcutid, 6)
}

if o.has_filename {
res << vproto.pack_string_field(o.filename, 7)
}

if o.has_file_size {
res << vproto.pack_uint64_field(o.file_size, 8)
}

if o.has_preview_file_size {
res << vproto.pack_uint64_field(o.preview_file_size, 9)
}

if o.has_file_url {
res << vproto.pack_string_field(o.file_url, 10)
}

if o.has_preview_url {
res << vproto.pack_string_field(o.preview_url, 11)
}

if o.has_youtubevideoid {
res << vproto.pack_string_field(o.youtubevideoid, 12)
}

if o.has_url {
res << vproto.pack_string_field(o.url, 13)
}

if o.has_hcontent_file {
res << vproto.pack_64bit_field(o.hcontent_file, 14)
}

if o.has_hcontent_preview {
res << vproto.pack_64bit_field(o.hcontent_preview, 15)
}

if o.has_title {
res << vproto.pack_string_field(o.title, 16)
}

if o.has_file_description {
res << vproto.pack_string_field(o.file_description, 17)
}

if o.has_short_description {
res << vproto.pack_string_field(o.short_description, 18)
}

if o.has_time_created {
res << vproto.pack_uint32_field(o.time_created, 19)
}

if o.has_time_updated {
res << vproto.pack_uint32_field(o.time_updated, 20)
}

if o.has_visibility {
res << vproto.pack_uint32_field(o.visibility, 21)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 22)
}

if o.has_workshop_file {
res << vproto.pack_bool_field(o.workshop_file, 23)
}

if o.has_workshop_accepted {
res << vproto.pack_bool_field(o.workshop_accepted, 24)
}

if o.has_show_subscribe_all {
res << vproto.pack_bool_field(o.show_subscribe_all, 25)
}

if o.has_num_comments_developer {
res << vproto.pack_int32_field(o.num_comments_developer, 26)
}

if o.has_num_comments_public {
res << vproto.pack_int32_field(o.num_comments_public, 27)
}

if o.has_banned {
res << vproto.pack_bool_field(o.banned, 28)
}

if o.has_ban_reason {
res << vproto.pack_string_field(o.ban_reason, 29)
}

if o.has_banner {
res << vproto.pack_64bit_field(o.banner, 30)
}

if o.has_can_be_deleted {
res << vproto.pack_bool_field(o.can_be_deleted, 31)
}

if o.has_incompatible {
res << vproto.pack_bool_field(o.incompatible, 32)
}

if o.has_app_name {
res << vproto.pack_string_field(o.app_name, 33)
}

if o.has_file_type {
res << vproto.pack_uint32_field(o.file_type, 34)
}

if o.has_can_subscribe {
res << vproto.pack_bool_field(o.can_subscribe, 35)
}

if o.has_subscriptions {
res << vproto.pack_uint32_field(o.subscriptions, 36)
}

if o.has_favorited {
res << vproto.pack_uint32_field(o.favorited, 37)
}

if o.has_followers {
res << vproto.pack_uint32_field(o.followers, 38)
}

if o.has_lifetime_subscriptions {
res << vproto.pack_uint32_field(o.lifetime_subscriptions, 39)
}

if o.has_lifetime_favorited {
res << vproto.pack_uint32_field(o.lifetime_favorited, 40)
}

if o.has_lifetime_followers {
res << vproto.pack_uint32_field(o.lifetime_followers, 41)
}

if o.has_lifetime_playtime {
res << vproto.pack_uint64_field(o.lifetime_playtime, 62)
}

if o.has_lifetime_playtime_sessions {
res << vproto.pack_uint64_field(o.lifetime_playtime_sessions, 63)
}

if o.has_views {
res << vproto.pack_uint32_field(o.views, 42)
}

if o.has_image_width {
res << vproto.pack_uint32_field(o.image_width, 43)
}

if o.has_image_height {
res << vproto.pack_uint32_field(o.image_height, 44)
}

if o.has_image_url {
res << vproto.pack_string_field(o.image_url, 45)
}

if o.has_spoiler_tag {
res << vproto.pack_bool_field(o.spoiler_tag, 46)
}

if o.has_shortcutid {
res << vproto.pack_uint32_field(o.shortcutid, 47)
}

if o.has_shortcutname {
res << vproto.pack_string_field(o.shortcutname, 48)
}

if o.has_num_children {
res << vproto.pack_uint32_field(o.num_children, 49)
}

if o.has_num_reports {
res << vproto.pack_uint32_field(o.num_reports, 50)
}

// [packed=false]
for _, x in o.previews {
res << zzz_vproto_internal_pack_publishedfiledetailspreview(x, 51)
}

// [packed=false]
for _, x in o.tags {
res << zzz_vproto_internal_pack_publishedfiledetailstag(x, 52)
}

// [packed=false]
for _, x in o.children {
res << zzz_vproto_internal_pack_publishedfiledetailschild(x, 53)
}

// [packed=false]
for _, x in o.kvtags {
res << zzz_vproto_internal_pack_publishedfiledetailskvtag(x, 54)
}

if o.has_vote_data {
res << zzz_vproto_internal_pack_publishedfiledetailsvotedata(o.vote_data, 55)
}

if o.has_playtime_stats {
res << zzz_vproto_internal_pack_publishedfiledetailsplaytimestats(o.playtime_stats, 64)
}

if o.has_time_subscribed {
res << vproto.pack_uint32_field(o.time_subscribed, 56)
}

if o.has_for_sale_data {
res << zzz_vproto_internal_pack_publishedfiledetailsforsaledata(o.for_sale_data, 57)
}

if o.has_metadata {
res << vproto.pack_string_field(o.metadata, 58)
}

if o.has_language {
res << vproto.pack_int32_field(o.language, 61)
}

if o.has_maybe_inappropriate_sex {
res << vproto.pack_bool_field(o.maybe_inappropriate_sex, 65)
}

if o.has_maybe_inappropriate_violence {
res << vproto.pack_bool_field(o.maybe_inappropriate_violence, 66)
}

if o.has_revision_change_number {
res << vproto.pack_uint64_field(o.revision_change_number, 67)
}

if o.has_revision {
res << zzz_vproto_internal_pack_epublishedfilerevision(o.revision, 68)
}

// [packed=false]
for _, x in o.available_revisions {
res << zzz_vproto_internal_pack_epublishedfilerevision(x, 69)
}

// [packed=false]
for _, x in o.reactions {
res << zzz_vproto_internal_pack_publishedfiledetailsreaction(x, 70)
}

return res
}

pub fn publishedfiledetails_unpack(buf []byte) ?PublishedFileDetails {
mut res := PublishedFileDetails{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_result = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.result = v
i = ii
}

2 {
res.has_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

3 {
res.has_creator = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.creator = v
i = ii
}

4 {
res.has_creator_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.creator_appid = v
i = ii
}

5 {
res.has_consumer_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.consumer_appid = v
i = ii
}

6 {
res.has_consumer_shortcutid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.consumer_shortcutid = v
i = ii
}

7 {
res.has_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename = v
i = ii
}

8 {
res.has_file_size = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.file_size = v
i = ii
}

9 {
res.has_preview_file_size = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.preview_file_size = v
i = ii
}

10 {
res.has_file_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_url = v
i = ii
}

11 {
res.has_preview_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.preview_url = v
i = ii
}

12 {
res.has_youtubevideoid = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.youtubevideoid = v
i = ii
}

13 {
res.has_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.url = v
i = ii
}

14 {
res.has_hcontent_file = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.hcontent_file = v
i = ii
}

15 {
res.has_hcontent_preview = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.hcontent_preview = v
i = ii
}

16 {
res.has_title = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.title = v
i = ii
}

17 {
res.has_file_description = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_description = v
i = ii
}

18 {
res.has_short_description = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.short_description = v
i = ii
}

19 {
res.has_time_created = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_created = v
i = ii
}

20 {
res.has_time_updated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_updated = v
i = ii
}

21 {
res.has_visibility = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.visibility = v
i = ii
}

22 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

23 {
res.has_workshop_file = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.workshop_file = v
i = ii
}

24 {
res.has_workshop_accepted = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.workshop_accepted = v
i = ii
}

25 {
res.has_show_subscribe_all = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.show_subscribe_all = v
i = ii
}

26 {
res.has_num_comments_developer = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.num_comments_developer = v
i = ii
}

27 {
res.has_num_comments_public = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.num_comments_public = v
i = ii
}

28 {
res.has_banned = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.banned = v
i = ii
}

29 {
res.has_ban_reason = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.ban_reason = v
i = ii
}

30 {
res.has_banner = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.banner = v
i = ii
}

31 {
res.has_can_be_deleted = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.can_be_deleted = v
i = ii
}

32 {
res.has_incompatible = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.incompatible = v
i = ii
}

33 {
res.has_app_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.app_name = v
i = ii
}

34 {
res.has_file_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.file_type = v
i = ii
}

35 {
res.has_can_subscribe = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.can_subscribe = v
i = ii
}

36 {
res.has_subscriptions = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.subscriptions = v
i = ii
}

37 {
res.has_favorited = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.favorited = v
i = ii
}

38 {
res.has_followers = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.followers = v
i = ii
}

39 {
res.has_lifetime_subscriptions = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.lifetime_subscriptions = v
i = ii
}

40 {
res.has_lifetime_favorited = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.lifetime_favorited = v
i = ii
}

41 {
res.has_lifetime_followers = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.lifetime_followers = v
i = ii
}

62 {
res.has_lifetime_playtime = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.lifetime_playtime = v
i = ii
}

63 {
res.has_lifetime_playtime_sessions = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.lifetime_playtime_sessions = v
i = ii
}

42 {
res.has_views = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.views = v
i = ii
}

43 {
res.has_image_width = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.image_width = v
i = ii
}

44 {
res.has_image_height = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.image_height = v
i = ii
}

45 {
res.has_image_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.image_url = v
i = ii
}

46 {
res.has_spoiler_tag = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.spoiler_tag = v
i = ii
}

47 {
res.has_shortcutid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.shortcutid = v
i = ii
}

48 {
res.has_shortcutname = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.shortcutname = v
i = ii
}

49 {
res.has_num_children = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.num_children = v
i = ii
}

50 {
res.has_num_reports = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.num_reports = v
i = ii
}

51 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_publishedfiledetailspreview(cur_buf, tag_wiretype.wire_type)?
res.previews << v
i = ii
}

52 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_publishedfiledetailstag(cur_buf, tag_wiretype.wire_type)?
res.tags << v
i = ii
}

53 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_publishedfiledetailschild(cur_buf, tag_wiretype.wire_type)?
res.children << v
i = ii
}

54 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_publishedfiledetailskvtag(cur_buf, tag_wiretype.wire_type)?
res.kvtags << v
i = ii
}

55 {
res.has_vote_data = true
ii, v := zzz_vproto_internal_unpack_publishedfiledetailsvotedata(cur_buf, tag_wiretype.wire_type)?
res.vote_data = v
i = ii
}

64 {
res.has_playtime_stats = true
ii, v := zzz_vproto_internal_unpack_publishedfiledetailsplaytimestats(cur_buf, tag_wiretype.wire_type)?
res.playtime_stats = v
i = ii
}

56 {
res.has_time_subscribed = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_subscribed = v
i = ii
}

57 {
res.has_for_sale_data = true
ii, v := zzz_vproto_internal_unpack_publishedfiledetailsforsaledata(cur_buf, tag_wiretype.wire_type)?
res.for_sale_data = v
i = ii
}

58 {
res.has_metadata = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.metadata = v
i = ii
}

61 {
res.has_language = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

65 {
res.has_maybe_inappropriate_sex = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.maybe_inappropriate_sex = v
i = ii
}

66 {
res.has_maybe_inappropriate_violence = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.maybe_inappropriate_violence = v
i = ii
}

67 {
res.has_revision_change_number = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.revision_change_number = v
i = ii
}

68 {
res.has_revision = true
ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
res.revision = v
i = ii
}

69 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
res.available_revisions << v
i = ii
}

70 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_publishedfiledetailsreaction(cur_buf, tag_wiretype.wire_type)?
res.reactions << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetails() PublishedFileDetails {
return PublishedFileDetails{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetails(o PublishedFileDetails, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetails(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := publishedfiledetails_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetDetailsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfiledetails []PublishedFileDetails
}
pub fn (o &CPublishedFileGetDetailsResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.publishedfiledetails {
res << zzz_vproto_internal_pack_publishedfiledetails(x, 1)
}

return res
}

pub fn cpublishedfilegetdetailsresponse_unpack(buf []byte) ?CPublishedFileGetDetailsResponse {
mut res := CPublishedFileGetDetailsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_publishedfiledetails(cur_buf, tag_wiretype.wire_type)?
res.publishedfiledetails << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetdetailsresponse() CPublishedFileGetDetailsResponse {
return CPublishedFileGetDetailsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetdetailsresponse(o CPublishedFileGetDetailsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetdetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetDetailsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetdetailsresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetItemInfoRequestWorkshopItem {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
time_updated u32
has_time_updated bool
desired_revision EPublishedFileRevision
has_desired_revision bool
}
pub fn (o &CPublishedFileGetItemInfoRequestWorkshopItem) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_time_updated {
res << vproto.pack_uint32_field(o.time_updated, 2)
}

if o.has_desired_revision {
res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 3)
}

return res
}

pub fn cpublishedfilegetiteminforequestworkshopitem_unpack(buf []byte) ?CPublishedFileGetItemInfoRequestWorkshopItem {
mut res := CPublishedFileGetItemInfoRequestWorkshopItem{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_time_updated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_updated = v
i = ii
}

3 {
res.has_desired_revision = true
ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
res.desired_revision = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetiteminforequestworkshopitem() CPublishedFileGetItemInfoRequestWorkshopItem {
return CPublishedFileGetItemInfoRequestWorkshopItem{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetiteminforequestworkshopitem(o CPublishedFileGetItemInfoRequestWorkshopItem, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetiteminforequestworkshopitem(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetItemInfoRequestWorkshopItem) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetiteminforequestworkshopitem_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetItemInfoRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
last_time_updated u32
has_last_time_updated bool
workshop_items []CPublishedFileGetItemInfoRequestWorkshopItem
}
pub fn (o &CPublishedFileGetItemInfoRequest) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_last_time_updated {
res << vproto.pack_uint32_field(o.last_time_updated, 2)
}

// [packed=false]
for _, x in o.workshop_items {
res << zzz_vproto_internal_pack_cpublishedfilegetiteminforequestworkshopitem(x, 3)
}

return res
}

pub fn cpublishedfilegetiteminforequest_unpack(buf []byte) ?CPublishedFileGetItemInfoRequest {
mut res := CPublishedFileGetItemInfoRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_last_time_updated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_time_updated = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpublishedfilegetiteminforequestworkshopitem(cur_buf, tag_wiretype.wire_type)?
res.workshop_items << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetiteminforequest() CPublishedFileGetItemInfoRequest {
return CPublishedFileGetItemInfoRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetiteminforequest(o CPublishedFileGetItemInfoRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetiteminforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetItemInfoRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetiteminforequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetItemInfoResponseWorkshopItemInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
time_updated u32
has_time_updated bool
manifest_id u64
has_manifest_id bool
flags u32
has_flags bool
}
pub fn (o &CPublishedFileGetItemInfoResponseWorkshopItemInfo) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_time_updated {
res << vproto.pack_uint32_field(o.time_updated, 2)
}

if o.has_manifest_id {
res << vproto.pack_64bit_field(o.manifest_id, 3)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 4)
}

return res
}

pub fn cpublishedfilegetiteminforesponseworkshopiteminfo_unpack(buf []byte) ?CPublishedFileGetItemInfoResponseWorkshopItemInfo {
mut res := CPublishedFileGetItemInfoResponseWorkshopItemInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_time_updated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_updated = v
i = ii
}

3 {
res.has_manifest_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.manifest_id = v
i = ii
}

4 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetiteminforesponseworkshopiteminfo() CPublishedFileGetItemInfoResponseWorkshopItemInfo {
return CPublishedFileGetItemInfoResponseWorkshopItemInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetiteminforesponseworkshopiteminfo(o CPublishedFileGetItemInfoResponseWorkshopItemInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetiteminforesponseworkshopiteminfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetItemInfoResponseWorkshopItemInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetiteminforesponseworkshopiteminfo_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetItemInfoResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
update_time u32
has_update_time bool
workshop_items []CPublishedFileGetItemInfoResponseWorkshopItemInfo
private_items []u64
}
pub fn (o &CPublishedFileGetItemInfoResponse) pack() []byte {
mut res := []byte{}
if o.has_update_time {
res << vproto.pack_uint32_field(o.update_time, 1)
}

// [packed=false]
for _, x in o.workshop_items {
res << zzz_vproto_internal_pack_cpublishedfilegetiteminforesponseworkshopiteminfo(x, 2)
}

// [packed=false]
for _, x in o.private_items {
res << vproto.pack_64bit_field(x, 3)
}

return res
}

pub fn cpublishedfilegetiteminforesponse_unpack(buf []byte) ?CPublishedFileGetItemInfoResponse {
mut res := CPublishedFileGetItemInfoResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_update_time = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.update_time = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpublishedfilegetiteminforesponseworkshopiteminfo(cur_buf, tag_wiretype.wire_type)?
res.workshop_items << v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.private_items << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetiteminforesponse() CPublishedFileGetItemInfoResponse {
return CPublishedFileGetItemInfoResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetiteminforesponse(o CPublishedFileGetItemInfoResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetiteminforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetItemInfoResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetiteminforesponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetUserFilesRequestKVtag {
mut:
unknown_fields []vproto.UnknownField
pub mut:
key string
has_key bool
value string
has_value bool
}
pub fn (o &CPublishedFileGetUserFilesRequestKVtag) pack() []byte {
mut res := []byte{}
if o.has_key {
res << vproto.pack_string_field(o.key, 1)
}

if o.has_value {
res << vproto.pack_string_field(o.value, 2)
}

return res
}

pub fn cpublishedfilegetuserfilesrequestkvtag_unpack(buf []byte) ?CPublishedFileGetUserFilesRequestKVtag {
mut res := CPublishedFileGetUserFilesRequestKVtag{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_key = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.key = v
i = ii
}

2 {
res.has_value = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.value = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetuserfilesrequestkvtag() CPublishedFileGetUserFilesRequestKVtag {
return CPublishedFileGetUserFilesRequestKVtag{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetuserfilesrequestkvtag(o CPublishedFileGetUserFilesRequestKVtag, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetuserfilesrequestkvtag(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetUserFilesRequestKVtag) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetuserfilesrequestkvtag_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetUserFilesRequestTagGroup {
mut:
unknown_fields []vproto.UnknownField
pub mut:
tags []string
}
pub fn (o &CPublishedFileGetUserFilesRequestTagGroup) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.tags {
res << vproto.pack_string_field(x, 1)
}

return res
}

pub fn cpublishedfilegetuserfilesrequesttaggroup_unpack(buf []byte) ?CPublishedFileGetUserFilesRequestTagGroup {
mut res := CPublishedFileGetUserFilesRequestTagGroup{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.tags << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetuserfilesrequesttaggroup() CPublishedFileGetUserFilesRequestTagGroup {
return CPublishedFileGetUserFilesRequestTagGroup{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetuserfilesrequesttaggroup(o CPublishedFileGetUserFilesRequestTagGroup, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetuserfilesrequesttaggroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetUserFilesRequestTagGroup) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetuserfilesrequesttaggroup_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetUserFilesRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
appid u32
has_appid bool
page u32
has_page bool
numperpage u32
has_numperpage bool
@type string
has_type bool
sortmethod string
has_sortmethod bool
privacy u32
has_privacy bool
requiredtags []string
excludedtags []string
required_kv_tags []CPublishedFileGetUserFilesRequestKVtag
filetype u32
has_filetype bool
creator_appid u32
has_creator_appid bool
match_cloud_filename string
has_match_cloud_filename bool
cache_max_age_seconds u32
has_cache_max_age_seconds bool
language int
has_language bool
taggroups []CPublishedFileGetUserFilesRequestTagGroup
totalonly bool
has_totalonly bool
ids_only bool
has_ids_only bool
return_vote_data bool
has_return_vote_data bool
return_tags bool
has_return_tags bool
return_kv_tags bool
has_return_kv_tags bool
return_previews bool
has_return_previews bool
return_children bool
has_return_children bool
return_short_description bool
has_return_short_description bool
return_for_sale_data bool
has_return_for_sale_data bool
return_metadata bool
has_return_metadata bool
return_playtime_stats u32
has_return_playtime_stats bool
strip_description_bbcode bool
has_strip_description_bbcode bool
return_reactions bool
has_return_reactions bool
desired_revision EPublishedFileRevision
has_desired_revision bool
}
pub fn (o &CPublishedFileGetUserFilesRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 2)
}

if o.has_page {
res << vproto.pack_uint32_field(o.page, 4)
}

if o.has_numperpage {
res << vproto.pack_uint32_field(o.numperpage, 5)
}

if o.has_type {
res << vproto.pack_string_field(o.@type, 6)
}

if o.has_sortmethod {
res << vproto.pack_string_field(o.sortmethod, 7)
}

if o.has_privacy {
res << vproto.pack_uint32_field(o.privacy, 9)
}

// [packed=false]
for _, x in o.requiredtags {
res << vproto.pack_string_field(x, 10)
}

// [packed=false]
for _, x in o.excludedtags {
res << vproto.pack_string_field(x, 11)
}

// [packed=false]
for _, x in o.required_kv_tags {
res << zzz_vproto_internal_pack_cpublishedfilegetuserfilesrequestkvtag(x, 30)
}

if o.has_filetype {
res << vproto.pack_uint32_field(o.filetype, 14)
}

if o.has_creator_appid {
res << vproto.pack_uint32_field(o.creator_appid, 15)
}

if o.has_match_cloud_filename {
res << vproto.pack_string_field(o.match_cloud_filename, 16)
}

if o.has_cache_max_age_seconds {
res << vproto.pack_uint32_field(o.cache_max_age_seconds, 27)
}

if o.has_language {
res << vproto.pack_int32_field(o.language, 29)
}

// [packed=false]
for _, x in o.taggroups {
res << zzz_vproto_internal_pack_cpublishedfilegetuserfilesrequesttaggroup(x, 34)
}

if o.has_totalonly {
res << vproto.pack_bool_field(o.totalonly, 17)
}

if o.has_ids_only {
res << vproto.pack_bool_field(o.ids_only, 18)
}

if o.has_return_vote_data {
res << vproto.pack_bool_field(o.return_vote_data, 19)
}

if o.has_return_tags {
res << vproto.pack_bool_field(o.return_tags, 20)
}

if o.has_return_kv_tags {
res << vproto.pack_bool_field(o.return_kv_tags, 21)
}

if o.has_return_previews {
res << vproto.pack_bool_field(o.return_previews, 22)
}

if o.has_return_children {
res << vproto.pack_bool_field(o.return_children, 23)
}

if o.has_return_short_description {
res << vproto.pack_bool_field(o.return_short_description, 24)
}

if o.has_return_for_sale_data {
res << vproto.pack_bool_field(o.return_for_sale_data, 26)
}

if o.has_return_metadata {
res << vproto.pack_bool_field(o.return_metadata, 28)
}

if o.has_return_playtime_stats {
res << vproto.pack_uint32_field(o.return_playtime_stats, 31)
}

if o.has_strip_description_bbcode {
res << vproto.pack_bool_field(o.strip_description_bbcode, 32)
}

if o.has_return_reactions {
res << vproto.pack_bool_field(o.return_reactions, 35)
}

if o.has_desired_revision {
res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 33)
}

return res
}

pub fn cpublishedfilegetuserfilesrequest_unpack(buf []byte) ?CPublishedFileGetUserFilesRequest {
mut res := CPublishedFileGetUserFilesRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

4 {
res.has_page = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.page = v
i = ii
}

5 {
res.has_numperpage = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.numperpage = v
i = ii
}

6 {
res.has_type = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.@type = v
i = ii
}

7 {
res.has_sortmethod = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.sortmethod = v
i = ii
}

9 {
res.has_privacy = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.privacy = v
i = ii
}

10 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.requiredtags << v
i = ii
}

11 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.excludedtags << v
i = ii
}

30 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpublishedfilegetuserfilesrequestkvtag(cur_buf, tag_wiretype.wire_type)?
res.required_kv_tags << v
i = ii
}

14 {
res.has_filetype = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.filetype = v
i = ii
}

15 {
res.has_creator_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.creator_appid = v
i = ii
}

16 {
res.has_match_cloud_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.match_cloud_filename = v
i = ii
}

27 {
res.has_cache_max_age_seconds = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cache_max_age_seconds = v
i = ii
}

29 {
res.has_language = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

34 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpublishedfilegetuserfilesrequesttaggroup(cur_buf, tag_wiretype.wire_type)?
res.taggroups << v
i = ii
}

17 {
res.has_totalonly = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.totalonly = v
i = ii
}

18 {
res.has_ids_only = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.ids_only = v
i = ii
}

19 {
res.has_return_vote_data = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_vote_data = v
i = ii
}

20 {
res.has_return_tags = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_tags = v
i = ii
}

21 {
res.has_return_kv_tags = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_kv_tags = v
i = ii
}

22 {
res.has_return_previews = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_previews = v
i = ii
}

23 {
res.has_return_children = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_children = v
i = ii
}

24 {
res.has_return_short_description = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_short_description = v
i = ii
}

26 {
res.has_return_for_sale_data = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_for_sale_data = v
i = ii
}

28 {
res.has_return_metadata = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_metadata = v
i = ii
}

31 {
res.has_return_playtime_stats = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.return_playtime_stats = v
i = ii
}

32 {
res.has_strip_description_bbcode = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.strip_description_bbcode = v
i = ii
}

35 {
res.has_return_reactions = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_reactions = v
i = ii
}

33 {
res.has_desired_revision = true
ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
res.desired_revision = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetuserfilesrequest() CPublishedFileGetUserFilesRequest {
return CPublishedFileGetUserFilesRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetuserfilesrequest(o CPublishedFileGetUserFilesRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetuserfilesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetUserFilesRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetuserfilesrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetUserFilesResponseApp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
name string
has_name bool
shortcutid u32
has_shortcutid bool
private bool
has_private bool
}
pub fn (o &CPublishedFileGetUserFilesResponseApp) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_name {
res << vproto.pack_string_field(o.name, 2)
}

if o.has_shortcutid {
res << vproto.pack_uint32_field(o.shortcutid, 3)
}

if o.has_private {
res << vproto.pack_bool_field(o.private, 4)
}

return res
}

pub fn cpublishedfilegetuserfilesresponseapp_unpack(buf []byte) ?CPublishedFileGetUserFilesResponseApp {
mut res := CPublishedFileGetUserFilesResponseApp{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

3 {
res.has_shortcutid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.shortcutid = v
i = ii
}

4 {
res.has_private = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.private = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetuserfilesresponseapp() CPublishedFileGetUserFilesResponseApp {
return CPublishedFileGetUserFilesResponseApp{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetuserfilesresponseapp(o CPublishedFileGetUserFilesResponseApp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetuserfilesresponseapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetUserFilesResponseApp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetuserfilesresponseapp_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetUserFilesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
total u32
has_total bool
startindex u32
has_startindex bool
publishedfiledetails []PublishedFileDetails
apps []CPublishedFileGetUserFilesResponseApp
}
pub fn (o &CPublishedFileGetUserFilesResponse) pack() []byte {
mut res := []byte{}
if o.has_total {
res << vproto.pack_uint32_field(o.total, 1)
}

if o.has_startindex {
res << vproto.pack_uint32_field(o.startindex, 2)
}

// [packed=false]
for _, x in o.publishedfiledetails {
res << zzz_vproto_internal_pack_publishedfiledetails(x, 3)
}

// [packed=false]
for _, x in o.apps {
res << zzz_vproto_internal_pack_cpublishedfilegetuserfilesresponseapp(x, 4)
}

return res
}

pub fn cpublishedfilegetuserfilesresponse_unpack(buf []byte) ?CPublishedFileGetUserFilesResponse {
mut res := CPublishedFileGetUserFilesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_total = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.total = v
i = ii
}

2 {
res.has_startindex = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.startindex = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_publishedfiledetails(cur_buf, tag_wiretype.wire_type)?
res.publishedfiledetails << v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpublishedfilegetuserfilesresponseapp(cur_buf, tag_wiretype.wire_type)?
res.apps << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetuserfilesresponse() CPublishedFileGetUserFilesResponse {
return CPublishedFileGetUserFilesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetuserfilesresponse(o CPublishedFileGetUserFilesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetuserfilesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetUserFilesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetuserfilesresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileAreFilesInSubscriptionListRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
publishedfileids []u64
listtype u32
has_listtype bool
filetype u32
has_filetype bool
workshopfiletype u32
has_workshopfiletype bool
}
pub fn (o &CPublishedFileAreFilesInSubscriptionListRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

// [packed=false]
for _, x in o.publishedfileids {
res << vproto.pack_64bit_field(x, 2)
}

if o.has_listtype {
res << vproto.pack_uint32_field(o.listtype, 3)
}

if o.has_filetype {
res << vproto.pack_uint32_field(o.filetype, 4)
}

if o.has_workshopfiletype {
res << vproto.pack_uint32_field(o.workshopfiletype, 5)
}

return res
}

pub fn cpublishedfilearefilesinsubscriptionlistrequest_unpack(buf []byte) ?CPublishedFileAreFilesInSubscriptionListRequest {
mut res := CPublishedFileAreFilesInSubscriptionListRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileids << v
i = ii
}

3 {
res.has_listtype = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.listtype = v
i = ii
}

4 {
res.has_filetype = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.filetype = v
i = ii
}

5 {
res.has_workshopfiletype = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.workshopfiletype = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilearefilesinsubscriptionlistrequest() CPublishedFileAreFilesInSubscriptionListRequest {
return CPublishedFileAreFilesInSubscriptionListRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilearefilesinsubscriptionlistrequest(o CPublishedFileAreFilesInSubscriptionListRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilearefilesinsubscriptionlistrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileAreFilesInSubscriptionListRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilearefilesinsubscriptionlistrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileAreFilesInSubscriptionListResponseInList {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
inlist bool
has_inlist bool
}
pub fn (o &CPublishedFileAreFilesInSubscriptionListResponseInList) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_64bit_field(o.publishedfileid, 1)
}

if o.has_inlist {
res << vproto.pack_bool_field(o.inlist, 2)
}

return res
}

pub fn cpublishedfilearefilesinsubscriptionlistresponseinlist_unpack(buf []byte) ?CPublishedFileAreFilesInSubscriptionListResponseInList {
mut res := CPublishedFileAreFilesInSubscriptionListResponseInList{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

2 {
res.has_inlist = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.inlist = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilearefilesinsubscriptionlistresponseinlist() CPublishedFileAreFilesInSubscriptionListResponseInList {
return CPublishedFileAreFilesInSubscriptionListResponseInList{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilearefilesinsubscriptionlistresponseinlist(o CPublishedFileAreFilesInSubscriptionListResponseInList, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilearefilesinsubscriptionlistresponseinlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileAreFilesInSubscriptionListResponseInList) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilearefilesinsubscriptionlistresponseinlist_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileAreFilesInSubscriptionListResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
files []CPublishedFileAreFilesInSubscriptionListResponseInList
}
pub fn (o &CPublishedFileAreFilesInSubscriptionListResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.files {
res << zzz_vproto_internal_pack_cpublishedfilearefilesinsubscriptionlistresponseinlist(x, 1)
}

return res
}

pub fn cpublishedfilearefilesinsubscriptionlistresponse_unpack(buf []byte) ?CPublishedFileAreFilesInSubscriptionListResponse {
mut res := CPublishedFileAreFilesInSubscriptionListResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpublishedfilearefilesinsubscriptionlistresponseinlist(cur_buf, tag_wiretype.wire_type)?
res.files << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilearefilesinsubscriptionlistresponse() CPublishedFileAreFilesInSubscriptionListResponse {
return CPublishedFileAreFilesInSubscriptionListResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilearefilesinsubscriptionlistresponse(o CPublishedFileAreFilesInSubscriptionListResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilearefilesinsubscriptionlistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileAreFilesInSubscriptionListResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilearefilesinsubscriptionlistresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileUpdateRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
publishedfileid u64
has_publishedfileid bool
title string
has_title bool
file_description string
has_file_description bool
visibility u32
has_visibility bool
tags []string
filename string
has_filename bool
preview_filename string
has_preview_filename bool
image_width u32
has_image_width bool
image_height u32
has_image_height bool
}
pub fn (o &CPublishedFileUpdateRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_publishedfileid {
res << vproto.pack_64bit_field(o.publishedfileid, 2)
}

if o.has_title {
res << vproto.pack_string_field(o.title, 3)
}

if o.has_file_description {
res << vproto.pack_string_field(o.file_description, 4)
}

if o.has_visibility {
res << vproto.pack_uint32_field(o.visibility, 5)
}

// [packed=false]
for _, x in o.tags {
res << vproto.pack_string_field(x, 6)
}

if o.has_filename {
res << vproto.pack_string_field(o.filename, 7)
}

if o.has_preview_filename {
res << vproto.pack_string_field(o.preview_filename, 8)
}

if o.has_image_width {
res << vproto.pack_uint32_field(o.image_width, 15)
}

if o.has_image_height {
res << vproto.pack_uint32_field(o.image_height, 16)
}

return res
}

pub fn cpublishedfileupdaterequest_unpack(buf []byte) ?CPublishedFileUpdateRequest {
mut res := CPublishedFileUpdateRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_publishedfileid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

3 {
res.has_title = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.title = v
i = ii
}

4 {
res.has_file_description = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_description = v
i = ii
}

5 {
res.has_visibility = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.visibility = v
i = ii
}

6 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.tags << v
i = ii
}

7 {
res.has_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename = v
i = ii
}

8 {
res.has_preview_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.preview_filename = v
i = ii
}

15 {
res.has_image_width = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.image_width = v
i = ii
}

16 {
res.has_image_height = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.image_height = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfileupdaterequest() CPublishedFileUpdateRequest {
return CPublishedFileUpdateRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfileupdaterequest(o CPublishedFileUpdateRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfileupdaterequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileUpdateRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfileupdaterequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileUpdateResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPublishedFileUpdateResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpublishedfileupdateresponse_unpack(buf []byte) ?CPublishedFileUpdateResponse {
res := CPublishedFileUpdateResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfileupdateresponse() CPublishedFileUpdateResponse {
return CPublishedFileUpdateResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfileupdateresponse(o CPublishedFileUpdateResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfileupdateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileUpdateResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfileupdateresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetChangeHistoryEntryRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
timestamp u32
has_timestamp bool
language int
has_language bool
}
pub fn (o &CPublishedFileGetChangeHistoryEntryRequest) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_64bit_field(o.publishedfileid, 1)
}

if o.has_timestamp {
res << vproto.pack_uint32_field(o.timestamp, 2)
}

if o.has_language {
res << vproto.pack_int32_field(o.language, 3)
}

return res
}

pub fn cpublishedfilegetchangehistoryentryrequest_unpack(buf []byte) ?CPublishedFileGetChangeHistoryEntryRequest {
mut res := CPublishedFileGetChangeHistoryEntryRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

2 {
res.has_timestamp = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp = v
i = ii
}

3 {
res.has_language = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetchangehistoryentryrequest() CPublishedFileGetChangeHistoryEntryRequest {
return CPublishedFileGetChangeHistoryEntryRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetchangehistoryentryrequest(o CPublishedFileGetChangeHistoryEntryRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetchangehistoryentryrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetChangeHistoryEntryRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetchangehistoryentryrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetChangeHistoryEntryResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
change_description string
has_change_description bool
language int
has_language bool
}
pub fn (o &CPublishedFileGetChangeHistoryEntryResponse) pack() []byte {
mut res := []byte{}
if o.has_change_description {
res << vproto.pack_string_field(o.change_description, 1)
}

if o.has_language {
res << vproto.pack_int32_field(o.language, 2)
}

return res
}

pub fn cpublishedfilegetchangehistoryentryresponse_unpack(buf []byte) ?CPublishedFileGetChangeHistoryEntryResponse {
mut res := CPublishedFileGetChangeHistoryEntryResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_change_description = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.change_description = v
i = ii
}

2 {
res.has_language = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetchangehistoryentryresponse() CPublishedFileGetChangeHistoryEntryResponse {
return CPublishedFileGetChangeHistoryEntryResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetchangehistoryentryresponse(o CPublishedFileGetChangeHistoryEntryResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetchangehistoryentryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetChangeHistoryEntryResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetchangehistoryentryresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetChangeHistoryRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
total_only bool
has_total_only bool
startindex u32
has_startindex bool
count u32
has_count bool
language int
has_language bool
}
pub fn (o &CPublishedFileGetChangeHistoryRequest) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_64bit_field(o.publishedfileid, 1)
}

if o.has_total_only {
res << vproto.pack_bool_field(o.total_only, 2)
}

if o.has_startindex {
res << vproto.pack_uint32_field(o.startindex, 3)
}

if o.has_count {
res << vproto.pack_uint32_field(o.count, 4)
}

if o.has_language {
res << vproto.pack_int32_field(o.language, 5)
}

return res
}

pub fn cpublishedfilegetchangehistoryrequest_unpack(buf []byte) ?CPublishedFileGetChangeHistoryRequest {
mut res := CPublishedFileGetChangeHistoryRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

2 {
res.has_total_only = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.total_only = v
i = ii
}

3 {
res.has_startindex = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.startindex = v
i = ii
}

4 {
res.has_count = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.count = v
i = ii
}

5 {
res.has_language = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetchangehistoryrequest() CPublishedFileGetChangeHistoryRequest {
return CPublishedFileGetChangeHistoryRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetchangehistoryrequest(o CPublishedFileGetChangeHistoryRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetchangehistoryrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetChangeHistoryRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetchangehistoryrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetChangeHistoryResponseChangeLog {
mut:
unknown_fields []vproto.UnknownField
pub mut:
timestamp u32
has_timestamp bool
change_description string
has_change_description bool
language int
has_language bool
}
pub fn (o &CPublishedFileGetChangeHistoryResponseChangeLog) pack() []byte {
mut res := []byte{}
if o.has_timestamp {
res << vproto.pack_uint32_field(o.timestamp, 1)
}

if o.has_change_description {
res << vproto.pack_string_field(o.change_description, 2)
}

if o.has_language {
res << vproto.pack_int32_field(o.language, 3)
}

return res
}

pub fn cpublishedfilegetchangehistoryresponsechangelog_unpack(buf []byte) ?CPublishedFileGetChangeHistoryResponseChangeLog {
mut res := CPublishedFileGetChangeHistoryResponseChangeLog{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_timestamp = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp = v
i = ii
}

2 {
res.has_change_description = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.change_description = v
i = ii
}

3 {
res.has_language = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetchangehistoryresponsechangelog() CPublishedFileGetChangeHistoryResponseChangeLog {
return CPublishedFileGetChangeHistoryResponseChangeLog{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetchangehistoryresponsechangelog(o CPublishedFileGetChangeHistoryResponseChangeLog, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetchangehistoryresponsechangelog(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetChangeHistoryResponseChangeLog) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetchangehistoryresponsechangelog_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetChangeHistoryResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
changes []CPublishedFileGetChangeHistoryResponseChangeLog
total u32
has_total bool
}
pub fn (o &CPublishedFileGetChangeHistoryResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.changes {
res << zzz_vproto_internal_pack_cpublishedfilegetchangehistoryresponsechangelog(x, 1)
}

if o.has_total {
res << vproto.pack_uint32_field(o.total, 2)
}

return res
}

pub fn cpublishedfilegetchangehistoryresponse_unpack(buf []byte) ?CPublishedFileGetChangeHistoryResponse {
mut res := CPublishedFileGetChangeHistoryResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpublishedfilegetchangehistoryresponsechangelog(cur_buf, tag_wiretype.wire_type)?
res.changes << v
i = ii
}

2 {
res.has_total = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.total = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetchangehistoryresponse() CPublishedFileGetChangeHistoryResponse {
return CPublishedFileGetChangeHistoryResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetchangehistoryresponse(o CPublishedFileGetChangeHistoryResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetchangehistoryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetChangeHistoryResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetchangehistoryresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileRefreshVotingQueueRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
matching_file_type u32
has_matching_file_type bool
tags []string
match_all_tags bool
has_match_all_tags bool
excluded_tags []string
desired_queue_size u32
has_desired_queue_size bool
desired_revision EPublishedFileRevision
has_desired_revision bool
}
pub fn (o &CPublishedFileRefreshVotingQueueRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_matching_file_type {
res << vproto.pack_uint32_field(o.matching_file_type, 2)
}

// [packed=false]
for _, x in o.tags {
res << vproto.pack_string_field(x, 3)
}

if o.has_match_all_tags {
res << vproto.pack_bool_field(o.match_all_tags, 4)
}

// [packed=false]
for _, x in o.excluded_tags {
res << vproto.pack_string_field(x, 5)
}

if o.has_desired_queue_size {
res << vproto.pack_uint32_field(o.desired_queue_size, 6)
}

if o.has_desired_revision {
res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 8)
}

return res
}

pub fn cpublishedfilerefreshvotingqueuerequest_unpack(buf []byte) ?CPublishedFileRefreshVotingQueueRequest {
mut res := CPublishedFileRefreshVotingQueueRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_matching_file_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.matching_file_type = v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.tags << v
i = ii
}

4 {
res.has_match_all_tags = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.match_all_tags = v
i = ii
}

5 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.excluded_tags << v
i = ii
}

6 {
res.has_desired_queue_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.desired_queue_size = v
i = ii
}

8 {
res.has_desired_revision = true
ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
res.desired_revision = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilerefreshvotingqueuerequest() CPublishedFileRefreshVotingQueueRequest {
return CPublishedFileRefreshVotingQueueRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilerefreshvotingqueuerequest(o CPublishedFileRefreshVotingQueueRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilerefreshvotingqueuerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileRefreshVotingQueueRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilerefreshvotingqueuerequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileRefreshVotingQueueResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPublishedFileRefreshVotingQueueResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpublishedfilerefreshvotingqueueresponse_unpack(buf []byte) ?CPublishedFileRefreshVotingQueueResponse {
res := CPublishedFileRefreshVotingQueueResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilerefreshvotingqueueresponse() CPublishedFileRefreshVotingQueueResponse {
return CPublishedFileRefreshVotingQueueResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilerefreshvotingqueueresponse(o CPublishedFileRefreshVotingQueueResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilerefreshvotingqueueresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileRefreshVotingQueueResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilerefreshvotingqueueresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileQueryFilesRequestKVtag {
mut:
unknown_fields []vproto.UnknownField
pub mut:
key string
has_key bool
value string
has_value bool
}
pub fn (o &CPublishedFileQueryFilesRequestKVtag) pack() []byte {
mut res := []byte{}
if o.has_key {
res << vproto.pack_string_field(o.key, 1)
}

if o.has_value {
res << vproto.pack_string_field(o.value, 2)
}

return res
}

pub fn cpublishedfilequeryfilesrequestkvtag_unpack(buf []byte) ?CPublishedFileQueryFilesRequestKVtag {
mut res := CPublishedFileQueryFilesRequestKVtag{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_key = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.key = v
i = ii
}

2 {
res.has_value = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.value = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilequeryfilesrequestkvtag() CPublishedFileQueryFilesRequestKVtag {
return CPublishedFileQueryFilesRequestKVtag{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilequeryfilesrequestkvtag(o CPublishedFileQueryFilesRequestKVtag, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilequeryfilesrequestkvtag(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileQueryFilesRequestKVtag) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilequeryfilesrequestkvtag_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileQueryFilesRequestTagGroup {
mut:
unknown_fields []vproto.UnknownField
pub mut:
tags []string
}
pub fn (o &CPublishedFileQueryFilesRequestTagGroup) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.tags {
res << vproto.pack_string_field(x, 1)
}

return res
}

pub fn cpublishedfilequeryfilesrequesttaggroup_unpack(buf []byte) ?CPublishedFileQueryFilesRequestTagGroup {
mut res := CPublishedFileQueryFilesRequestTagGroup{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.tags << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilequeryfilesrequesttaggroup() CPublishedFileQueryFilesRequestTagGroup {
return CPublishedFileQueryFilesRequestTagGroup{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilequeryfilesrequesttaggroup(o CPublishedFileQueryFilesRequestTagGroup, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilequeryfilesrequesttaggroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileQueryFilesRequestTagGroup) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilequeryfilesrequesttaggroup_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileQueryFilesRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
query_type u32
has_query_type bool
page u32
has_page bool
cursor string
has_cursor bool
numperpage u32
has_numperpage bool
creator_appid u32
has_creator_appid bool
appid u32
has_appid bool
requiredtags []string
excludedtags []string
match_all_tags bool
has_match_all_tags bool
required_flags []string
omitted_flags []string
search_text string
has_search_text bool
filetype u32
has_filetype bool
child_publishedfileid u64
has_child_publishedfileid bool
days u32
has_days bool
include_recent_votes_only bool
has_include_recent_votes_only bool
cache_max_age_seconds u32
has_cache_max_age_seconds bool
language int
has_language bool
required_kv_tags []CPublishedFileQueryFilesRequestKVtag
taggroups []CPublishedFileQueryFilesRequestTagGroup
totalonly bool
has_totalonly bool
ids_only bool
has_ids_only bool
return_vote_data bool
has_return_vote_data bool
return_tags bool
has_return_tags bool
return_kv_tags bool
has_return_kv_tags bool
return_previews bool
has_return_previews bool
return_children bool
has_return_children bool
return_short_description bool
has_return_short_description bool
return_for_sale_data bool
has_return_for_sale_data bool
return_metadata bool
has_return_metadata bool
return_playtime_stats u32
has_return_playtime_stats bool
return_details bool
has_return_details bool
strip_description_bbcode bool
has_strip_description_bbcode bool
desired_revision EPublishedFileRevision
has_desired_revision bool
return_reactions bool
has_return_reactions bool
}
pub fn (o &CPublishedFileQueryFilesRequest) pack() []byte {
mut res := []byte{}
if o.has_query_type {
res << vproto.pack_uint32_field(o.query_type, 1)
}

if o.has_page {
res << vproto.pack_uint32_field(o.page, 2)
}

if o.has_cursor {
res << vproto.pack_string_field(o.cursor, 39)
}

if o.has_numperpage {
res << vproto.pack_uint32_field(o.numperpage, 3)
}

if o.has_creator_appid {
res << vproto.pack_uint32_field(o.creator_appid, 4)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 5)
}

// [packed=false]
for _, x in o.requiredtags {
res << vproto.pack_string_field(x, 6)
}

// [packed=false]
for _, x in o.excludedtags {
res << vproto.pack_string_field(x, 7)
}

if o.has_match_all_tags {
res << vproto.pack_bool_field(o.match_all_tags, 8)
}

// [packed=false]
for _, x in o.required_flags {
res << vproto.pack_string_field(x, 9)
}

// [packed=false]
for _, x in o.omitted_flags {
res << vproto.pack_string_field(x, 10)
}

if o.has_search_text {
res << vproto.pack_string_field(o.search_text, 11)
}

if o.has_filetype {
res << vproto.pack_uint32_field(o.filetype, 12)
}

if o.has_child_publishedfileid {
res << vproto.pack_64bit_field(o.child_publishedfileid, 13)
}

if o.has_days {
res << vproto.pack_uint32_field(o.days, 14)
}

if o.has_include_recent_votes_only {
res << vproto.pack_bool_field(o.include_recent_votes_only, 15)
}

if o.has_cache_max_age_seconds {
res << vproto.pack_uint32_field(o.cache_max_age_seconds, 31)
}

if o.has_language {
res << vproto.pack_int32_field(o.language, 33)
}

// [packed=false]
for _, x in o.required_kv_tags {
res << zzz_vproto_internal_pack_cpublishedfilequeryfilesrequestkvtag(x, 34)
}

// [packed=false]
for _, x in o.taggroups {
res << zzz_vproto_internal_pack_cpublishedfilequeryfilesrequesttaggroup(x, 42)
}

if o.has_totalonly {
res << vproto.pack_bool_field(o.totalonly, 16)
}

if o.has_ids_only {
res << vproto.pack_bool_field(o.ids_only, 35)
}

if o.has_return_vote_data {
res << vproto.pack_bool_field(o.return_vote_data, 17)
}

if o.has_return_tags {
res << vproto.pack_bool_field(o.return_tags, 18)
}

if o.has_return_kv_tags {
res << vproto.pack_bool_field(o.return_kv_tags, 19)
}

if o.has_return_previews {
res << vproto.pack_bool_field(o.return_previews, 20)
}

if o.has_return_children {
res << vproto.pack_bool_field(o.return_children, 21)
}

if o.has_return_short_description {
res << vproto.pack_bool_field(o.return_short_description, 22)
}

if o.has_return_for_sale_data {
res << vproto.pack_bool_field(o.return_for_sale_data, 30)
}

if o.has_return_metadata {
res << vproto.pack_bool_field(o.return_metadata, 32)
}

if o.has_return_playtime_stats {
res << vproto.pack_uint32_field(o.return_playtime_stats, 36)
}

if o.has_return_details {
res << vproto.pack_bool_field(o.return_details, 37)
}

if o.has_strip_description_bbcode {
res << vproto.pack_bool_field(o.strip_description_bbcode, 38)
}

if o.has_desired_revision {
res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 40)
}

if o.has_return_reactions {
res << vproto.pack_bool_field(o.return_reactions, 43)
}

return res
}

pub fn cpublishedfilequeryfilesrequest_unpack(buf []byte) ?CPublishedFileQueryFilesRequest {
mut res := CPublishedFileQueryFilesRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_query_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.query_type = v
i = ii
}

2 {
res.has_page = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.page = v
i = ii
}

39 {
res.has_cursor = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.cursor = v
i = ii
}

3 {
res.has_numperpage = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.numperpage = v
i = ii
}

4 {
res.has_creator_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.creator_appid = v
i = ii
}

5 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

6 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.requiredtags << v
i = ii
}

7 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.excludedtags << v
i = ii
}

8 {
res.has_match_all_tags = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.match_all_tags = v
i = ii
}

9 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.required_flags << v
i = ii
}

10 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.omitted_flags << v
i = ii
}

11 {
res.has_search_text = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.search_text = v
i = ii
}

12 {
res.has_filetype = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.filetype = v
i = ii
}

13 {
res.has_child_publishedfileid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.child_publishedfileid = v
i = ii
}

14 {
res.has_days = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.days = v
i = ii
}

15 {
res.has_include_recent_votes_only = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.include_recent_votes_only = v
i = ii
}

31 {
res.has_cache_max_age_seconds = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cache_max_age_seconds = v
i = ii
}

33 {
res.has_language = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

34 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpublishedfilequeryfilesrequestkvtag(cur_buf, tag_wiretype.wire_type)?
res.required_kv_tags << v
i = ii
}

42 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpublishedfilequeryfilesrequesttaggroup(cur_buf, tag_wiretype.wire_type)?
res.taggroups << v
i = ii
}

16 {
res.has_totalonly = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.totalonly = v
i = ii
}

35 {
res.has_ids_only = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.ids_only = v
i = ii
}

17 {
res.has_return_vote_data = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_vote_data = v
i = ii
}

18 {
res.has_return_tags = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_tags = v
i = ii
}

19 {
res.has_return_kv_tags = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_kv_tags = v
i = ii
}

20 {
res.has_return_previews = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_previews = v
i = ii
}

21 {
res.has_return_children = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_children = v
i = ii
}

22 {
res.has_return_short_description = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_short_description = v
i = ii
}

30 {
res.has_return_for_sale_data = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_for_sale_data = v
i = ii
}

32 {
res.has_return_metadata = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_metadata = v
i = ii
}

36 {
res.has_return_playtime_stats = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.return_playtime_stats = v
i = ii
}

37 {
res.has_return_details = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_details = v
i = ii
}

38 {
res.has_strip_description_bbcode = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.strip_description_bbcode = v
i = ii
}

40 {
res.has_desired_revision = true
ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
res.desired_revision = v
i = ii
}

43 {
res.has_return_reactions = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_reactions = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilequeryfilesrequest() CPublishedFileQueryFilesRequest {
return CPublishedFileQueryFilesRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilequeryfilesrequest(o CPublishedFileQueryFilesRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilequeryfilesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileQueryFilesRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilequeryfilesrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileQueryFilesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
total u32
has_total bool
publishedfiledetails []PublishedFileDetails
next_cursor string
has_next_cursor bool
}
pub fn (o &CPublishedFileQueryFilesResponse) pack() []byte {
mut res := []byte{}
if o.has_total {
res << vproto.pack_uint32_field(o.total, 1)
}

// [packed=false]
for _, x in o.publishedfiledetails {
res << zzz_vproto_internal_pack_publishedfiledetails(x, 2)
}

if o.has_next_cursor {
res << vproto.pack_string_field(o.next_cursor, 3)
}

return res
}

pub fn cpublishedfilequeryfilesresponse_unpack(buf []byte) ?CPublishedFileQueryFilesResponse {
mut res := CPublishedFileQueryFilesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_total = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.total = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_publishedfiledetails(cur_buf, tag_wiretype.wire_type)?
res.publishedfiledetails << v
i = ii
}

3 {
res.has_next_cursor = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.next_cursor = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilequeryfilesresponse() CPublishedFileQueryFilesResponse {
return CPublishedFileQueryFilesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilequeryfilesresponse(o CPublishedFileQueryFilesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilequeryfilesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileQueryFilesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilequeryfilesresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileAddAppRelationshipRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
appid u32
has_appid bool
relationship u32
has_relationship bool
}
pub fn (o &CPublishedFileAddAppRelationshipRequest) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_uint64_field(o.publishedfileid, 1)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 2)
}

if o.has_relationship {
res << vproto.pack_uint32_field(o.relationship, 3)
}

return res
}

pub fn cpublishedfileaddapprelationshiprequest_unpack(buf []byte) ?CPublishedFileAddAppRelationshipRequest {
mut res := CPublishedFileAddAppRelationshipRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

2 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

3 {
res.has_relationship = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.relationship = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfileaddapprelationshiprequest() CPublishedFileAddAppRelationshipRequest {
return CPublishedFileAddAppRelationshipRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfileaddapprelationshiprequest(o CPublishedFileAddAppRelationshipRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfileaddapprelationshiprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileAddAppRelationshipRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfileaddapprelationshiprequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileAddAppRelationshipResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPublishedFileAddAppRelationshipResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpublishedfileaddapprelationshipresponse_unpack(buf []byte) ?CPublishedFileAddAppRelationshipResponse {
res := CPublishedFileAddAppRelationshipResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfileaddapprelationshipresponse() CPublishedFileAddAppRelationshipResponse {
return CPublishedFileAddAppRelationshipResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfileaddapprelationshipresponse(o CPublishedFileAddAppRelationshipResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfileaddapprelationshipresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileAddAppRelationshipResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfileaddapprelationshipresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileRemoveAppRelationshipRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
appid u32
has_appid bool
relationship u32
has_relationship bool
}
pub fn (o &CPublishedFileRemoveAppRelationshipRequest) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_uint64_field(o.publishedfileid, 1)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 2)
}

if o.has_relationship {
res << vproto.pack_uint32_field(o.relationship, 3)
}

return res
}

pub fn cpublishedfileremoveapprelationshiprequest_unpack(buf []byte) ?CPublishedFileRemoveAppRelationshipRequest {
mut res := CPublishedFileRemoveAppRelationshipRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

2 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

3 {
res.has_relationship = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.relationship = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfileremoveapprelationshiprequest() CPublishedFileRemoveAppRelationshipRequest {
return CPublishedFileRemoveAppRelationshipRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfileremoveapprelationshiprequest(o CPublishedFileRemoveAppRelationshipRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfileremoveapprelationshiprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileRemoveAppRelationshipRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfileremoveapprelationshiprequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileRemoveAppRelationshipResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPublishedFileRemoveAppRelationshipResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpublishedfileremoveapprelationshipresponse_unpack(buf []byte) ?CPublishedFileRemoveAppRelationshipResponse {
res := CPublishedFileRemoveAppRelationshipResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfileremoveapprelationshipresponse() CPublishedFileRemoveAppRelationshipResponse {
return CPublishedFileRemoveAppRelationshipResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfileremoveapprelationshipresponse(o CPublishedFileRemoveAppRelationshipResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfileremoveapprelationshipresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileRemoveAppRelationshipResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfileremoveapprelationshipresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetAppRelationshipsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
}
pub fn (o &CPublishedFileGetAppRelationshipsRequest) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_uint64_field(o.publishedfileid, 1)
}

return res
}

pub fn cpublishedfilegetapprelationshipsrequest_unpack(buf []byte) ?CPublishedFileGetAppRelationshipsRequest {
mut res := CPublishedFileGetAppRelationshipsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetapprelationshipsrequest() CPublishedFileGetAppRelationshipsRequest {
return CPublishedFileGetAppRelationshipsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetapprelationshipsrequest(o CPublishedFileGetAppRelationshipsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetapprelationshipsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetAppRelationshipsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetapprelationshipsrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetAppRelationshipsResponseAppRelationship {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
relationship u32
has_relationship bool
}
pub fn (o &CPublishedFileGetAppRelationshipsResponseAppRelationship) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_relationship {
res << vproto.pack_uint32_field(o.relationship, 2)
}

return res
}

pub fn cpublishedfilegetapprelationshipsresponseapprelationship_unpack(buf []byte) ?CPublishedFileGetAppRelationshipsResponseAppRelationship {
mut res := CPublishedFileGetAppRelationshipsResponseAppRelationship{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_relationship = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.relationship = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetapprelationshipsresponseapprelationship() CPublishedFileGetAppRelationshipsResponseAppRelationship {
return CPublishedFileGetAppRelationshipsResponseAppRelationship{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetapprelationshipsresponseapprelationship(o CPublishedFileGetAppRelationshipsResponseAppRelationship, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetapprelationshipsresponseapprelationship(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetAppRelationshipsResponseAppRelationship) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetapprelationshipsresponseapprelationship_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetAppRelationshipsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_relationships []CPublishedFileGetAppRelationshipsResponseAppRelationship
}
pub fn (o &CPublishedFileGetAppRelationshipsResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.app_relationships {
res << zzz_vproto_internal_pack_cpublishedfilegetapprelationshipsresponseapprelationship(x, 3)
}

return res
}

pub fn cpublishedfilegetapprelationshipsresponse_unpack(buf []byte) ?CPublishedFileGetAppRelationshipsResponse {
mut res := CPublishedFileGetAppRelationshipsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpublishedfilegetapprelationshipsresponseapprelationship(cur_buf, tag_wiretype.wire_type)?
res.app_relationships << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetapprelationshipsresponse() CPublishedFileGetAppRelationshipsResponse {
return CPublishedFileGetAppRelationshipsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetapprelationshipsresponse(o CPublishedFileGetAppRelationshipsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetapprelationshipsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetAppRelationshipsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetapprelationshipsresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileStartPlaytimeTrackingRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
publishedfileids []u64
}
pub fn (o &CPublishedFileStartPlaytimeTrackingRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

// [packed=false]
for _, x in o.publishedfileids {
res << vproto.pack_uint64_field(x, 2)
}

return res
}

pub fn cpublishedfilestartplaytimetrackingrequest_unpack(buf []byte) ?CPublishedFileStartPlaytimeTrackingRequest {
mut res := CPublishedFileStartPlaytimeTrackingRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilestartplaytimetrackingrequest() CPublishedFileStartPlaytimeTrackingRequest {
return CPublishedFileStartPlaytimeTrackingRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilestartplaytimetrackingrequest(o CPublishedFileStartPlaytimeTrackingRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilestartplaytimetrackingrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileStartPlaytimeTrackingRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilestartplaytimetrackingrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileStartPlaytimeTrackingResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPublishedFileStartPlaytimeTrackingResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpublishedfilestartplaytimetrackingresponse_unpack(buf []byte) ?CPublishedFileStartPlaytimeTrackingResponse {
res := CPublishedFileStartPlaytimeTrackingResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilestartplaytimetrackingresponse() CPublishedFileStartPlaytimeTrackingResponse {
return CPublishedFileStartPlaytimeTrackingResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilestartplaytimetrackingresponse(o CPublishedFileStartPlaytimeTrackingResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilestartplaytimetrackingresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileStartPlaytimeTrackingResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilestartplaytimetrackingresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileStopPlaytimeTrackingRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
publishedfileids []u64
}
pub fn (o &CPublishedFileStopPlaytimeTrackingRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

// [packed=false]
for _, x in o.publishedfileids {
res << vproto.pack_uint64_field(x, 2)
}

return res
}

pub fn cpublishedfilestopplaytimetrackingrequest_unpack(buf []byte) ?CPublishedFileStopPlaytimeTrackingRequest {
mut res := CPublishedFileStopPlaytimeTrackingRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilestopplaytimetrackingrequest() CPublishedFileStopPlaytimeTrackingRequest {
return CPublishedFileStopPlaytimeTrackingRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilestopplaytimetrackingrequest(o CPublishedFileStopPlaytimeTrackingRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilestopplaytimetrackingrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileStopPlaytimeTrackingRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilestopplaytimetrackingrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileStopPlaytimeTrackingResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPublishedFileStopPlaytimeTrackingResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpublishedfilestopplaytimetrackingresponse_unpack(buf []byte) ?CPublishedFileStopPlaytimeTrackingResponse {
res := CPublishedFileStopPlaytimeTrackingResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilestopplaytimetrackingresponse() CPublishedFileStopPlaytimeTrackingResponse {
return CPublishedFileStopPlaytimeTrackingResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilestopplaytimetrackingresponse(o CPublishedFileStopPlaytimeTrackingResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilestopplaytimetrackingresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileStopPlaytimeTrackingResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilestopplaytimetrackingresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileStopPlaytimeTrackingForAllAppItemsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
}
pub fn (o &CPublishedFileStopPlaytimeTrackingForAllAppItemsRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

return res
}

pub fn cpublishedfilestopplaytimetrackingforallappitemsrequest_unpack(buf []byte) ?CPublishedFileStopPlaytimeTrackingForAllAppItemsRequest {
mut res := CPublishedFileStopPlaytimeTrackingForAllAppItemsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilestopplaytimetrackingforallappitemsrequest() CPublishedFileStopPlaytimeTrackingForAllAppItemsRequest {
return CPublishedFileStopPlaytimeTrackingForAllAppItemsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilestopplaytimetrackingforallappitemsrequest(o CPublishedFileStopPlaytimeTrackingForAllAppItemsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilestopplaytimetrackingforallappitemsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileStopPlaytimeTrackingForAllAppItemsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilestopplaytimetrackingforallappitemsrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileStopPlaytimeTrackingForAllAppItemsResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPublishedFileStopPlaytimeTrackingForAllAppItemsResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpublishedfilestopplaytimetrackingforallappitemsresponse_unpack(buf []byte) ?CPublishedFileStopPlaytimeTrackingForAllAppItemsResponse {
res := CPublishedFileStopPlaytimeTrackingForAllAppItemsResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilestopplaytimetrackingforallappitemsresponse() CPublishedFileStopPlaytimeTrackingForAllAppItemsResponse {
return CPublishedFileStopPlaytimeTrackingForAllAppItemsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilestopplaytimetrackingforallappitemsresponse(o CPublishedFileStopPlaytimeTrackingForAllAppItemsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilestopplaytimetrackingforallappitemsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileStopPlaytimeTrackingForAllAppItemsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilestopplaytimetrackingforallappitemsresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileSetPlaytimeForControllerConfigsRequestControllerConfigUsage {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
seconds_active f32
has_seconds_active bool
}
pub fn (o &CPublishedFileSetPlaytimeForControllerConfigsRequestControllerConfigUsage) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_uint64_field(o.publishedfileid, 1)
}

if o.has_seconds_active {
res << vproto.pack_float_field(o.seconds_active, 2)
}

return res
}

pub fn cpublishedfilesetplaytimeforcontrollerconfigsrequestcontrollerconfigusage_unpack(buf []byte) ?CPublishedFileSetPlaytimeForControllerConfigsRequestControllerConfigUsage {
mut res := CPublishedFileSetPlaytimeForControllerConfigsRequestControllerConfigUsage{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

2 {
res.has_seconds_active = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_active = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilesetplaytimeforcontrollerconfigsrequestcontrollerconfigusage() CPublishedFileSetPlaytimeForControllerConfigsRequestControllerConfigUsage {
return CPublishedFileSetPlaytimeForControllerConfigsRequestControllerConfigUsage{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilesetplaytimeforcontrollerconfigsrequestcontrollerconfigusage(o CPublishedFileSetPlaytimeForControllerConfigsRequestControllerConfigUsage, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilesetplaytimeforcontrollerconfigsrequestcontrollerconfigusage(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileSetPlaytimeForControllerConfigsRequestControllerConfigUsage) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilesetplaytimeforcontrollerconfigsrequestcontrollerconfigusage_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileSetPlaytimeForControllerConfigsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
controller_config_usage []CPublishedFileSetPlaytimeForControllerConfigsRequestControllerConfigUsage
}
pub fn (o &CPublishedFileSetPlaytimeForControllerConfigsRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

// [packed=false]
for _, x in o.controller_config_usage {
res << zzz_vproto_internal_pack_cpublishedfilesetplaytimeforcontrollerconfigsrequestcontrollerconfigusage(x, 2)
}

return res
}

pub fn cpublishedfilesetplaytimeforcontrollerconfigsrequest_unpack(buf []byte) ?CPublishedFileSetPlaytimeForControllerConfigsRequest {
mut res := CPublishedFileSetPlaytimeForControllerConfigsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpublishedfilesetplaytimeforcontrollerconfigsrequestcontrollerconfigusage(cur_buf, tag_wiretype.wire_type)?
res.controller_config_usage << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilesetplaytimeforcontrollerconfigsrequest() CPublishedFileSetPlaytimeForControllerConfigsRequest {
return CPublishedFileSetPlaytimeForControllerConfigsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilesetplaytimeforcontrollerconfigsrequest(o CPublishedFileSetPlaytimeForControllerConfigsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilesetplaytimeforcontrollerconfigsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileSetPlaytimeForControllerConfigsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilesetplaytimeforcontrollerconfigsrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileSetPlaytimeForControllerConfigsResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPublishedFileSetPlaytimeForControllerConfigsResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpublishedfilesetplaytimeforcontrollerconfigsresponse_unpack(buf []byte) ?CPublishedFileSetPlaytimeForControllerConfigsResponse {
res := CPublishedFileSetPlaytimeForControllerConfigsResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilesetplaytimeforcontrollerconfigsresponse() CPublishedFileSetPlaytimeForControllerConfigsResponse {
return CPublishedFileSetPlaytimeForControllerConfigsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilesetplaytimeforcontrollerconfigsresponse(o CPublishedFileSetPlaytimeForControllerConfigsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilesetplaytimeforcontrollerconfigsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileSetPlaytimeForControllerConfigsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilesetplaytimeforcontrollerconfigsresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileAddChildRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
child_publishedfileid u64
has_child_publishedfileid bool
}
pub fn (o &CPublishedFileAddChildRequest) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_uint64_field(o.publishedfileid, 1)
}

if o.has_child_publishedfileid {
res << vproto.pack_uint64_field(o.child_publishedfileid, 2)
}

return res
}

pub fn cpublishedfileaddchildrequest_unpack(buf []byte) ?CPublishedFileAddChildRequest {
mut res := CPublishedFileAddChildRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

2 {
res.has_child_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.child_publishedfileid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfileaddchildrequest() CPublishedFileAddChildRequest {
return CPublishedFileAddChildRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfileaddchildrequest(o CPublishedFileAddChildRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfileaddchildrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileAddChildRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfileaddchildrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileAddChildResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPublishedFileAddChildResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpublishedfileaddchildresponse_unpack(buf []byte) ?CPublishedFileAddChildResponse {
res := CPublishedFileAddChildResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfileaddchildresponse() CPublishedFileAddChildResponse {
return CPublishedFileAddChildResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfileaddchildresponse(o CPublishedFileAddChildResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfileaddchildresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileAddChildResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfileaddchildresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileRemoveChildRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
child_publishedfileid u64
has_child_publishedfileid bool
}
pub fn (o &CPublishedFileRemoveChildRequest) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_uint64_field(o.publishedfileid, 1)
}

if o.has_child_publishedfileid {
res << vproto.pack_uint64_field(o.child_publishedfileid, 2)
}

return res
}

pub fn cpublishedfileremovechildrequest_unpack(buf []byte) ?CPublishedFileRemoveChildRequest {
mut res := CPublishedFileRemoveChildRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

2 {
res.has_child_publishedfileid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.child_publishedfileid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfileremovechildrequest() CPublishedFileRemoveChildRequest {
return CPublishedFileRemoveChildRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfileremovechildrequest(o CPublishedFileRemoveChildRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfileremovechildrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileRemoveChildRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfileremovechildrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileRemoveChildResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPublishedFileRemoveChildResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpublishedfileremovechildresponse_unpack(buf []byte) ?CPublishedFileRemoveChildResponse {
res := CPublishedFileRemoveChildResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfileremovechildresponse() CPublishedFileRemoveChildResponse {
return CPublishedFileRemoveChildResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfileremovechildresponse(o CPublishedFileRemoveChildResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfileremovechildresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileRemoveChildResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfileremovechildresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetUserVoteSummaryRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileids []u64
}
pub fn (o &CPublishedFileGetUserVoteSummaryRequest) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.publishedfileids {
res << vproto.pack_64bit_field(x, 1)
}

return res
}

pub fn cpublishedfilegetuservotesummaryrequest_unpack(buf []byte) ?CPublishedFileGetUserVoteSummaryRequest {
mut res := CPublishedFileGetUserVoteSummaryRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetuservotesummaryrequest() CPublishedFileGetUserVoteSummaryRequest {
return CPublishedFileGetUserVoteSummaryRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetuservotesummaryrequest(o CPublishedFileGetUserVoteSummaryRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetuservotesummaryrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetUserVoteSummaryRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetuservotesummaryrequest_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetUserVoteSummaryResponseVoteSummary {
mut:
unknown_fields []vproto.UnknownField
pub mut:
publishedfileid u64
has_publishedfileid bool
vote_for bool
has_vote_for bool
vote_against bool
has_vote_against bool
reported bool
has_reported bool
}
pub fn (o &CPublishedFileGetUserVoteSummaryResponseVoteSummary) pack() []byte {
mut res := []byte{}
if o.has_publishedfileid {
res << vproto.pack_64bit_field(o.publishedfileid, 1)
}

if o.has_vote_for {
res << vproto.pack_bool_field(o.vote_for, 2)
}

if o.has_vote_against {
res << vproto.pack_bool_field(o.vote_against, 3)
}

if o.has_reported {
res << vproto.pack_bool_field(o.reported, 4)
}

return res
}

pub fn cpublishedfilegetuservotesummaryresponsevotesummary_unpack(buf []byte) ?CPublishedFileGetUserVoteSummaryResponseVoteSummary {
mut res := CPublishedFileGetUserVoteSummaryResponseVoteSummary{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_publishedfileid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.publishedfileid = v
i = ii
}

2 {
res.has_vote_for = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.vote_for = v
i = ii
}

3 {
res.has_vote_against = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.vote_against = v
i = ii
}

4 {
res.has_reported = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.reported = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetuservotesummaryresponsevotesummary() CPublishedFileGetUserVoteSummaryResponseVoteSummary {
return CPublishedFileGetUserVoteSummaryResponseVoteSummary{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetuservotesummaryresponsevotesummary(o CPublishedFileGetUserVoteSummaryResponseVoteSummary, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetuservotesummaryresponsevotesummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetUserVoteSummaryResponseVoteSummary) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetuservotesummaryresponsevotesummary_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileGetUserVoteSummaryResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
summaries []CPublishedFileGetUserVoteSummaryResponseVoteSummary
}
pub fn (o &CPublishedFileGetUserVoteSummaryResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.summaries {
res << zzz_vproto_internal_pack_cpublishedfilegetuservotesummaryresponsevotesummary(x, 1)
}

return res
}

pub fn cpublishedfilegetuservotesummaryresponse_unpack(buf []byte) ?CPublishedFileGetUserVoteSummaryResponse {
mut res := CPublishedFileGetUserVoteSummaryResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpublishedfilegetuservotesummaryresponsevotesummary(cur_buf, tag_wiretype.wire_type)?
res.summaries << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilegetuservotesummaryresponse() CPublishedFileGetUserVoteSummaryResponse {
return CPublishedFileGetUserVoteSummaryResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilegetuservotesummaryresponse(o CPublishedFileGetUserVoteSummaryResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilegetuservotesummaryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileGetUserVoteSummaryResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilegetuservotesummaryresponse_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileFileSubscribedNotificationRevisionData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
revision EPublishedFileRevision
has_revision bool
file_hcontent u64
has_file_hcontent bool
rtime_updated u32
has_rtime_updated bool
}
pub fn (o &CPublishedFileFileSubscribedNotificationRevisionData) pack() []byte {
mut res := []byte{}
if o.has_revision {
res << zzz_vproto_internal_pack_epublishedfilerevision(o.revision, 1)
}

if o.has_file_hcontent {
res << vproto.pack_64bit_field(o.file_hcontent, 2)
}

if o.has_rtime_updated {
res << vproto.pack_uint32_field(o.rtime_updated, 3)
}

return res
}

pub fn cpublishedfilefilesubscribednotificationrevisiondata_unpack(buf []byte) ?CPublishedFileFileSubscribedNotificationRevisionData {
mut res := CPublishedFileFileSubscribedNotificationRevisionData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_revision = true
ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
res.revision = v
i = ii
}

2 {
res.has_file_hcontent = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.file_hcontent = v
i = ii
}

3 {
res.has_rtime_updated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.rtime_updated = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilefilesubscribednotificationrevisiondata() CPublishedFileFileSubscribedNotificationRevisionData {
return CPublishedFileFileSubscribedNotificationRevisionData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilefilesubscribednotificationrevisiondata(o CPublishedFileFileSubscribedNotificationRevisionData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilefilesubscribednotificationrevisiondata(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileFileSubscribedNotificationRevisionData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilefilesubscribednotificationrevisiondata_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileFileSubscribedNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
app_id u32
has_app_id bool
file_hcontent u64
has_file_hcontent bool
file_size u32
has_file_size bool
rtime_subscribed u32
has_rtime_subscribed bool
is_depot_content bool
has_is_depot_content bool
rtime_updated u32
has_rtime_updated bool
revisions []CPublishedFileFileSubscribedNotificationRevisionData
}
pub fn (o &CPublishedFileFileSubscribedNotification) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

if o.has_file_hcontent {
res << vproto.pack_64bit_field(o.file_hcontent, 3)
}

if o.has_file_size {
res << vproto.pack_uint32_field(o.file_size, 4)
}

if o.has_rtime_subscribed {
res << vproto.pack_uint32_field(o.rtime_subscribed, 5)
}

if o.has_is_depot_content {
res << vproto.pack_bool_field(o.is_depot_content, 6)
}

if o.has_rtime_updated {
res << vproto.pack_uint32_field(o.rtime_updated, 7)
}

// [packed=false]
for _, x in o.revisions {
res << zzz_vproto_internal_pack_cpublishedfilefilesubscribednotificationrevisiondata(x, 8)
}

return res
}

pub fn cpublishedfilefilesubscribednotification_unpack(buf []byte) ?CPublishedFileFileSubscribedNotification {
mut res := CPublishedFileFileSubscribedNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

3 {
res.has_file_hcontent = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.file_hcontent = v
i = ii
}

4 {
res.has_file_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.file_size = v
i = ii
}

5 {
res.has_rtime_subscribed = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.rtime_subscribed = v
i = ii
}

6 {
res.has_is_depot_content = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_depot_content = v
i = ii
}

7 {
res.has_rtime_updated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.rtime_updated = v
i = ii
}

8 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpublishedfilefilesubscribednotificationrevisiondata(cur_buf, tag_wiretype.wire_type)?
res.revisions << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilefilesubscribednotification() CPublishedFileFileSubscribedNotification {
return CPublishedFileFileSubscribedNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilefilesubscribednotification(o CPublishedFileFileSubscribedNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilefilesubscribednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileFileSubscribedNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilefilesubscribednotification_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileFileUnsubscribedNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
app_id u32
has_app_id bool
}
pub fn (o &CPublishedFileFileUnsubscribedNotification) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

return res
}

pub fn cpublishedfilefileunsubscribednotification_unpack(buf []byte) ?CPublishedFileFileUnsubscribedNotification {
mut res := CPublishedFileFileUnsubscribedNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilefileunsubscribednotification() CPublishedFileFileUnsubscribedNotification {
return CPublishedFileFileUnsubscribedNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilefileunsubscribednotification(o CPublishedFileFileUnsubscribedNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilefileunsubscribednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileFileUnsubscribedNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilefileunsubscribednotification_unpack(v)?
return i, unpacked
}
pub struct CPublishedFileFileDeletedClientNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
app_id u32
has_app_id bool
}
pub fn (o &CPublishedFileFileDeletedClientNotification) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

return res
}

pub fn cpublishedfilefiledeletedclientnotification_unpack(buf []byte) ?CPublishedFileFileDeletedClientNotification {
mut res := CPublishedFileFileDeletedClientNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfilefiledeletedclientnotification() CPublishedFileFileDeletedClientNotification {
return CPublishedFileFileDeletedClientNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfilefiledeletedclientnotification(o CPublishedFileFileDeletedClientNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfilefiledeletedclientnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFileFileDeletedClientNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpublishedfilefiledeletedclientnotification_unpack(v)?
return i, unpacked
}
