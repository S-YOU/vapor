// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EPublishedFileRevision {
	k_epublishedfilerevision_default = 0
	k_epublishedfilerevision_latest = 1
	k_epublishedfilerevision_approvedsnapshot = 2
	k_epublishedfilerevision_approvedsnapshot_china = 3
	k_epublishedfilerevision_rejectedsnapshot = 4
	k_epublishedfilerevision_rejectedsnapshot_china = 5
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_epublishedfilerevision(e EPublishedFileRevision, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_epublishedfilerevision_packed(e []EPublishedFileRevision, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_epublishedfilerevision(buf []byte, tag_wiretype vproto.WireType) ?(int, EPublishedFileRevision) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EPublishedFileRevision(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_epublishedfilerevision_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EPublishedFileRevision) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EPublishedFileForSaleStatus {
	k_pffss_notforsale = 0
	k_pffss_pendingapproval = 1
	k_pffss_approvedforsale = 2
	k_pffss_rejectedforsale = 3
	k_pffss_nolongerforsale = 4
	k_pffss_tentativeapproval = 5
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_epublishedfileforsalestatus(e EPublishedFileForSaleStatus, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_epublishedfileforsalestatus_packed(e []EPublishedFileForSaleStatus, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_epublishedfileforsalestatus(buf []byte, tag_wiretype vproto.WireType) ?(int, EPublishedFileForSaleStatus) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EPublishedFileForSaleStatus(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_epublishedfileforsalestatus_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EPublishedFileForSaleStatus) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CPublishedFile_Subscribe_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
	list_type           u32
	has_list_type       bool
	appid               int
	has_appid           bool
	notify_client       bool
	has_notify_client   bool
}

pub fn (o &CPublishedFile_Subscribe_Request) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.has_list_type {
		res << vproto.pack_uint32_field(o.list_type, 2)
	}
	if o.has_appid {
		res << vproto.pack_int32_field(o.appid, 3)
	}
	if o.has_notify_client {
		res << vproto.pack_bool_field(o.notify_client, 4)
	}
	return res
}

pub fn cpublishedfile_subscribe_request_unpack(buf []byte) ?CPublishedFile_Subscribe_Request {
	mut res := CPublishedFile_Subscribe_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				res.has_list_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.list_type = v
				i = ii
			}
			3 {
				res.has_appid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			4 {
				res.has_notify_client = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notify_client = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_subscribe_request() CPublishedFile_Subscribe_Request {
	return CPublishedFile_Subscribe_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_subscribe_request(o CPublishedFile_Subscribe_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_subscribe_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Subscribe_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_subscribe_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Subscribe_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_Subscribe_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_subscribe_response_unpack(buf []byte) ?CPublishedFile_Subscribe_Response {
	res := CPublishedFile_Subscribe_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_subscribe_response() CPublishedFile_Subscribe_Response {
	return CPublishedFile_Subscribe_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_subscribe_response(o CPublishedFile_Subscribe_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_subscribe_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Subscribe_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_subscribe_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Unsubscribe_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
	list_type           u32
	has_list_type       bool
	appid               int
	has_appid           bool
	notify_client       bool
	has_notify_client   bool
}

pub fn (o &CPublishedFile_Unsubscribe_Request) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.has_list_type {
		res << vproto.pack_uint32_field(o.list_type, 2)
	}
	if o.has_appid {
		res << vproto.pack_int32_field(o.appid, 3)
	}
	if o.has_notify_client {
		res << vproto.pack_bool_field(o.notify_client, 4)
	}
	return res
}

pub fn cpublishedfile_unsubscribe_request_unpack(buf []byte) ?CPublishedFile_Unsubscribe_Request {
	mut res := CPublishedFile_Unsubscribe_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				res.has_list_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.list_type = v
				i = ii
			}
			3 {
				res.has_appid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			4 {
				res.has_notify_client = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notify_client = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_unsubscribe_request() CPublishedFile_Unsubscribe_Request {
	return CPublishedFile_Unsubscribe_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_unsubscribe_request(o CPublishedFile_Unsubscribe_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_unsubscribe_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Unsubscribe_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_unsubscribe_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Unsubscribe_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_Unsubscribe_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_unsubscribe_response_unpack(buf []byte) ?CPublishedFile_Unsubscribe_Response {
	res := CPublishedFile_Unsubscribe_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_unsubscribe_response() CPublishedFile_Unsubscribe_Response {
	return CPublishedFile_Unsubscribe_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_unsubscribe_response(o CPublishedFile_Unsubscribe_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_unsubscribe_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Unsubscribe_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_unsubscribe_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_CanSubscribe_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
}

pub fn (o &CPublishedFile_CanSubscribe_Request) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	return res
}

pub fn cpublishedfile_cansubscribe_request_unpack(buf []byte) ?CPublishedFile_CanSubscribe_Request {
	mut res := CPublishedFile_CanSubscribe_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_cansubscribe_request() CPublishedFile_CanSubscribe_Request {
	return CPublishedFile_CanSubscribe_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_cansubscribe_request(o CPublishedFile_CanSubscribe_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_cansubscribe_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_CanSubscribe_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_cansubscribe_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_CanSubscribe_Response {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	can_subscribe     bool
	has_can_subscribe bool
}

pub fn (o &CPublishedFile_CanSubscribe_Response) pack() []byte {
	mut res := []byte{}
	if o.has_can_subscribe {
		res << vproto.pack_bool_field(o.can_subscribe, 1)
	}
	return res
}

pub fn cpublishedfile_cansubscribe_response_unpack(buf []byte) ?CPublishedFile_CanSubscribe_Response {
	mut res := CPublishedFile_CanSubscribe_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_can_subscribe = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_subscribe = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_cansubscribe_response() CPublishedFile_CanSubscribe_Response {
	return CPublishedFile_CanSubscribe_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_cansubscribe_response(o CPublishedFile_CanSubscribe_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_cansubscribe_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_CanSubscribe_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_cansubscribe_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Publish_Request {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	appid                      u32
	has_appid                  bool
	consumer_appid             u32
	has_consumer_appid         bool
	cloudfilename              string
	has_cloudfilename          bool
	preview_cloudfilename      string
	has_preview_cloudfilename  bool
	title                      string
	has_title                  bool
	file_description           string
	has_file_description       bool
	file_type                  u32
	has_file_type              bool
	consumer_shortcut_name     string
	has_consumer_shortcut_name bool
	youtube_username           string
	has_youtube_username       bool
	youtube_videoid            string
	has_youtube_videoid        bool
	visibility                 u32
	has_visibility             bool
	redirect_uri               string
	has_redirect_uri           bool
	tags                       []string
	collection_type            string
	has_collection_type        bool
	game_type                  string
	has_game_type              bool
	url                        string
	has_url                    bool
}

pub fn (o &CPublishedFile_Publish_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_consumer_appid {
		res << vproto.pack_uint32_field(o.consumer_appid, 2)
	}
	if o.has_cloudfilename {
		res << vproto.pack_string_field(o.cloudfilename, 3)
	}
	if o.has_preview_cloudfilename {
		res << vproto.pack_string_field(o.preview_cloudfilename, 4)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 5)
	}
	if o.has_file_description {
		res << vproto.pack_string_field(o.file_description, 6)
	}
	if o.has_file_type {
		res << vproto.pack_uint32_field(o.file_type, 7)
	}
	if o.has_consumer_shortcut_name {
		res << vproto.pack_string_field(o.consumer_shortcut_name, 8)
	}
	if o.has_youtube_username {
		res << vproto.pack_string_field(o.youtube_username, 9)
	}
	if o.has_youtube_videoid {
		res << vproto.pack_string_field(o.youtube_videoid, 10)
	}
	if o.has_visibility {
		res << vproto.pack_uint32_field(o.visibility, 11)
	}
	if o.has_redirect_uri {
		res << vproto.pack_string_field(o.redirect_uri, 12)
	}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 13)
	}
	if o.has_collection_type {
		res << vproto.pack_string_field(o.collection_type, 14)
	}
	if o.has_game_type {
		res << vproto.pack_string_field(o.game_type, 15)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 16)
	}
	return res
}

pub fn cpublishedfile_publish_request_unpack(buf []byte) ?CPublishedFile_Publish_Request {
	mut res := CPublishedFile_Publish_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_consumer_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.consumer_appid = v
				i = ii
			}
			3 {
				res.has_cloudfilename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cloudfilename = v
				i = ii
			}
			4 {
				res.has_preview_cloudfilename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.preview_cloudfilename = v
				i = ii
			}
			5 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			6 {
				res.has_file_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_description = v
				i = ii
			}
			7 {
				res.has_file_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_type = v
				i = ii
			}
			8 {
				res.has_consumer_shortcut_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.consumer_shortcut_name = v
				i = ii
			}
			9 {
				res.has_youtube_username = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.youtube_username = v
				i = ii
			}
			10 {
				res.has_youtube_videoid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.youtube_videoid = v
				i = ii
			}
			11 {
				res.has_visibility = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.visibility = v
				i = ii
			}
			12 {
				res.has_redirect_uri = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.redirect_uri = v
				i = ii
			}
			13 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			14 {
				res.has_collection_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.collection_type = v
				i = ii
			}
			15 {
				res.has_game_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_type = v
				i = ii
			}
			16 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_publish_request() CPublishedFile_Publish_Request {
	return CPublishedFile_Publish_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_publish_request(o CPublishedFile_Publish_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_publish_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Publish_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_publish_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Publish_Response {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
	redirect_uri        string
	has_redirect_uri    bool
}

pub fn (o &CPublishedFile_Publish_Response) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.has_redirect_uri {
		res << vproto.pack_string_field(o.redirect_uri, 2)
	}
	return res
}

pub fn cpublishedfile_publish_response_unpack(buf []byte) ?CPublishedFile_Publish_Response {
	mut res := CPublishedFile_Publish_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				res.has_redirect_uri = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.redirect_uri = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_publish_response() CPublishedFile_Publish_Response {
	return CPublishedFile_Publish_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_publish_response(o CPublishedFile_Publish_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_publish_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Publish_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_publish_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetDetails_Request {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	publishedfileids              []u64
	includetags                   bool
	has_includetags               bool
	includeadditionalpreviews     bool
	has_includeadditionalpreviews bool
	includechildren               bool
	has_includechildren           bool
	includekvtags                 bool
	has_includekvtags             bool
	includevotes                  bool
	has_includevotes              bool
	short_description             bool
	has_short_description         bool
	includeforsaledata            bool
	has_includeforsaledata        bool
	includemetadata               bool
	has_includemetadata           bool
	language                      int
	has_language                  bool
	return_playtime_stats         u32
	has_return_playtime_stats     bool
	appid                         u32
	has_appid                     bool
	strip_description_bbcode      bool
	has_strip_description_bbcode  bool
	desired_revision              EPublishedFileRevision
	has_desired_revision          bool
	includereactions              bool
	has_includereactions          bool
}

pub fn (o &CPublishedFile_GetDetails_Request) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.publishedfileids {
		res << vproto.pack_64bit_field(x, 1)
	}
	if o.has_includetags {
		res << vproto.pack_bool_field(o.includetags, 2)
	}
	if o.has_includeadditionalpreviews {
		res << vproto.pack_bool_field(o.includeadditionalpreviews, 3)
	}
	if o.has_includechildren {
		res << vproto.pack_bool_field(o.includechildren, 4)
	}
	if o.has_includekvtags {
		res << vproto.pack_bool_field(o.includekvtags, 5)
	}
	if o.has_includevotes {
		res << vproto.pack_bool_field(o.includevotes, 6)
	}
	if o.has_short_description {
		res << vproto.pack_bool_field(o.short_description, 8)
	}
	if o.has_includeforsaledata {
		res << vproto.pack_bool_field(o.includeforsaledata, 10)
	}
	if o.has_includemetadata {
		res << vproto.pack_bool_field(o.includemetadata, 11)
	}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 12)
	}
	if o.has_return_playtime_stats {
		res << vproto.pack_uint32_field(o.return_playtime_stats, 13)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 14)
	}
	if o.has_strip_description_bbcode {
		res << vproto.pack_bool_field(o.strip_description_bbcode, 15)
	}
	if o.has_desired_revision {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 16)
	}
	if o.has_includereactions {
		res << vproto.pack_bool_field(o.includereactions, 17)
	}
	return res
}

pub fn cpublishedfile_getdetails_request_unpack(buf []byte) ?CPublishedFile_GetDetails_Request {
	mut res := CPublishedFile_GetDetails_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileids << v
				i = ii
			}
			2 {
				res.has_includetags = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includetags = v
				i = ii
			}
			3 {
				res.has_includeadditionalpreviews = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includeadditionalpreviews = v
				i = ii
			}
			4 {
				res.has_includechildren = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includechildren = v
				i = ii
			}
			5 {
				res.has_includekvtags = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includekvtags = v
				i = ii
			}
			6 {
				res.has_includevotes = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includevotes = v
				i = ii
			}
			8 {
				res.has_short_description = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.short_description = v
				i = ii
			}
			10 {
				res.has_includeforsaledata = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includeforsaledata = v
				i = ii
			}
			11 {
				res.has_includemetadata = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includemetadata = v
				i = ii
			}
			12 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			13 {
				res.has_return_playtime_stats = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.return_playtime_stats = v
				i = ii
			}
			14 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			15 {
				res.has_strip_description_bbcode = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.strip_description_bbcode = v
				i = ii
			}
			16 {
				res.has_desired_revision = true
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.desired_revision = v
				i = ii
			}
			17 {
				res.has_includereactions = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.includereactions = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getdetails_request() CPublishedFile_GetDetails_Request {
	return CPublishedFile_GetDetails_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getdetails_request(o CPublishedFile_GetDetails_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getdetails_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetDetails_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getdetails_request_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_Tag {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	tag            string
	has_tag        bool
	adminonly      bool
	has_adminonly  bool
}

pub fn (o &PublishedFileDetails_Tag) pack() []byte {
	mut res := []byte{}
	if o.has_tag {
		res << vproto.pack_string_field(o.tag, 1)
	}
	if o.has_adminonly {
		res << vproto.pack_bool_field(o.adminonly, 2)
	}
	return res
}

pub fn publishedfiledetails_tag_unpack(buf []byte) ?PublishedFileDetails_Tag {
	mut res := PublishedFileDetails_Tag{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_tag = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tag = v
				i = ii
			}
			2 {
				res.has_adminonly = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.adminonly = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetails_tag() PublishedFileDetails_Tag {
	return PublishedFileDetails_Tag{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetails_tag(o PublishedFileDetails_Tag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetails_tag(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_Tag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_tag_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_Preview {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	previewid              u64
	has_previewid          bool
	sortorder              u32
	has_sortorder          bool
	url                    string
	has_url                bool
	size                   u32
	has_size               bool
	filename               string
	has_filename           bool
	youtubevideoid         string
	has_youtubevideoid     bool
	preview_type           u32
	has_preview_type       bool
	external_reference     string
	has_external_reference bool
}

pub fn (o &PublishedFileDetails_Preview) pack() []byte {
	mut res := []byte{}
	if o.has_previewid {
		res << vproto.pack_uint64_field(o.previewid, 1)
	}
	if o.has_sortorder {
		res << vproto.pack_uint32_field(o.sortorder, 2)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 3)
	}
	if o.has_size {
		res << vproto.pack_uint32_field(o.size, 4)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 5)
	}
	if o.has_youtubevideoid {
		res << vproto.pack_string_field(o.youtubevideoid, 6)
	}
	if o.has_preview_type {
		res << vproto.pack_uint32_field(o.preview_type, 7)
	}
	if o.has_external_reference {
		res << vproto.pack_string_field(o.external_reference, 8)
	}
	return res
}

pub fn publishedfiledetails_preview_unpack(buf []byte) ?PublishedFileDetails_Preview {
	mut res := PublishedFileDetails_Preview{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_previewid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.previewid = v
				i = ii
			}
			2 {
				res.has_sortorder = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sortorder = v
				i = ii
			}
			3 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			4 {
				res.has_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.size = v
				i = ii
			}
			5 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			6 {
				res.has_youtubevideoid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.youtubevideoid = v
				i = ii
			}
			7 {
				res.has_preview_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.preview_type = v
				i = ii
			}
			8 {
				res.has_external_reference = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.external_reference = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetails_preview() PublishedFileDetails_Preview {
	return PublishedFileDetails_Preview{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetails_preview(o PublishedFileDetails_Preview, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetails_preview(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_Preview) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_preview_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_Child {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
	sortorder           u32
	has_sortorder       bool
	file_type           u32
	has_file_type       bool
}

pub fn (o &PublishedFileDetails_Child) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.has_sortorder {
		res << vproto.pack_uint32_field(o.sortorder, 2)
	}
	if o.has_file_type {
		res << vproto.pack_uint32_field(o.file_type, 3)
	}
	return res
}

pub fn publishedfiledetails_child_unpack(buf []byte) ?PublishedFileDetails_Child {
	mut res := PublishedFileDetails_Child{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				res.has_sortorder = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sortorder = v
				i = ii
			}
			3 {
				res.has_file_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_type = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetails_child() PublishedFileDetails_Child {
	return PublishedFileDetails_Child{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetails_child(o PublishedFileDetails_Child, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetails_child(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_Child) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_child_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_KVTag {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &PublishedFileDetails_KVTag) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn publishedfiledetails_kvtag_unpack(buf []byte) ?PublishedFileDetails_KVTag {
	mut res := PublishedFileDetails_KVTag{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetails_kvtag() PublishedFileDetails_KVTag {
	return PublishedFileDetails_KVTag{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetails_kvtag(o PublishedFileDetails_KVTag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetails_kvtag(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_KVTag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_kvtag_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_VoteData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	score          f32
	has_score      bool
	votes_up       u32
	has_votes_up   bool
	votes_down     u32
	has_votes_down bool
}

pub fn (o &PublishedFileDetails_VoteData) pack() []byte {
	mut res := []byte{}
	if o.has_score {
		res << vproto.pack_float_field(o.score, 1)
	}
	if o.has_votes_up {
		res << vproto.pack_uint32_field(o.votes_up, 2)
	}
	if o.has_votes_down {
		res << vproto.pack_uint32_field(o.votes_down, 3)
	}
	return res
}

pub fn publishedfiledetails_votedata_unpack(buf []byte) ?PublishedFileDetails_VoteData {
	mut res := PublishedFileDetails_VoteData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_score = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.score = v
				i = ii
			}
			2 {
				res.has_votes_up = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.votes_up = v
				i = ii
			}
			3 {
				res.has_votes_down = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.votes_down = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetails_votedata() PublishedFileDetails_VoteData {
	return PublishedFileDetails_VoteData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetails_votedata(o PublishedFileDetails_VoteData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetails_votedata(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_VoteData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_votedata_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_ForSaleData {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	is_for_sale                    bool
	has_is_for_sale                bool
	price_category                 u32
	has_price_category             bool
	estatus                        EPublishedFileForSaleStatus
	has_estatus                    bool
	price_category_floor           u32
	has_price_category_floor       bool
	price_is_pay_what_you_want     bool
	has_price_is_pay_what_you_want bool
	discount_percentage            u32
	has_discount_percentage        bool
}

pub fn (o &PublishedFileDetails_ForSaleData) pack() []byte {
	mut res := []byte{}
	if o.has_is_for_sale {
		res << vproto.pack_bool_field(o.is_for_sale, 1)
	}
	if o.has_price_category {
		res << vproto.pack_uint32_field(o.price_category, 2)
	}
	if o.has_estatus {
		res << zzz_vproto_internal_pack_epublishedfileforsalestatus(o.estatus, 3)
	}
	if o.has_price_category_floor {
		res << vproto.pack_uint32_field(o.price_category_floor, 4)
	}
	if o.has_price_is_pay_what_you_want {
		res << vproto.pack_bool_field(o.price_is_pay_what_you_want, 5)
	}
	if o.has_discount_percentage {
		res << vproto.pack_uint32_field(o.discount_percentage, 6)
	}
	return res
}

pub fn publishedfiledetails_forsaledata_unpack(buf []byte) ?PublishedFileDetails_ForSaleData {
	mut res := PublishedFileDetails_ForSaleData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_is_for_sale = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_for_sale = v
				i = ii
			}
			2 {
				res.has_price_category = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.price_category = v
				i = ii
			}
			3 {
				res.has_estatus = true
				ii, v := zzz_vproto_internal_unpack_epublishedfileforsalestatus(cur_buf,
					tag_wiretype.wire_type)?
				res.estatus = v
				i = ii
			}
			4 {
				res.has_price_category_floor = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.price_category_floor = v
				i = ii
			}
			5 {
				res.has_price_is_pay_what_you_want = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.price_is_pay_what_you_want = v
				i = ii
			}
			6 {
				res.has_discount_percentage = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.discount_percentage = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetails_forsaledata() PublishedFileDetails_ForSaleData {
	return PublishedFileDetails_ForSaleData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetails_forsaledata(o PublishedFileDetails_ForSaleData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetails_forsaledata(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_ForSaleData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_forsaledata_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_PlaytimeStats {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	playtime_seconds     u64
	has_playtime_seconds bool
	num_sessions         u64
	has_num_sessions     bool
}

pub fn (o &PublishedFileDetails_PlaytimeStats) pack() []byte {
	mut res := []byte{}
	if o.has_playtime_seconds {
		res << vproto.pack_uint64_field(o.playtime_seconds, 1)
	}
	if o.has_num_sessions {
		res << vproto.pack_uint64_field(o.num_sessions, 2)
	}
	return res
}

pub fn publishedfiledetails_playtimestats_unpack(buf []byte) ?PublishedFileDetails_PlaytimeStats {
	mut res := PublishedFileDetails_PlaytimeStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_playtime_seconds = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.playtime_seconds = v
				i = ii
			}
			2 {
				res.has_num_sessions = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.num_sessions = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetails_playtimestats() PublishedFileDetails_PlaytimeStats {
	return PublishedFileDetails_PlaytimeStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetails_playtimestats(o PublishedFileDetails_PlaytimeStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetails_playtimestats(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_PlaytimeStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_playtimestats_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails_Reaction {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	reactionid     u32
	has_reactionid bool
	count          u32
	has_count      bool
}

pub fn (o &PublishedFileDetails_Reaction) pack() []byte {
	mut res := []byte{}
	if o.has_reactionid {
		res << vproto.pack_uint32_field(o.reactionid, 1)
	}
	if o.has_count {
		res << vproto.pack_uint32_field(o.count, 2)
	}
	return res
}

pub fn publishedfiledetails_reaction_unpack(buf []byte) ?PublishedFileDetails_Reaction {
	mut res := PublishedFileDetails_Reaction{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_reactionid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.reactionid = v
				i = ii
			}
			2 {
				res.has_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetails_reaction() PublishedFileDetails_Reaction {
	return PublishedFileDetails_Reaction{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetails_reaction(o PublishedFileDetails_Reaction, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetails_reaction(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails_Reaction) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_reaction_unpack(v)?
	return i, unpacked
}

pub struct PublishedFileDetails {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	result                           u32
	has_result                       bool
	publishedfileid                  u64
	has_publishedfileid              bool
	creator                          u64
	has_creator                      bool
	creator_appid                    u32
	has_creator_appid                bool
	consumer_appid                   u32
	has_consumer_appid               bool
	consumer_shortcutid              u32
	has_consumer_shortcutid          bool
	filename                         string
	has_filename                     bool
	file_size                        u64
	has_file_size                    bool
	preview_file_size                u64
	has_preview_file_size            bool
	file_url                         string
	has_file_url                     bool
	preview_url                      string
	has_preview_url                  bool
	youtubevideoid                   string
	has_youtubevideoid               bool
	url                              string
	has_url                          bool
	hcontent_file                    u64
	has_hcontent_file                bool
	hcontent_preview                 u64
	has_hcontent_preview             bool
	title                            string
	has_title                        bool
	file_description                 string
	has_file_description             bool
	short_description                string
	has_short_description            bool
	time_created                     u32
	has_time_created                 bool
	time_updated                     u32
	has_time_updated                 bool
	visibility                       u32
	has_visibility                   bool
	flags                            u32
	has_flags                        bool
	workshop_file                    bool
	has_workshop_file                bool
	workshop_accepted                bool
	has_workshop_accepted            bool
	show_subscribe_all               bool
	has_show_subscribe_all           bool
	num_comments_developer           int
	has_num_comments_developer       bool
	num_comments_public              int
	has_num_comments_public          bool
	banned                           bool
	has_banned                       bool
	ban_reason                       string
	has_ban_reason                   bool
	banner                           u64
	has_banner                       bool
	can_be_deleted                   bool
	has_can_be_deleted               bool
	incompatible                     bool
	has_incompatible                 bool
	app_name                         string
	has_app_name                     bool
	file_type                        u32
	has_file_type                    bool
	can_subscribe                    bool
	has_can_subscribe                bool
	subscriptions                    u32
	has_subscriptions                bool
	favorited                        u32
	has_favorited                    bool
	followers                        u32
	has_followers                    bool
	lifetime_subscriptions           u32
	has_lifetime_subscriptions       bool
	lifetime_favorited               u32
	has_lifetime_favorited           bool
	lifetime_followers               u32
	has_lifetime_followers           bool
	lifetime_playtime                u64
	has_lifetime_playtime            bool
	lifetime_playtime_sessions       u64
	has_lifetime_playtime_sessions   bool
	views                            u32
	has_views                        bool
	image_width                      u32
	has_image_width                  bool
	image_height                     u32
	has_image_height                 bool
	image_url                        string
	has_image_url                    bool
	spoiler_tag                      bool
	has_spoiler_tag                  bool
	shortcutid                       u32
	has_shortcutid                   bool
	shortcutname                     string
	has_shortcutname                 bool
	num_children                     u32
	has_num_children                 bool
	num_reports                      u32
	has_num_reports                  bool
	previews                         []PublishedFileDetails_Preview
	tags                             []PublishedFileDetails_Tag
	children                         []PublishedFileDetails_Child
	kvtags                           []PublishedFileDetails_KVTag
	vote_data                        PublishedFileDetails_VoteData
	has_vote_data                    bool
	playtime_stats                   PublishedFileDetails_PlaytimeStats
	has_playtime_stats               bool
	time_subscribed                  u32
	has_time_subscribed              bool
	for_sale_data                    PublishedFileDetails_ForSaleData
	has_for_sale_data                bool
	metadata                         string
	has_metadata                     bool
	language                         int
	has_language                     bool
	maybe_inappropriate_sex          bool
	has_maybe_inappropriate_sex      bool
	maybe_inappropriate_violence     bool
	has_maybe_inappropriate_violence bool
	revision_change_number           u64
	has_revision_change_number       bool
	revision                         EPublishedFileRevision
	has_revision                     bool
	available_revisions              []EPublishedFileRevision
	reactions                        []PublishedFileDetails_Reaction
}

pub fn (o &PublishedFileDetails) pack() []byte {
	mut res := []byte{}
	if o.has_result {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 2)
	}
	if o.has_creator {
		res << vproto.pack_64bit_field(o.creator, 3)
	}
	if o.has_creator_appid {
		res << vproto.pack_uint32_field(o.creator_appid, 4)
	}
	if o.has_consumer_appid {
		res << vproto.pack_uint32_field(o.consumer_appid, 5)
	}
	if o.has_consumer_shortcutid {
		res << vproto.pack_uint32_field(o.consumer_shortcutid, 6)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 7)
	}
	if o.has_file_size {
		res << vproto.pack_uint64_field(o.file_size, 8)
	}
	if o.has_preview_file_size {
		res << vproto.pack_uint64_field(o.preview_file_size, 9)
	}
	if o.has_file_url {
		res << vproto.pack_string_field(o.file_url, 10)
	}
	if o.has_preview_url {
		res << vproto.pack_string_field(o.preview_url, 11)
	}
	if o.has_youtubevideoid {
		res << vproto.pack_string_field(o.youtubevideoid, 12)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 13)
	}
	if o.has_hcontent_file {
		res << vproto.pack_64bit_field(o.hcontent_file, 14)
	}
	if o.has_hcontent_preview {
		res << vproto.pack_64bit_field(o.hcontent_preview, 15)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 16)
	}
	if o.has_file_description {
		res << vproto.pack_string_field(o.file_description, 17)
	}
	if o.has_short_description {
		res << vproto.pack_string_field(o.short_description, 18)
	}
	if o.has_time_created {
		res << vproto.pack_uint32_field(o.time_created, 19)
	}
	if o.has_time_updated {
		res << vproto.pack_uint32_field(o.time_updated, 20)
	}
	if o.has_visibility {
		res << vproto.pack_uint32_field(o.visibility, 21)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 22)
	}
	if o.has_workshop_file {
		res << vproto.pack_bool_field(o.workshop_file, 23)
	}
	if o.has_workshop_accepted {
		res << vproto.pack_bool_field(o.workshop_accepted, 24)
	}
	if o.has_show_subscribe_all {
		res << vproto.pack_bool_field(o.show_subscribe_all, 25)
	}
	if o.has_num_comments_developer {
		res << vproto.pack_int32_field(o.num_comments_developer, 26)
	}
	if o.has_num_comments_public {
		res << vproto.pack_int32_field(o.num_comments_public, 27)
	}
	if o.has_banned {
		res << vproto.pack_bool_field(o.banned, 28)
	}
	if o.has_ban_reason {
		res << vproto.pack_string_field(o.ban_reason, 29)
	}
	if o.has_banner {
		res << vproto.pack_64bit_field(o.banner, 30)
	}
	if o.has_can_be_deleted {
		res << vproto.pack_bool_field(o.can_be_deleted, 31)
	}
	if o.has_incompatible {
		res << vproto.pack_bool_field(o.incompatible, 32)
	}
	if o.has_app_name {
		res << vproto.pack_string_field(o.app_name, 33)
	}
	if o.has_file_type {
		res << vproto.pack_uint32_field(o.file_type, 34)
	}
	if o.has_can_subscribe {
		res << vproto.pack_bool_field(o.can_subscribe, 35)
	}
	if o.has_subscriptions {
		res << vproto.pack_uint32_field(o.subscriptions, 36)
	}
	if o.has_favorited {
		res << vproto.pack_uint32_field(o.favorited, 37)
	}
	if o.has_followers {
		res << vproto.pack_uint32_field(o.followers, 38)
	}
	if o.has_lifetime_subscriptions {
		res << vproto.pack_uint32_field(o.lifetime_subscriptions, 39)
	}
	if o.has_lifetime_favorited {
		res << vproto.pack_uint32_field(o.lifetime_favorited, 40)
	}
	if o.has_lifetime_followers {
		res << vproto.pack_uint32_field(o.lifetime_followers, 41)
	}
	if o.has_lifetime_playtime {
		res << vproto.pack_uint64_field(o.lifetime_playtime, 62)
	}
	if o.has_lifetime_playtime_sessions {
		res << vproto.pack_uint64_field(o.lifetime_playtime_sessions, 63)
	}
	if o.has_views {
		res << vproto.pack_uint32_field(o.views, 42)
	}
	if o.has_image_width {
		res << vproto.pack_uint32_field(o.image_width, 43)
	}
	if o.has_image_height {
		res << vproto.pack_uint32_field(o.image_height, 44)
	}
	if o.has_image_url {
		res << vproto.pack_string_field(o.image_url, 45)
	}
	if o.has_spoiler_tag {
		res << vproto.pack_bool_field(o.spoiler_tag, 46)
	}
	if o.has_shortcutid {
		res << vproto.pack_uint32_field(o.shortcutid, 47)
	}
	if o.has_shortcutname {
		res << vproto.pack_string_field(o.shortcutname, 48)
	}
	if o.has_num_children {
		res << vproto.pack_uint32_field(o.num_children, 49)
	}
	if o.has_num_reports {
		res << vproto.pack_uint32_field(o.num_reports, 50)
	}
	// [packed=false]
	for _, x in o.previews {
		res << zzz_vproto_internal_pack_publishedfiledetails_preview(x, 51)
	}
	// [packed=false]
	for _, x in o.tags {
		res << zzz_vproto_internal_pack_publishedfiledetails_tag(x, 52)
	}
	// [packed=false]
	for _, x in o.children {
		res << zzz_vproto_internal_pack_publishedfiledetails_child(x, 53)
	}
	// [packed=false]
	for _, x in o.kvtags {
		res << zzz_vproto_internal_pack_publishedfiledetails_kvtag(x, 54)
	}
	if o.has_vote_data {
		res << zzz_vproto_internal_pack_publishedfiledetails_votedata(o.vote_data, 55)
	}
	if o.has_playtime_stats {
		res << zzz_vproto_internal_pack_publishedfiledetails_playtimestats(o.playtime_stats, 64)
	}
	if o.has_time_subscribed {
		res << vproto.pack_uint32_field(o.time_subscribed, 56)
	}
	if o.has_for_sale_data {
		res << zzz_vproto_internal_pack_publishedfiledetails_forsaledata(o.for_sale_data, 57)
	}
	if o.has_metadata {
		res << vproto.pack_string_field(o.metadata, 58)
	}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 61)
	}
	if o.has_maybe_inappropriate_sex {
		res << vproto.pack_bool_field(o.maybe_inappropriate_sex, 65)
	}
	if o.has_maybe_inappropriate_violence {
		res << vproto.pack_bool_field(o.maybe_inappropriate_violence, 66)
	}
	if o.has_revision_change_number {
		res << vproto.pack_uint64_field(o.revision_change_number, 67)
	}
	if o.has_revision {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.revision, 68)
	}
	// [packed=false]
	for _, x in o.available_revisions {
		res << zzz_vproto_internal_pack_epublishedfilerevision(x, 69)
	}
	// [packed=false]
	for _, x in o.reactions {
		res << zzz_vproto_internal_pack_publishedfiledetails_reaction(x, 70)
	}
	return res
}

pub fn publishedfiledetails_unpack(buf []byte) ?PublishedFileDetails {
	mut res := PublishedFileDetails{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			2 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			3 {
				res.has_creator = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.creator = v
				i = ii
			}
			4 {
				res.has_creator_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.creator_appid = v
				i = ii
			}
			5 {
				res.has_consumer_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.consumer_appid = v
				i = ii
			}
			6 {
				res.has_consumer_shortcutid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.consumer_shortcutid = v
				i = ii
			}
			7 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			8 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			9 {
				res.has_preview_file_size = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.preview_file_size = v
				i = ii
			}
			10 {
				res.has_file_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_url = v
				i = ii
			}
			11 {
				res.has_preview_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.preview_url = v
				i = ii
			}
			12 {
				res.has_youtubevideoid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.youtubevideoid = v
				i = ii
			}
			13 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			14 {
				res.has_hcontent_file = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.hcontent_file = v
				i = ii
			}
			15 {
				res.has_hcontent_preview = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.hcontent_preview = v
				i = ii
			}
			16 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			17 {
				res.has_file_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_description = v
				i = ii
			}
			18 {
				res.has_short_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.short_description = v
				i = ii
			}
			19 {
				res.has_time_created = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			20 {
				res.has_time_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_updated = v
				i = ii
			}
			21 {
				res.has_visibility = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.visibility = v
				i = ii
			}
			22 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			23 {
				res.has_workshop_file = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.workshop_file = v
				i = ii
			}
			24 {
				res.has_workshop_accepted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.workshop_accepted = v
				i = ii
			}
			25 {
				res.has_show_subscribe_all = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.show_subscribe_all = v
				i = ii
			}
			26 {
				res.has_num_comments_developer = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_comments_developer = v
				i = ii
			}
			27 {
				res.has_num_comments_public = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_comments_public = v
				i = ii
			}
			28 {
				res.has_banned = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.banned = v
				i = ii
			}
			29 {
				res.has_ban_reason = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.ban_reason = v
				i = ii
			}
			30 {
				res.has_banner = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.banner = v
				i = ii
			}
			31 {
				res.has_can_be_deleted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_be_deleted = v
				i = ii
			}
			32 {
				res.has_incompatible = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.incompatible = v
				i = ii
			}
			33 {
				res.has_app_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.app_name = v
				i = ii
			}
			34 {
				res.has_file_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_type = v
				i = ii
			}
			35 {
				res.has_can_subscribe = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_subscribe = v
				i = ii
			}
			36 {
				res.has_subscriptions = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.subscriptions = v
				i = ii
			}
			37 {
				res.has_favorited = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.favorited = v
				i = ii
			}
			38 {
				res.has_followers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.followers = v
				i = ii
			}
			39 {
				res.has_lifetime_subscriptions = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.lifetime_subscriptions = v
				i = ii
			}
			40 {
				res.has_lifetime_favorited = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.lifetime_favorited = v
				i = ii
			}
			41 {
				res.has_lifetime_followers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.lifetime_followers = v
				i = ii
			}
			62 {
				res.has_lifetime_playtime = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.lifetime_playtime = v
				i = ii
			}
			63 {
				res.has_lifetime_playtime_sessions = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.lifetime_playtime_sessions = v
				i = ii
			}
			42 {
				res.has_views = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.views = v
				i = ii
			}
			43 {
				res.has_image_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.image_width = v
				i = ii
			}
			44 {
				res.has_image_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.image_height = v
				i = ii
			}
			45 {
				res.has_image_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.image_url = v
				i = ii
			}
			46 {
				res.has_spoiler_tag = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.spoiler_tag = v
				i = ii
			}
			47 {
				res.has_shortcutid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.shortcutid = v
				i = ii
			}
			48 {
				res.has_shortcutname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.shortcutname = v
				i = ii
			}
			49 {
				res.has_num_children = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_children = v
				i = ii
			}
			50 {
				res.has_num_reports = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_reports = v
				i = ii
			}
			51 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_preview(cur_buf,
					tag_wiretype.wire_type)?
				res.previews << v
				i = ii
			}
			52 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_tag(cur_buf,
					tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			53 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_child(cur_buf,
					tag_wiretype.wire_type)?
				res.children << v
				i = ii
			}
			54 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_kvtag(cur_buf,
					tag_wiretype.wire_type)?
				res.kvtags << v
				i = ii
			}
			55 {
				res.has_vote_data = true
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_votedata(cur_buf,
					tag_wiretype.wire_type)?
				res.vote_data = v
				i = ii
			}
			64 {
				res.has_playtime_stats = true
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_playtimestats(cur_buf,
					tag_wiretype.wire_type)?
				res.playtime_stats = v
				i = ii
			}
			56 {
				res.has_time_subscribed = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_subscribed = v
				i = ii
			}
			57 {
				res.has_for_sale_data = true
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_forsaledata(cur_buf,
					tag_wiretype.wire_type)?
				res.for_sale_data = v
				i = ii
			}
			58 {
				res.has_metadata = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.metadata = v
				i = ii
			}
			61 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			65 {
				res.has_maybe_inappropriate_sex = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.maybe_inappropriate_sex = v
				i = ii
			}
			66 {
				res.has_maybe_inappropriate_violence = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.maybe_inappropriate_violence = v
				i = ii
			}
			67 {
				res.has_revision_change_number = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.revision_change_number = v
				i = ii
			}
			68 {
				res.has_revision = true
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.revision = v
				i = ii
			}
			69 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.available_revisions << v
				i = ii
			}
			70 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails_reaction(cur_buf,
					tag_wiretype.wire_type)?
				res.reactions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_publishedfiledetails() PublishedFileDetails {
	return PublishedFileDetails{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_publishedfiledetails(o PublishedFileDetails, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_publishedfiledetails(buf []byte, tag_wiretype vproto.WireType) ?(int, PublishedFileDetails) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := publishedfiledetails_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetDetails_Response {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	publishedfiledetails []PublishedFileDetails
}

pub fn (o &CPublishedFile_GetDetails_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.publishedfiledetails {
		res << zzz_vproto_internal_pack_publishedfiledetails(x, 1)
	}
	return res
}

pub fn cpublishedfile_getdetails_response_unpack(buf []byte) ?CPublishedFile_GetDetails_Response {
	mut res := CPublishedFile_GetDetails_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails(cur_buf, tag_wiretype.wire_type)?
				res.publishedfiledetails << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getdetails_response() CPublishedFile_GetDetails_Response {
	return CPublishedFile_GetDetails_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getdetails_response(o CPublishedFile_GetDetails_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getdetails_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetDetails_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getdetails_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetItemInfo_Request_WorkshopItem {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	time_updated          u32
	has_time_updated      bool
	desired_revision      EPublishedFileRevision
	has_desired_revision  bool
}

pub fn (o &CPublishedFile_GetItemInfo_Request_WorkshopItem) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_time_updated {
		res << vproto.pack_uint32_field(o.time_updated, 2)
	}
	if o.has_desired_revision {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 3)
	}
	return res
}

pub fn cpublishedfile_getiteminfo_request_workshopitem_unpack(buf []byte) ?CPublishedFile_GetItemInfo_Request_WorkshopItem {
	mut res := CPublishedFile_GetItemInfo_Request_WorkshopItem{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_time_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_updated = v
				i = ii
			}
			3 {
				res.has_desired_revision = true
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.desired_revision = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getiteminfo_request_workshopitem() CPublishedFile_GetItemInfo_Request_WorkshopItem {
	return CPublishedFile_GetItemInfo_Request_WorkshopItem{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getiteminfo_request_workshopitem(o CPublishedFile_GetItemInfo_Request_WorkshopItem, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getiteminfo_request_workshopitem(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetItemInfo_Request_WorkshopItem) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getiteminfo_request_workshopitem_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetItemInfo_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	app_id                u32
	has_app_id            bool
	last_time_updated     u32
	has_last_time_updated bool
	workshop_items        []CPublishedFile_GetItemInfo_Request_WorkshopItem
}

pub fn (o &CPublishedFile_GetItemInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_last_time_updated {
		res << vproto.pack_uint32_field(o.last_time_updated, 2)
	}
	// [packed=false]
	for _, x in o.workshop_items {
		res << zzz_vproto_internal_pack_cpublishedfile_getiteminfo_request_workshopitem(x, 3)
	}
	return res
}

pub fn cpublishedfile_getiteminfo_request_unpack(buf []byte) ?CPublishedFile_GetItemInfo_Request {
	mut res := CPublishedFile_GetItemInfo_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_last_time_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_time_updated = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getiteminfo_request_workshopitem(cur_buf,
					tag_wiretype.wire_type)?
				res.workshop_items << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getiteminfo_request() CPublishedFile_GetItemInfo_Request {
	return CPublishedFile_GetItemInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getiteminfo_request(o CPublishedFile_GetItemInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getiteminfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetItemInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getiteminfo_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	time_updated          u32
	has_time_updated      bool
	manifest_id           u64
	has_manifest_id       bool
	flags                 u32
	has_flags             bool
}

pub fn (o &CPublishedFile_GetItemInfo_Response_WorkshopItemInfo) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_time_updated {
		res << vproto.pack_uint32_field(o.time_updated, 2)
	}
	if o.has_manifest_id {
		res << vproto.pack_64bit_field(o.manifest_id, 3)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 4)
	}
	return res
}

pub fn cpublishedfile_getiteminfo_response_workshopiteminfo_unpack(buf []byte) ?CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
	mut res := CPublishedFile_GetItemInfo_Response_WorkshopItemInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_time_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_updated = v
				i = ii
			}
			3 {
				res.has_manifest_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.manifest_id = v
				i = ii
			}
			4 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getiteminfo_response_workshopiteminfo() CPublishedFile_GetItemInfo_Response_WorkshopItemInfo {
	return CPublishedFile_GetItemInfo_Response_WorkshopItemInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getiteminfo_response_workshopiteminfo(o CPublishedFile_GetItemInfo_Response_WorkshopItemInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getiteminfo_response_workshopiteminfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetItemInfo_Response_WorkshopItemInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getiteminfo_response_workshopiteminfo_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetItemInfo_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	update_time     u32
	has_update_time bool
	workshop_items  []CPublishedFile_GetItemInfo_Response_WorkshopItemInfo
	private_items   []u64
}

pub fn (o &CPublishedFile_GetItemInfo_Response) pack() []byte {
	mut res := []byte{}
	if o.has_update_time {
		res << vproto.pack_uint32_field(o.update_time, 1)
	}
	// [packed=false]
	for _, x in o.workshop_items {
		res << zzz_vproto_internal_pack_cpublishedfile_getiteminfo_response_workshopiteminfo(x, 2)
	}
	// [packed=false]
	for _, x in o.private_items {
		res << vproto.pack_64bit_field(x, 3)
	}
	return res
}

pub fn cpublishedfile_getiteminfo_response_unpack(buf []byte) ?CPublishedFile_GetItemInfo_Response {
	mut res := CPublishedFile_GetItemInfo_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_update_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.update_time = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getiteminfo_response_workshopiteminfo(cur_buf,
					tag_wiretype.wire_type)?
				res.workshop_items << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.private_items << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getiteminfo_response() CPublishedFile_GetItemInfo_Response {
	return CPublishedFile_GetItemInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getiteminfo_response(o CPublishedFile_GetItemInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getiteminfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetItemInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getiteminfo_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserFiles_Request_KVTag {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &CPublishedFile_GetUserFiles_Request_KVTag) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn cpublishedfile_getuserfiles_request_kvtag_unpack(buf []byte) ?CPublishedFile_GetUserFiles_Request_KVTag {
	mut res := CPublishedFile_GetUserFiles_Request_KVTag{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getuserfiles_request_kvtag() CPublishedFile_GetUserFiles_Request_KVTag {
	return CPublishedFile_GetUserFiles_Request_KVTag{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getuserfiles_request_kvtag(o CPublishedFile_GetUserFiles_Request_KVTag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_request_kvtag(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserFiles_Request_KVTag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuserfiles_request_kvtag_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserFiles_Request_TagGroup {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	tags           []string
}

pub fn (o &CPublishedFile_GetUserFiles_Request_TagGroup) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 1)
	}
	return res
}

pub fn cpublishedfile_getuserfiles_request_taggroup_unpack(buf []byte) ?CPublishedFile_GetUserFiles_Request_TagGroup {
	mut res := CPublishedFile_GetUserFiles_Request_TagGroup{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getuserfiles_request_taggroup() CPublishedFile_GetUserFiles_Request_TagGroup {
	return CPublishedFile_GetUserFiles_Request_TagGroup{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getuserfiles_request_taggroup(o CPublishedFile_GetUserFiles_Request_TagGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_request_taggroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserFiles_Request_TagGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuserfiles_request_taggroup_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserFiles_Request {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	steamid                      u64
	has_steamid                  bool
	appid                        u32
	has_appid                    bool
	page                         u32
	has_page                     bool
	numperpage                   u32
	has_numperpage               bool
	@type                        string
	has_type                     bool
	sortmethod                   string
	has_sortmethod               bool
	privacy                      u32
	has_privacy                  bool
	requiredtags                 []string
	excludedtags                 []string
	required_kv_tags             []CPublishedFile_GetUserFiles_Request_KVTag
	filetype                     u32
	has_filetype                 bool
	creator_appid                u32
	has_creator_appid            bool
	match_cloud_filename         string
	has_match_cloud_filename     bool
	cache_max_age_seconds        u32
	has_cache_max_age_seconds    bool
	language                     int
	has_language                 bool
	taggroups                    []CPublishedFile_GetUserFiles_Request_TagGroup
	totalonly                    bool
	has_totalonly                bool
	ids_only                     bool
	has_ids_only                 bool
	return_vote_data             bool
	has_return_vote_data         bool
	return_tags                  bool
	has_return_tags              bool
	return_kv_tags               bool
	has_return_kv_tags           bool
	return_previews              bool
	has_return_previews          bool
	return_children              bool
	has_return_children          bool
	return_short_description     bool
	has_return_short_description bool
	return_for_sale_data         bool
	has_return_for_sale_data     bool
	return_metadata              bool
	has_return_metadata          bool
	return_playtime_stats        u32
	has_return_playtime_stats    bool
	strip_description_bbcode     bool
	has_strip_description_bbcode bool
	return_reactions             bool
	has_return_reactions         bool
	desired_revision             EPublishedFileRevision
	has_desired_revision         bool
}

pub fn (o &CPublishedFile_GetUserFiles_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_page {
		res << vproto.pack_uint32_field(o.page, 4)
	}
	if o.has_numperpage {
		res << vproto.pack_uint32_field(o.numperpage, 5)
	}
	if o.has_type {
		res << vproto.pack_string_field(o.@type, 6)
	}
	if o.has_sortmethod {
		res << vproto.pack_string_field(o.sortmethod, 7)
	}
	if o.has_privacy {
		res << vproto.pack_uint32_field(o.privacy, 9)
	}
	// [packed=false]
	for _, x in o.requiredtags {
		res << vproto.pack_string_field(x, 10)
	}
	// [packed=false]
	for _, x in o.excludedtags {
		res << vproto.pack_string_field(x, 11)
	}
	// [packed=false]
	for _, x in o.required_kv_tags {
		res << zzz_vproto_internal_pack_cpublishedfile_getuserfiles_request_kvtag(x, 30)
	}
	if o.has_filetype {
		res << vproto.pack_uint32_field(o.filetype, 14)
	}
	if o.has_creator_appid {
		res << vproto.pack_uint32_field(o.creator_appid, 15)
	}
	if o.has_match_cloud_filename {
		res << vproto.pack_string_field(o.match_cloud_filename, 16)
	}
	if o.has_cache_max_age_seconds {
		res << vproto.pack_uint32_field(o.cache_max_age_seconds, 27)
	}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 29)
	}
	// [packed=false]
	for _, x in o.taggroups {
		res << zzz_vproto_internal_pack_cpublishedfile_getuserfiles_request_taggroup(x, 34)
	}
	if o.has_totalonly {
		res << vproto.pack_bool_field(o.totalonly, 17)
	}
	if o.has_ids_only {
		res << vproto.pack_bool_field(o.ids_only, 18)
	}
	if o.has_return_vote_data {
		res << vproto.pack_bool_field(o.return_vote_data, 19)
	}
	if o.has_return_tags {
		res << vproto.pack_bool_field(o.return_tags, 20)
	}
	if o.has_return_kv_tags {
		res << vproto.pack_bool_field(o.return_kv_tags, 21)
	}
	if o.has_return_previews {
		res << vproto.pack_bool_field(o.return_previews, 22)
	}
	if o.has_return_children {
		res << vproto.pack_bool_field(o.return_children, 23)
	}
	if o.has_return_short_description {
		res << vproto.pack_bool_field(o.return_short_description, 24)
	}
	if o.has_return_for_sale_data {
		res << vproto.pack_bool_field(o.return_for_sale_data, 26)
	}
	if o.has_return_metadata {
		res << vproto.pack_bool_field(o.return_metadata, 28)
	}
	if o.has_return_playtime_stats {
		res << vproto.pack_uint32_field(o.return_playtime_stats, 31)
	}
	if o.has_strip_description_bbcode {
		res << vproto.pack_bool_field(o.strip_description_bbcode, 32)
	}
	if o.has_return_reactions {
		res << vproto.pack_bool_field(o.return_reactions, 35)
	}
	if o.has_desired_revision {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 33)
	}
	return res
}

pub fn cpublishedfile_getuserfiles_request_unpack(buf []byte) ?CPublishedFile_GetUserFiles_Request {
	mut res := CPublishedFile_GetUserFiles_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			4 {
				res.has_page = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.page = v
				i = ii
			}
			5 {
				res.has_numperpage = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.numperpage = v
				i = ii
			}
			6 {
				res.has_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			7 {
				res.has_sortmethod = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sortmethod = v
				i = ii
			}
			9 {
				res.has_privacy = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.privacy = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.requiredtags << v
				i = ii
			}
			11 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.excludedtags << v
				i = ii
			}
			30 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_request_kvtag(cur_buf,
					tag_wiretype.wire_type)?
				res.required_kv_tags << v
				i = ii
			}
			14 {
				res.has_filetype = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.filetype = v
				i = ii
			}
			15 {
				res.has_creator_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.creator_appid = v
				i = ii
			}
			16 {
				res.has_match_cloud_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.match_cloud_filename = v
				i = ii
			}
			27 {
				res.has_cache_max_age_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_max_age_seconds = v
				i = ii
			}
			29 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			34 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_request_taggroup(cur_buf,
					tag_wiretype.wire_type)?
				res.taggroups << v
				i = ii
			}
			17 {
				res.has_totalonly = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.totalonly = v
				i = ii
			}
			18 {
				res.has_ids_only = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ids_only = v
				i = ii
			}
			19 {
				res.has_return_vote_data = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_vote_data = v
				i = ii
			}
			20 {
				res.has_return_tags = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_tags = v
				i = ii
			}
			21 {
				res.has_return_kv_tags = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_kv_tags = v
				i = ii
			}
			22 {
				res.has_return_previews = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_previews = v
				i = ii
			}
			23 {
				res.has_return_children = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_children = v
				i = ii
			}
			24 {
				res.has_return_short_description = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_short_description = v
				i = ii
			}
			26 {
				res.has_return_for_sale_data = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_for_sale_data = v
				i = ii
			}
			28 {
				res.has_return_metadata = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_metadata = v
				i = ii
			}
			31 {
				res.has_return_playtime_stats = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.return_playtime_stats = v
				i = ii
			}
			32 {
				res.has_strip_description_bbcode = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.strip_description_bbcode = v
				i = ii
			}
			35 {
				res.has_return_reactions = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_reactions = v
				i = ii
			}
			33 {
				res.has_desired_revision = true
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.desired_revision = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getuserfiles_request() CPublishedFile_GetUserFiles_Request {
	return CPublishedFile_GetUserFiles_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getuserfiles_request(o CPublishedFile_GetUserFiles_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserFiles_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuserfiles_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserFiles_Response_App {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	name           string
	has_name       bool
	shortcutid     u32
	has_shortcutid bool
	private        bool
	has_private    bool
}

pub fn (o &CPublishedFile_GetUserFiles_Response_App) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	if o.has_shortcutid {
		res << vproto.pack_uint32_field(o.shortcutid, 3)
	}
	if o.has_private {
		res << vproto.pack_bool_field(o.private, 4)
	}
	return res
}

pub fn cpublishedfile_getuserfiles_response_app_unpack(buf []byte) ?CPublishedFile_GetUserFiles_Response_App {
	mut res := CPublishedFile_GetUserFiles_Response_App{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				res.has_shortcutid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.shortcutid = v
				i = ii
			}
			4 {
				res.has_private = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.private = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getuserfiles_response_app() CPublishedFile_GetUserFiles_Response_App {
	return CPublishedFile_GetUserFiles_Response_App{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getuserfiles_response_app(o CPublishedFile_GetUserFiles_Response_App, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_response_app(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserFiles_Response_App) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuserfiles_response_app_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserFiles_Response {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	total                u32
	has_total            bool
	startindex           u32
	has_startindex       bool
	publishedfiledetails []PublishedFileDetails
	apps                 []CPublishedFile_GetUserFiles_Response_App
}

pub fn (o &CPublishedFile_GetUserFiles_Response) pack() []byte {
	mut res := []byte{}
	if o.has_total {
		res << vproto.pack_uint32_field(o.total, 1)
	}
	if o.has_startindex {
		res << vproto.pack_uint32_field(o.startindex, 2)
	}
	// [packed=false]
	for _, x in o.publishedfiledetails {
		res << zzz_vproto_internal_pack_publishedfiledetails(x, 3)
	}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_cpublishedfile_getuserfiles_response_app(x, 4)
	}
	return res
}

pub fn cpublishedfile_getuserfiles_response_unpack(buf []byte) ?CPublishedFile_GetUserFiles_Response {
	mut res := CPublishedFile_GetUserFiles_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_total = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total = v
				i = ii
			}
			2 {
				res.has_startindex = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.startindex = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails(cur_buf, tag_wiretype.wire_type)?
				res.publishedfiledetails << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_response_app(cur_buf,
					tag_wiretype.wire_type)?
				res.apps << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getuserfiles_response() CPublishedFile_GetUserFiles_Response {
	return CPublishedFile_GetUserFiles_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getuserfiles_response(o CPublishedFile_GetUserFiles_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuserfiles_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserFiles_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuserfiles_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AreFilesInSubscriptionList_Request {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	appid                u32
	has_appid            bool
	publishedfileids     []u64
	listtype             u32
	has_listtype         bool
	filetype             u32
	has_filetype         bool
	workshopfiletype     u32
	has_workshopfiletype bool
}

pub fn (o &CPublishedFile_AreFilesInSubscriptionList_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.publishedfileids {
		res << vproto.pack_64bit_field(x, 2)
	}
	if o.has_listtype {
		res << vproto.pack_uint32_field(o.listtype, 3)
	}
	if o.has_filetype {
		res << vproto.pack_uint32_field(o.filetype, 4)
	}
	if o.has_workshopfiletype {
		res << vproto.pack_uint32_field(o.workshopfiletype, 5)
	}
	return res
}

pub fn cpublishedfile_arefilesinsubscriptionlist_request_unpack(buf []byte) ?CPublishedFile_AreFilesInSubscriptionList_Request {
	mut res := CPublishedFile_AreFilesInSubscriptionList_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileids << v
				i = ii
			}
			3 {
				res.has_listtype = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.listtype = v
				i = ii
			}
			4 {
				res.has_filetype = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.filetype = v
				i = ii
			}
			5 {
				res.has_workshopfiletype = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.workshopfiletype = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_arefilesinsubscriptionlist_request() CPublishedFile_AreFilesInSubscriptionList_Request {
	return CPublishedFile_AreFilesInSubscriptionList_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_arefilesinsubscriptionlist_request(o CPublishedFile_AreFilesInSubscriptionList_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_arefilesinsubscriptionlist_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AreFilesInSubscriptionList_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_arefilesinsubscriptionlist_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AreFilesInSubscriptionList_Response_InList {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
	inlist              bool
	has_inlist          bool
}

pub fn (o &CPublishedFile_AreFilesInSubscriptionList_Response_InList) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_64bit_field(o.publishedfileid, 1)
	}
	if o.has_inlist {
		res << vproto.pack_bool_field(o.inlist, 2)
	}
	return res
}

pub fn cpublishedfile_arefilesinsubscriptionlist_response_inlist_unpack(buf []byte) ?CPublishedFile_AreFilesInSubscriptionList_Response_InList {
	mut res := CPublishedFile_AreFilesInSubscriptionList_Response_InList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				res.has_inlist = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.inlist = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_arefilesinsubscriptionlist_response_inlist() CPublishedFile_AreFilesInSubscriptionList_Response_InList {
	return CPublishedFile_AreFilesInSubscriptionList_Response_InList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_arefilesinsubscriptionlist_response_inlist(o CPublishedFile_AreFilesInSubscriptionList_Response_InList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_arefilesinsubscriptionlist_response_inlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AreFilesInSubscriptionList_Response_InList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_arefilesinsubscriptionlist_response_inlist_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AreFilesInSubscriptionList_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	files          []CPublishedFile_AreFilesInSubscriptionList_Response_InList
}

pub fn (o &CPublishedFile_AreFilesInSubscriptionList_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.files {
		res <<
			zzz_vproto_internal_pack_cpublishedfile_arefilesinsubscriptionlist_response_inlist(x, 1)
	}
	return res
}

pub fn cpublishedfile_arefilesinsubscriptionlist_response_unpack(buf []byte) ?CPublishedFile_AreFilesInSubscriptionList_Response {
	mut res := CPublishedFile_AreFilesInSubscriptionList_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_arefilesinsubscriptionlist_response_inlist(cur_buf,
					tag_wiretype.wire_type)?
				res.files << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_arefilesinsubscriptionlist_response() CPublishedFile_AreFilesInSubscriptionList_Response {
	return CPublishedFile_AreFilesInSubscriptionList_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_arefilesinsubscriptionlist_response(o CPublishedFile_AreFilesInSubscriptionList_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_arefilesinsubscriptionlist_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AreFilesInSubscriptionList_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_arefilesinsubscriptionlist_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Update_Request {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	appid                u32
	has_appid            bool
	publishedfileid      u64
	has_publishedfileid  bool
	title                string
	has_title            bool
	file_description     string
	has_file_description bool
	visibility           u32
	has_visibility       bool
	tags                 []string
	filename             string
	has_filename         bool
	preview_filename     string
	has_preview_filename bool
	image_width          u32
	has_image_width      bool
	image_height         u32
	has_image_height     bool
}

pub fn (o &CPublishedFile_Update_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_publishedfileid {
		res << vproto.pack_64bit_field(o.publishedfileid, 2)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 3)
	}
	if o.has_file_description {
		res << vproto.pack_string_field(o.file_description, 4)
	}
	if o.has_visibility {
		res << vproto.pack_uint32_field(o.visibility, 5)
	}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 6)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 7)
	}
	if o.has_preview_filename {
		res << vproto.pack_string_field(o.preview_filename, 8)
	}
	if o.has_image_width {
		res << vproto.pack_uint32_field(o.image_width, 15)
	}
	if o.has_image_height {
		res << vproto.pack_uint32_field(o.image_height, 16)
	}
	return res
}

pub fn cpublishedfile_update_request_unpack(buf []byte) ?CPublishedFile_Update_Request {
	mut res := CPublishedFile_Update_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			3 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			4 {
				res.has_file_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_description = v
				i = ii
			}
			5 {
				res.has_visibility = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.visibility = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			7 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			8 {
				res.has_preview_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.preview_filename = v
				i = ii
			}
			15 {
				res.has_image_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.image_width = v
				i = ii
			}
			16 {
				res.has_image_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.image_height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_update_request() CPublishedFile_Update_Request {
	return CPublishedFile_Update_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_update_request(o CPublishedFile_Update_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_update_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Update_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_update_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_Update_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_Update_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_update_response_unpack(buf []byte) ?CPublishedFile_Update_Response {
	res := CPublishedFile_Update_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_update_response() CPublishedFile_Update_Response {
	return CPublishedFile_Update_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_update_response(o CPublishedFile_Update_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_update_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_Update_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_update_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetChangeHistoryEntry_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
	timestamp           u32
	has_timestamp       bool
	language            int
	has_language        bool
}

pub fn (o &CPublishedFile_GetChangeHistoryEntry_Request) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_64bit_field(o.publishedfileid, 1)
	}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 2)
	}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 3)
	}
	return res
}

pub fn cpublishedfile_getchangehistoryentry_request_unpack(buf []byte) ?CPublishedFile_GetChangeHistoryEntry_Request {
	mut res := CPublishedFile_GetChangeHistoryEntry_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			3 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getchangehistoryentry_request() CPublishedFile_GetChangeHistoryEntry_Request {
	return CPublishedFile_GetChangeHistoryEntry_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getchangehistoryentry_request(o CPublishedFile_GetChangeHistoryEntry_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getchangehistoryentry_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetChangeHistoryEntry_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getchangehistoryentry_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetChangeHistoryEntry_Response {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	change_description     string
	has_change_description bool
	language               int
	has_language           bool
}

pub fn (o &CPublishedFile_GetChangeHistoryEntry_Response) pack() []byte {
	mut res := []byte{}
	if o.has_change_description {
		res << vproto.pack_string_field(o.change_description, 1)
	}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 2)
	}
	return res
}

pub fn cpublishedfile_getchangehistoryentry_response_unpack(buf []byte) ?CPublishedFile_GetChangeHistoryEntry_Response {
	mut res := CPublishedFile_GetChangeHistoryEntry_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_change_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.change_description = v
				i = ii
			}
			2 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getchangehistoryentry_response() CPublishedFile_GetChangeHistoryEntry_Response {
	return CPublishedFile_GetChangeHistoryEntry_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getchangehistoryentry_response(o CPublishedFile_GetChangeHistoryEntry_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getchangehistoryentry_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetChangeHistoryEntry_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getchangehistoryentry_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetChangeHistory_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
	total_only          bool
	has_total_only      bool
	startindex          u32
	has_startindex      bool
	count               u32
	has_count           bool
	language            int
	has_language        bool
}

pub fn (o &CPublishedFile_GetChangeHistory_Request) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_64bit_field(o.publishedfileid, 1)
	}
	if o.has_total_only {
		res << vproto.pack_bool_field(o.total_only, 2)
	}
	if o.has_startindex {
		res << vproto.pack_uint32_field(o.startindex, 3)
	}
	if o.has_count {
		res << vproto.pack_uint32_field(o.count, 4)
	}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 5)
	}
	return res
}

pub fn cpublishedfile_getchangehistory_request_unpack(buf []byte) ?CPublishedFile_GetChangeHistory_Request {
	mut res := CPublishedFile_GetChangeHistory_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				res.has_total_only = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.total_only = v
				i = ii
			}
			3 {
				res.has_startindex = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.startindex = v
				i = ii
			}
			4 {
				res.has_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			5 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getchangehistory_request() CPublishedFile_GetChangeHistory_Request {
	return CPublishedFile_GetChangeHistory_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getchangehistory_request(o CPublishedFile_GetChangeHistory_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getchangehistory_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetChangeHistory_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getchangehistory_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetChangeHistory_Response_ChangeLog {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	timestamp              u32
	has_timestamp          bool
	change_description     string
	has_change_description bool
	language               int
	has_language           bool
}

pub fn (o &CPublishedFile_GetChangeHistory_Response_ChangeLog) pack() []byte {
	mut res := []byte{}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 1)
	}
	if o.has_change_description {
		res << vproto.pack_string_field(o.change_description, 2)
	}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 3)
	}
	return res
}

pub fn cpublishedfile_getchangehistory_response_changelog_unpack(buf []byte) ?CPublishedFile_GetChangeHistory_Response_ChangeLog {
	mut res := CPublishedFile_GetChangeHistory_Response_ChangeLog{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			2 {
				res.has_change_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.change_description = v
				i = ii
			}
			3 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getchangehistory_response_changelog() CPublishedFile_GetChangeHistory_Response_ChangeLog {
	return CPublishedFile_GetChangeHistory_Response_ChangeLog{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getchangehistory_response_changelog(o CPublishedFile_GetChangeHistory_Response_ChangeLog, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getchangehistory_response_changelog(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetChangeHistory_Response_ChangeLog) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getchangehistory_response_changelog_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetChangeHistory_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	changes        []CPublishedFile_GetChangeHistory_Response_ChangeLog
	total          u32
	has_total      bool
}

pub fn (o &CPublishedFile_GetChangeHistory_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.changes {
		res << zzz_vproto_internal_pack_cpublishedfile_getchangehistory_response_changelog(x, 1)
	}
	if o.has_total {
		res << vproto.pack_uint32_field(o.total, 2)
	}
	return res
}

pub fn cpublishedfile_getchangehistory_response_unpack(buf []byte) ?CPublishedFile_GetChangeHistory_Response {
	mut res := CPublishedFile_GetChangeHistory_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getchangehistory_response_changelog(cur_buf,
					tag_wiretype.wire_type)?
				res.changes << v
				i = ii
			}
			2 {
				res.has_total = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getchangehistory_response() CPublishedFile_GetChangeHistory_Response {
	return CPublishedFile_GetChangeHistory_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getchangehistory_response(o CPublishedFile_GetChangeHistory_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getchangehistory_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetChangeHistory_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getchangehistory_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_RefreshVotingQueue_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	appid                  u32
	has_appid              bool
	matching_file_type     u32
	has_matching_file_type bool
	tags                   []string
	match_all_tags         bool
	has_match_all_tags     bool
	excluded_tags          []string
	desired_queue_size     u32
	has_desired_queue_size bool
	desired_revision       EPublishedFileRevision
	has_desired_revision   bool
}

pub fn (o &CPublishedFile_RefreshVotingQueue_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_matching_file_type {
		res << vproto.pack_uint32_field(o.matching_file_type, 2)
	}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 3)
	}
	if o.has_match_all_tags {
		res << vproto.pack_bool_field(o.match_all_tags, 4)
	}
	// [packed=false]
	for _, x in o.excluded_tags {
		res << vproto.pack_string_field(x, 5)
	}
	if o.has_desired_queue_size {
		res << vproto.pack_uint32_field(o.desired_queue_size, 6)
	}
	if o.has_desired_revision {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 8)
	}
	return res
}

pub fn cpublishedfile_refreshvotingqueue_request_unpack(buf []byte) ?CPublishedFile_RefreshVotingQueue_Request {
	mut res := CPublishedFile_RefreshVotingQueue_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_matching_file_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.matching_file_type = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			4 {
				res.has_match_all_tags = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.match_all_tags = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.excluded_tags << v
				i = ii
			}
			6 {
				res.has_desired_queue_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.desired_queue_size = v
				i = ii
			}
			8 {
				res.has_desired_revision = true
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.desired_revision = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_refreshvotingqueue_request() CPublishedFile_RefreshVotingQueue_Request {
	return CPublishedFile_RefreshVotingQueue_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_refreshvotingqueue_request(o CPublishedFile_RefreshVotingQueue_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_refreshvotingqueue_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_RefreshVotingQueue_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_refreshvotingqueue_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_RefreshVotingQueue_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_RefreshVotingQueue_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_refreshvotingqueue_response_unpack(buf []byte) ?CPublishedFile_RefreshVotingQueue_Response {
	res := CPublishedFile_RefreshVotingQueue_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_refreshvotingqueue_response() CPublishedFile_RefreshVotingQueue_Response {
	return CPublishedFile_RefreshVotingQueue_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_refreshvotingqueue_response(o CPublishedFile_RefreshVotingQueue_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_refreshvotingqueue_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_RefreshVotingQueue_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_refreshvotingqueue_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_QueryFiles_Request_KVTag {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &CPublishedFile_QueryFiles_Request_KVTag) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn cpublishedfile_queryfiles_request_kvtag_unpack(buf []byte) ?CPublishedFile_QueryFiles_Request_KVTag {
	mut res := CPublishedFile_QueryFiles_Request_KVTag{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_queryfiles_request_kvtag() CPublishedFile_QueryFiles_Request_KVTag {
	return CPublishedFile_QueryFiles_Request_KVTag{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_queryfiles_request_kvtag(o CPublishedFile_QueryFiles_Request_KVTag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_queryfiles_request_kvtag(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_QueryFiles_Request_KVTag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_queryfiles_request_kvtag_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_QueryFiles_Request_TagGroup {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	tags           []string
}

pub fn (o &CPublishedFile_QueryFiles_Request_TagGroup) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 1)
	}
	return res
}

pub fn cpublishedfile_queryfiles_request_taggroup_unpack(buf []byte) ?CPublishedFile_QueryFiles_Request_TagGroup {
	mut res := CPublishedFile_QueryFiles_Request_TagGroup{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_queryfiles_request_taggroup() CPublishedFile_QueryFiles_Request_TagGroup {
	return CPublishedFile_QueryFiles_Request_TagGroup{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_queryfiles_request_taggroup(o CPublishedFile_QueryFiles_Request_TagGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_queryfiles_request_taggroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_QueryFiles_Request_TagGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_queryfiles_request_taggroup_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_QueryFiles_Request {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	query_type                    u32
	has_query_type                bool
	page                          u32
	has_page                      bool
	cursor                        string
	has_cursor                    bool
	numperpage                    u32
	has_numperpage                bool
	creator_appid                 u32
	has_creator_appid             bool
	appid                         u32
	has_appid                     bool
	requiredtags                  []string
	excludedtags                  []string
	match_all_tags                bool
	has_match_all_tags            bool
	required_flags                []string
	omitted_flags                 []string
	search_text                   string
	has_search_text               bool
	filetype                      u32
	has_filetype                  bool
	child_publishedfileid         u64
	has_child_publishedfileid     bool
	days                          u32
	has_days                      bool
	include_recent_votes_only     bool
	has_include_recent_votes_only bool
	cache_max_age_seconds         u32
	has_cache_max_age_seconds     bool
	language                      int
	has_language                  bool
	required_kv_tags              []CPublishedFile_QueryFiles_Request_KVTag
	taggroups                     []CPublishedFile_QueryFiles_Request_TagGroup
	totalonly                     bool
	has_totalonly                 bool
	ids_only                      bool
	has_ids_only                  bool
	return_vote_data              bool
	has_return_vote_data          bool
	return_tags                   bool
	has_return_tags               bool
	return_kv_tags                bool
	has_return_kv_tags            bool
	return_previews               bool
	has_return_previews           bool
	return_children               bool
	has_return_children           bool
	return_short_description      bool
	has_return_short_description  bool
	return_for_sale_data          bool
	has_return_for_sale_data      bool
	return_metadata               bool
	has_return_metadata           bool
	return_playtime_stats         u32
	has_return_playtime_stats     bool
	return_details                bool
	has_return_details            bool
	strip_description_bbcode      bool
	has_strip_description_bbcode  bool
	desired_revision              EPublishedFileRevision
	has_desired_revision          bool
	return_reactions              bool
	has_return_reactions          bool
}

pub fn (o &CPublishedFile_QueryFiles_Request) pack() []byte {
	mut res := []byte{}
	if o.has_query_type {
		res << vproto.pack_uint32_field(o.query_type, 1)
	}
	if o.has_page {
		res << vproto.pack_uint32_field(o.page, 2)
	}
	if o.has_cursor {
		res << vproto.pack_string_field(o.cursor, 39)
	}
	if o.has_numperpage {
		res << vproto.pack_uint32_field(o.numperpage, 3)
	}
	if o.has_creator_appid {
		res << vproto.pack_uint32_field(o.creator_appid, 4)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 5)
	}
	// [packed=false]
	for _, x in o.requiredtags {
		res << vproto.pack_string_field(x, 6)
	}
	// [packed=false]
	for _, x in o.excludedtags {
		res << vproto.pack_string_field(x, 7)
	}
	if o.has_match_all_tags {
		res << vproto.pack_bool_field(o.match_all_tags, 8)
	}
	// [packed=false]
	for _, x in o.required_flags {
		res << vproto.pack_string_field(x, 9)
	}
	// [packed=false]
	for _, x in o.omitted_flags {
		res << vproto.pack_string_field(x, 10)
	}
	if o.has_search_text {
		res << vproto.pack_string_field(o.search_text, 11)
	}
	if o.has_filetype {
		res << vproto.pack_uint32_field(o.filetype, 12)
	}
	if o.has_child_publishedfileid {
		res << vproto.pack_64bit_field(o.child_publishedfileid, 13)
	}
	if o.has_days {
		res << vproto.pack_uint32_field(o.days, 14)
	}
	if o.has_include_recent_votes_only {
		res << vproto.pack_bool_field(o.include_recent_votes_only, 15)
	}
	if o.has_cache_max_age_seconds {
		res << vproto.pack_uint32_field(o.cache_max_age_seconds, 31)
	}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 33)
	}
	// [packed=false]
	for _, x in o.required_kv_tags {
		res << zzz_vproto_internal_pack_cpublishedfile_queryfiles_request_kvtag(x, 34)
	}
	// [packed=false]
	for _, x in o.taggroups {
		res << zzz_vproto_internal_pack_cpublishedfile_queryfiles_request_taggroup(x, 42)
	}
	if o.has_totalonly {
		res << vproto.pack_bool_field(o.totalonly, 16)
	}
	if o.has_ids_only {
		res << vproto.pack_bool_field(o.ids_only, 35)
	}
	if o.has_return_vote_data {
		res << vproto.pack_bool_field(o.return_vote_data, 17)
	}
	if o.has_return_tags {
		res << vproto.pack_bool_field(o.return_tags, 18)
	}
	if o.has_return_kv_tags {
		res << vproto.pack_bool_field(o.return_kv_tags, 19)
	}
	if o.has_return_previews {
		res << vproto.pack_bool_field(o.return_previews, 20)
	}
	if o.has_return_children {
		res << vproto.pack_bool_field(o.return_children, 21)
	}
	if o.has_return_short_description {
		res << vproto.pack_bool_field(o.return_short_description, 22)
	}
	if o.has_return_for_sale_data {
		res << vproto.pack_bool_field(o.return_for_sale_data, 30)
	}
	if o.has_return_metadata {
		res << vproto.pack_bool_field(o.return_metadata, 32)
	}
	if o.has_return_playtime_stats {
		res << vproto.pack_uint32_field(o.return_playtime_stats, 36)
	}
	if o.has_return_details {
		res << vproto.pack_bool_field(o.return_details, 37)
	}
	if o.has_strip_description_bbcode {
		res << vproto.pack_bool_field(o.strip_description_bbcode, 38)
	}
	if o.has_desired_revision {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.desired_revision, 40)
	}
	if o.has_return_reactions {
		res << vproto.pack_bool_field(o.return_reactions, 43)
	}
	return res
}

pub fn cpublishedfile_queryfiles_request_unpack(buf []byte) ?CPublishedFile_QueryFiles_Request {
	mut res := CPublishedFile_QueryFiles_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_query_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.query_type = v
				i = ii
			}
			2 {
				res.has_page = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.page = v
				i = ii
			}
			39 {
				res.has_cursor = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cursor = v
				i = ii
			}
			3 {
				res.has_numperpage = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.numperpage = v
				i = ii
			}
			4 {
				res.has_creator_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.creator_appid = v
				i = ii
			}
			5 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.requiredtags << v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.excludedtags << v
				i = ii
			}
			8 {
				res.has_match_all_tags = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.match_all_tags = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.required_flags << v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.omitted_flags << v
				i = ii
			}
			11 {
				res.has_search_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.search_text = v
				i = ii
			}
			12 {
				res.has_filetype = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.filetype = v
				i = ii
			}
			13 {
				res.has_child_publishedfileid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.child_publishedfileid = v
				i = ii
			}
			14 {
				res.has_days = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.days = v
				i = ii
			}
			15 {
				res.has_include_recent_votes_only = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_recent_votes_only = v
				i = ii
			}
			31 {
				res.has_cache_max_age_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_max_age_seconds = v
				i = ii
			}
			33 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			34 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_queryfiles_request_kvtag(cur_buf,
					tag_wiretype.wire_type)?
				res.required_kv_tags << v
				i = ii
			}
			42 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_queryfiles_request_taggroup(cur_buf,
					tag_wiretype.wire_type)?
				res.taggroups << v
				i = ii
			}
			16 {
				res.has_totalonly = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.totalonly = v
				i = ii
			}
			35 {
				res.has_ids_only = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ids_only = v
				i = ii
			}
			17 {
				res.has_return_vote_data = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_vote_data = v
				i = ii
			}
			18 {
				res.has_return_tags = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_tags = v
				i = ii
			}
			19 {
				res.has_return_kv_tags = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_kv_tags = v
				i = ii
			}
			20 {
				res.has_return_previews = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_previews = v
				i = ii
			}
			21 {
				res.has_return_children = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_children = v
				i = ii
			}
			22 {
				res.has_return_short_description = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_short_description = v
				i = ii
			}
			30 {
				res.has_return_for_sale_data = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_for_sale_data = v
				i = ii
			}
			32 {
				res.has_return_metadata = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_metadata = v
				i = ii
			}
			36 {
				res.has_return_playtime_stats = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.return_playtime_stats = v
				i = ii
			}
			37 {
				res.has_return_details = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_details = v
				i = ii
			}
			38 {
				res.has_strip_description_bbcode = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.strip_description_bbcode = v
				i = ii
			}
			40 {
				res.has_desired_revision = true
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.desired_revision = v
				i = ii
			}
			43 {
				res.has_return_reactions = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_reactions = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_queryfiles_request() CPublishedFile_QueryFiles_Request {
	return CPublishedFile_QueryFiles_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_queryfiles_request(o CPublishedFile_QueryFiles_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_queryfiles_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_QueryFiles_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_queryfiles_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_QueryFiles_Response {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	total                u32
	has_total            bool
	publishedfiledetails []PublishedFileDetails
	next_cursor          string
	has_next_cursor      bool
}

pub fn (o &CPublishedFile_QueryFiles_Response) pack() []byte {
	mut res := []byte{}
	if o.has_total {
		res << vproto.pack_uint32_field(o.total, 1)
	}
	// [packed=false]
	for _, x in o.publishedfiledetails {
		res << zzz_vproto_internal_pack_publishedfiledetails(x, 2)
	}
	if o.has_next_cursor {
		res << vproto.pack_string_field(o.next_cursor, 3)
	}
	return res
}

pub fn cpublishedfile_queryfiles_response_unpack(buf []byte) ?CPublishedFile_QueryFiles_Response {
	mut res := CPublishedFile_QueryFiles_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_total = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_publishedfiledetails(cur_buf, tag_wiretype.wire_type)?
				res.publishedfiledetails << v
				i = ii
			}
			3 {
				res.has_next_cursor = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.next_cursor = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_queryfiles_response() CPublishedFile_QueryFiles_Response {
	return CPublishedFile_QueryFiles_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_queryfiles_response(o CPublishedFile_QueryFiles_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_queryfiles_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_QueryFiles_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_queryfiles_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AddAppRelationship_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
	appid               u32
	has_appid           bool
	relationship        u32
	has_relationship    bool
}

pub fn (o &CPublishedFile_AddAppRelationship_Request) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_relationship {
		res << vproto.pack_uint32_field(o.relationship, 3)
	}
	return res
}

pub fn cpublishedfile_addapprelationship_request_unpack(buf []byte) ?CPublishedFile_AddAppRelationship_Request {
	mut res := CPublishedFile_AddAppRelationship_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_relationship = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.relationship = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_addapprelationship_request() CPublishedFile_AddAppRelationship_Request {
	return CPublishedFile_AddAppRelationship_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_addapprelationship_request(o CPublishedFile_AddAppRelationship_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_addapprelationship_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AddAppRelationship_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_addapprelationship_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AddAppRelationship_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_AddAppRelationship_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_addapprelationship_response_unpack(buf []byte) ?CPublishedFile_AddAppRelationship_Response {
	res := CPublishedFile_AddAppRelationship_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_addapprelationship_response() CPublishedFile_AddAppRelationship_Response {
	return CPublishedFile_AddAppRelationship_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_addapprelationship_response(o CPublishedFile_AddAppRelationship_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_addapprelationship_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AddAppRelationship_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_addapprelationship_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_RemoveAppRelationship_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
	appid               u32
	has_appid           bool
	relationship        u32
	has_relationship    bool
}

pub fn (o &CPublishedFile_RemoveAppRelationship_Request) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_relationship {
		res << vproto.pack_uint32_field(o.relationship, 3)
	}
	return res
}

pub fn cpublishedfile_removeapprelationship_request_unpack(buf []byte) ?CPublishedFile_RemoveAppRelationship_Request {
	mut res := CPublishedFile_RemoveAppRelationship_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_relationship = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.relationship = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_removeapprelationship_request() CPublishedFile_RemoveAppRelationship_Request {
	return CPublishedFile_RemoveAppRelationship_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_removeapprelationship_request(o CPublishedFile_RemoveAppRelationship_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_removeapprelationship_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_RemoveAppRelationship_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_removeapprelationship_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_RemoveAppRelationship_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_RemoveAppRelationship_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_removeapprelationship_response_unpack(buf []byte) ?CPublishedFile_RemoveAppRelationship_Response {
	res := CPublishedFile_RemoveAppRelationship_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_removeapprelationship_response() CPublishedFile_RemoveAppRelationship_Response {
	return CPublishedFile_RemoveAppRelationship_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_removeapprelationship_response(o CPublishedFile_RemoveAppRelationship_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_removeapprelationship_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_RemoveAppRelationship_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_removeapprelationship_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetAppRelationships_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
}

pub fn (o &CPublishedFile_GetAppRelationships_Request) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	return res
}

pub fn cpublishedfile_getapprelationships_request_unpack(buf []byte) ?CPublishedFile_GetAppRelationships_Request {
	mut res := CPublishedFile_GetAppRelationships_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getapprelationships_request() CPublishedFile_GetAppRelationships_Request {
	return CPublishedFile_GetAppRelationships_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getapprelationships_request(o CPublishedFile_GetAppRelationships_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getapprelationships_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetAppRelationships_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getapprelationships_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetAppRelationships_Response_AppRelationship {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	has_appid        bool
	relationship     u32
	has_relationship bool
}

pub fn (o &CPublishedFile_GetAppRelationships_Response_AppRelationship) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_relationship {
		res << vproto.pack_uint32_field(o.relationship, 2)
	}
	return res
}

pub fn cpublishedfile_getapprelationships_response_apprelationship_unpack(buf []byte) ?CPublishedFile_GetAppRelationships_Response_AppRelationship {
	mut res := CPublishedFile_GetAppRelationships_Response_AppRelationship{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_relationship = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.relationship = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getapprelationships_response_apprelationship() CPublishedFile_GetAppRelationships_Response_AppRelationship {
	return CPublishedFile_GetAppRelationships_Response_AppRelationship{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getapprelationships_response_apprelationship(o CPublishedFile_GetAppRelationships_Response_AppRelationship, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getapprelationships_response_apprelationship(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetAppRelationships_Response_AppRelationship) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getapprelationships_response_apprelationship_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetAppRelationships_Response {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	app_relationships []CPublishedFile_GetAppRelationships_Response_AppRelationship
}

pub fn (o &CPublishedFile_GetAppRelationships_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.app_relationships {
		res <<
			zzz_vproto_internal_pack_cpublishedfile_getapprelationships_response_apprelationship(x, 3)
	}
	return res
}

pub fn cpublishedfile_getapprelationships_response_unpack(buf []byte) ?CPublishedFile_GetAppRelationships_Response {
	mut res := CPublishedFile_GetAppRelationships_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getapprelationships_response_apprelationship(cur_buf,
					tag_wiretype.wire_type)?
				res.app_relationships << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getapprelationships_response() CPublishedFile_GetAppRelationships_Response {
	return CPublishedFile_GetAppRelationships_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getapprelationships_response(o CPublishedFile_GetAppRelationships_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getapprelationships_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetAppRelationships_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getapprelationships_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_StartPlaytimeTracking_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	has_appid        bool
	publishedfileids []u64
}

pub fn (o &CPublishedFile_StartPlaytimeTracking_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.publishedfileids {
		res << vproto.pack_uint64_field(x, 2)
	}
	return res
}

pub fn cpublishedfile_startplaytimetracking_request_unpack(buf []byte) ?CPublishedFile_StartPlaytimeTracking_Request {
	mut res := CPublishedFile_StartPlaytimeTracking_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_startplaytimetracking_request() CPublishedFile_StartPlaytimeTracking_Request {
	return CPublishedFile_StartPlaytimeTracking_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_startplaytimetracking_request(o CPublishedFile_StartPlaytimeTracking_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_startplaytimetracking_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_StartPlaytimeTracking_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_startplaytimetracking_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_StartPlaytimeTracking_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_StartPlaytimeTracking_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_startplaytimetracking_response_unpack(buf []byte) ?CPublishedFile_StartPlaytimeTracking_Response {
	res := CPublishedFile_StartPlaytimeTracking_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_startplaytimetracking_response() CPublishedFile_StartPlaytimeTracking_Response {
	return CPublishedFile_StartPlaytimeTracking_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_startplaytimetracking_response(o CPublishedFile_StartPlaytimeTracking_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_startplaytimetracking_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_StartPlaytimeTracking_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_startplaytimetracking_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_StopPlaytimeTracking_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	has_appid        bool
	publishedfileids []u64
}

pub fn (o &CPublishedFile_StopPlaytimeTracking_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.publishedfileids {
		res << vproto.pack_uint64_field(x, 2)
	}
	return res
}

pub fn cpublishedfile_stopplaytimetracking_request_unpack(buf []byte) ?CPublishedFile_StopPlaytimeTracking_Request {
	mut res := CPublishedFile_StopPlaytimeTracking_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_stopplaytimetracking_request() CPublishedFile_StopPlaytimeTracking_Request {
	return CPublishedFile_StopPlaytimeTracking_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_stopplaytimetracking_request(o CPublishedFile_StopPlaytimeTracking_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_stopplaytimetracking_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_StopPlaytimeTracking_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_stopplaytimetracking_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_StopPlaytimeTracking_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_StopPlaytimeTracking_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_stopplaytimetracking_response_unpack(buf []byte) ?CPublishedFile_StopPlaytimeTracking_Response {
	res := CPublishedFile_StopPlaytimeTracking_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_stopplaytimetracking_response() CPublishedFile_StopPlaytimeTracking_Response {
	return CPublishedFile_StopPlaytimeTracking_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_stopplaytimetracking_response(o CPublishedFile_StopPlaytimeTracking_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_stopplaytimetracking_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_StopPlaytimeTracking_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_stopplaytimetracking_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
}

pub fn (o &CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cpublishedfile_stopplaytimetrackingforallappitems_request_unpack(buf []byte) ?CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
	mut res := CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_stopplaytimetrackingforallappitems_request() CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request {
	return CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_stopplaytimetrackingforallappitems_request(o CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_stopplaytimetrackingforallappitems_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_StopPlaytimeTrackingForAllAppItems_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_stopplaytimetrackingforallappitems_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_stopplaytimetrackingforallappitems_response_unpack(buf []byte) ?CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
	res := CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_stopplaytimetrackingforallappitems_response() CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response {
	return CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_stopplaytimetrackingforallappitems_response(o CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_stopplaytimetrackingforallappitems_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_StopPlaytimeTrackingForAllAppItems_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_stopplaytimetrackingforallappitems_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
	seconds_active      f32
	has_seconds_active  bool
}

pub fn (o &CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.has_seconds_active {
		res << vproto.pack_float_field(o.seconds_active, 2)
	}
	return res
}

pub fn cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage_unpack(buf []byte) ?CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
	mut res := CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				res.has_seconds_active = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_active = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage() CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage {
	return CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage(o CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_SetPlaytimeForControllerConfigs_Request {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	appid                   u32
	has_appid               bool
	controller_config_usage []CPublishedFile_SetPlaytimeForControllerConfigs_Request_ControllerConfigUsage
}

pub fn (o &CPublishedFile_SetPlaytimeForControllerConfigs_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.controller_config_usage {
		res <<
			zzz_vproto_internal_pack_cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage(x, 2)
	}
	return res
}

pub fn cpublishedfile_setplaytimeforcontrollerconfigs_request_unpack(buf []byte) ?CPublishedFile_SetPlaytimeForControllerConfigs_Request {
	mut res := CPublishedFile_SetPlaytimeForControllerConfigs_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_setplaytimeforcontrollerconfigs_request_controllerconfigusage(cur_buf,
					tag_wiretype.wire_type)?
				res.controller_config_usage << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_setplaytimeforcontrollerconfigs_request() CPublishedFile_SetPlaytimeForControllerConfigs_Request {
	return CPublishedFile_SetPlaytimeForControllerConfigs_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_setplaytimeforcontrollerconfigs_request(o CPublishedFile_SetPlaytimeForControllerConfigs_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_setplaytimeforcontrollerconfigs_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_SetPlaytimeForControllerConfigs_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_setplaytimeforcontrollerconfigs_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_SetPlaytimeForControllerConfigs_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_SetPlaytimeForControllerConfigs_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_setplaytimeforcontrollerconfigs_response_unpack(buf []byte) ?CPublishedFile_SetPlaytimeForControllerConfigs_Response {
	res := CPublishedFile_SetPlaytimeForControllerConfigs_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_setplaytimeforcontrollerconfigs_response() CPublishedFile_SetPlaytimeForControllerConfigs_Response {
	return CPublishedFile_SetPlaytimeForControllerConfigs_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_setplaytimeforcontrollerconfigs_response(o CPublishedFile_SetPlaytimeForControllerConfigs_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_setplaytimeforcontrollerconfigs_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_SetPlaytimeForControllerConfigs_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_setplaytimeforcontrollerconfigs_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AddChild_Request {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	publishedfileid           u64
	has_publishedfileid       bool
	child_publishedfileid     u64
	has_child_publishedfileid bool
}

pub fn (o &CPublishedFile_AddChild_Request) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.has_child_publishedfileid {
		res << vproto.pack_uint64_field(o.child_publishedfileid, 2)
	}
	return res
}

pub fn cpublishedfile_addchild_request_unpack(buf []byte) ?CPublishedFile_AddChild_Request {
	mut res := CPublishedFile_AddChild_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				res.has_child_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.child_publishedfileid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_addchild_request() CPublishedFile_AddChild_Request {
	return CPublishedFile_AddChild_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_addchild_request(o CPublishedFile_AddChild_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_addchild_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AddChild_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_addchild_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_AddChild_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_AddChild_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_addchild_response_unpack(buf []byte) ?CPublishedFile_AddChild_Response {
	res := CPublishedFile_AddChild_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_addchild_response() CPublishedFile_AddChild_Response {
	return CPublishedFile_AddChild_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_addchild_response(o CPublishedFile_AddChild_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_addchild_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_AddChild_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_addchild_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_RemoveChild_Request {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	publishedfileid           u64
	has_publishedfileid       bool
	child_publishedfileid     u64
	has_child_publishedfileid bool
}

pub fn (o &CPublishedFile_RemoveChild_Request) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	if o.has_child_publishedfileid {
		res << vproto.pack_uint64_field(o.child_publishedfileid, 2)
	}
	return res
}

pub fn cpublishedfile_removechild_request_unpack(buf []byte) ?CPublishedFile_RemoveChild_Request {
	mut res := CPublishedFile_RemoveChild_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				res.has_child_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.child_publishedfileid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_removechild_request() CPublishedFile_RemoveChild_Request {
	return CPublishedFile_RemoveChild_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_removechild_request(o CPublishedFile_RemoveChild_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_removechild_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_RemoveChild_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_removechild_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_RemoveChild_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPublishedFile_RemoveChild_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpublishedfile_removechild_response_unpack(buf []byte) ?CPublishedFile_RemoveChild_Response {
	res := CPublishedFile_RemoveChild_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_removechild_response() CPublishedFile_RemoveChild_Response {
	return CPublishedFile_RemoveChild_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_removechild_response(o CPublishedFile_RemoveChild_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_removechild_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_RemoveChild_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_removechild_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserVoteSummary_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	publishedfileids []u64
}

pub fn (o &CPublishedFile_GetUserVoteSummary_Request) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.publishedfileids {
		res << vproto.pack_64bit_field(x, 1)
	}
	return res
}

pub fn cpublishedfile_getuservotesummary_request_unpack(buf []byte) ?CPublishedFile_GetUserVoteSummary_Request {
	mut res := CPublishedFile_GetUserVoteSummary_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getuservotesummary_request() CPublishedFile_GetUserVoteSummary_Request {
	return CPublishedFile_GetUserVoteSummary_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getuservotesummary_request(o CPublishedFile_GetUserVoteSummary_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuservotesummary_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserVoteSummary_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuservotesummary_request_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
	vote_for            bool
	has_vote_for        bool
	vote_against        bool
	has_vote_against    bool
	reported            bool
	has_reported        bool
}

pub fn (o &CPublishedFile_GetUserVoteSummary_Response_VoteSummary) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_64bit_field(o.publishedfileid, 1)
	}
	if o.has_vote_for {
		res << vproto.pack_bool_field(o.vote_for, 2)
	}
	if o.has_vote_against {
		res << vproto.pack_bool_field(o.vote_against, 3)
	}
	if o.has_reported {
		res << vproto.pack_bool_field(o.reported, 4)
	}
	return res
}

pub fn cpublishedfile_getuservotesummary_response_votesummary_unpack(buf []byte) ?CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
	mut res := CPublishedFile_GetUserVoteSummary_Response_VoteSummary{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			2 {
				res.has_vote_for = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.vote_for = v
				i = ii
			}
			3 {
				res.has_vote_against = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.vote_against = v
				i = ii
			}
			4 {
				res.has_reported = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.reported = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getuservotesummary_response_votesummary() CPublishedFile_GetUserVoteSummary_Response_VoteSummary {
	return CPublishedFile_GetUserVoteSummary_Response_VoteSummary{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getuservotesummary_response_votesummary(o CPublishedFile_GetUserVoteSummary_Response_VoteSummary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuservotesummary_response_votesummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserVoteSummary_Response_VoteSummary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuservotesummary_response_votesummary_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_GetUserVoteSummary_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	summaries      []CPublishedFile_GetUserVoteSummary_Response_VoteSummary
}

pub fn (o &CPublishedFile_GetUserVoteSummary_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.summaries {
		res <<
			zzz_vproto_internal_pack_cpublishedfile_getuservotesummary_response_votesummary(x, 1)
	}
	return res
}

pub fn cpublishedfile_getuservotesummary_response_unpack(buf []byte) ?CPublishedFile_GetUserVoteSummary_Response {
	mut res := CPublishedFile_GetUserVoteSummary_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_getuservotesummary_response_votesummary(cur_buf,
					tag_wiretype.wire_type)?
				res.summaries << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_getuservotesummary_response() CPublishedFile_GetUserVoteSummary_Response {
	return CPublishedFile_GetUserVoteSummary_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_getuservotesummary_response(o CPublishedFile_GetUserVoteSummary_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_getuservotesummary_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_GetUserVoteSummary_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_getuservotesummary_response_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_FileSubscribed_Notification_RevisionData {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	revision          EPublishedFileRevision
	has_revision      bool
	file_hcontent     u64
	has_file_hcontent bool
	rtime_updated     u32
	has_rtime_updated bool
}

pub fn (o &CPublishedFile_FileSubscribed_Notification_RevisionData) pack() []byte {
	mut res := []byte{}
	if o.has_revision {
		res << zzz_vproto_internal_pack_epublishedfilerevision(o.revision, 1)
	}
	if o.has_file_hcontent {
		res << vproto.pack_64bit_field(o.file_hcontent, 2)
	}
	if o.has_rtime_updated {
		res << vproto.pack_uint32_field(o.rtime_updated, 3)
	}
	return res
}

pub fn cpublishedfile_filesubscribed_notification_revisiondata_unpack(buf []byte) ?CPublishedFile_FileSubscribed_Notification_RevisionData {
	mut res := CPublishedFile_FileSubscribed_Notification_RevisionData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_revision = true
				ii, v := zzz_vproto_internal_unpack_epublishedfilerevision(cur_buf, tag_wiretype.wire_type)?
				res.revision = v
				i = ii
			}
			2 {
				res.has_file_hcontent = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.file_hcontent = v
				i = ii
			}
			3 {
				res.has_rtime_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_updated = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_filesubscribed_notification_revisiondata() CPublishedFile_FileSubscribed_Notification_RevisionData {
	return CPublishedFile_FileSubscribed_Notification_RevisionData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_filesubscribed_notification_revisiondata(o CPublishedFile_FileSubscribed_Notification_RevisionData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_filesubscribed_notification_revisiondata(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_FileSubscribed_Notification_RevisionData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_filesubscribed_notification_revisiondata_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_FileSubscribed_Notification {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	app_id                u32
	has_app_id            bool
	file_hcontent         u64
	has_file_hcontent     bool
	file_size             u32
	has_file_size         bool
	rtime_subscribed      u32
	has_rtime_subscribed  bool
	is_depot_content      bool
	has_is_depot_content  bool
	rtime_updated         u32
	has_rtime_updated     bool
	revisions             []CPublishedFile_FileSubscribed_Notification_RevisionData
}

pub fn (o &CPublishedFile_FileSubscribed_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.has_file_hcontent {
		res << vproto.pack_64bit_field(o.file_hcontent, 3)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 4)
	}
	if o.has_rtime_subscribed {
		res << vproto.pack_uint32_field(o.rtime_subscribed, 5)
	}
	if o.has_is_depot_content {
		res << vproto.pack_bool_field(o.is_depot_content, 6)
	}
	if o.has_rtime_updated {
		res << vproto.pack_uint32_field(o.rtime_updated, 7)
	}
	// [packed=false]
	for _, x in o.revisions {
		res <<
			zzz_vproto_internal_pack_cpublishedfile_filesubscribed_notification_revisiondata(x, 8)
	}
	return res
}

pub fn cpublishedfile_filesubscribed_notification_unpack(buf []byte) ?CPublishedFile_FileSubscribed_Notification {
	mut res := CPublishedFile_FileSubscribed_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			3 {
				res.has_file_hcontent = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.file_hcontent = v
				i = ii
			}
			4 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			5 {
				res.has_rtime_subscribed = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_subscribed = v
				i = ii
			}
			6 {
				res.has_is_depot_content = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_depot_content = v
				i = ii
			}
			7 {
				res.has_rtime_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_updated = v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpublishedfile_filesubscribed_notification_revisiondata(cur_buf,
					tag_wiretype.wire_type)?
				res.revisions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_filesubscribed_notification() CPublishedFile_FileSubscribed_Notification {
	return CPublishedFile_FileSubscribed_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_filesubscribed_notification(o CPublishedFile_FileSubscribed_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_filesubscribed_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_FileSubscribed_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_filesubscribed_notification_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_FileUnsubscribed_Notification {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	app_id                u32
	has_app_id            bool
}

pub fn (o &CPublishedFile_FileUnsubscribed_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	return res
}

pub fn cpublishedfile_fileunsubscribed_notification_unpack(buf []byte) ?CPublishedFile_FileUnsubscribed_Notification {
	mut res := CPublishedFile_FileUnsubscribed_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_fileunsubscribed_notification() CPublishedFile_FileUnsubscribed_Notification {
	return CPublishedFile_FileUnsubscribed_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_fileunsubscribed_notification(o CPublishedFile_FileUnsubscribed_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_fileunsubscribed_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_FileUnsubscribed_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_fileunsubscribed_notification_unpack(v)?
	return i, unpacked
}

pub struct CPublishedFile_FileDeleted_Client_Notification {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	app_id                u32
	has_app_id            bool
}

pub fn (o &CPublishedFile_FileDeleted_Client_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	return res
}

pub fn cpublishedfile_filedeleted_client_notification_unpack(buf []byte) ?CPublishedFile_FileDeleted_Client_Notification {
	mut res := CPublishedFile_FileDeleted_Client_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpublishedfile_filedeleted_client_notification() CPublishedFile_FileDeleted_Client_Notification {
	return CPublishedFile_FileDeleted_Client_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpublishedfile_filedeleted_client_notification(o CPublishedFile_FileDeleted_Client_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpublishedfile_filedeleted_client_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPublishedFile_FileDeleted_Client_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpublishedfile_filedeleted_client_notification_unpack(v)?
	return i, unpacked
}
