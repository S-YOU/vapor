
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


pub struct ParentalApp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
is_allowed bool
has_is_allowed bool
}
pub fn (o &ParentalApp) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_is_allowed {
res << vproto.pack_bool_field(o.is_allowed, 2)
}

return res
}

pub fn parentalapp_unpack(buf []byte) ?ParentalApp {
mut res := ParentalApp{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_is_allowed = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_allowed = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_parentalapp() ParentalApp {
return ParentalApp{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_parentalapp(o ParentalApp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_parentalapp(buf []byte, tag_wiretype vproto.WireType) ?(int, ParentalApp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := parentalapp_unpack(v)?
return i, unpacked
}
pub struct ParentalSettings {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
applist_base_id u32
has_applist_base_id bool
applist_base_description string
has_applist_base_description bool
applist_base []ParentalApp
applist_custom []ParentalApp
passwordhashtype u32
has_passwordhashtype bool
salt []byte
has_salt bool
passwordhash []byte
has_passwordhash bool
is_enabled bool
has_is_enabled bool
enabled_features u32
has_enabled_features bool
recovery_email string
has_recovery_email bool
is_site_license_lock bool
has_is_site_license_lock bool
}
pub fn (o &ParentalSettings) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_applist_base_id {
res << vproto.pack_uint32_field(o.applist_base_id, 2)
}

if o.has_applist_base_description {
res << vproto.pack_string_field(o.applist_base_description, 3)
}

// [packed=false]
for _, x in o.applist_base {
res << zzz_vproto_internal_pack_parentalapp(x, 4)
}

// [packed=false]
for _, x in o.applist_custom {
res << zzz_vproto_internal_pack_parentalapp(x, 5)
}

if o.has_passwordhashtype {
res << vproto.pack_uint32_field(o.passwordhashtype, 6)
}

if o.has_salt {
res << vproto.pack_bytes_field(o.salt, 7)
}

if o.has_passwordhash {
res << vproto.pack_bytes_field(o.passwordhash, 8)
}

if o.has_is_enabled {
res << vproto.pack_bool_field(o.is_enabled, 9)
}

if o.has_enabled_features {
res << vproto.pack_uint32_field(o.enabled_features, 10)
}

if o.has_recovery_email {
res << vproto.pack_string_field(o.recovery_email, 11)
}

if o.has_is_site_license_lock {
res << vproto.pack_bool_field(o.is_site_license_lock, 12)
}

return res
}

pub fn parentalsettings_unpack(buf []byte) ?ParentalSettings {
mut res := ParentalSettings{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_applist_base_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.applist_base_id = v
i = ii
}

3 {
res.has_applist_base_description = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.applist_base_description = v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_parentalapp(cur_buf, tag_wiretype.wire_type)?
res.applist_base << v
i = ii
}

5 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_parentalapp(cur_buf, tag_wiretype.wire_type)?
res.applist_custom << v
i = ii
}

6 {
res.has_passwordhashtype = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.passwordhashtype = v
i = ii
}

7 {
res.has_salt = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.salt = v
i = ii
}

8 {
res.has_passwordhash = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.passwordhash = v
i = ii
}

9 {
res.has_is_enabled = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_enabled = v
i = ii
}

10 {
res.has_enabled_features = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.enabled_features = v
i = ii
}

11 {
res.has_recovery_email = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.recovery_email = v
i = ii
}

12 {
res.has_is_site_license_lock = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_site_license_lock = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_parentalsettings() ParentalSettings {
return ParentalSettings{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_parentalsettings(o ParentalSettings, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_parentalsettings(buf []byte, tag_wiretype vproto.WireType) ?(int, ParentalSettings) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := parentalsettings_unpack(v)?
return i, unpacked
}
pub struct CParentalEnableParentalSettingsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
password string
has_password bool
settings ParentalSettings
has_settings bool
sessionid string
has_sessionid bool
enablecode u32
has_enablecode bool
steamid u64
has_steamid bool
}
pub fn (o &CParentalEnableParentalSettingsRequest) pack() []byte {
mut res := []byte{}
if o.has_password {
res << vproto.pack_string_field(o.password, 1)
}

if o.has_settings {
res << zzz_vproto_internal_pack_parentalsettings(o.settings, 2)
}

if o.has_sessionid {
res << vproto.pack_string_field(o.sessionid, 3)
}

if o.has_enablecode {
res << vproto.pack_uint32_field(o.enablecode, 4)
}

if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 10)
}

return res
}

pub fn cparentalenableparentalsettingsrequest_unpack(buf []byte) ?CParentalEnableParentalSettingsRequest {
mut res := CParentalEnableParentalSettingsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_password = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.password = v
i = ii
}

2 {
res.has_settings = true
ii, v := zzz_vproto_internal_unpack_parentalsettings(cur_buf, tag_wiretype.wire_type)?
res.settings = v
i = ii
}

3 {
res.has_sessionid = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.sessionid = v
i = ii
}

4 {
res.has_enablecode = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.enablecode = v
i = ii
}

10 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalenableparentalsettingsrequest() CParentalEnableParentalSettingsRequest {
return CParentalEnableParentalSettingsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalenableparentalsettingsrequest(o CParentalEnableParentalSettingsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalenableparentalsettingsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalEnableParentalSettingsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalenableparentalsettingsrequest_unpack(v)?
return i, unpacked
}
pub struct CParentalEnableParentalSettingsResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CParentalEnableParentalSettingsResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cparentalenableparentalsettingsresponse_unpack(buf []byte) ?CParentalEnableParentalSettingsResponse {
res := CParentalEnableParentalSettingsResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalenableparentalsettingsresponse() CParentalEnableParentalSettingsResponse {
return CParentalEnableParentalSettingsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalenableparentalsettingsresponse(o CParentalEnableParentalSettingsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalenableparentalsettingsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalEnableParentalSettingsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalenableparentalsettingsresponse_unpack(v)?
return i, unpacked
}
pub struct CParentalDisableParentalSettingsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
password string
has_password bool
steamid u64
has_steamid bool
}
pub fn (o &CParentalDisableParentalSettingsRequest) pack() []byte {
mut res := []byte{}
if o.has_password {
res << vproto.pack_string_field(o.password, 1)
}

if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 10)
}

return res
}

pub fn cparentaldisableparentalsettingsrequest_unpack(buf []byte) ?CParentalDisableParentalSettingsRequest {
mut res := CParentalDisableParentalSettingsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_password = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.password = v
i = ii
}

10 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentaldisableparentalsettingsrequest() CParentalDisableParentalSettingsRequest {
return CParentalDisableParentalSettingsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentaldisableparentalsettingsrequest(o CParentalDisableParentalSettingsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentaldisableparentalsettingsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalDisableParentalSettingsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentaldisableparentalsettingsrequest_unpack(v)?
return i, unpacked
}
pub struct CParentalDisableParentalSettingsResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CParentalDisableParentalSettingsResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cparentaldisableparentalsettingsresponse_unpack(buf []byte) ?CParentalDisableParentalSettingsResponse {
res := CParentalDisableParentalSettingsResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentaldisableparentalsettingsresponse() CParentalDisableParentalSettingsResponse {
return CParentalDisableParentalSettingsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentaldisableparentalsettingsresponse(o CParentalDisableParentalSettingsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentaldisableparentalsettingsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalDisableParentalSettingsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentaldisableparentalsettingsresponse_unpack(v)?
return i, unpacked
}
pub struct CParentalGetParentalSettingsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
}
pub fn (o &CParentalGetParentalSettingsRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 10)
}

return res
}

pub fn cparentalgetparentalsettingsrequest_unpack(buf []byte) ?CParentalGetParentalSettingsRequest {
mut res := CParentalGetParentalSettingsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
10 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalgetparentalsettingsrequest() CParentalGetParentalSettingsRequest {
return CParentalGetParentalSettingsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalgetparentalsettingsrequest(o CParentalGetParentalSettingsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalgetparentalsettingsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalGetParentalSettingsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalgetparentalsettingsrequest_unpack(v)?
return i, unpacked
}
pub struct CParentalGetParentalSettingsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
settings ParentalSettings
has_settings bool
}
pub fn (o &CParentalGetParentalSettingsResponse) pack() []byte {
mut res := []byte{}
if o.has_settings {
res << zzz_vproto_internal_pack_parentalsettings(o.settings, 1)
}

return res
}

pub fn cparentalgetparentalsettingsresponse_unpack(buf []byte) ?CParentalGetParentalSettingsResponse {
mut res := CParentalGetParentalSettingsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_settings = true
ii, v := zzz_vproto_internal_unpack_parentalsettings(cur_buf, tag_wiretype.wire_type)?
res.settings = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalgetparentalsettingsresponse() CParentalGetParentalSettingsResponse {
return CParentalGetParentalSettingsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalgetparentalsettingsresponse(o CParentalGetParentalSettingsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalgetparentalsettingsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalGetParentalSettingsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalgetparentalsettingsresponse_unpack(v)?
return i, unpacked
}
pub struct CParentalGetSignedParentalSettingsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
priority u32
has_priority bool
}
pub fn (o &CParentalGetSignedParentalSettingsRequest) pack() []byte {
mut res := []byte{}
if o.has_priority {
res << vproto.pack_uint32_field(o.priority, 1)
}

return res
}

pub fn cparentalgetsignedparentalsettingsrequest_unpack(buf []byte) ?CParentalGetSignedParentalSettingsRequest {
mut res := CParentalGetSignedParentalSettingsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_priority = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.priority = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalgetsignedparentalsettingsrequest() CParentalGetSignedParentalSettingsRequest {
return CParentalGetSignedParentalSettingsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalgetsignedparentalsettingsrequest(o CParentalGetSignedParentalSettingsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalgetsignedparentalsettingsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalGetSignedParentalSettingsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalgetsignedparentalsettingsrequest_unpack(v)?
return i, unpacked
}
pub struct CParentalGetSignedParentalSettingsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
serialized_settings []byte
has_serialized_settings bool
signature []byte
has_signature bool
}
pub fn (o &CParentalGetSignedParentalSettingsResponse) pack() []byte {
mut res := []byte{}
if o.has_serialized_settings {
res << vproto.pack_bytes_field(o.serialized_settings, 1)
}

if o.has_signature {
res << vproto.pack_bytes_field(o.signature, 2)
}

return res
}

pub fn cparentalgetsignedparentalsettingsresponse_unpack(buf []byte) ?CParentalGetSignedParentalSettingsResponse {
mut res := CParentalGetSignedParentalSettingsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_serialized_settings = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.serialized_settings = v
i = ii
}

2 {
res.has_signature = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.signature = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalgetsignedparentalsettingsresponse() CParentalGetSignedParentalSettingsResponse {
return CParentalGetSignedParentalSettingsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalgetsignedparentalsettingsresponse(o CParentalGetSignedParentalSettingsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalgetsignedparentalsettingsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalGetSignedParentalSettingsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalgetsignedparentalsettingsresponse_unpack(v)?
return i, unpacked
}
pub struct CParentalSetParentalSettingsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
password string
has_password bool
settings ParentalSettings
has_settings bool
new_password string
has_new_password bool
sessionid string
has_sessionid bool
steamid u64
has_steamid bool
}
pub fn (o &CParentalSetParentalSettingsRequest) pack() []byte {
mut res := []byte{}
if o.has_password {
res << vproto.pack_string_field(o.password, 1)
}

if o.has_settings {
res << zzz_vproto_internal_pack_parentalsettings(o.settings, 2)
}

if o.has_new_password {
res << vproto.pack_string_field(o.new_password, 3)
}

if o.has_sessionid {
res << vproto.pack_string_field(o.sessionid, 4)
}

if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 10)
}

return res
}

pub fn cparentalsetparentalsettingsrequest_unpack(buf []byte) ?CParentalSetParentalSettingsRequest {
mut res := CParentalSetParentalSettingsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_password = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.password = v
i = ii
}

2 {
res.has_settings = true
ii, v := zzz_vproto_internal_unpack_parentalsettings(cur_buf, tag_wiretype.wire_type)?
res.settings = v
i = ii
}

3 {
res.has_new_password = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.new_password = v
i = ii
}

4 {
res.has_sessionid = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.sessionid = v
i = ii
}

10 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalsetparentalsettingsrequest() CParentalSetParentalSettingsRequest {
return CParentalSetParentalSettingsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalsetparentalsettingsrequest(o CParentalSetParentalSettingsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalsetparentalsettingsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalSetParentalSettingsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalsetparentalsettingsrequest_unpack(v)?
return i, unpacked
}
pub struct CParentalSetParentalSettingsResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CParentalSetParentalSettingsResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cparentalsetparentalsettingsresponse_unpack(buf []byte) ?CParentalSetParentalSettingsResponse {
res := CParentalSetParentalSettingsResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalsetparentalsettingsresponse() CParentalSetParentalSettingsResponse {
return CParentalSetParentalSettingsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalsetparentalsettingsresponse(o CParentalSetParentalSettingsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalsetparentalsettingsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalSetParentalSettingsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalsetparentalsettingsresponse_unpack(v)?
return i, unpacked
}
pub struct CParentalValidateTokenRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
unlock_token string
has_unlock_token bool
}
pub fn (o &CParentalValidateTokenRequest) pack() []byte {
mut res := []byte{}
if o.has_unlock_token {
res << vproto.pack_string_field(o.unlock_token, 1)
}

return res
}

pub fn cparentalvalidatetokenrequest_unpack(buf []byte) ?CParentalValidateTokenRequest {
mut res := CParentalValidateTokenRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_unlock_token = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.unlock_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalvalidatetokenrequest() CParentalValidateTokenRequest {
return CParentalValidateTokenRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalvalidatetokenrequest(o CParentalValidateTokenRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalvalidatetokenrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalValidateTokenRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalvalidatetokenrequest_unpack(v)?
return i, unpacked
}
pub struct CParentalValidateTokenResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CParentalValidateTokenResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cparentalvalidatetokenresponse_unpack(buf []byte) ?CParentalValidateTokenResponse {
res := CParentalValidateTokenResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalvalidatetokenresponse() CParentalValidateTokenResponse {
return CParentalValidateTokenResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalvalidatetokenresponse(o CParentalValidateTokenResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalvalidatetokenresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalValidateTokenResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalvalidatetokenresponse_unpack(v)?
return i, unpacked
}
pub struct CParentalValidatePasswordRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
password string
has_password bool
session string
has_session bool
send_unlock_on_success bool
has_send_unlock_on_success bool
}
pub fn (o &CParentalValidatePasswordRequest) pack() []byte {
mut res := []byte{}
if o.has_password {
res << vproto.pack_string_field(o.password, 1)
}

if o.has_session {
res << vproto.pack_string_field(o.session, 2)
}

if o.has_send_unlock_on_success {
res << vproto.pack_bool_field(o.send_unlock_on_success, 3)
}

return res
}

pub fn cparentalvalidatepasswordrequest_unpack(buf []byte) ?CParentalValidatePasswordRequest {
mut res := CParentalValidatePasswordRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_password = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.password = v
i = ii
}

2 {
res.has_session = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.session = v
i = ii
}

3 {
res.has_send_unlock_on_success = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.send_unlock_on_success = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalvalidatepasswordrequest() CParentalValidatePasswordRequest {
return CParentalValidatePasswordRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalvalidatepasswordrequest(o CParentalValidatePasswordRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalvalidatepasswordrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalValidatePasswordRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalvalidatepasswordrequest_unpack(v)?
return i, unpacked
}
pub struct CParentalValidatePasswordResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
token string
has_token bool
}
pub fn (o &CParentalValidatePasswordResponse) pack() []byte {
mut res := []byte{}
if o.has_token {
res << vproto.pack_string_field(o.token, 1)
}

return res
}

pub fn cparentalvalidatepasswordresponse_unpack(buf []byte) ?CParentalValidatePasswordResponse {
mut res := CParentalValidatePasswordResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_token = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalvalidatepasswordresponse() CParentalValidatePasswordResponse {
return CParentalValidatePasswordResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalvalidatepasswordresponse(o CParentalValidatePasswordResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalvalidatepasswordresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalValidatePasswordResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalvalidatepasswordresponse_unpack(v)?
return i, unpacked
}
pub struct CParentalLockClientRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
session string
has_session bool
}
pub fn (o &CParentalLockClientRequest) pack() []byte {
mut res := []byte{}
if o.has_session {
res << vproto.pack_string_field(o.session, 1)
}

return res
}

pub fn cparentallockclientrequest_unpack(buf []byte) ?CParentalLockClientRequest {
mut res := CParentalLockClientRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_session = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.session = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentallockclientrequest() CParentalLockClientRequest {
return CParentalLockClientRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentallockclientrequest(o CParentalLockClientRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentallockclientrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalLockClientRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentallockclientrequest_unpack(v)?
return i, unpacked
}
pub struct CParentalLockClientResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CParentalLockClientResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cparentallockclientresponse_unpack(buf []byte) ?CParentalLockClientResponse {
res := CParentalLockClientResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentallockclientresponse() CParentalLockClientResponse {
return CParentalLockClientResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentallockclientresponse(o CParentalLockClientResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentallockclientresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalLockClientResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentallockclientresponse_unpack(v)?
return i, unpacked
}
pub struct CParentalRequestRecoveryCodeRequest {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CParentalRequestRecoveryCodeRequest) pack() []byte {
res := []byte{}
return res
}

pub fn cparentalrequestrecoverycoderequest_unpack(buf []byte) ?CParentalRequestRecoveryCodeRequest {
res := CParentalRequestRecoveryCodeRequest{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalrequestrecoverycoderequest() CParentalRequestRecoveryCodeRequest {
return CParentalRequestRecoveryCodeRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalrequestrecoverycoderequest(o CParentalRequestRecoveryCodeRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalrequestrecoverycoderequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalRequestRecoveryCodeRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalrequestrecoverycoderequest_unpack(v)?
return i, unpacked
}
pub struct CParentalRequestRecoveryCodeResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CParentalRequestRecoveryCodeResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cparentalrequestrecoverycoderesponse_unpack(buf []byte) ?CParentalRequestRecoveryCodeResponse {
res := CParentalRequestRecoveryCodeResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalrequestrecoverycoderesponse() CParentalRequestRecoveryCodeResponse {
return CParentalRequestRecoveryCodeResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalrequestrecoverycoderesponse(o CParentalRequestRecoveryCodeResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalrequestrecoverycoderesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalRequestRecoveryCodeResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalrequestrecoverycoderesponse_unpack(v)?
return i, unpacked
}
pub struct CParentalDisableWithRecoveryCodeRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
recovery_code u32
has_recovery_code bool
steamid u64
has_steamid bool
}
pub fn (o &CParentalDisableWithRecoveryCodeRequest) pack() []byte {
mut res := []byte{}
if o.has_recovery_code {
res << vproto.pack_uint32_field(o.recovery_code, 1)
}

if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 10)
}

return res
}

pub fn cparentaldisablewithrecoverycoderequest_unpack(buf []byte) ?CParentalDisableWithRecoveryCodeRequest {
mut res := CParentalDisableWithRecoveryCodeRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_recovery_code = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.recovery_code = v
i = ii
}

10 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentaldisablewithrecoverycoderequest() CParentalDisableWithRecoveryCodeRequest {
return CParentalDisableWithRecoveryCodeRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentaldisablewithrecoverycoderequest(o CParentalDisableWithRecoveryCodeRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentaldisablewithrecoverycoderequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalDisableWithRecoveryCodeRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentaldisablewithrecoverycoderequest_unpack(v)?
return i, unpacked
}
pub struct CParentalDisableWithRecoveryCodeResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CParentalDisableWithRecoveryCodeResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cparentaldisablewithrecoverycoderesponse_unpack(buf []byte) ?CParentalDisableWithRecoveryCodeResponse {
res := CParentalDisableWithRecoveryCodeResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentaldisablewithrecoverycoderesponse() CParentalDisableWithRecoveryCodeResponse {
return CParentalDisableWithRecoveryCodeResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentaldisablewithrecoverycoderesponse(o CParentalDisableWithRecoveryCodeResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentaldisablewithrecoverycoderesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalDisableWithRecoveryCodeResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentaldisablewithrecoverycoderesponse_unpack(v)?
return i, unpacked
}
pub struct CParentalParentalSettingsChangeNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
serialized_settings []byte
has_serialized_settings bool
signature []byte
has_signature bool
password string
has_password bool
sessionid string
has_sessionid bool
}
pub fn (o &CParentalParentalSettingsChangeNotification) pack() []byte {
mut res := []byte{}
if o.has_serialized_settings {
res << vproto.pack_bytes_field(o.serialized_settings, 1)
}

if o.has_signature {
res << vproto.pack_bytes_field(o.signature, 2)
}

if o.has_password {
res << vproto.pack_string_field(o.password, 3)
}

if o.has_sessionid {
res << vproto.pack_string_field(o.sessionid, 4)
}

return res
}

pub fn cparentalparentalsettingschangenotification_unpack(buf []byte) ?CParentalParentalSettingsChangeNotification {
mut res := CParentalParentalSettingsChangeNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_serialized_settings = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.serialized_settings = v
i = ii
}

2 {
res.has_signature = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.signature = v
i = ii
}

3 {
res.has_password = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.password = v
i = ii
}

4 {
res.has_sessionid = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.sessionid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalparentalsettingschangenotification() CParentalParentalSettingsChangeNotification {
return CParentalParentalSettingsChangeNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalparentalsettingschangenotification(o CParentalParentalSettingsChangeNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalparentalsettingschangenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalParentalSettingsChangeNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalparentalsettingschangenotification_unpack(v)?
return i, unpacked
}
pub struct CParentalParentalUnlockNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
password string
has_password bool
sessionid string
has_sessionid bool
}
pub fn (o &CParentalParentalUnlockNotification) pack() []byte {
mut res := []byte{}
if o.has_password {
res << vproto.pack_string_field(o.password, 1)
}

if o.has_sessionid {
res << vproto.pack_string_field(o.sessionid, 2)
}

return res
}

pub fn cparentalparentalunlocknotification_unpack(buf []byte) ?CParentalParentalUnlockNotification {
mut res := CParentalParentalUnlockNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_password = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.password = v
i = ii
}

2 {
res.has_sessionid = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.sessionid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalparentalunlocknotification() CParentalParentalUnlockNotification {
return CParentalParentalUnlockNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalparentalunlocknotification(o CParentalParentalUnlockNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalparentalunlocknotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalParentalUnlockNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalparentalunlocknotification_unpack(v)?
return i, unpacked
}
pub struct CParentalParentalLockNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
sessionid string
has_sessionid bool
}
pub fn (o &CParentalParentalLockNotification) pack() []byte {
mut res := []byte{}
if o.has_sessionid {
res << vproto.pack_string_field(o.sessionid, 1)
}

return res
}

pub fn cparentalparentallocknotification_unpack(buf []byte) ?CParentalParentalLockNotification {
mut res := CParentalParentalLockNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_sessionid = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.sessionid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparentalparentallocknotification() CParentalParentalLockNotification {
return CParentalParentalLockNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparentalparentallocknotification(o CParentalParentalLockNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparentalparentallocknotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CParentalParentalLockNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cparentalparentallocknotification_unpack(v)?
return i, unpacked
}
