// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct ParentalApp {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	is_allowed     bool
	has_is_allowed bool
}

pub fn (o &ParentalApp) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_is_allowed {
		res << vproto.pack_bool_field(o.is_allowed, 2)
	}
	return res
}

pub fn parentalapp_unpack(buf []byte) ?ParentalApp {
	mut res := ParentalApp{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_is_allowed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_allowed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_parentalapp() ParentalApp {
	return ParentalApp{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_parentalapp(o ParentalApp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_parentalapp(buf []byte, tag_wiretype vproto.WireType) ?(int, ParentalApp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := parentalapp_unpack(v)?
	return i, unpacked
}

pub struct ParentalSettings {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	steamid                      u64
	has_steamid                  bool
	applist_base_id              u32
	has_applist_base_id          bool
	applist_base_description     string
	has_applist_base_description bool
	applist_base                 []ParentalApp
	applist_custom               []ParentalApp
	passwordhashtype             u32
	has_passwordhashtype         bool
	salt                         []byte
	has_salt                     bool
	passwordhash                 []byte
	has_passwordhash             bool
	is_enabled                   bool
	has_is_enabled               bool
	enabled_features             u32
	has_enabled_features         bool
	recovery_email               string
	has_recovery_email           bool
	is_site_license_lock         bool
	has_is_site_license_lock     bool
}

pub fn (o &ParentalSettings) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_applist_base_id {
		res << vproto.pack_uint32_field(o.applist_base_id, 2)
	}
	if o.has_applist_base_description {
		res << vproto.pack_string_field(o.applist_base_description, 3)
	}
	// [packed=false]
	for _, x in o.applist_base {
		res << zzz_vproto_internal_pack_parentalapp(x, 4)
	}
	// [packed=false]
	for _, x in o.applist_custom {
		res << zzz_vproto_internal_pack_parentalapp(x, 5)
	}
	if o.has_passwordhashtype {
		res << vproto.pack_uint32_field(o.passwordhashtype, 6)
	}
	if o.has_salt {
		res << vproto.pack_bytes_field(o.salt, 7)
	}
	if o.has_passwordhash {
		res << vproto.pack_bytes_field(o.passwordhash, 8)
	}
	if o.has_is_enabled {
		res << vproto.pack_bool_field(o.is_enabled, 9)
	}
	if o.has_enabled_features {
		res << vproto.pack_uint32_field(o.enabled_features, 10)
	}
	if o.has_recovery_email {
		res << vproto.pack_string_field(o.recovery_email, 11)
	}
	if o.has_is_site_license_lock {
		res << vproto.pack_bool_field(o.is_site_license_lock, 12)
	}
	return res
}

pub fn parentalsettings_unpack(buf []byte) ?ParentalSettings {
	mut res := ParentalSettings{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_applist_base_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.applist_base_id = v
				i = ii
			}
			3 {
				res.has_applist_base_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.applist_base_description = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_parentalapp(cur_buf, tag_wiretype.wire_type)?
				res.applist_base << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_parentalapp(cur_buf, tag_wiretype.wire_type)?
				res.applist_custom << v
				i = ii
			}
			6 {
				res.has_passwordhashtype = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.passwordhashtype = v
				i = ii
			}
			7 {
				res.has_salt = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.salt = v
				i = ii
			}
			8 {
				res.has_passwordhash = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.passwordhash = v
				i = ii
			}
			9 {
				res.has_is_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_enabled = v
				i = ii
			}
			10 {
				res.has_enabled_features = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.enabled_features = v
				i = ii
			}
			11 {
				res.has_recovery_email = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.recovery_email = v
				i = ii
			}
			12 {
				res.has_is_site_license_lock = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_site_license_lock = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_parentalsettings() ParentalSettings {
	return ParentalSettings{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_parentalsettings(o ParentalSettings, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_parentalsettings(buf []byte, tag_wiretype vproto.WireType) ?(int, ParentalSettings) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := parentalsettings_unpack(v)?
	return i, unpacked
}

pub struct CParental_EnableParentalSettings_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	password       string
	has_password   bool
	settings       ParentalSettings
	has_settings   bool
	sessionid      string
	has_sessionid  bool
	enablecode     u32
	has_enablecode bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CParental_EnableParentalSettings_Request) pack() []byte {
	mut res := []byte{}
	if o.has_password {
		res << vproto.pack_string_field(o.password, 1)
	}
	if o.has_settings {
		res << zzz_vproto_internal_pack_parentalsettings(o.settings, 2)
	}
	if o.has_sessionid {
		res << vproto.pack_string_field(o.sessionid, 3)
	}
	if o.has_enablecode {
		res << vproto.pack_uint32_field(o.enablecode, 4)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 10)
	}
	return res
}

pub fn cparental_enableparentalsettings_request_unpack(buf []byte) ?CParental_EnableParentalSettings_Request {
	mut res := CParental_EnableParentalSettings_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_password = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.password = v
				i = ii
			}
			2 {
				res.has_settings = true
				ii, v := zzz_vproto_internal_unpack_parentalsettings(cur_buf, tag_wiretype.wire_type)?
				res.settings = v
				i = ii
			}
			3 {
				res.has_sessionid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			4 {
				res.has_enablecode = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.enablecode = v
				i = ii
			}
			10 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_enableparentalsettings_request() CParental_EnableParentalSettings_Request {
	return CParental_EnableParentalSettings_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_enableparentalsettings_request(o CParental_EnableParentalSettings_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_enableparentalsettings_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_EnableParentalSettings_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_enableparentalsettings_request_unpack(v)?
	return i, unpacked
}

pub struct CParental_EnableParentalSettings_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_EnableParentalSettings_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_enableparentalsettings_response_unpack(buf []byte) ?CParental_EnableParentalSettings_Response {
	res := CParental_EnableParentalSettings_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_enableparentalsettings_response() CParental_EnableParentalSettings_Response {
	return CParental_EnableParentalSettings_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_enableparentalsettings_response(o CParental_EnableParentalSettings_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_enableparentalsettings_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_EnableParentalSettings_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_enableparentalsettings_response_unpack(v)?
	return i, unpacked
}

pub struct CParental_DisableParentalSettings_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	password       string
	has_password   bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CParental_DisableParentalSettings_Request) pack() []byte {
	mut res := []byte{}
	if o.has_password {
		res << vproto.pack_string_field(o.password, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 10)
	}
	return res
}

pub fn cparental_disableparentalsettings_request_unpack(buf []byte) ?CParental_DisableParentalSettings_Request {
	mut res := CParental_DisableParentalSettings_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_password = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.password = v
				i = ii
			}
			10 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_disableparentalsettings_request() CParental_DisableParentalSettings_Request {
	return CParental_DisableParentalSettings_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_disableparentalsettings_request(o CParental_DisableParentalSettings_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_disableparentalsettings_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_DisableParentalSettings_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_disableparentalsettings_request_unpack(v)?
	return i, unpacked
}

pub struct CParental_DisableParentalSettings_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_DisableParentalSettings_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_disableparentalsettings_response_unpack(buf []byte) ?CParental_DisableParentalSettings_Response {
	res := CParental_DisableParentalSettings_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_disableparentalsettings_response() CParental_DisableParentalSettings_Response {
	return CParental_DisableParentalSettings_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_disableparentalsettings_response(o CParental_DisableParentalSettings_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_disableparentalsettings_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_DisableParentalSettings_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_disableparentalsettings_response_unpack(v)?
	return i, unpacked
}

pub struct CParental_GetParentalSettings_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CParental_GetParentalSettings_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 10)
	}
	return res
}

pub fn cparental_getparentalsettings_request_unpack(buf []byte) ?CParental_GetParentalSettings_Request {
	mut res := CParental_GetParentalSettings_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			10 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_getparentalsettings_request() CParental_GetParentalSettings_Request {
	return CParental_GetParentalSettings_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_getparentalsettings_request(o CParental_GetParentalSettings_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_getparentalsettings_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_GetParentalSettings_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_getparentalsettings_request_unpack(v)?
	return i, unpacked
}

pub struct CParental_GetParentalSettings_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	settings       ParentalSettings
	has_settings   bool
}

pub fn (o &CParental_GetParentalSettings_Response) pack() []byte {
	mut res := []byte{}
	if o.has_settings {
		res << zzz_vproto_internal_pack_parentalsettings(o.settings, 1)
	}
	return res
}

pub fn cparental_getparentalsettings_response_unpack(buf []byte) ?CParental_GetParentalSettings_Response {
	mut res := CParental_GetParentalSettings_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_settings = true
				ii, v := zzz_vproto_internal_unpack_parentalsettings(cur_buf, tag_wiretype.wire_type)?
				res.settings = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_getparentalsettings_response() CParental_GetParentalSettings_Response {
	return CParental_GetParentalSettings_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_getparentalsettings_response(o CParental_GetParentalSettings_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_getparentalsettings_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_GetParentalSettings_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_getparentalsettings_response_unpack(v)?
	return i, unpacked
}

pub struct CParental_GetSignedParentalSettings_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	priority       u32
	has_priority   bool
}

pub fn (o &CParental_GetSignedParentalSettings_Request) pack() []byte {
	mut res := []byte{}
	if o.has_priority {
		res << vproto.pack_uint32_field(o.priority, 1)
	}
	return res
}

pub fn cparental_getsignedparentalsettings_request_unpack(buf []byte) ?CParental_GetSignedParentalSettings_Request {
	mut res := CParental_GetSignedParentalSettings_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_priority = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.priority = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_getsignedparentalsettings_request() CParental_GetSignedParentalSettings_Request {
	return CParental_GetSignedParentalSettings_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_getsignedparentalsettings_request(o CParental_GetSignedParentalSettings_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_getsignedparentalsettings_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_GetSignedParentalSettings_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_getsignedparentalsettings_request_unpack(v)?
	return i, unpacked
}

pub struct CParental_GetSignedParentalSettings_Response {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	serialized_settings     []byte
	has_serialized_settings bool
	signature               []byte
	has_signature           bool
}

pub fn (o &CParental_GetSignedParentalSettings_Response) pack() []byte {
	mut res := []byte{}
	if o.has_serialized_settings {
		res << vproto.pack_bytes_field(o.serialized_settings, 1)
	}
	if o.has_signature {
		res << vproto.pack_bytes_field(o.signature, 2)
	}
	return res
}

pub fn cparental_getsignedparentalsettings_response_unpack(buf []byte) ?CParental_GetSignedParentalSettings_Response {
	mut res := CParental_GetSignedParentalSettings_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serialized_settings = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.serialized_settings = v
				i = ii
			}
			2 {
				res.has_signature = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.signature = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_getsignedparentalsettings_response() CParental_GetSignedParentalSettings_Response {
	return CParental_GetSignedParentalSettings_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_getsignedparentalsettings_response(o CParental_GetSignedParentalSettings_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_getsignedparentalsettings_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_GetSignedParentalSettings_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_getsignedparentalsettings_response_unpack(v)?
	return i, unpacked
}

pub struct CParental_SetParentalSettings_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	password         string
	has_password     bool
	settings         ParentalSettings
	has_settings     bool
	new_password     string
	has_new_password bool
	sessionid        string
	has_sessionid    bool
	steamid          u64
	has_steamid      bool
}

pub fn (o &CParental_SetParentalSettings_Request) pack() []byte {
	mut res := []byte{}
	if o.has_password {
		res << vproto.pack_string_field(o.password, 1)
	}
	if o.has_settings {
		res << zzz_vproto_internal_pack_parentalsettings(o.settings, 2)
	}
	if o.has_new_password {
		res << vproto.pack_string_field(o.new_password, 3)
	}
	if o.has_sessionid {
		res << vproto.pack_string_field(o.sessionid, 4)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 10)
	}
	return res
}

pub fn cparental_setparentalsettings_request_unpack(buf []byte) ?CParental_SetParentalSettings_Request {
	mut res := CParental_SetParentalSettings_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_password = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.password = v
				i = ii
			}
			2 {
				res.has_settings = true
				ii, v := zzz_vproto_internal_unpack_parentalsettings(cur_buf, tag_wiretype.wire_type)?
				res.settings = v
				i = ii
			}
			3 {
				res.has_new_password = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.new_password = v
				i = ii
			}
			4 {
				res.has_sessionid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			10 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_setparentalsettings_request() CParental_SetParentalSettings_Request {
	return CParental_SetParentalSettings_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_setparentalsettings_request(o CParental_SetParentalSettings_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_setparentalsettings_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_SetParentalSettings_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_setparentalsettings_request_unpack(v)?
	return i, unpacked
}

pub struct CParental_SetParentalSettings_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_SetParentalSettings_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_setparentalsettings_response_unpack(buf []byte) ?CParental_SetParentalSettings_Response {
	res := CParental_SetParentalSettings_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_setparentalsettings_response() CParental_SetParentalSettings_Response {
	return CParental_SetParentalSettings_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_setparentalsettings_response(o CParental_SetParentalSettings_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_setparentalsettings_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_SetParentalSettings_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_setparentalsettings_response_unpack(v)?
	return i, unpacked
}

pub struct CParental_ValidateToken_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	unlock_token     string
	has_unlock_token bool
}

pub fn (o &CParental_ValidateToken_Request) pack() []byte {
	mut res := []byte{}
	if o.has_unlock_token {
		res << vproto.pack_string_field(o.unlock_token, 1)
	}
	return res
}

pub fn cparental_validatetoken_request_unpack(buf []byte) ?CParental_ValidateToken_Request {
	mut res := CParental_ValidateToken_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_unlock_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.unlock_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_validatetoken_request() CParental_ValidateToken_Request {
	return CParental_ValidateToken_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_validatetoken_request(o CParental_ValidateToken_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_validatetoken_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ValidateToken_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_validatetoken_request_unpack(v)?
	return i, unpacked
}

pub struct CParental_ValidateToken_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_ValidateToken_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_validatetoken_response_unpack(buf []byte) ?CParental_ValidateToken_Response {
	res := CParental_ValidateToken_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_validatetoken_response() CParental_ValidateToken_Response {
	return CParental_ValidateToken_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_validatetoken_response(o CParental_ValidateToken_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_validatetoken_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ValidateToken_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_validatetoken_response_unpack(v)?
	return i, unpacked
}

pub struct CParental_ValidatePassword_Request {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	password                   string
	has_password               bool
	session                    string
	has_session                bool
	send_unlock_on_success     bool
	has_send_unlock_on_success bool
}

pub fn (o &CParental_ValidatePassword_Request) pack() []byte {
	mut res := []byte{}
	if o.has_password {
		res << vproto.pack_string_field(o.password, 1)
	}
	if o.has_session {
		res << vproto.pack_string_field(o.session, 2)
	}
	if o.has_send_unlock_on_success {
		res << vproto.pack_bool_field(o.send_unlock_on_success, 3)
	}
	return res
}

pub fn cparental_validatepassword_request_unpack(buf []byte) ?CParental_ValidatePassword_Request {
	mut res := CParental_ValidatePassword_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_password = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.password = v
				i = ii
			}
			2 {
				res.has_session = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.session = v
				i = ii
			}
			3 {
				res.has_send_unlock_on_success = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.send_unlock_on_success = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_validatepassword_request() CParental_ValidatePassword_Request {
	return CParental_ValidatePassword_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_validatepassword_request(o CParental_ValidatePassword_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_validatepassword_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ValidatePassword_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_validatepassword_request_unpack(v)?
	return i, unpacked
}

pub struct CParental_ValidatePassword_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	token          string
	has_token      bool
}

pub fn (o &CParental_ValidatePassword_Response) pack() []byte {
	mut res := []byte{}
	if o.has_token {
		res << vproto.pack_string_field(o.token, 1)
	}
	return res
}

pub fn cparental_validatepassword_response_unpack(buf []byte) ?CParental_ValidatePassword_Response {
	mut res := CParental_ValidatePassword_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_validatepassword_response() CParental_ValidatePassword_Response {
	return CParental_ValidatePassword_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_validatepassword_response(o CParental_ValidatePassword_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_validatepassword_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ValidatePassword_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_validatepassword_response_unpack(v)?
	return i, unpacked
}

pub struct CParental_LockClient_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	session        string
	has_session    bool
}

pub fn (o &CParental_LockClient_Request) pack() []byte {
	mut res := []byte{}
	if o.has_session {
		res << vproto.pack_string_field(o.session, 1)
	}
	return res
}

pub fn cparental_lockclient_request_unpack(buf []byte) ?CParental_LockClient_Request {
	mut res := CParental_LockClient_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_session = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.session = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_lockclient_request() CParental_LockClient_Request {
	return CParental_LockClient_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_lockclient_request(o CParental_LockClient_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_lockclient_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_LockClient_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_lockclient_request_unpack(v)?
	return i, unpacked
}

pub struct CParental_LockClient_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_LockClient_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_lockclient_response_unpack(buf []byte) ?CParental_LockClient_Response {
	res := CParental_LockClient_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_lockclient_response() CParental_LockClient_Response {
	return CParental_LockClient_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_lockclient_response(o CParental_LockClient_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_lockclient_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_LockClient_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_lockclient_response_unpack(v)?
	return i, unpacked
}

pub struct CParental_RequestRecoveryCode_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_RequestRecoveryCode_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_requestrecoverycode_request_unpack(buf []byte) ?CParental_RequestRecoveryCode_Request {
	res := CParental_RequestRecoveryCode_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_requestrecoverycode_request() CParental_RequestRecoveryCode_Request {
	return CParental_RequestRecoveryCode_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_requestrecoverycode_request(o CParental_RequestRecoveryCode_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_requestrecoverycode_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_RequestRecoveryCode_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_requestrecoverycode_request_unpack(v)?
	return i, unpacked
}

pub struct CParental_RequestRecoveryCode_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_RequestRecoveryCode_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_requestrecoverycode_response_unpack(buf []byte) ?CParental_RequestRecoveryCode_Response {
	res := CParental_RequestRecoveryCode_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_requestrecoverycode_response() CParental_RequestRecoveryCode_Response {
	return CParental_RequestRecoveryCode_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_requestrecoverycode_response(o CParental_RequestRecoveryCode_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_requestrecoverycode_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_RequestRecoveryCode_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_requestrecoverycode_response_unpack(v)?
	return i, unpacked
}

pub struct CParental_DisableWithRecoveryCode_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	recovery_code     u32
	has_recovery_code bool
	steamid           u64
	has_steamid       bool
}

pub fn (o &CParental_DisableWithRecoveryCode_Request) pack() []byte {
	mut res := []byte{}
	if o.has_recovery_code {
		res << vproto.pack_uint32_field(o.recovery_code, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 10)
	}
	return res
}

pub fn cparental_disablewithrecoverycode_request_unpack(buf []byte) ?CParental_DisableWithRecoveryCode_Request {
	mut res := CParental_DisableWithRecoveryCode_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_recovery_code = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.recovery_code = v
				i = ii
			}
			10 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_disablewithrecoverycode_request() CParental_DisableWithRecoveryCode_Request {
	return CParental_DisableWithRecoveryCode_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_disablewithrecoverycode_request(o CParental_DisableWithRecoveryCode_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_disablewithrecoverycode_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_DisableWithRecoveryCode_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_disablewithrecoverycode_request_unpack(v)?
	return i, unpacked
}

pub struct CParental_DisableWithRecoveryCode_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CParental_DisableWithRecoveryCode_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cparental_disablewithrecoverycode_response_unpack(buf []byte) ?CParental_DisableWithRecoveryCode_Response {
	res := CParental_DisableWithRecoveryCode_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_disablewithrecoverycode_response() CParental_DisableWithRecoveryCode_Response {
	return CParental_DisableWithRecoveryCode_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_disablewithrecoverycode_response(o CParental_DisableWithRecoveryCode_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_disablewithrecoverycode_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_DisableWithRecoveryCode_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_disablewithrecoverycode_response_unpack(v)?
	return i, unpacked
}

pub struct CParental_ParentalSettingsChange_Notification {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	serialized_settings     []byte
	has_serialized_settings bool
	signature               []byte
	has_signature           bool
	password                string
	has_password            bool
	sessionid               string
	has_sessionid           bool
}

pub fn (o &CParental_ParentalSettingsChange_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_serialized_settings {
		res << vproto.pack_bytes_field(o.serialized_settings, 1)
	}
	if o.has_signature {
		res << vproto.pack_bytes_field(o.signature, 2)
	}
	if o.has_password {
		res << vproto.pack_string_field(o.password, 3)
	}
	if o.has_sessionid {
		res << vproto.pack_string_field(o.sessionid, 4)
	}
	return res
}

pub fn cparental_parentalsettingschange_notification_unpack(buf []byte) ?CParental_ParentalSettingsChange_Notification {
	mut res := CParental_ParentalSettingsChange_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serialized_settings = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.serialized_settings = v
				i = ii
			}
			2 {
				res.has_signature = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.signature = v
				i = ii
			}
			3 {
				res.has_password = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.password = v
				i = ii
			}
			4 {
				res.has_sessionid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_parentalsettingschange_notification() CParental_ParentalSettingsChange_Notification {
	return CParental_ParentalSettingsChange_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_parentalsettingschange_notification(o CParental_ParentalSettingsChange_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_parentalsettingschange_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ParentalSettingsChange_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_parentalsettingschange_notification_unpack(v)?
	return i, unpacked
}

pub struct CParental_ParentalUnlock_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	password       string
	has_password   bool
	sessionid      string
	has_sessionid  bool
}

pub fn (o &CParental_ParentalUnlock_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_password {
		res << vproto.pack_string_field(o.password, 1)
	}
	if o.has_sessionid {
		res << vproto.pack_string_field(o.sessionid, 2)
	}
	return res
}

pub fn cparental_parentalunlock_notification_unpack(buf []byte) ?CParental_ParentalUnlock_Notification {
	mut res := CParental_ParentalUnlock_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_password = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.password = v
				i = ii
			}
			2 {
				res.has_sessionid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_parentalunlock_notification() CParental_ParentalUnlock_Notification {
	return CParental_ParentalUnlock_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_parentalunlock_notification(o CParental_ParentalUnlock_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_parentalunlock_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ParentalUnlock_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_parentalunlock_notification_unpack(v)?
	return i, unpacked
}

pub struct CParental_ParentalLock_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessionid      string
	has_sessionid  bool
}

pub fn (o &CParental_ParentalLock_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_sessionid {
		res << vproto.pack_string_field(o.sessionid, 1)
	}
	return res
}

pub fn cparental_parentallock_notification_unpack(buf []byte) ?CParental_ParentalLock_Notification {
	mut res := CParental_ParentalLock_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sessionid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cparental_parentallock_notification() CParental_ParentalLock_Notification {
	return CParental_ParentalLock_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cparental_parentallock_notification(o CParental_ParentalLock_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cparental_parentallock_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CParental_ParentalLock_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cparental_parentallock_notification_unpack(v)?
	return i, unpacked
}
