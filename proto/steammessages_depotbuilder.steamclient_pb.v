// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CContentBuilder_InitDepotBuild_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	appid               u32
	has_appid           bool
	depotid             u32
	has_depotid         bool
	workshop_itemid     u64
	has_workshop_itemid bool
	for_local_cs        bool
	has_for_local_cs    bool
}

pub fn (o &CContentBuilder_InitDepotBuild_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_depotid {
		res << vproto.pack_uint32_field(o.depotid, 2)
	}
	if o.has_workshop_itemid {
		res << vproto.pack_uint64_field(o.workshop_itemid, 3)
	}
	if o.has_for_local_cs {
		res << vproto.pack_bool_field(o.for_local_cs, 4)
	}
	return res
}

pub fn ccontentbuilder_initdepotbuild_request_unpack(buf []byte) ?CContentBuilder_InitDepotBuild_Request {
	mut res := CContentBuilder_InitDepotBuild_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_depotid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depotid = v
				i = ii
			}
			3 {
				res.has_workshop_itemid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.workshop_itemid = v
				i = ii
			}
			4 {
				res.has_for_local_cs = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.for_local_cs = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_initdepotbuild_request() CContentBuilder_InitDepotBuild_Request {
	return CContentBuilder_InitDepotBuild_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_initdepotbuild_request(o CContentBuilder_InitDepotBuild_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_initdepotbuild_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_InitDepotBuild_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_initdepotbuild_request_unpack(v)?
	return i, unpacked
}

pub struct CContentBuilder_InitDepotBuild_Response {
mut:
	unknown_fields                         []vproto.UnknownField
pub mut:
	baseline_manifestid                    u64
	has_baseline_manifestid                bool
	chunk_size                             u32
	has_chunk_size                         bool
	aes_key                                []byte
	has_aes_key                            bool
	rsa_key                                []byte
	has_rsa_key                            bool
	url_host                               string
	has_url_host                           bool
	offset_detection_enabled               bool
	has_offset_detection_enabled           bool
	offset_detection_min_clean_chunk       u32
	has_offset_detection_min_clean_chunk   bool
	offset_detection_blast_radius_pre      u32
	has_offset_detection_blast_radius_pre  bool
	offset_detection_blast_radius_post     u32
	has_offset_detection_blast_radius_post bool
	offset_detection_max_distance_pre      u32
	has_offset_detection_max_distance_pre  bool
	offset_detection_max_distance_post     u32
	has_offset_detection_max_distance_post bool
}

pub fn (o &CContentBuilder_InitDepotBuild_Response) pack() []byte {
	mut res := []byte{}
	if o.has_baseline_manifestid {
		res << vproto.pack_uint64_field(o.baseline_manifestid, 1)
	}
	if o.has_chunk_size {
		res << vproto.pack_uint32_field(o.chunk_size, 2)
	}
	if o.has_aes_key {
		res << vproto.pack_bytes_field(o.aes_key, 3)
	}
	if o.has_rsa_key {
		res << vproto.pack_bytes_field(o.rsa_key, 4)
	}
	if o.has_url_host {
		res << vproto.pack_string_field(o.url_host, 5)
	}
	if o.has_offset_detection_enabled {
		res << vproto.pack_bool_field(o.offset_detection_enabled, 6)
	}
	if o.has_offset_detection_min_clean_chunk {
		res << vproto.pack_uint32_field(o.offset_detection_min_clean_chunk, 7)
	}
	if o.has_offset_detection_blast_radius_pre {
		res << vproto.pack_uint32_field(o.offset_detection_blast_radius_pre, 8)
	}
	if o.has_offset_detection_blast_radius_post {
		res << vproto.pack_uint32_field(o.offset_detection_blast_radius_post, 9)
	}
	if o.has_offset_detection_max_distance_pre {
		res << vproto.pack_uint32_field(o.offset_detection_max_distance_pre, 10)
	}
	if o.has_offset_detection_max_distance_post {
		res << vproto.pack_uint32_field(o.offset_detection_max_distance_post, 11)
	}
	return res
}

pub fn ccontentbuilder_initdepotbuild_response_unpack(buf []byte) ?CContentBuilder_InitDepotBuild_Response {
	mut res := CContentBuilder_InitDepotBuild_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_baseline_manifestid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.baseline_manifestid = v
				i = ii
			}
			2 {
				res.has_chunk_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.chunk_size = v
				i = ii
			}
			3 {
				res.has_aes_key = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.aes_key = v
				i = ii
			}
			4 {
				res.has_rsa_key = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.rsa_key = v
				i = ii
			}
			5 {
				res.has_url_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_host = v
				i = ii
			}
			6 {
				res.has_offset_detection_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.offset_detection_enabled = v
				i = ii
			}
			7 {
				res.has_offset_detection_min_clean_chunk = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.offset_detection_min_clean_chunk = v
				i = ii
			}
			8 {
				res.has_offset_detection_blast_radius_pre = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.offset_detection_blast_radius_pre = v
				i = ii
			}
			9 {
				res.has_offset_detection_blast_radius_post = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.offset_detection_blast_radius_post = v
				i = ii
			}
			10 {
				res.has_offset_detection_max_distance_pre = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.offset_detection_max_distance_pre = v
				i = ii
			}
			11 {
				res.has_offset_detection_max_distance_post = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.offset_detection_max_distance_post = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_initdepotbuild_response() CContentBuilder_InitDepotBuild_Response {
	return CContentBuilder_InitDepotBuild_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_initdepotbuild_response(o CContentBuilder_InitDepotBuild_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_initdepotbuild_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_InitDepotBuild_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_initdepotbuild_response_unpack(v)?
	return i, unpacked
}

pub struct CContentBuilder_StartDepotUpload_Request {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	appid                   u32
	has_appid               bool
	depotid                 u32
	has_depotid             bool
	workshop_itemid         u64
	has_workshop_itemid     bool
	for_local_cs            bool
	has_for_local_cs        bool
	baseline_manifestid     u64
	has_baseline_manifestid bool
	manifest_size           u32
	has_manifest_size       bool
}

pub fn (o &CContentBuilder_StartDepotUpload_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_depotid {
		res << vproto.pack_uint32_field(o.depotid, 2)
	}
	if o.has_workshop_itemid {
		res << vproto.pack_uint64_field(o.workshop_itemid, 3)
	}
	if o.has_for_local_cs {
		res << vproto.pack_bool_field(o.for_local_cs, 4)
	}
	if o.has_baseline_manifestid {
		res << vproto.pack_uint64_field(o.baseline_manifestid, 5)
	}
	if o.has_manifest_size {
		res << vproto.pack_uint32_field(o.manifest_size, 6)
	}
	return res
}

pub fn ccontentbuilder_startdepotupload_request_unpack(buf []byte) ?CContentBuilder_StartDepotUpload_Request {
	mut res := CContentBuilder_StartDepotUpload_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_depotid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depotid = v
				i = ii
			}
			3 {
				res.has_workshop_itemid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.workshop_itemid = v
				i = ii
			}
			4 {
				res.has_for_local_cs = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.for_local_cs = v
				i = ii
			}
			5 {
				res.has_baseline_manifestid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.baseline_manifestid = v
				i = ii
			}
			6 {
				res.has_manifest_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.manifest_size = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_startdepotupload_request() CContentBuilder_StartDepotUpload_Request {
	return CContentBuilder_StartDepotUpload_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_startdepotupload_request(o CContentBuilder_StartDepotUpload_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_startdepotupload_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_StartDepotUpload_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_startdepotupload_request_unpack(v)?
	return i, unpacked
}

pub struct CContentBuilder_StartDepotUpload_Response {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	depot_build_handle     u64
	has_depot_build_handle bool
}

pub fn (o &CContentBuilder_StartDepotUpload_Response) pack() []byte {
	mut res := []byte{}
	if o.has_depot_build_handle {
		res << vproto.pack_uint64_field(o.depot_build_handle, 1)
	}
	return res
}

pub fn ccontentbuilder_startdepotupload_response_unpack(buf []byte) ?CContentBuilder_StartDepotUpload_Response {
	mut res := CContentBuilder_StartDepotUpload_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_depot_build_handle = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.depot_build_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_startdepotupload_response() CContentBuilder_StartDepotUpload_Response {
	return CContentBuilder_StartDepotUpload_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_startdepotupload_response(o CContentBuilder_StartDepotUpload_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_startdepotupload_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_StartDepotUpload_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_startdepotupload_response_unpack(v)?
	return i, unpacked
}

pub struct CContentBuilder_GetMissingDepotChunks_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	appid                  u32
	has_appid              bool
	depot_build_handle     u64
	has_depot_build_handle bool
}

pub fn (o &CContentBuilder_GetMissingDepotChunks_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_depot_build_handle {
		res << vproto.pack_uint64_field(o.depot_build_handle, 2)
	}
	return res
}

pub fn ccontentbuilder_getmissingdepotchunks_request_unpack(buf []byte) ?CContentBuilder_GetMissingDepotChunks_Request {
	mut res := CContentBuilder_GetMissingDepotChunks_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_depot_build_handle = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.depot_build_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_getmissingdepotchunks_request() CContentBuilder_GetMissingDepotChunks_Request {
	return CContentBuilder_GetMissingDepotChunks_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_getmissingdepotchunks_request(o CContentBuilder_GetMissingDepotChunks_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_getmissingdepotchunks_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_GetMissingDepotChunks_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_getmissingdepotchunks_request_unpack(v)?
	return i, unpacked
}

pub struct CContentBuilder_GetMissingDepotChunks_Response_Chunks {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sha            []byte
	has_sha        bool
}

pub fn (o &CContentBuilder_GetMissingDepotChunks_Response_Chunks) pack() []byte {
	mut res := []byte{}
	if o.has_sha {
		res << vproto.pack_bytes_field(o.sha, 1)
	}
	return res
}

pub fn ccontentbuilder_getmissingdepotchunks_response_chunks_unpack(buf []byte) ?CContentBuilder_GetMissingDepotChunks_Response_Chunks {
	mut res := CContentBuilder_GetMissingDepotChunks_Response_Chunks{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_getmissingdepotchunks_response_chunks() CContentBuilder_GetMissingDepotChunks_Response_Chunks {
	return CContentBuilder_GetMissingDepotChunks_Response_Chunks{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_getmissingdepotchunks_response_chunks(o CContentBuilder_GetMissingDepotChunks_Response_Chunks, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_getmissingdepotchunks_response_chunks(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_GetMissingDepotChunks_Response_Chunks) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_getmissingdepotchunks_response_chunks_unpack(v)?
	return i, unpacked
}

pub struct CContentBuilder_GetMissingDepotChunks_Response {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	missing_chunks           []CContentBuilder_GetMissingDepotChunks_Response_Chunks
	total_missing_chunks     u32
	has_total_missing_chunks bool
	total_missing_bytes      u64
	has_total_missing_bytes  bool
}

pub fn (o &CContentBuilder_GetMissingDepotChunks_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.missing_chunks {
		res << zzz_vproto_internal_pack_ccontentbuilder_getmissingdepotchunks_response_chunks(x, 1)
	}
	if o.has_total_missing_chunks {
		res << vproto.pack_uint32_field(o.total_missing_chunks, 2)
	}
	if o.has_total_missing_bytes {
		res << vproto.pack_uint64_field(o.total_missing_bytes, 3)
	}
	return res
}

pub fn ccontentbuilder_getmissingdepotchunks_response_unpack(buf []byte) ?CContentBuilder_GetMissingDepotChunks_Response {
	mut res := CContentBuilder_GetMissingDepotChunks_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccontentbuilder_getmissingdepotchunks_response_chunks(cur_buf,
					tag_wiretype.wire_type)?
				res.missing_chunks << v
				i = ii
			}
			2 {
				res.has_total_missing_chunks = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_missing_chunks = v
				i = ii
			}
			3 {
				res.has_total_missing_bytes = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.total_missing_bytes = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_getmissingdepotchunks_response() CContentBuilder_GetMissingDepotChunks_Response {
	return CContentBuilder_GetMissingDepotChunks_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_getmissingdepotchunks_response(o CContentBuilder_GetMissingDepotChunks_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_getmissingdepotchunks_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_GetMissingDepotChunks_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_getmissingdepotchunks_response_unpack(v)?
	return i, unpacked
}

pub struct CContentBuilder_FinishDepotUpload_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	appid                  u32
	has_appid              bool
	depot_build_handle     u64
	has_depot_build_handle bool
}

pub fn (o &CContentBuilder_FinishDepotUpload_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_depot_build_handle {
		res << vproto.pack_uint64_field(o.depot_build_handle, 2)
	}
	return res
}

pub fn ccontentbuilder_finishdepotupload_request_unpack(buf []byte) ?CContentBuilder_FinishDepotUpload_Request {
	mut res := CContentBuilder_FinishDepotUpload_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_depot_build_handle = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.depot_build_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_finishdepotupload_request() CContentBuilder_FinishDepotUpload_Request {
	return CContentBuilder_FinishDepotUpload_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_finishdepotupload_request(o CContentBuilder_FinishDepotUpload_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_finishdepotupload_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_FinishDepotUpload_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_finishdepotupload_request_unpack(v)?
	return i, unpacked
}

pub struct CContentBuilder_FinishDepotUpload_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	manifestid      u64
	has_manifestid  bool
	prev_reused     bool
	has_prev_reused bool
}

pub fn (o &CContentBuilder_FinishDepotUpload_Response) pack() []byte {
	mut res := []byte{}
	if o.has_manifestid {
		res << vproto.pack_uint64_field(o.manifestid, 1)
	}
	if o.has_prev_reused {
		res << vproto.pack_bool_field(o.prev_reused, 2)
	}
	return res
}

pub fn ccontentbuilder_finishdepotupload_response_unpack(buf []byte) ?CContentBuilder_FinishDepotUpload_Response {
	mut res := CContentBuilder_FinishDepotUpload_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_manifestid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.manifestid = v
				i = ii
			}
			2 {
				res.has_prev_reused = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.prev_reused = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_finishdepotupload_response() CContentBuilder_FinishDepotUpload_Response {
	return CContentBuilder_FinishDepotUpload_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_finishdepotupload_response(o CContentBuilder_FinishDepotUpload_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_finishdepotupload_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_FinishDepotUpload_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_finishdepotupload_response_unpack(v)?
	return i, unpacked
}

pub struct CContentBuilder_CommitAppBuild_Request_Depots {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	depotid        u32
	has_depotid    bool
	manifestid     u64
	has_manifestid bool
}

pub fn (o &CContentBuilder_CommitAppBuild_Request_Depots) pack() []byte {
	mut res := []byte{}
	if o.has_depotid {
		res << vproto.pack_uint32_field(o.depotid, 1)
	}
	if o.has_manifestid {
		res << vproto.pack_uint64_field(o.manifestid, 2)
	}
	return res
}

pub fn ccontentbuilder_commitappbuild_request_depots_unpack(buf []byte) ?CContentBuilder_CommitAppBuild_Request_Depots {
	mut res := CContentBuilder_CommitAppBuild_Request_Depots{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_depotid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depotid = v
				i = ii
			}
			2 {
				res.has_manifestid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.manifestid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_commitappbuild_request_depots() CContentBuilder_CommitAppBuild_Request_Depots {
	return CContentBuilder_CommitAppBuild_Request_Depots{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_commitappbuild_request_depots(o CContentBuilder_CommitAppBuild_Request_Depots, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_commitappbuild_request_depots(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_CommitAppBuild_Request_Depots) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_commitappbuild_request_depots_unpack(v)?
	return i, unpacked
}

pub struct CContentBuilder_CommitAppBuild_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	appid           u32
	has_appid       bool
	depot_manifests []CContentBuilder_CommitAppBuild_Request_Depots
	build_notes     string
	has_build_notes bool
	live_branch     string
	has_live_branch bool
}

pub fn (o &CContentBuilder_CommitAppBuild_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.depot_manifests {
		res << zzz_vproto_internal_pack_ccontentbuilder_commitappbuild_request_depots(x, 2)
	}
	if o.has_build_notes {
		res << vproto.pack_string_field(o.build_notes, 4)
	}
	if o.has_live_branch {
		res << vproto.pack_string_field(o.live_branch, 5)
	}
	return res
}

pub fn ccontentbuilder_commitappbuild_request_unpack(buf []byte) ?CContentBuilder_CommitAppBuild_Request {
	mut res := CContentBuilder_CommitAppBuild_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccontentbuilder_commitappbuild_request_depots(cur_buf,
					tag_wiretype.wire_type)?
				res.depot_manifests << v
				i = ii
			}
			4 {
				res.has_build_notes = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.build_notes = v
				i = ii
			}
			5 {
				res.has_live_branch = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.live_branch = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_commitappbuild_request() CContentBuilder_CommitAppBuild_Request {
	return CContentBuilder_CommitAppBuild_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_commitappbuild_request(o CContentBuilder_CommitAppBuild_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_commitappbuild_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_CommitAppBuild_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_commitappbuild_request_unpack(v)?
	return i, unpacked
}

pub struct CContentBuilder_CommitAppBuild_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	buildid        u32
	has_buildid    bool
}

pub fn (o &CContentBuilder_CommitAppBuild_Response) pack() []byte {
	mut res := []byte{}
	if o.has_buildid {
		res << vproto.pack_uint32_field(o.buildid, 1)
	}
	return res
}

pub fn ccontentbuilder_commitappbuild_response_unpack(buf []byte) ?CContentBuilder_CommitAppBuild_Response {
	mut res := CContentBuilder_CommitAppBuild_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_buildid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.buildid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_commitappbuild_response() CContentBuilder_CommitAppBuild_Response {
	return CContentBuilder_CommitAppBuild_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_commitappbuild_response(o CContentBuilder_CommitAppBuild_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_commitappbuild_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_CommitAppBuild_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_commitappbuild_response_unpack(v)?
	return i, unpacked
}

pub struct CContentBuilder_SignInstallScript_Request {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	appid              u32
	has_appid          bool
	depotid            u32
	has_depotid        bool
	install_script     string
	has_install_script bool
}

pub fn (o &CContentBuilder_SignInstallScript_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_depotid {
		res << vproto.pack_uint32_field(o.depotid, 2)
	}
	if o.has_install_script {
		res << vproto.pack_string_field(o.install_script, 3)
	}
	return res
}

pub fn ccontentbuilder_signinstallscript_request_unpack(buf []byte) ?CContentBuilder_SignInstallScript_Request {
	mut res := CContentBuilder_SignInstallScript_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_depotid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depotid = v
				i = ii
			}
			3 {
				res.has_install_script = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.install_script = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_signinstallscript_request() CContentBuilder_SignInstallScript_Request {
	return CContentBuilder_SignInstallScript_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_signinstallscript_request(o CContentBuilder_SignInstallScript_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_signinstallscript_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_SignInstallScript_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_signinstallscript_request_unpack(v)?
	return i, unpacked
}

pub struct CContentBuilder_SignInstallScript_Response {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	signed_install_script     string
	has_signed_install_script bool
}

pub fn (o &CContentBuilder_SignInstallScript_Response) pack() []byte {
	mut res := []byte{}
	if o.has_signed_install_script {
		res << vproto.pack_string_field(o.signed_install_script, 1)
	}
	return res
}

pub fn ccontentbuilder_signinstallscript_response_unpack(buf []byte) ?CContentBuilder_SignInstallScript_Response {
	mut res := CContentBuilder_SignInstallScript_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_signed_install_script = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.signed_install_script = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentbuilder_signinstallscript_response() CContentBuilder_SignInstallScript_Response {
	return CContentBuilder_SignInstallScript_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentbuilder_signinstallscript_response(o CContentBuilder_SignInstallScript_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentbuilder_signinstallscript_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentBuilder_SignInstallScript_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentbuilder_signinstallscript_response_unpack(v)?
	return i, unpacked
}
