// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct SiteServerUI_Login_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	username              string
	has_username          bool
	password              string
	has_password          bool
	steamguardcode        string
	has_steamguardcode    bool
	remember_password     bool
	has_remember_password bool
}

pub fn (o &SiteServerUI_Login_Request) pack() []byte {
	mut res := []byte{}
	if o.has_username {
		res << vproto.pack_string_field(o.username, 1)
	}
	if o.has_password {
		res << vproto.pack_string_field(o.password, 2)
	}
	if o.has_steamguardcode {
		res << vproto.pack_string_field(o.steamguardcode, 3)
	}
	if o.has_remember_password {
		res << vproto.pack_bool_field(o.remember_password, 4)
	}
	return res
}

pub fn siteserverui_login_request_unpack(buf []byte) ?SiteServerUI_Login_Request {
	mut res := SiteServerUI_Login_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_username = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.username = v
				i = ii
			}
			2 {
				res.has_password = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.password = v
				i = ii
			}
			3 {
				res.has_steamguardcode = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.steamguardcode = v
				i = ii
			}
			4 {
				res.has_remember_password = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.remember_password = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_login_request() SiteServerUI_Login_Request {
	return SiteServerUI_Login_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_login_request(o SiteServerUI_Login_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_login_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Login_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_login_request_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_Login_Response {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	logon_state       int
	has_logon_state   bool
	logon_eresult     int
	has_logon_eresult bool
}

pub fn (o &SiteServerUI_Login_Response) pack() []byte {
	mut res := []byte{}
	if o.has_logon_state {
		res << vproto.pack_int32_field(o.logon_state, 1)
	}
	if o.has_logon_eresult {
		res << vproto.pack_int32_field(o.logon_eresult, 2)
	}
	return res
}

pub fn siteserverui_login_response_unpack(buf []byte) ?SiteServerUI_Login_Response {
	mut res := SiteServerUI_Login_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_logon_state = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_state = v
				i = ii
			}
			2 {
				res.has_logon_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_login_response() SiteServerUI_Login_Response {
	return SiteServerUI_Login_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_login_response(o SiteServerUI_Login_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_login_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Login_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_login_response_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_LoginStatus_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_LoginStatus_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_loginstatus_request_unpack(buf []byte) ?SiteServerUI_LoginStatus_Request {
	res := SiteServerUI_LoginStatus_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_loginstatus_request() SiteServerUI_LoginStatus_Request {
	return SiteServerUI_LoginStatus_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_loginstatus_request(o SiteServerUI_LoginStatus_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_loginstatus_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_LoginStatus_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_loginstatus_request_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_LoginStatus_Response {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	username               string
	has_username           bool
	cached_credentials     bool
	has_cached_credentials bool
	logon_state            int
	has_logon_state        bool
	logon_eresult          int
	has_logon_eresult      bool
}

pub fn (o &SiteServerUI_LoginStatus_Response) pack() []byte {
	mut res := []byte{}
	if o.has_username {
		res << vproto.pack_string_field(o.username, 1)
	}
	if o.has_cached_credentials {
		res << vproto.pack_bool_field(o.cached_credentials, 2)
	}
	if o.has_logon_state {
		res << vproto.pack_int32_field(o.logon_state, 3)
	}
	if o.has_logon_eresult {
		res << vproto.pack_int32_field(o.logon_eresult, 4)
	}
	return res
}

pub fn siteserverui_loginstatus_response_unpack(buf []byte) ?SiteServerUI_LoginStatus_Response {
	mut res := SiteServerUI_LoginStatus_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_username = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.username = v
				i = ii
			}
			2 {
				res.has_cached_credentials = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.cached_credentials = v
				i = ii
			}
			3 {
				res.has_logon_state = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_state = v
				i = ii
			}
			4 {
				res.has_logon_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_loginstatus_response() SiteServerUI_LoginStatus_Response {
	return SiteServerUI_LoginStatus_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_loginstatus_response(o SiteServerUI_LoginStatus_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_loginstatus_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_LoginStatus_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_loginstatus_response_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_CancelLogin_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_CancelLogin_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_cancellogin_request_unpack(buf []byte) ?SiteServerUI_CancelLogin_Request {
	res := SiteServerUI_CancelLogin_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_cancellogin_request() SiteServerUI_CancelLogin_Request {
	return SiteServerUI_CancelLogin_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_cancellogin_request(o SiteServerUI_CancelLogin_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_cancellogin_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_CancelLogin_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_cancellogin_request_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_CancelLogin_Response {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	logon_state       int
	has_logon_state   bool
	logon_eresult     int
	has_logon_eresult bool
}

pub fn (o &SiteServerUI_CancelLogin_Response) pack() []byte {
	mut res := []byte{}
	if o.has_logon_state {
		res << vproto.pack_int32_field(o.logon_state, 1)
	}
	if o.has_logon_eresult {
		res << vproto.pack_int32_field(o.logon_eresult, 2)
	}
	return res
}

pub fn siteserverui_cancellogin_response_unpack(buf []byte) ?SiteServerUI_CancelLogin_Response {
	mut res := SiteServerUI_CancelLogin_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_logon_state = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_state = v
				i = ii
			}
			2 {
				res.has_logon_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_cancellogin_response() SiteServerUI_CancelLogin_Response {
	return SiteServerUI_CancelLogin_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_cancellogin_response(o SiteServerUI_CancelLogin_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_cancellogin_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_CancelLogin_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_cancellogin_response_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_Logout_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_Logout_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_logout_request_unpack(buf []byte) ?SiteServerUI_Logout_Request {
	res := SiteServerUI_Logout_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_logout_request() SiteServerUI_Logout_Request {
	return SiteServerUI_Logout_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_logout_request(o SiteServerUI_Logout_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_logout_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Logout_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_logout_request_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_Logout_Response {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	logon_state        int
	has_logon_state    bool
	logout_eresult     int
	has_logout_eresult bool
}

pub fn (o &SiteServerUI_Logout_Response) pack() []byte {
	mut res := []byte{}
	if o.has_logon_state {
		res << vproto.pack_int32_field(o.logon_state, 1)
	}
	if o.has_logout_eresult {
		res << vproto.pack_int32_field(o.logout_eresult, 2)
	}
	return res
}

pub fn siteserverui_logout_response_unpack(buf []byte) ?SiteServerUI_Logout_Response {
	mut res := SiteServerUI_Logout_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_logon_state = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_state = v
				i = ii
			}
			2 {
				res.has_logout_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logout_eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_logout_response() SiteServerUI_Logout_Response {
	return SiteServerUI_Logout_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_logout_response(o SiteServerUI_Logout_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_logout_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Logout_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_logout_response_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_Quit_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	restart        bool
	has_restart    bool
}

pub fn (o &SiteServerUI_Quit_Request) pack() []byte {
	mut res := []byte{}
	if o.has_restart {
		res << vproto.pack_bool_field(o.restart, 1)
	}
	return res
}

pub fn siteserverui_quit_request_unpack(buf []byte) ?SiteServerUI_Quit_Request {
	mut res := SiteServerUI_Quit_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_restart = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.restart = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_quit_request() SiteServerUI_Quit_Request {
	return SiteServerUI_Quit_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_quit_request(o SiteServerUI_Quit_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_quit_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Quit_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_quit_request_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_Quit_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_Quit_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_quit_response_unpack(buf []byte) ?SiteServerUI_Quit_Response {
	res := SiteServerUI_Quit_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_quit_response() SiteServerUI_Quit_Response {
	return SiteServerUI_Quit_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_quit_response(o SiteServerUI_Quit_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_quit_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Quit_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_quit_response_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_Status_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_Status_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_status_request_unpack(buf []byte) ?SiteServerUI_Status_Request {
	res := SiteServerUI_Status_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_status_request() SiteServerUI_Status_Request {
	return SiteServerUI_Status_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_status_request(o SiteServerUI_Status_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_status_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Status_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_status_request_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_Status_Response {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	logon_state       int
	has_logon_state   bool
	logon_eresult     int
	has_logon_eresult bool
	connected         bool
	has_connected     bool
	cache_enabled     bool
	has_cache_enabled bool
	acct_status       int
	has_acct_status   bool
}

pub fn (o &SiteServerUI_Status_Response) pack() []byte {
	mut res := []byte{}
	if o.has_logon_state {
		res << vproto.pack_int32_field(o.logon_state, 1)
	}
	if o.has_logon_eresult {
		res << vproto.pack_int32_field(o.logon_eresult, 2)
	}
	if o.has_connected {
		res << vproto.pack_bool_field(o.connected, 3)
	}
	if o.has_cache_enabled {
		res << vproto.pack_bool_field(o.cache_enabled, 4)
	}
	if o.has_acct_status {
		res << vproto.pack_int32_field(o.acct_status, 5)
	}
	return res
}

pub fn siteserverui_status_response_unpack(buf []byte) ?SiteServerUI_Status_Response {
	mut res := SiteServerUI_Status_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_logon_state = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_state = v
				i = ii
			}
			2 {
				res.has_logon_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_eresult = v
				i = ii
			}
			3 {
				res.has_connected = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.connected = v
				i = ii
			}
			4 {
				res.has_cache_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_enabled = v
				i = ii
			}
			5 {
				res.has_acct_status = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.acct_status = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_status_response() SiteServerUI_Status_Response {
	return SiteServerUI_Status_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_status_response(o SiteServerUI_Status_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_status_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_Status_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_status_response_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_GetLanguage_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_GetLanguage_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_getlanguage_request_unpack(buf []byte) ?SiteServerUI_GetLanguage_Request {
	res := SiteServerUI_GetLanguage_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_getlanguage_request() SiteServerUI_GetLanguage_Request {
	return SiteServerUI_GetLanguage_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_getlanguage_request(o SiteServerUI_GetLanguage_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_getlanguage_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_GetLanguage_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_getlanguage_request_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_GetLanguage_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	language       string
	has_language   bool
}

pub fn (o &SiteServerUI_GetLanguage_Response) pack() []byte {
	mut res := []byte{}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 1)
	}
	return res
}

pub fn siteserverui_getlanguage_response_unpack(buf []byte) ?SiteServerUI_GetLanguage_Response {
	mut res := SiteServerUI_GetLanguage_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_getlanguage_response() SiteServerUI_GetLanguage_Response {
	return SiteServerUI_GetLanguage_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_getlanguage_response(o SiteServerUI_GetLanguage_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_getlanguage_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_GetLanguage_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_getlanguage_response_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_SetLanguage_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	language       string
	has_language   bool
}

pub fn (o &SiteServerUI_SetLanguage_Request) pack() []byte {
	mut res := []byte{}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 1)
	}
	return res
}

pub fn siteserverui_setlanguage_request_unpack(buf []byte) ?SiteServerUI_SetLanguage_Request {
	mut res := SiteServerUI_SetLanguage_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_setlanguage_request() SiteServerUI_SetLanguage_Request {
	return SiteServerUI_SetLanguage_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_setlanguage_request(o SiteServerUI_SetLanguage_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_setlanguage_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_SetLanguage_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_setlanguage_request_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_SetLanguage_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_SetLanguage_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_setlanguage_response_unpack(buf []byte) ?SiteServerUI_SetLanguage_Response {
	res := SiteServerUI_SetLanguage_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_setlanguage_response() SiteServerUI_SetLanguage_Response {
	return SiteServerUI_SetLanguage_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_setlanguage_response(o SiteServerUI_SetLanguage_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_setlanguage_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_SetLanguage_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_setlanguage_response_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_ClientStatus_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_ClientStatus_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_clientstatus_request_unpack(buf []byte) ?SiteServerUI_ClientStatus_Request {
	res := SiteServerUI_ClientStatus_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_clientstatus_request() SiteServerUI_ClientStatus_Request {
	return SiteServerUI_ClientStatus_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_clientstatus_request(o SiteServerUI_ClientStatus_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_clientstatus_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ClientStatus_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_clientstatus_request_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_ClientStatus_Response_ClientInfo {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	ip              u32
	has_ip          bool
	hostname        string
	has_hostname    bool
	connected       bool
	has_connected   bool
	instance_id     u64
	has_instance_id bool
}

pub fn (o &SiteServerUI_ClientStatus_Response_ClientInfo) pack() []byte {
	mut res := []byte{}
	if o.has_ip {
		res << vproto.pack_uint32_field(o.ip, 1)
	}
	if o.has_hostname {
		res << vproto.pack_string_field(o.hostname, 2)
	}
	if o.has_connected {
		res << vproto.pack_bool_field(o.connected, 3)
	}
	if o.has_instance_id {
		res << vproto.pack_uint64_field(o.instance_id, 4)
	}
	return res
}

pub fn siteserverui_clientstatus_response_clientinfo_unpack(buf []byte) ?SiteServerUI_ClientStatus_Response_ClientInfo {
	mut res := SiteServerUI_ClientStatus_Response_ClientInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ip = v
				i = ii
			}
			2 {
				res.has_hostname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.hostname = v
				i = ii
			}
			3 {
				res.has_connected = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.connected = v
				i = ii
			}
			4 {
				res.has_instance_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.instance_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_clientstatus_response_clientinfo() SiteServerUI_ClientStatus_Response_ClientInfo {
	return SiteServerUI_ClientStatus_Response_ClientInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_clientstatus_response_clientinfo(o SiteServerUI_ClientStatus_Response_ClientInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_clientstatus_response_clientinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ClientStatus_Response_ClientInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_clientstatus_response_clientinfo_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_ClientStatus_Response_Payment {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	transid             u64
	has_transid         bool
	steamid             u64
	has_steamid         bool
	amount              string
	has_amount          bool
	time_created        int
	has_time_created    bool
	purchase_status     int
	has_purchase_status bool
	hostname            string
	has_hostname        bool
	persona_name        string
	has_persona_name    bool
	profile_url         string
	has_profile_url     bool
	avatar_url          string
	has_avatar_url      bool
}

pub fn (o &SiteServerUI_ClientStatus_Response_Payment) pack() []byte {
	mut res := []byte{}
	if o.has_transid {
		res << vproto.pack_uint64_field(o.transid, 1)
	}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 2)
	}
	if o.has_amount {
		res << vproto.pack_string_field(o.amount, 3)
	}
	if o.has_time_created {
		res << vproto.pack_int32_field(o.time_created, 4)
	}
	if o.has_purchase_status {
		res << vproto.pack_int32_field(o.purchase_status, 5)
	}
	if o.has_hostname {
		res << vproto.pack_string_field(o.hostname, 6)
	}
	if o.has_persona_name {
		res << vproto.pack_string_field(o.persona_name, 7)
	}
	if o.has_profile_url {
		res << vproto.pack_string_field(o.profile_url, 8)
	}
	if o.has_avatar_url {
		res << vproto.pack_string_field(o.avatar_url, 9)
	}
	return res
}

pub fn siteserverui_clientstatus_response_payment_unpack(buf []byte) ?SiteServerUI_ClientStatus_Response_Payment {
	mut res := SiteServerUI_ClientStatus_Response_Payment{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_transid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.transid = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_amount = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.amount = v
				i = ii
			}
			4 {
				res.has_time_created = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			5 {
				res.has_purchase_status = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.purchase_status = v
				i = ii
			}
			6 {
				res.has_hostname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.hostname = v
				i = ii
			}
			7 {
				res.has_persona_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_name = v
				i = ii
			}
			8 {
				res.has_profile_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.profile_url = v
				i = ii
			}
			9 {
				res.has_avatar_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.avatar_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_clientstatus_response_payment() SiteServerUI_ClientStatus_Response_Payment {
	return SiteServerUI_ClientStatus_Response_Payment{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_clientstatus_response_payment(o SiteServerUI_ClientStatus_Response_Payment, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_clientstatus_response_payment(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ClientStatus_Response_Payment) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_clientstatus_response_payment_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_ClientStatus_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	clients        []SiteServerUI_ClientStatus_Response_ClientInfo
	payments       []SiteServerUI_ClientStatus_Response_Payment
}

pub fn (o &SiteServerUI_ClientStatus_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.clients {
		res << zzz_vproto_internal_pack_siteserverui_clientstatus_response_clientinfo(x, 4)
	}
	// [packed=false]
	for _, x in o.payments {
		res << zzz_vproto_internal_pack_siteserverui_clientstatus_response_payment(x, 5)
	}
	return res
}

pub fn siteserverui_clientstatus_response_unpack(buf []byte) ?SiteServerUI_ClientStatus_Response {
	mut res := SiteServerUI_ClientStatus_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_siteserverui_clientstatus_response_clientinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.clients << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_siteserverui_clientstatus_response_payment(cur_buf,
					tag_wiretype.wire_type)?
				res.payments << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_clientstatus_response() SiteServerUI_ClientStatus_Response {
	return SiteServerUI_ClientStatus_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_clientstatus_response(o SiteServerUI_ClientStatus_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_clientstatus_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ClientStatus_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_clientstatus_response_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_ContentCacheStatus_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_ContentCacheStatus_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_contentcachestatus_request_unpack(buf []byte) ?SiteServerUI_ContentCacheStatus_Request {
	res := SiteServerUI_ContentCacheStatus_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_contentcachestatus_request() SiteServerUI_ContentCacheStatus_Request {
	return SiteServerUI_ContentCacheStatus_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_contentcachestatus_request(o SiteServerUI_ContentCacheStatus_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_contentcachestatus_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ContentCacheStatus_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_contentcachestatus_request_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_ContentCacheStatus_Response {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	enabled                 bool
	has_enabled             bool
	port                    u32
	has_port                bool
	cache_location          string
	has_cache_location      bool
	max_size_gb             u32
	has_max_size_gb         bool
	p2p_enabled             bool
	has_p2p_enabled         bool
	explicit_ip_address     string
	has_explicit_ip_address bool
	external_process        bool
	has_external_process    bool
	current_size_gb         u32
	has_current_size_gb     bool
	current_bw              u64
	has_current_bw          bool
	total_bytes_served      u64
	has_total_bytes_served  bool
}

pub fn (o &SiteServerUI_ContentCacheStatus_Response) pack() []byte {
	mut res := []byte{}
	if o.has_enabled {
		res << vproto.pack_bool_field(o.enabled, 1)
	}
	if o.has_port {
		res << vproto.pack_uint32_field(o.port, 2)
	}
	if o.has_cache_location {
		res << vproto.pack_string_field(o.cache_location, 3)
	}
	if o.has_max_size_gb {
		res << vproto.pack_uint32_field(o.max_size_gb, 4)
	}
	if o.has_p2p_enabled {
		res << vproto.pack_bool_field(o.p2p_enabled, 5)
	}
	if o.has_explicit_ip_address {
		res << vproto.pack_string_field(o.explicit_ip_address, 9)
	}
	if o.has_external_process {
		res << vproto.pack_bool_field(o.external_process, 10)
	}
	if o.has_current_size_gb {
		res << vproto.pack_uint32_field(o.current_size_gb, 6)
	}
	if o.has_current_bw {
		res << vproto.pack_uint64_field(o.current_bw, 7)
	}
	if o.has_total_bytes_served {
		res << vproto.pack_uint64_field(o.total_bytes_served, 8)
	}
	return res
}

pub fn siteserverui_contentcachestatus_response_unpack(buf []byte) ?SiteServerUI_ContentCacheStatus_Response {
	mut res := SiteServerUI_ContentCacheStatus_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enabled = v
				i = ii
			}
			2 {
				res.has_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.port = v
				i = ii
			}
			3 {
				res.has_cache_location = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_location = v
				i = ii
			}
			4 {
				res.has_max_size_gb = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_size_gb = v
				i = ii
			}
			5 {
				res.has_p2p_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.p2p_enabled = v
				i = ii
			}
			9 {
				res.has_explicit_ip_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.explicit_ip_address = v
				i = ii
			}
			10 {
				res.has_external_process = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.external_process = v
				i = ii
			}
			6 {
				res.has_current_size_gb = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.current_size_gb = v
				i = ii
			}
			7 {
				res.has_current_bw = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.current_bw = v
				i = ii
			}
			8 {
				res.has_total_bytes_served = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.total_bytes_served = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_contentcachestatus_response() SiteServerUI_ContentCacheStatus_Response {
	return SiteServerUI_ContentCacheStatus_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_contentcachestatus_response(o SiteServerUI_ContentCacheStatus_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_contentcachestatus_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ContentCacheStatus_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_contentcachestatus_response_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_ContentCacheConfig_Request {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	enabled                 bool
	has_enabled             bool
	port                    u32
	has_port                bool
	cache_location          string
	has_cache_location      bool
	max_size_gb             u32
	has_max_size_gb         bool
	p2p_enabled             bool
	has_p2p_enabled         bool
	external_process        bool
	has_external_process    bool
	explicit_ip_address     string
	has_explicit_ip_address bool
}

pub fn (o &SiteServerUI_ContentCacheConfig_Request) pack() []byte {
	mut res := []byte{}
	if o.has_enabled {
		res << vproto.pack_bool_field(o.enabled, 1)
	}
	if o.has_port {
		res << vproto.pack_uint32_field(o.port, 2)
	}
	if o.has_cache_location {
		res << vproto.pack_string_field(o.cache_location, 3)
	}
	if o.has_max_size_gb {
		res << vproto.pack_uint32_field(o.max_size_gb, 4)
	}
	if o.has_p2p_enabled {
		res << vproto.pack_bool_field(o.p2p_enabled, 5)
	}
	if o.has_external_process {
		res << vproto.pack_bool_field(o.external_process, 6)
	}
	if o.has_explicit_ip_address {
		res << vproto.pack_string_field(o.explicit_ip_address, 7)
	}
	return res
}

pub fn siteserverui_contentcacheconfig_request_unpack(buf []byte) ?SiteServerUI_ContentCacheConfig_Request {
	mut res := SiteServerUI_ContentCacheConfig_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enabled = v
				i = ii
			}
			2 {
				res.has_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.port = v
				i = ii
			}
			3 {
				res.has_cache_location = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_location = v
				i = ii
			}
			4 {
				res.has_max_size_gb = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_size_gb = v
				i = ii
			}
			5 {
				res.has_p2p_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.p2p_enabled = v
				i = ii
			}
			6 {
				res.has_external_process = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.external_process = v
				i = ii
			}
			7 {
				res.has_explicit_ip_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.explicit_ip_address = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_contentcacheconfig_request() SiteServerUI_ContentCacheConfig_Request {
	return SiteServerUI_ContentCacheConfig_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_contentcacheconfig_request(o SiteServerUI_ContentCacheConfig_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_contentcacheconfig_request(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ContentCacheConfig_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_contentcacheconfig_request_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUI_ContentCacheConfig_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUI_ContentCacheConfig_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserverui_contentcacheconfig_response_unpack(buf []byte) ?SiteServerUI_ContentCacheConfig_Response {
	res := SiteServerUI_ContentCacheConfig_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserverui_contentcacheconfig_response() SiteServerUI_ContentCacheConfig_Response {
	return SiteServerUI_ContentCacheConfig_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserverui_contentcacheconfig_response(o SiteServerUI_ContentCacheConfig_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserverui_contentcacheconfig_response(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUI_ContentCacheConfig_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserverui_contentcacheconfig_response_unpack(v)?
	return i, unpacked
}
