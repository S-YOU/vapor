// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct SiteServerUIloginRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	username              string
	has_username          bool
	password              string
	has_password          bool
	steamguardcode        string
	has_steamguardcode    bool
	remember_password     bool
	has_remember_password bool
}

pub fn (o &SiteServerUIloginRequest) pack() []byte {
	mut res := []byte{}
	if o.has_username {
		res << vproto.pack_string_field(o.username, 1)
	}
	if o.has_password {
		res << vproto.pack_string_field(o.password, 2)
	}
	if o.has_steamguardcode {
		res << vproto.pack_string_field(o.steamguardcode, 3)
	}
	if o.has_remember_password {
		res << vproto.pack_bool_field(o.remember_password, 4)
	}
	return res
}

pub fn siteserveruiloginrequest_unpack(buf []byte) ?SiteServerUIloginRequest {
	mut res := SiteServerUIloginRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_username = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.username = v
				i = ii
			}
			2 {
				res.has_password = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.password = v
				i = ii
			}
			3 {
				res.has_steamguardcode = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.steamguardcode = v
				i = ii
			}
			4 {
				res.has_remember_password = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.remember_password = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruiloginrequest() SiteServerUIloginRequest {
	return SiteServerUIloginRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruiloginrequest(o SiteServerUIloginRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruiloginrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIloginRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruiloginrequest_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIloginResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	logon_state       int
	has_logon_state   bool
	logon_eresult     int
	has_logon_eresult bool
}

pub fn (o &SiteServerUIloginResponse) pack() []byte {
	mut res := []byte{}
	if o.has_logon_state {
		res << vproto.pack_int32_field(o.logon_state, 1)
	}
	if o.has_logon_eresult {
		res << vproto.pack_int32_field(o.logon_eresult, 2)
	}
	return res
}

pub fn siteserveruiloginresponse_unpack(buf []byte) ?SiteServerUIloginResponse {
	mut res := SiteServerUIloginResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_logon_state = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_state = v
				i = ii
			}
			2 {
				res.has_logon_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruiloginresponse() SiteServerUIloginResponse {
	return SiteServerUIloginResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruiloginresponse(o SiteServerUIloginResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruiloginresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIloginResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruiloginresponse_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIloginStatusRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUIloginStatusRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserveruiloginstatusrequest_unpack(buf []byte) ?SiteServerUIloginStatusRequest {
	res := SiteServerUIloginStatusRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruiloginstatusrequest() SiteServerUIloginStatusRequest {
	return SiteServerUIloginStatusRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruiloginstatusrequest(o SiteServerUIloginStatusRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruiloginstatusrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIloginStatusRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruiloginstatusrequest_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIloginStatusResponse {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	username               string
	has_username           bool
	cached_credentials     bool
	has_cached_credentials bool
	logon_state            int
	has_logon_state        bool
	logon_eresult          int
	has_logon_eresult      bool
}

pub fn (o &SiteServerUIloginStatusResponse) pack() []byte {
	mut res := []byte{}
	if o.has_username {
		res << vproto.pack_string_field(o.username, 1)
	}
	if o.has_cached_credentials {
		res << vproto.pack_bool_field(o.cached_credentials, 2)
	}
	if o.has_logon_state {
		res << vproto.pack_int32_field(o.logon_state, 3)
	}
	if o.has_logon_eresult {
		res << vproto.pack_int32_field(o.logon_eresult, 4)
	}
	return res
}

pub fn siteserveruiloginstatusresponse_unpack(buf []byte) ?SiteServerUIloginStatusResponse {
	mut res := SiteServerUIloginStatusResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_username = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.username = v
				i = ii
			}
			2 {
				res.has_cached_credentials = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.cached_credentials = v
				i = ii
			}
			3 {
				res.has_logon_state = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_state = v
				i = ii
			}
			4 {
				res.has_logon_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruiloginstatusresponse() SiteServerUIloginStatusResponse {
	return SiteServerUIloginStatusResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruiloginstatusresponse(o SiteServerUIloginStatusResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruiloginstatusresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIloginStatusResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruiloginstatusresponse_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIcancelLoginRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUIcancelLoginRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserveruicancelloginrequest_unpack(buf []byte) ?SiteServerUIcancelLoginRequest {
	res := SiteServerUIcancelLoginRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruicancelloginrequest() SiteServerUIcancelLoginRequest {
	return SiteServerUIcancelLoginRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruicancelloginrequest(o SiteServerUIcancelLoginRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruicancelloginrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIcancelLoginRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruicancelloginrequest_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIcancelLoginResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	logon_state       int
	has_logon_state   bool
	logon_eresult     int
	has_logon_eresult bool
}

pub fn (o &SiteServerUIcancelLoginResponse) pack() []byte {
	mut res := []byte{}
	if o.has_logon_state {
		res << vproto.pack_int32_field(o.logon_state, 1)
	}
	if o.has_logon_eresult {
		res << vproto.pack_int32_field(o.logon_eresult, 2)
	}
	return res
}

pub fn siteserveruicancelloginresponse_unpack(buf []byte) ?SiteServerUIcancelLoginResponse {
	mut res := SiteServerUIcancelLoginResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_logon_state = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_state = v
				i = ii
			}
			2 {
				res.has_logon_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruicancelloginresponse() SiteServerUIcancelLoginResponse {
	return SiteServerUIcancelLoginResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruicancelloginresponse(o SiteServerUIcancelLoginResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruicancelloginresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIcancelLoginResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruicancelloginresponse_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIlogoutRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUIlogoutRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserveruilogoutrequest_unpack(buf []byte) ?SiteServerUIlogoutRequest {
	res := SiteServerUIlogoutRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruilogoutrequest() SiteServerUIlogoutRequest {
	return SiteServerUIlogoutRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruilogoutrequest(o SiteServerUIlogoutRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruilogoutrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIlogoutRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruilogoutrequest_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIlogoutResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	logon_state        int
	has_logon_state    bool
	logout_eresult     int
	has_logout_eresult bool
}

pub fn (o &SiteServerUIlogoutResponse) pack() []byte {
	mut res := []byte{}
	if o.has_logon_state {
		res << vproto.pack_int32_field(o.logon_state, 1)
	}
	if o.has_logout_eresult {
		res << vproto.pack_int32_field(o.logout_eresult, 2)
	}
	return res
}

pub fn siteserveruilogoutresponse_unpack(buf []byte) ?SiteServerUIlogoutResponse {
	mut res := SiteServerUIlogoutResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_logon_state = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_state = v
				i = ii
			}
			2 {
				res.has_logout_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logout_eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruilogoutresponse() SiteServerUIlogoutResponse {
	return SiteServerUIlogoutResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruilogoutresponse(o SiteServerUIlogoutResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruilogoutresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIlogoutResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruilogoutresponse_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIquitRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	restart        bool
	has_restart    bool
}

pub fn (o &SiteServerUIquitRequest) pack() []byte {
	mut res := []byte{}
	if o.has_restart {
		res << vproto.pack_bool_field(o.restart, 1)
	}
	return res
}

pub fn siteserveruiquitrequest_unpack(buf []byte) ?SiteServerUIquitRequest {
	mut res := SiteServerUIquitRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_restart = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.restart = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruiquitrequest() SiteServerUIquitRequest {
	return SiteServerUIquitRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruiquitrequest(o SiteServerUIquitRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruiquitrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIquitRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruiquitrequest_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIquitResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUIquitResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserveruiquitresponse_unpack(buf []byte) ?SiteServerUIquitResponse {
	res := SiteServerUIquitResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruiquitresponse() SiteServerUIquitResponse {
	return SiteServerUIquitResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruiquitresponse(o SiteServerUIquitResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruiquitresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIquitResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruiquitresponse_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIstatusRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUIstatusRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserveruistatusrequest_unpack(buf []byte) ?SiteServerUIstatusRequest {
	res := SiteServerUIstatusRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruistatusrequest() SiteServerUIstatusRequest {
	return SiteServerUIstatusRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruistatusrequest(o SiteServerUIstatusRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruistatusrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIstatusRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruistatusrequest_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIstatusResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	logon_state       int
	has_logon_state   bool
	logon_eresult     int
	has_logon_eresult bool
	connected         bool
	has_connected     bool
	cache_enabled     bool
	has_cache_enabled bool
	acct_status       int
	has_acct_status   bool
}

pub fn (o &SiteServerUIstatusResponse) pack() []byte {
	mut res := []byte{}
	if o.has_logon_state {
		res << vproto.pack_int32_field(o.logon_state, 1)
	}
	if o.has_logon_eresult {
		res << vproto.pack_int32_field(o.logon_eresult, 2)
	}
	if o.has_connected {
		res << vproto.pack_bool_field(o.connected, 3)
	}
	if o.has_cache_enabled {
		res << vproto.pack_bool_field(o.cache_enabled, 4)
	}
	if o.has_acct_status {
		res << vproto.pack_int32_field(o.acct_status, 5)
	}
	return res
}

pub fn siteserveruistatusresponse_unpack(buf []byte) ?SiteServerUIstatusResponse {
	mut res := SiteServerUIstatusResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_logon_state = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_state = v
				i = ii
			}
			2 {
				res.has_logon_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.logon_eresult = v
				i = ii
			}
			3 {
				res.has_connected = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.connected = v
				i = ii
			}
			4 {
				res.has_cache_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_enabled = v
				i = ii
			}
			5 {
				res.has_acct_status = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.acct_status = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruistatusresponse() SiteServerUIstatusResponse {
	return SiteServerUIstatusResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruistatusresponse(o SiteServerUIstatusResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruistatusresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIstatusResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruistatusresponse_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIgetLanguageRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUIgetLanguageRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserveruigetlanguagerequest_unpack(buf []byte) ?SiteServerUIgetLanguageRequest {
	res := SiteServerUIgetLanguageRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruigetlanguagerequest() SiteServerUIgetLanguageRequest {
	return SiteServerUIgetLanguageRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruigetlanguagerequest(o SiteServerUIgetLanguageRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruigetlanguagerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIgetLanguageRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruigetlanguagerequest_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIgetLanguageResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	language       string
	has_language   bool
}

pub fn (o &SiteServerUIgetLanguageResponse) pack() []byte {
	mut res := []byte{}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 1)
	}
	return res
}

pub fn siteserveruigetlanguageresponse_unpack(buf []byte) ?SiteServerUIgetLanguageResponse {
	mut res := SiteServerUIgetLanguageResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruigetlanguageresponse() SiteServerUIgetLanguageResponse {
	return SiteServerUIgetLanguageResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruigetlanguageresponse(o SiteServerUIgetLanguageResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruigetlanguageresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIgetLanguageResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruigetlanguageresponse_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIsetLanguageRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	language       string
	has_language   bool
}

pub fn (o &SiteServerUIsetLanguageRequest) pack() []byte {
	mut res := []byte{}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 1)
	}
	return res
}

pub fn siteserveruisetlanguagerequest_unpack(buf []byte) ?SiteServerUIsetLanguageRequest {
	mut res := SiteServerUIsetLanguageRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruisetlanguagerequest() SiteServerUIsetLanguageRequest {
	return SiteServerUIsetLanguageRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruisetlanguagerequest(o SiteServerUIsetLanguageRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruisetlanguagerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIsetLanguageRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruisetlanguagerequest_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIsetLanguageResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUIsetLanguageResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserveruisetlanguageresponse_unpack(buf []byte) ?SiteServerUIsetLanguageResponse {
	res := SiteServerUIsetLanguageResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruisetlanguageresponse() SiteServerUIsetLanguageResponse {
	return SiteServerUIsetLanguageResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruisetlanguageresponse(o SiteServerUIsetLanguageResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruisetlanguageresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIsetLanguageResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruisetlanguageresponse_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIclientStatusRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUIclientStatusRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserveruiclientstatusrequest_unpack(buf []byte) ?SiteServerUIclientStatusRequest {
	res := SiteServerUIclientStatusRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruiclientstatusrequest() SiteServerUIclientStatusRequest {
	return SiteServerUIclientStatusRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruiclientstatusrequest(o SiteServerUIclientStatusRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruiclientstatusrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIclientStatusRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruiclientstatusrequest_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIclientStatusResponseClientInfo {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	ip              u32
	has_ip          bool
	hostname        string
	has_hostname    bool
	connected       bool
	has_connected   bool
	instance_id     u64
	has_instance_id bool
}

pub fn (o &SiteServerUIclientStatusResponseClientInfo) pack() []byte {
	mut res := []byte{}
	if o.has_ip {
		res << vproto.pack_uint32_field(o.ip, 1)
	}
	if o.has_hostname {
		res << vproto.pack_string_field(o.hostname, 2)
	}
	if o.has_connected {
		res << vproto.pack_bool_field(o.connected, 3)
	}
	if o.has_instance_id {
		res << vproto.pack_uint64_field(o.instance_id, 4)
	}
	return res
}

pub fn siteserveruiclientstatusresponseclientinfo_unpack(buf []byte) ?SiteServerUIclientStatusResponseClientInfo {
	mut res := SiteServerUIclientStatusResponseClientInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ip = v
				i = ii
			}
			2 {
				res.has_hostname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.hostname = v
				i = ii
			}
			3 {
				res.has_connected = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.connected = v
				i = ii
			}
			4 {
				res.has_instance_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.instance_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruiclientstatusresponseclientinfo() SiteServerUIclientStatusResponseClientInfo {
	return SiteServerUIclientStatusResponseClientInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruiclientstatusresponseclientinfo(o SiteServerUIclientStatusResponseClientInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruiclientstatusresponseclientinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIclientStatusResponseClientInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruiclientstatusresponseclientinfo_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIclientStatusResponsePayment {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	transid             u64
	has_transid         bool
	steamid             u64
	has_steamid         bool
	amount              string
	has_amount          bool
	time_created        int
	has_time_created    bool
	purchase_status     int
	has_purchase_status bool
	hostname            string
	has_hostname        bool
	persona_name        string
	has_persona_name    bool
	profile_url         string
	has_profile_url     bool
	avatar_url          string
	has_avatar_url      bool
}

pub fn (o &SiteServerUIclientStatusResponsePayment) pack() []byte {
	mut res := []byte{}
	if o.has_transid {
		res << vproto.pack_uint64_field(o.transid, 1)
	}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 2)
	}
	if o.has_amount {
		res << vproto.pack_string_field(o.amount, 3)
	}
	if o.has_time_created {
		res << vproto.pack_int32_field(o.time_created, 4)
	}
	if o.has_purchase_status {
		res << vproto.pack_int32_field(o.purchase_status, 5)
	}
	if o.has_hostname {
		res << vproto.pack_string_field(o.hostname, 6)
	}
	if o.has_persona_name {
		res << vproto.pack_string_field(o.persona_name, 7)
	}
	if o.has_profile_url {
		res << vproto.pack_string_field(o.profile_url, 8)
	}
	if o.has_avatar_url {
		res << vproto.pack_string_field(o.avatar_url, 9)
	}
	return res
}

pub fn siteserveruiclientstatusresponsepayment_unpack(buf []byte) ?SiteServerUIclientStatusResponsePayment {
	mut res := SiteServerUIclientStatusResponsePayment{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_transid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.transid = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_amount = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.amount = v
				i = ii
			}
			4 {
				res.has_time_created = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			5 {
				res.has_purchase_status = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.purchase_status = v
				i = ii
			}
			6 {
				res.has_hostname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.hostname = v
				i = ii
			}
			7 {
				res.has_persona_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_name = v
				i = ii
			}
			8 {
				res.has_profile_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.profile_url = v
				i = ii
			}
			9 {
				res.has_avatar_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.avatar_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruiclientstatusresponsepayment() SiteServerUIclientStatusResponsePayment {
	return SiteServerUIclientStatusResponsePayment{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruiclientstatusresponsepayment(o SiteServerUIclientStatusResponsePayment, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruiclientstatusresponsepayment(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIclientStatusResponsePayment) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruiclientstatusresponsepayment_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIclientStatusResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	clients        []SiteServerUIclientStatusResponseClientInfo
	payments       []SiteServerUIclientStatusResponsePayment
}

pub fn (o &SiteServerUIclientStatusResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.clients {
		res << zzz_vproto_internal_pack_siteserveruiclientstatusresponseclientinfo(x, 4)
	}
	// [packed=false]
	for _, x in o.payments {
		res << zzz_vproto_internal_pack_siteserveruiclientstatusresponsepayment(x, 5)
	}
	return res
}

pub fn siteserveruiclientstatusresponse_unpack(buf []byte) ?SiteServerUIclientStatusResponse {
	mut res := SiteServerUIclientStatusResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_siteserveruiclientstatusresponseclientinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.clients << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_siteserveruiclientstatusresponsepayment(cur_buf,
					tag_wiretype.wire_type)?
				res.payments << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruiclientstatusresponse() SiteServerUIclientStatusResponse {
	return SiteServerUIclientStatusResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruiclientstatusresponse(o SiteServerUIclientStatusResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruiclientstatusresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIclientStatusResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruiclientstatusresponse_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIcontentCacheStatusRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUIcontentCacheStatusRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserveruicontentcachestatusrequest_unpack(buf []byte) ?SiteServerUIcontentCacheStatusRequest {
	res := SiteServerUIcontentCacheStatusRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruicontentcachestatusrequest() SiteServerUIcontentCacheStatusRequest {
	return SiteServerUIcontentCacheStatusRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruicontentcachestatusrequest(o SiteServerUIcontentCacheStatusRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruicontentcachestatusrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIcontentCacheStatusRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruicontentcachestatusrequest_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIcontentCacheStatusResponse {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	enabled                 bool
	has_enabled             bool
	port                    u32
	has_port                bool
	cache_location          string
	has_cache_location      bool
	max_size_gb             u32
	has_max_size_gb         bool
	p2p_enabled             bool
	has_p2p_enabled         bool
	explicit_ip_address     string
	has_explicit_ip_address bool
	external_process        bool
	has_external_process    bool
	current_size_gb         u32
	has_current_size_gb     bool
	current_bw              u64
	has_current_bw          bool
	total_bytes_served      u64
	has_total_bytes_served  bool
}

pub fn (o &SiteServerUIcontentCacheStatusResponse) pack() []byte {
	mut res := []byte{}
	if o.has_enabled {
		res << vproto.pack_bool_field(o.enabled, 1)
	}
	if o.has_port {
		res << vproto.pack_uint32_field(o.port, 2)
	}
	if o.has_cache_location {
		res << vproto.pack_string_field(o.cache_location, 3)
	}
	if o.has_max_size_gb {
		res << vproto.pack_uint32_field(o.max_size_gb, 4)
	}
	if o.has_p2p_enabled {
		res << vproto.pack_bool_field(o.p2p_enabled, 5)
	}
	if o.has_explicit_ip_address {
		res << vproto.pack_string_field(o.explicit_ip_address, 9)
	}
	if o.has_external_process {
		res << vproto.pack_bool_field(o.external_process, 10)
	}
	if o.has_current_size_gb {
		res << vproto.pack_uint32_field(o.current_size_gb, 6)
	}
	if o.has_current_bw {
		res << vproto.pack_uint64_field(o.current_bw, 7)
	}
	if o.has_total_bytes_served {
		res << vproto.pack_uint64_field(o.total_bytes_served, 8)
	}
	return res
}

pub fn siteserveruicontentcachestatusresponse_unpack(buf []byte) ?SiteServerUIcontentCacheStatusResponse {
	mut res := SiteServerUIcontentCacheStatusResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enabled = v
				i = ii
			}
			2 {
				res.has_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.port = v
				i = ii
			}
			3 {
				res.has_cache_location = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_location = v
				i = ii
			}
			4 {
				res.has_max_size_gb = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_size_gb = v
				i = ii
			}
			5 {
				res.has_p2p_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.p2p_enabled = v
				i = ii
			}
			9 {
				res.has_explicit_ip_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.explicit_ip_address = v
				i = ii
			}
			10 {
				res.has_external_process = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.external_process = v
				i = ii
			}
			6 {
				res.has_current_size_gb = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.current_size_gb = v
				i = ii
			}
			7 {
				res.has_current_bw = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.current_bw = v
				i = ii
			}
			8 {
				res.has_total_bytes_served = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.total_bytes_served = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruicontentcachestatusresponse() SiteServerUIcontentCacheStatusResponse {
	return SiteServerUIcontentCacheStatusResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruicontentcachestatusresponse(o SiteServerUIcontentCacheStatusResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruicontentcachestatusresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIcontentCacheStatusResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruicontentcachestatusresponse_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIcontentCacheConfigRequest {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	enabled                 bool
	has_enabled             bool
	port                    u32
	has_port                bool
	cache_location          string
	has_cache_location      bool
	max_size_gb             u32
	has_max_size_gb         bool
	p2p_enabled             bool
	has_p2p_enabled         bool
	external_process        bool
	has_external_process    bool
	explicit_ip_address     string
	has_explicit_ip_address bool
}

pub fn (o &SiteServerUIcontentCacheConfigRequest) pack() []byte {
	mut res := []byte{}
	if o.has_enabled {
		res << vproto.pack_bool_field(o.enabled, 1)
	}
	if o.has_port {
		res << vproto.pack_uint32_field(o.port, 2)
	}
	if o.has_cache_location {
		res << vproto.pack_string_field(o.cache_location, 3)
	}
	if o.has_max_size_gb {
		res << vproto.pack_uint32_field(o.max_size_gb, 4)
	}
	if o.has_p2p_enabled {
		res << vproto.pack_bool_field(o.p2p_enabled, 5)
	}
	if o.has_external_process {
		res << vproto.pack_bool_field(o.external_process, 6)
	}
	if o.has_explicit_ip_address {
		res << vproto.pack_string_field(o.explicit_ip_address, 7)
	}
	return res
}

pub fn siteserveruicontentcacheconfigrequest_unpack(buf []byte) ?SiteServerUIcontentCacheConfigRequest {
	mut res := SiteServerUIcontentCacheConfigRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enabled = v
				i = ii
			}
			2 {
				res.has_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.port = v
				i = ii
			}
			3 {
				res.has_cache_location = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_location = v
				i = ii
			}
			4 {
				res.has_max_size_gb = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_size_gb = v
				i = ii
			}
			5 {
				res.has_p2p_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.p2p_enabled = v
				i = ii
			}
			6 {
				res.has_external_process = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.external_process = v
				i = ii
			}
			7 {
				res.has_explicit_ip_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.explicit_ip_address = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruicontentcacheconfigrequest() SiteServerUIcontentCacheConfigRequest {
	return SiteServerUIcontentCacheConfigRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruicontentcacheconfigrequest(o SiteServerUIcontentCacheConfigRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruicontentcacheconfigrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIcontentCacheConfigRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruicontentcacheconfigrequest_unpack(v)?
	return i, unpacked
}

pub struct SiteServerUIcontentCacheConfigResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &SiteServerUIcontentCacheConfigResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn siteserveruicontentcacheconfigresponse_unpack(buf []byte) ?SiteServerUIcontentCacheConfigResponse {
	res := SiteServerUIcontentCacheConfigResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_siteserveruicontentcacheconfigresponse() SiteServerUIcontentCacheConfigResponse {
	return SiteServerUIcontentCacheConfigResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_siteserveruicontentcacheconfigresponse(o SiteServerUIcontentCacheConfigResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_siteserveruicontentcacheconfigresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, SiteServerUIcontentCacheConfigResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := siteserveruicontentcacheconfigresponse_unpack(v)?
	return i, unpacked
}
