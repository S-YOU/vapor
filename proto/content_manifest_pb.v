
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


[_allow_multiple_values]
enum EContentDeltaChunkDataLocation {
k_econtentdeltachunkdatalocationinprotobuf = 0
k_econtentdeltachunkdatalocationafterprotobuf = 1
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_econtentdeltachunkdatalocation(e EContentDeltaChunkDataLocation, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_econtentdeltachunkdatalocation(buf []byte, tag_wiretype vproto.WireType) ?(int, EContentDeltaChunkDataLocation) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, EContentDeltaChunkDataLocation(v)
}
pub struct ContentManifestPayloadFileMappingChunkData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
sha []byte
has_sha bool
crc u32
has_crc bool
offset u64
has_offset bool
cb_original u32
has_cb_original bool
cb_compressed u32
has_cb_compressed bool
}
pub fn (o &ContentManifestPayloadFileMappingChunkData) pack() []byte {
mut res := []byte{}
if o.has_sha {
res << vproto.pack_bytes_field(o.sha, 1)
}

if o.has_crc {
res << vproto.pack_32bit_field(o.crc, 2)
}

if o.has_offset {
res << vproto.pack_uint64_field(o.offset, 3)
}

if o.has_cb_original {
res << vproto.pack_uint32_field(o.cb_original, 4)
}

if o.has_cb_compressed {
res << vproto.pack_uint32_field(o.cb_compressed, 5)
}

return res
}

pub fn contentmanifestpayloadfilemappingchunkdata_unpack(buf []byte) ?ContentManifestPayloadFileMappingChunkData {
mut res := ContentManifestPayloadFileMappingChunkData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_sha = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha = v
i = ii
}

2 {
res.has_crc = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.crc = v
i = ii
}

3 {
res.has_offset = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.offset = v
i = ii
}

4 {
res.has_cb_original = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cb_original = v
i = ii
}

5 {
res.has_cb_compressed = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cb_compressed = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_contentmanifestpayloadfilemappingchunkdata() ContentManifestPayloadFileMappingChunkData {
return ContentManifestPayloadFileMappingChunkData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_contentmanifestpayloadfilemappingchunkdata(o ContentManifestPayloadFileMappingChunkData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_contentmanifestpayloadfilemappingchunkdata(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentManifestPayloadFileMappingChunkData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := contentmanifestpayloadfilemappingchunkdata_unpack(v)?
return i, unpacked
}
pub struct ContentManifestPayloadFileMapping {
mut:
unknown_fields []vproto.UnknownField
pub mut:
filename string
has_filename bool
size u64
has_size bool
flags u32
has_flags bool
sha_filename []byte
has_sha_filename bool
sha_content []byte
has_sha_content bool
chunks []ContentManifestPayloadFileMappingChunkData
linktarget string
has_linktarget bool
}
pub fn (o &ContentManifestPayloadFileMapping) pack() []byte {
mut res := []byte{}
if o.has_filename {
res << vproto.pack_string_field(o.filename, 1)
}

if o.has_size {
res << vproto.pack_uint64_field(o.size, 2)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 3)
}

if o.has_sha_filename {
res << vproto.pack_bytes_field(o.sha_filename, 4)
}

if o.has_sha_content {
res << vproto.pack_bytes_field(o.sha_content, 5)
}

// [packed=false]
for _, x in o.chunks {
res << zzz_vproto_internal_pack_contentmanifestpayloadfilemappingchunkdata(x, 6)
}

if o.has_linktarget {
res << vproto.pack_string_field(o.linktarget, 7)
}

return res
}

pub fn contentmanifestpayloadfilemapping_unpack(buf []byte) ?ContentManifestPayloadFileMapping {
mut res := ContentManifestPayloadFileMapping{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename = v
i = ii
}

2 {
res.has_size = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.size = v
i = ii
}

3 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

4 {
res.has_sha_filename = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_filename = v
i = ii
}

5 {
res.has_sha_content = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_content = v
i = ii
}

6 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_contentmanifestpayloadfilemappingchunkdata(cur_buf, tag_wiretype.wire_type)?
res.chunks << v
i = ii
}

7 {
res.has_linktarget = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.linktarget = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_contentmanifestpayloadfilemapping() ContentManifestPayloadFileMapping {
return ContentManifestPayloadFileMapping{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_contentmanifestpayloadfilemapping(o ContentManifestPayloadFileMapping, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_contentmanifestpayloadfilemapping(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentManifestPayloadFileMapping) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := contentmanifestpayloadfilemapping_unpack(v)?
return i, unpacked
}
pub struct ContentManifestPayload {
mut:
unknown_fields []vproto.UnknownField
pub mut:
mappings []ContentManifestPayloadFileMapping
}
pub fn (o &ContentManifestPayload) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.mappings {
res << zzz_vproto_internal_pack_contentmanifestpayloadfilemapping(x, 1)
}

return res
}

pub fn contentmanifestpayload_unpack(buf []byte) ?ContentManifestPayload {
mut res := ContentManifestPayload{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_contentmanifestpayloadfilemapping(cur_buf, tag_wiretype.wire_type)?
res.mappings << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_contentmanifestpayload() ContentManifestPayload {
return ContentManifestPayload{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_contentmanifestpayload(o ContentManifestPayload, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_contentmanifestpayload(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentManifestPayload) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := contentmanifestpayload_unpack(v)?
return i, unpacked
}
pub struct ContentManifestMetadata {
mut:
unknown_fields []vproto.UnknownField
pub mut:
depot_id u32
has_depot_id bool
gid_manifest u64
has_gid_manifest bool
creation_time u32
has_creation_time bool
filenames_encrypted bool
has_filenames_encrypted bool
cb_disk_original u64
has_cb_disk_original bool
cb_disk_compressed u64
has_cb_disk_compressed bool
unique_chunks u32
has_unique_chunks bool
crc_encrypted u32
has_crc_encrypted bool
crc_clear u32
has_crc_clear bool
}
pub fn (o &ContentManifestMetadata) pack() []byte {
mut res := []byte{}
if o.has_depot_id {
res << vproto.pack_uint32_field(o.depot_id, 1)
}

if o.has_gid_manifest {
res << vproto.pack_uint64_field(o.gid_manifest, 2)
}

if o.has_creation_time {
res << vproto.pack_uint32_field(o.creation_time, 3)
}

if o.has_filenames_encrypted {
res << vproto.pack_bool_field(o.filenames_encrypted, 4)
}

if o.has_cb_disk_original {
res << vproto.pack_uint64_field(o.cb_disk_original, 5)
}

if o.has_cb_disk_compressed {
res << vproto.pack_uint64_field(o.cb_disk_compressed, 6)
}

if o.has_unique_chunks {
res << vproto.pack_uint32_field(o.unique_chunks, 7)
}

if o.has_crc_encrypted {
res << vproto.pack_uint32_field(o.crc_encrypted, 8)
}

if o.has_crc_clear {
res << vproto.pack_uint32_field(o.crc_clear, 9)
}

return res
}

pub fn contentmanifestmetadata_unpack(buf []byte) ?ContentManifestMetadata {
mut res := ContentManifestMetadata{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_depot_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.depot_id = v
i = ii
}

2 {
res.has_gid_manifest = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.gid_manifest = v
i = ii
}

3 {
res.has_creation_time = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.creation_time = v
i = ii
}

4 {
res.has_filenames_encrypted = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.filenames_encrypted = v
i = ii
}

5 {
res.has_cb_disk_original = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.cb_disk_original = v
i = ii
}

6 {
res.has_cb_disk_compressed = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.cb_disk_compressed = v
i = ii
}

7 {
res.has_unique_chunks = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.unique_chunks = v
i = ii
}

8 {
res.has_crc_encrypted = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.crc_encrypted = v
i = ii
}

9 {
res.has_crc_clear = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.crc_clear = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_contentmanifestmetadata() ContentManifestMetadata {
return ContentManifestMetadata{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_contentmanifestmetadata(o ContentManifestMetadata, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_contentmanifestmetadata(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentManifestMetadata) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := contentmanifestmetadata_unpack(v)?
return i, unpacked
}
pub struct ContentManifestSignature {
mut:
unknown_fields []vproto.UnknownField
pub mut:
signature []byte
has_signature bool
}
pub fn (o &ContentManifestSignature) pack() []byte {
mut res := []byte{}
if o.has_signature {
res << vproto.pack_bytes_field(o.signature, 1)
}

return res
}

pub fn contentmanifestsignature_unpack(buf []byte) ?ContentManifestSignature {
mut res := ContentManifestSignature{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_signature = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.signature = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_contentmanifestsignature() ContentManifestSignature {
return ContentManifestSignature{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_contentmanifestsignature(o ContentManifestSignature, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_contentmanifestsignature(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentManifestSignature) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := contentmanifestsignature_unpack(v)?
return i, unpacked
}
pub struct ContentDeltaChunksDeltaChunk {
mut:
unknown_fields []vproto.UnknownField
pub mut:
sha_source []byte
has_sha_source bool
sha_target []byte
has_sha_target bool
size_original u32
has_size_original bool
patch_method u32
has_patch_method bool
chunk []byte
has_chunk bool
size_delta u32
has_size_delta bool
}
pub fn (o &ContentDeltaChunksDeltaChunk) pack() []byte {
mut res := []byte{}
if o.has_sha_source {
res << vproto.pack_bytes_field(o.sha_source, 1)
}

if o.has_sha_target {
res << vproto.pack_bytes_field(o.sha_target, 2)
}

if o.has_size_original {
res << vproto.pack_uint32_field(o.size_original, 3)
}

if o.has_patch_method {
res << vproto.pack_uint32_field(o.patch_method, 4)
}

if o.has_chunk {
res << vproto.pack_bytes_field(o.chunk, 5)
}

if o.has_size_delta {
res << vproto.pack_uint32_field(o.size_delta, 6)
}

return res
}

pub fn contentdeltachunksdeltachunk_unpack(buf []byte) ?ContentDeltaChunksDeltaChunk {
mut res := ContentDeltaChunksDeltaChunk{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_sha_source = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_source = v
i = ii
}

2 {
res.has_sha_target = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_target = v
i = ii
}

3 {
res.has_size_original = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.size_original = v
i = ii
}

4 {
res.has_patch_method = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.patch_method = v
i = ii
}

5 {
res.has_chunk = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.chunk = v
i = ii
}

6 {
res.has_size_delta = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.size_delta = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_contentdeltachunksdeltachunk() ContentDeltaChunksDeltaChunk {
return ContentDeltaChunksDeltaChunk{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_contentdeltachunksdeltachunk(o ContentDeltaChunksDeltaChunk, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_contentdeltachunksdeltachunk(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentDeltaChunksDeltaChunk) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := contentdeltachunksdeltachunk_unpack(v)?
return i, unpacked
}
pub struct ContentDeltaChunks {
mut:
unknown_fields []vproto.UnknownField
pub mut:
depot_id u32
has_depot_id bool
manifest_id_source u64
has_manifest_id_source bool
manifest_id_target u64
has_manifest_id_target bool
deltachunks []ContentDeltaChunksDeltaChunk
chunk_data_location EContentDeltaChunkDataLocation
has_chunk_data_location bool
}
pub fn (o &ContentDeltaChunks) pack() []byte {
mut res := []byte{}
if o.has_depot_id {
res << vproto.pack_uint32_field(o.depot_id, 1)
}

if o.has_manifest_id_source {
res << vproto.pack_uint64_field(o.manifest_id_source, 2)
}

if o.has_manifest_id_target {
res << vproto.pack_uint64_field(o.manifest_id_target, 3)
}

// [packed=false]
for _, x in o.deltachunks {
res << zzz_vproto_internal_pack_contentdeltachunksdeltachunk(x, 4)
}

if o.has_chunk_data_location {
res << zzz_vproto_internal_pack_econtentdeltachunkdatalocation(o.chunk_data_location, 5)
}

return res
}

pub fn contentdeltachunks_unpack(buf []byte) ?ContentDeltaChunks {
mut res := ContentDeltaChunks{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_depot_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.depot_id = v
i = ii
}

2 {
res.has_manifest_id_source = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.manifest_id_source = v
i = ii
}

3 {
res.has_manifest_id_target = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.manifest_id_target = v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_contentdeltachunksdeltachunk(cur_buf, tag_wiretype.wire_type)?
res.deltachunks << v
i = ii
}

5 {
res.has_chunk_data_location = true
ii, v := zzz_vproto_internal_unpack_econtentdeltachunkdatalocation(cur_buf, tag_wiretype.wire_type)?
res.chunk_data_location = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_contentdeltachunks() ContentDeltaChunks {
return ContentDeltaChunks{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_contentdeltachunks(o ContentDeltaChunks, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_contentdeltachunks(buf []byte, tag_wiretype vproto.WireType) ?(int, ContentDeltaChunks) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := contentdeltachunks_unpack(v)?
return i, unpacked
}
