
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


[_allow_multiple_values]
enum ESteamDatagramMsgID {
k_esteamdatagrammsg_invalid = 0
k_esteamdatagrammsg_routerpingrequest = 1
k_esteamdatagrammsg_routerpingreply = 2
k_esteamdatagrammsg_gameserverpingrequest = 3
k_esteamdatagrammsg_legacygameserverpingreply = 4
k_esteamdatagrammsg_gameserversessionrequest = 5
k_esteamdatagrammsg_gameserversessionestablished = 6
k_esteamdatagrammsg_nosession = 7
k_esteamdatagrammsg_diagnostic = 8
k_esteamdatagrammsg_dataclienttorouter = 9
k_esteamdatagrammsg_dataroutertoserver = 10
k_esteamdatagrammsg_dataservertorouter = 11
k_esteamdatagrammsg_dataroutertoclient = 12
k_esteamdatagrammsg_stats = 13
k_esteamdatagrammsg_clientpingsamplerequest = 14
k_esteamdatagrammsg_clientpingsamplereply = 15
k_esteamdatagrammsg_clienttorouterswitchedprimary = 16
k_esteamdatagrammsg_relayhealth = 17
k_esteamdatagrammsg_connectrequest = 18
k_esteamdatagrammsg_connectok = 19
k_esteamdatagrammsg_connectionclosed = 20
k_esteamdatagrammsg_noconnection = 21
k_esteamdatagrammsg_relaytorelaypingrequest = 22
k_esteamdatagrammsg_relaytorelaypingreply = 23
k_esteamdatagrammsg_p2psessionrequest = 24
k_esteamdatagrammsg_p2psessionestablished = 25
k_esteamdatagrammsg_p2pstatsclient = 26
k_esteamdatagrammsg_p2pstatsrelay = 27
k_esteamdatagrammsg_p2pbadroute = 28
k_esteamdatagrammsg_gameserverpingreply = 29
k_esteamdatagrammsg_gameserverregistration = 30
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_esteamdatagrammsgid(e ESteamDatagramMsgID, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_esteamdatagrammsgid(buf []byte, tag_wiretype vproto.WireType) ?(int, ESteamDatagramMsgID) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, ESteamDatagramMsgID(v)
}
pub struct CMsgSteamDatagramRouterPingReplyRouteException {
mut:
unknown_fields []vproto.UnknownField
pub mut:
data_center_id u32
has_data_center_id bool
flags u32
has_flags bool
penalty u32
has_penalty bool
}
pub fn (o &CMsgSteamDatagramRouterPingReplyRouteException) pack() []byte {
mut res := []byte{}
if o.has_data_center_id {
res << vproto.pack_32bit_field(o.data_center_id, 1)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 2)
}

if o.has_penalty {
res << vproto.pack_uint32_field(o.penalty, 3)
}

return res
}

pub fn cmsgsteamdatagramrouterpingreplyrouteexception_unpack(buf []byte) ?CMsgSteamDatagramRouterPingReplyRouteException {
mut res := CMsgSteamDatagramRouterPingReplyRouteException{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_data_center_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.data_center_id = v
i = ii
}

2 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

3 {
res.has_penalty = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.penalty = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrouterpingreplyrouteexception() CMsgSteamDatagramRouterPingReplyRouteException {
return CMsgSteamDatagramRouterPingReplyRouteException{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrouterpingreplyrouteexception(o CMsgSteamDatagramRouterPingReplyRouteException, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrouterpingreplyrouteexception(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRouterPingReplyRouteException) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramrouterpingreplyrouteexception_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramRouterPingReply {
mut:
unknown_fields []vproto.UnknownField
pub mut:
client_timestamp u32
has_client_timestamp bool
latency_datacenter_ids []u32
latency_ping_ms []u32
your_public_ip u32
has_your_public_ip bool
server_time u32
has_server_time bool
challenge u64
has_challenge bool
seconds_until_shutdown u32
has_seconds_until_shutdown bool
client_cookie u32
has_client_cookie bool
scoring_penalty_relay_cluster u32
has_scoring_penalty_relay_cluster bool
route_exceptions []CMsgSteamDatagramRouterPingReplyRouteException
}
pub fn (o &CMsgSteamDatagramRouterPingReply) pack() []byte {
mut res := []byte{}
if o.has_client_timestamp {
res << vproto.pack_32bit_field(o.client_timestamp, 1)
}

// [packed=true]
res << vproto.pack_32bit_field_packed(o.latency_datacenter_ids, 2)

// [packed=true]
res << vproto.pack_uint32_field_packed(o.latency_ping_ms, 3)

if o.has_your_public_ip {
res << vproto.pack_32bit_field(o.your_public_ip, 4)
}

if o.has_server_time {
res << vproto.pack_32bit_field(o.server_time, 5)
}

if o.has_challenge {
res << vproto.pack_64bit_field(o.challenge, 6)
}

if o.has_seconds_until_shutdown {
res << vproto.pack_uint32_field(o.seconds_until_shutdown, 7)
}

if o.has_client_cookie {
res << vproto.pack_32bit_field(o.client_cookie, 8)
}

if o.has_scoring_penalty_relay_cluster {
res << vproto.pack_uint32_field(o.scoring_penalty_relay_cluster, 9)
}

// [packed=false]
for _, x in o.route_exceptions {
res << zzz_vproto_internal_pack_cmsgsteamdatagramrouterpingreplyrouteexception(x, 10)
}

return res
}

pub fn cmsgsteamdatagramrouterpingreply_unpack(buf []byte) ?CMsgSteamDatagramRouterPingReply {
mut res := CMsgSteamDatagramRouterPingReply{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_client_timestamp = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.client_timestamp = v
i = ii
}

2 {
// [packed=true]
ii, v := vproto.unpack_32bit_field_packed(cur_buf, tag_wiretype.wire_type) ?
res.latency_datacenter_ids << v
i = ii
}

3 {
// [packed=true]
ii, v := vproto.unpack_uint32_field_packed(cur_buf, tag_wiretype.wire_type) ?
res.latency_ping_ms << v
i = ii
}

4 {
res.has_your_public_ip = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.your_public_ip = v
i = ii
}

5 {
res.has_server_time = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.server_time = v
i = ii
}

6 {
res.has_challenge = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.challenge = v
i = ii
}

7 {
res.has_seconds_until_shutdown = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_until_shutdown = v
i = ii
}

8 {
res.has_client_cookie = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.client_cookie = v
i = ii
}

9 {
res.has_scoring_penalty_relay_cluster = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.scoring_penalty_relay_cluster = v
i = ii
}

10 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramrouterpingreplyrouteexception(cur_buf, tag_wiretype.wire_type)?
res.route_exceptions << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrouterpingreply() CMsgSteamDatagramRouterPingReply {
return CMsgSteamDatagramRouterPingReply{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrouterpingreply(o CMsgSteamDatagramRouterPingReply, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrouterpingreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRouterPingReply) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramrouterpingreply_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramGameserverPingRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
your_public_ip u32
has_your_public_ip bool
server_time u32
has_server_time bool
challenge u64
has_challenge bool
router_timestamp u32
has_router_timestamp bool
}
pub fn (o &CMsgSteamDatagramGameserverPingRequest) pack() []byte {
mut res := []byte{}
if o.has_your_public_ip {
res << vproto.pack_32bit_field(o.your_public_ip, 1)
}

if o.has_server_time {
res << vproto.pack_32bit_field(o.server_time, 2)
}

if o.has_challenge {
res << vproto.pack_64bit_field(o.challenge, 3)
}

if o.has_router_timestamp {
res << vproto.pack_32bit_field(o.router_timestamp, 4)
}

return res
}

pub fn cmsgsteamdatagramgameserverpingrequest_unpack(buf []byte) ?CMsgSteamDatagramGameserverPingRequest {
mut res := CMsgSteamDatagramGameserverPingRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_your_public_ip = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.your_public_ip = v
i = ii
}

2 {
res.has_server_time = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.server_time = v
i = ii
}

3 {
res.has_challenge = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.challenge = v
i = ii
}

4 {
res.has_router_timestamp = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.router_timestamp = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserverpingrequest() CMsgSteamDatagramGameserverPingRequest {
return CMsgSteamDatagramGameserverPingRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserverpingrequest(o CMsgSteamDatagramGameserverPingRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserverpingrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverPingRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramgameserverpingrequest_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramLegacyGameserverPingReply {
mut:
unknown_fields []vproto.UnknownField
pub mut:
router_timestamp u32
has_router_timestamp bool
dummy_pad u64
has_dummy_pad bool
}
pub fn (o &CMsgSteamDatagramLegacyGameserverPingReply) pack() []byte {
mut res := []byte{}
if o.has_router_timestamp {
res << vproto.pack_32bit_field(o.router_timestamp, 4)
}

if o.has_dummy_pad {
res << vproto.pack_64bit_field(o.dummy_pad, 99)
}

return res
}

pub fn cmsgsteamdatagramlegacygameserverpingreply_unpack(buf []byte) ?CMsgSteamDatagramLegacyGameserverPingReply {
mut res := CMsgSteamDatagramLegacyGameserverPingReply{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
4 {
res.has_router_timestamp = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.router_timestamp = v
i = ii
}

99 {
res.has_dummy_pad = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.dummy_pad = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramlegacygameserverpingreply() CMsgSteamDatagramLegacyGameserverPingReply {
return CMsgSteamDatagramLegacyGameserverPingReply{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramlegacygameserverpingreply(o CMsgSteamDatagramLegacyGameserverPingReply, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramlegacygameserverpingreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramLegacyGameserverPingReply) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramlegacygameserverpingreply_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramGameserverPingReplySignedData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
challenge_time u32
has_challenge_time bool
challenge u64
has_challenge bool
router_timestamp u32
has_router_timestamp bool
data_center_id u32
has_data_center_id bool
appid u32
has_appid bool
}
pub fn (o &CMsgSteamDatagramGameserverPingReplySignedData) pack() []byte {
mut res := []byte{}
if o.has_challenge_time {
res << vproto.pack_32bit_field(o.challenge_time, 2)
}

if o.has_challenge {
res << vproto.pack_64bit_field(o.challenge, 3)
}

if o.has_router_timestamp {
res << vproto.pack_32bit_field(o.router_timestamp, 4)
}

if o.has_data_center_id {
res << vproto.pack_32bit_field(o.data_center_id, 5)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 6)
}

return res
}

pub fn cmsgsteamdatagramgameserverpingreplysigneddata_unpack(buf []byte) ?CMsgSteamDatagramGameserverPingReplySignedData {
mut res := CMsgSteamDatagramGameserverPingReplySignedData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
2 {
res.has_challenge_time = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.challenge_time = v
i = ii
}

3 {
res.has_challenge = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.challenge = v
i = ii
}

4 {
res.has_router_timestamp = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.router_timestamp = v
i = ii
}

5 {
res.has_data_center_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.data_center_id = v
i = ii
}

6 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserverpingreplysigneddata() CMsgSteamDatagramGameserverPingReplySignedData {
return CMsgSteamDatagramGameserverPingReplySignedData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserverpingreplysigneddata(o CMsgSteamDatagramGameserverPingReplySignedData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserverpingreplysigneddata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverPingReplySignedData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramgameserverpingreplysigneddata_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramGameserverPingReply {
mut:
unknown_fields []vproto.UnknownField
pub mut:
cert CMsgSteamDatagramCertificateSigned
has_cert bool
signed_data []byte
has_signed_data bool
signature []byte
has_signature bool
}
pub fn (o &CMsgSteamDatagramGameserverPingReply) pack() []byte {
mut res := []byte{}
if o.has_cert {
res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 1)
}

if o.has_signed_data {
res << vproto.pack_bytes_field(o.signed_data, 2)
}

if o.has_signature {
res << vproto.pack_bytes_field(o.signature, 3)
}

return res
}

pub fn cmsgsteamdatagramgameserverpingreply_unpack(buf []byte) ?CMsgSteamDatagramGameserverPingReply {
mut res := CMsgSteamDatagramGameserverPingReply{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_cert = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf, tag_wiretype.wire_type)?
res.cert = v
i = ii
}

2 {
res.has_signed_data = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.signed_data = v
i = ii
}

3 {
res.has_signature = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.signature = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserverpingreply() CMsgSteamDatagramGameserverPingReply {
return CMsgSteamDatagramGameserverPingReply{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserverpingreply(o CMsgSteamDatagramGameserverPingReply, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserverpingreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverPingReply) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramgameserverpingreply_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramNoSessionRelayToClient {
mut:
unknown_fields []vproto.UnknownField
pub mut:
connection_id u32
has_connection_id bool
your_public_ip u32
has_your_public_ip bool
server_time u32
has_server_time bool
challenge u64
has_challenge bool
seconds_until_shutdown u32
has_seconds_until_shutdown bool
}
pub fn (o &CMsgSteamDatagramNoSessionRelayToClient) pack() []byte {
mut res := []byte{}
if o.has_connection_id {
res << vproto.pack_32bit_field(o.connection_id, 7)
}

if o.has_your_public_ip {
res << vproto.pack_32bit_field(o.your_public_ip, 2)
}

if o.has_server_time {
res << vproto.pack_32bit_field(o.server_time, 3)
}

if o.has_challenge {
res << vproto.pack_64bit_field(o.challenge, 4)
}

if o.has_seconds_until_shutdown {
res << vproto.pack_uint32_field(o.seconds_until_shutdown, 5)
}

return res
}

pub fn cmsgsteamdatagramnosessionrelaytoclient_unpack(buf []byte) ?CMsgSteamDatagramNoSessionRelayToClient {
mut res := CMsgSteamDatagramNoSessionRelayToClient{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
7 {
res.has_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.connection_id = v
i = ii
}

2 {
res.has_your_public_ip = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.your_public_ip = v
i = ii
}

3 {
res.has_server_time = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.server_time = v
i = ii
}

4 {
res.has_challenge = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.challenge = v
i = ii
}

5 {
res.has_seconds_until_shutdown = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_until_shutdown = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramnosessionrelaytoclient() CMsgSteamDatagramNoSessionRelayToClient {
return CMsgSteamDatagramNoSessionRelayToClient{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramnosessionrelaytoclient(o CMsgSteamDatagramNoSessionRelayToClient, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramnosessionrelaytoclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramNoSessionRelayToClient) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramnosessionrelaytoclient_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramNoSessionRelayToPeer {
mut:
unknown_fields []vproto.UnknownField
pub mut:
legacy_relay_session_id u32
has_legacy_relay_session_id bool
from_relay_session_id u32
has_from_relay_session_id bool
from_connection_id u32
has_from_connection_id bool
kludge_pad u64
has_kludge_pad bool
}
pub fn (o &CMsgSteamDatagramNoSessionRelayToPeer) pack() []byte {
mut res := []byte{}
if o.has_legacy_relay_session_id {
res << vproto.pack_uint32_field(o.legacy_relay_session_id, 1)
}

if o.has_from_relay_session_id {
res << vproto.pack_32bit_field(o.from_relay_session_id, 2)
}

if o.has_from_connection_id {
res << vproto.pack_32bit_field(o.from_connection_id, 7)
}

if o.has_kludge_pad {
res << vproto.pack_64bit_field(o.kludge_pad, 99)
}

return res
}

pub fn cmsgsteamdatagramnosessionrelaytopeer_unpack(buf []byte) ?CMsgSteamDatagramNoSessionRelayToPeer {
mut res := CMsgSteamDatagramNoSessionRelayToPeer{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_legacy_relay_session_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_relay_session_id = v
i = ii
}

2 {
res.has_from_relay_session_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.from_relay_session_id = v
i = ii
}

7 {
res.has_from_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.from_connection_id = v
i = ii
}

99 {
res.has_kludge_pad = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.kludge_pad = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramnosessionrelaytopeer() CMsgSteamDatagramNoSessionRelayToPeer {
return CMsgSteamDatagramNoSessionRelayToPeer{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramnosessionrelaytopeer(o CMsgSteamDatagramNoSessionRelayToPeer, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramnosessionrelaytopeer(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramNoSessionRelayToPeer) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramnosessionrelaytopeer_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramClientPingSampleRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
connection_id u32
has_connection_id bool
}
pub fn (o &CMsgSteamDatagramClientPingSampleRequest) pack() []byte {
mut res := []byte{}
if o.has_connection_id {
res << vproto.pack_32bit_field(o.connection_id, 1)
}

return res
}

pub fn cmsgsteamdatagramclientpingsamplerequest_unpack(buf []byte) ?CMsgSteamDatagramClientPingSampleRequest {
mut res := CMsgSteamDatagramClientPingSampleRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.connection_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplerequest() CMsgSteamDatagramClientPingSampleRequest {
return CMsgSteamDatagramClientPingSampleRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplerequest(o CMsgSteamDatagramClientPingSampleRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientPingSampleRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramclientpingsamplerequest_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramClientPingSampleReplyRoutingCluster {
mut:
unknown_fields []vproto.UnknownField
pub mut:
id u32
has_id bool
front_ping_ms u32
has_front_ping_ms bool
e2e_ping_ms u32
has_e2e_ping_ms bool
}
pub fn (o &CMsgSteamDatagramClientPingSampleReplyRoutingCluster) pack() []byte {
mut res := []byte{}
if o.has_id {
res << vproto.pack_32bit_field(o.id, 1)
}

if o.has_front_ping_ms {
res << vproto.pack_uint32_field(o.front_ping_ms, 2)
}

if o.has_e2e_ping_ms {
res << vproto.pack_uint32_field(o.e2e_ping_ms, 3)
}

return res
}

pub fn cmsgsteamdatagramclientpingsamplereplyroutingcluster_unpack(buf []byte) ?CMsgSteamDatagramClientPingSampleReplyRoutingCluster {
mut res := CMsgSteamDatagramClientPingSampleReplyRoutingCluster{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.id = v
i = ii
}

2 {
res.has_front_ping_ms = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.front_ping_ms = v
i = ii
}

3 {
res.has_e2e_ping_ms = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.e2e_ping_ms = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplereplyroutingcluster() CMsgSteamDatagramClientPingSampleReplyRoutingCluster {
return CMsgSteamDatagramClientPingSampleReplyRoutingCluster{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereplyroutingcluster(o CMsgSteamDatagramClientPingSampleReplyRoutingCluster, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereplyroutingcluster(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientPingSampleReplyRoutingCluster) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramclientpingsamplereplyroutingcluster_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramClientPingSampleReplyDataCenter {
mut:
unknown_fields []vproto.UnknownField
pub mut:
data_center_id u32
has_data_center_id bool
via_relay_id u32
has_via_relay_id bool
e2e_ping_ms u32
has_e2e_ping_ms bool
}
pub fn (o &CMsgSteamDatagramClientPingSampleReplyDataCenter) pack() []byte {
mut res := []byte{}
if o.has_data_center_id {
res << vproto.pack_32bit_field(o.data_center_id, 1)
}

if o.has_via_relay_id {
res << vproto.pack_32bit_field(o.via_relay_id, 2)
}

if o.has_e2e_ping_ms {
res << vproto.pack_uint32_field(o.e2e_ping_ms, 3)
}

return res
}

pub fn cmsgsteamdatagramclientpingsamplereplydatacenter_unpack(buf []byte) ?CMsgSteamDatagramClientPingSampleReplyDataCenter {
mut res := CMsgSteamDatagramClientPingSampleReplyDataCenter{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_data_center_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.data_center_id = v
i = ii
}

2 {
res.has_via_relay_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.via_relay_id = v
i = ii
}

3 {
res.has_e2e_ping_ms = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.e2e_ping_ms = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplereplydatacenter() CMsgSteamDatagramClientPingSampleReplyDataCenter {
return CMsgSteamDatagramClientPingSampleReplyDataCenter{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereplydatacenter(o CMsgSteamDatagramClientPingSampleReplyDataCenter, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereplydatacenter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientPingSampleReplyDataCenter) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramclientpingsamplereplydatacenter_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramClientPingSampleReply {
mut:
unknown_fields []vproto.UnknownField
pub mut:
connection_id u32
has_connection_id bool
routing_clusters []CMsgSteamDatagramClientPingSampleReplyRoutingCluster
data_centers []CMsgSteamDatagramClientPingSampleReplyDataCenter
}
pub fn (o &CMsgSteamDatagramClientPingSampleReply) pack() []byte {
mut res := []byte{}
if o.has_connection_id {
res << vproto.pack_32bit_field(o.connection_id, 1)
}

// [packed=false]
for _, x in o.routing_clusters {
res << zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereplyroutingcluster(x, 2)
}

// [packed=false]
for _, x in o.data_centers {
res << zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereplydatacenter(x, 3)
}

return res
}

pub fn cmsgsteamdatagramclientpingsamplereply_unpack(buf []byte) ?CMsgSteamDatagramClientPingSampleReply {
mut res := CMsgSteamDatagramClientPingSampleReply{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.connection_id = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereplyroutingcluster(cur_buf, tag_wiretype.wire_type)?
res.routing_clusters << v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereplydatacenter(cur_buf, tag_wiretype.wire_type)?
res.data_centers << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplereply() CMsgSteamDatagramClientPingSampleReply {
return CMsgSteamDatagramClientPingSampleReply{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereply(o CMsgSteamDatagramClientPingSampleReply, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientPingSampleReply) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramclientpingsamplereply_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramClientSwitchedPrimaryRouterQuality {
mut:
unknown_fields []vproto.UnknownField
pub mut:
score u32
has_score bool
front_ping u32
has_front_ping bool
back_ping u32
has_back_ping bool
seconds_until_down u32
has_seconds_until_down bool
}
pub fn (o &CMsgSteamDatagramClientSwitchedPrimaryRouterQuality) pack() []byte {
mut res := []byte{}
if o.has_score {
res << vproto.pack_uint32_field(o.score, 1)
}

if o.has_front_ping {
res << vproto.pack_uint32_field(o.front_ping, 2)
}

if o.has_back_ping {
res << vproto.pack_uint32_field(o.back_ping, 3)
}

if o.has_seconds_until_down {
res << vproto.pack_uint32_field(o.seconds_until_down, 4)
}

return res
}

pub fn cmsgsteamdatagramclientswitchedprimaryrouterquality_unpack(buf []byte) ?CMsgSteamDatagramClientSwitchedPrimaryRouterQuality {
mut res := CMsgSteamDatagramClientSwitchedPrimaryRouterQuality{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_score = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.score = v
i = ii
}

2 {
res.has_front_ping = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.front_ping = v
i = ii
}

3 {
res.has_back_ping = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.back_ping = v
i = ii
}

4 {
res.has_seconds_until_down = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_until_down = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientswitchedprimaryrouterquality() CMsgSteamDatagramClientSwitchedPrimaryRouterQuality {
return CMsgSteamDatagramClientSwitchedPrimaryRouterQuality{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimaryrouterquality(o CMsgSteamDatagramClientSwitchedPrimaryRouterQuality, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimaryrouterquality(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientSwitchedPrimaryRouterQuality) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramclientswitchedprimaryrouterquality_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramClientSwitchedPrimary {
mut:
unknown_fields []vproto.UnknownField
pub mut:
connection_id u32
has_connection_id bool
from_ip u32
has_from_ip bool
from_port u32
has_from_port bool
from_router_cluster u32
has_from_router_cluster bool
from_active_time u32
has_from_active_time bool
from_active_packets_recv u32
has_from_active_packets_recv bool
from_dropped_reason string
has_from_dropped_reason bool
gap_ms u32
has_gap_ms bool
from_quality_now CMsgSteamDatagramClientSwitchedPrimaryRouterQuality
has_from_quality_now bool
to_quality_now CMsgSteamDatagramClientSwitchedPrimaryRouterQuality
has_to_quality_now bool
from_quality_then CMsgSteamDatagramClientSwitchedPrimaryRouterQuality
has_from_quality_then bool
to_quality_then CMsgSteamDatagramClientSwitchedPrimaryRouterQuality
has_to_quality_then bool
}
pub fn (o &CMsgSteamDatagramClientSwitchedPrimary) pack() []byte {
mut res := []byte{}
if o.has_connection_id {
res << vproto.pack_32bit_field(o.connection_id, 1)
}

if o.has_from_ip {
res << vproto.pack_32bit_field(o.from_ip, 2)
}

if o.has_from_port {
res << vproto.pack_uint32_field(o.from_port, 3)
}

if o.has_from_router_cluster {
res << vproto.pack_32bit_field(o.from_router_cluster, 4)
}

if o.has_from_active_time {
res << vproto.pack_uint32_field(o.from_active_time, 5)
}

if o.has_from_active_packets_recv {
res << vproto.pack_uint32_field(o.from_active_packets_recv, 6)
}

if o.has_from_dropped_reason {
res << vproto.pack_string_field(o.from_dropped_reason, 7)
}

if o.has_gap_ms {
res << vproto.pack_uint32_field(o.gap_ms, 8)
}

if o.has_from_quality_now {
res << zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimaryrouterquality(o.from_quality_now, 9)
}

if o.has_to_quality_now {
res << zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimaryrouterquality(o.to_quality_now, 10)
}

if o.has_from_quality_then {
res << zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimaryrouterquality(o.from_quality_then, 11)
}

if o.has_to_quality_then {
res << zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimaryrouterquality(o.to_quality_then, 12)
}

return res
}

pub fn cmsgsteamdatagramclientswitchedprimary_unpack(buf []byte) ?CMsgSteamDatagramClientSwitchedPrimary {
mut res := CMsgSteamDatagramClientSwitchedPrimary{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.connection_id = v
i = ii
}

2 {
res.has_from_ip = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.from_ip = v
i = ii
}

3 {
res.has_from_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.from_port = v
i = ii
}

4 {
res.has_from_router_cluster = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.from_router_cluster = v
i = ii
}

5 {
res.has_from_active_time = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.from_active_time = v
i = ii
}

6 {
res.has_from_active_packets_recv = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.from_active_packets_recv = v
i = ii
}

7 {
res.has_from_dropped_reason = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.from_dropped_reason = v
i = ii
}

8 {
res.has_gap_ms = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.gap_ms = v
i = ii
}

9 {
res.has_from_quality_now = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimaryrouterquality(cur_buf, tag_wiretype.wire_type)?
res.from_quality_now = v
i = ii
}

10 {
res.has_to_quality_now = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimaryrouterquality(cur_buf, tag_wiretype.wire_type)?
res.to_quality_now = v
i = ii
}

11 {
res.has_from_quality_then = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimaryrouterquality(cur_buf, tag_wiretype.wire_type)?
res.from_quality_then = v
i = ii
}

12 {
res.has_to_quality_then = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimaryrouterquality(cur_buf, tag_wiretype.wire_type)?
res.to_quality_then = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientswitchedprimary() CMsgSteamDatagramClientSwitchedPrimary {
return CMsgSteamDatagramClientSwitchedPrimary{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimary(o CMsgSteamDatagramClientSwitchedPrimary, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientSwitchedPrimary) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramclientswitchedprimary_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramConnectRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
connection_id u32
has_connection_id bool
my_timestamp u64
has_my_timestamp bool
ping_est_ms u32
has_ping_est_ms bool
virtual_port u32
has_virtual_port bool
gameserver_relay_session_id u32
has_gameserver_relay_session_id bool
crypt CMsgSteamDatagramSessionCryptInfoSigned
has_crypt bool
cert CMsgSteamDatagramCertificateSigned
has_cert bool
routing_secret u64
has_routing_secret bool
legacy_client_steam_id u64
has_legacy_client_steam_id bool
}
pub fn (o &CMsgSteamDatagramConnectRequest) pack() []byte {
mut res := []byte{}
if o.has_connection_id {
res << vproto.pack_32bit_field(o.connection_id, 1)
}

if o.has_my_timestamp {
res << vproto.pack_64bit_field(o.my_timestamp, 4)
}

if o.has_ping_est_ms {
res << vproto.pack_uint32_field(o.ping_est_ms, 5)
}

if o.has_virtual_port {
res << vproto.pack_uint32_field(o.virtual_port, 9)
}

if o.has_gameserver_relay_session_id {
res << vproto.pack_uint32_field(o.gameserver_relay_session_id, 2)
}

if o.has_crypt {
res << zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfosigned(o.crypt, 6)
}

if o.has_cert {
res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 7)
}

if o.has_routing_secret {
res << vproto.pack_64bit_field(o.routing_secret, 10)
}

if o.has_legacy_client_steam_id {
res << vproto.pack_64bit_field(o.legacy_client_steam_id, 3)
}

return res
}

pub fn cmsgsteamdatagramconnectrequest_unpack(buf []byte) ?CMsgSteamDatagramConnectRequest {
mut res := CMsgSteamDatagramConnectRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.connection_id = v
i = ii
}

4 {
res.has_my_timestamp = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.my_timestamp = v
i = ii
}

5 {
res.has_ping_est_ms = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ping_est_ms = v
i = ii
}

9 {
res.has_virtual_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.virtual_port = v
i = ii
}

2 {
res.has_gameserver_relay_session_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.gameserver_relay_session_id = v
i = ii
}

6 {
res.has_crypt = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfosigned(cur_buf, tag_wiretype.wire_type)?
res.crypt = v
i = ii
}

7 {
res.has_cert = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf, tag_wiretype.wire_type)?
res.cert = v
i = ii
}

10 {
res.has_routing_secret = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.routing_secret = v
i = ii
}

3 {
res.has_legacy_client_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_client_steam_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectrequest() CMsgSteamDatagramConnectRequest {
return CMsgSteamDatagramConnectRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectrequest(o CMsgSteamDatagramConnectRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramconnectrequest_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramConnectOK {
mut:
unknown_fields []vproto.UnknownField
pub mut:
client_connection_id u32
has_client_connection_id bool
server_connection_id u32
has_server_connection_id bool
your_timestamp u64
has_your_timestamp bool
delay_time_usec u32
has_delay_time_usec bool
gameserver_relay_session_id u32
has_gameserver_relay_session_id bool
crypt CMsgSteamDatagramSessionCryptInfoSigned
has_crypt bool
cert CMsgSteamDatagramCertificateSigned
has_cert bool
}
pub fn (o &CMsgSteamDatagramConnectOK) pack() []byte {
mut res := []byte{}
if o.has_client_connection_id {
res << vproto.pack_32bit_field(o.client_connection_id, 1)
}

if o.has_server_connection_id {
res << vproto.pack_32bit_field(o.server_connection_id, 7)
}

if o.has_your_timestamp {
res << vproto.pack_64bit_field(o.your_timestamp, 3)
}

if o.has_delay_time_usec {
res << vproto.pack_uint32_field(o.delay_time_usec, 4)
}

if o.has_gameserver_relay_session_id {
res << vproto.pack_uint32_field(o.gameserver_relay_session_id, 2)
}

if o.has_crypt {
res << zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfosigned(o.crypt, 5)
}

if o.has_cert {
res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 6)
}

return res
}

pub fn cmsgsteamdatagramconnectok_unpack(buf []byte) ?CMsgSteamDatagramConnectOK {
mut res := CMsgSteamDatagramConnectOK{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_client_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.client_connection_id = v
i = ii
}

7 {
res.has_server_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.server_connection_id = v
i = ii
}

3 {
res.has_your_timestamp = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.your_timestamp = v
i = ii
}

4 {
res.has_delay_time_usec = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.delay_time_usec = v
i = ii
}

2 {
res.has_gameserver_relay_session_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.gameserver_relay_session_id = v
i = ii
}

5 {
res.has_crypt = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfosigned(cur_buf, tag_wiretype.wire_type)?
res.crypt = v
i = ii
}

6 {
res.has_cert = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf, tag_wiretype.wire_type)?
res.cert = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectok() CMsgSteamDatagramConnectOK {
return CMsgSteamDatagramConnectOK{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectok(o CMsgSteamDatagramConnectOK, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectok(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectOK) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramconnectok_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamNetworkingP2PSdrroutingSummary {
mut:
unknown_fields []vproto.UnknownField
pub mut:
initial_ping u32
has_initial_ping bool
initial_ping_front_local u32
has_initial_ping_front_local bool
initial_ping_front_remote u32
has_initial_ping_front_remote bool
initial_score u32
has_initial_score bool
initial_pop_local u32
has_initial_pop_local bool
initial_pop_remote u32
has_initial_pop_remote bool
negotiation_ms u32
has_negotiation_ms bool
selected_seconds u32
has_selected_seconds bool
}
pub fn (o &CMsgSteamNetworkingP2PSdrroutingSummary) pack() []byte {
mut res := []byte{}
if o.has_initial_ping {
res << vproto.pack_uint32_field(o.initial_ping, 1)
}

if o.has_initial_ping_front_local {
res << vproto.pack_uint32_field(o.initial_ping_front_local, 2)
}

if o.has_initial_ping_front_remote {
res << vproto.pack_uint32_field(o.initial_ping_front_remote, 3)
}

if o.has_initial_score {
res << vproto.pack_uint32_field(o.initial_score, 4)
}

if o.has_initial_pop_local {
res << vproto.pack_32bit_field(o.initial_pop_local, 5)
}

if o.has_initial_pop_remote {
res << vproto.pack_32bit_field(o.initial_pop_remote, 6)
}

if o.has_negotiation_ms {
res << vproto.pack_uint32_field(o.negotiation_ms, 7)
}

if o.has_selected_seconds {
res << vproto.pack_uint32_field(o.selected_seconds, 8)
}

return res
}

pub fn cmsgsteamnetworkingp2psdrroutingsummary_unpack(buf []byte) ?CMsgSteamNetworkingP2PSdrroutingSummary {
mut res := CMsgSteamNetworkingP2PSdrroutingSummary{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_initial_ping = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.initial_ping = v
i = ii
}

2 {
res.has_initial_ping_front_local = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.initial_ping_front_local = v
i = ii
}

3 {
res.has_initial_ping_front_remote = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.initial_ping_front_remote = v
i = ii
}

4 {
res.has_initial_score = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.initial_score = v
i = ii
}

5 {
res.has_initial_pop_local = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.initial_pop_local = v
i = ii
}

6 {
res.has_initial_pop_remote = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.initial_pop_remote = v
i = ii
}

7 {
res.has_negotiation_ms = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.negotiation_ms = v
i = ii
}

8 {
res.has_selected_seconds = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.selected_seconds = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingp2psdrroutingsummary() CMsgSteamNetworkingP2PSdrroutingSummary {
return CMsgSteamNetworkingP2PSdrroutingSummary{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingp2psdrroutingsummary(o CMsgSteamNetworkingP2PSdrroutingSummary, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingp2psdrroutingsummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingP2PSdrroutingSummary) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamnetworkingp2psdrroutingsummary_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramP2PRoutingSummary {
mut:
unknown_fields []vproto.UnknownField
pub mut:
ice CMsgSteamNetworkingICesessionSummary
has_ice bool
sdr CMsgSteamNetworkingP2PSdrroutingSummary
has_sdr bool
}
pub fn (o &CMsgSteamDatagramP2PRoutingSummary) pack() []byte {
mut res := []byte{}
if o.has_ice {
res << zzz_vproto_internal_pack_cmsgsteamnetworkingicesessionsummary(o.ice, 2)
}

if o.has_sdr {
res << zzz_vproto_internal_pack_cmsgsteamnetworkingp2psdrroutingsummary(o.sdr, 3)
}

return res
}

pub fn cmsgsteamdatagramp2proutingsummary_unpack(buf []byte) ?CMsgSteamDatagramP2PRoutingSummary {
mut res := CMsgSteamDatagramP2PRoutingSummary{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
2 {
res.has_ice = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingicesessionsummary(cur_buf, tag_wiretype.wire_type)?
res.ice = v
i = ii
}

3 {
res.has_sdr = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingp2psdrroutingsummary(cur_buf, tag_wiretype.wire_type)?
res.sdr = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2proutingsummary() CMsgSteamDatagramP2PRoutingSummary {
return CMsgSteamDatagramP2PRoutingSummary{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2proutingsummary(o CMsgSteamDatagramP2PRoutingSummary, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutingsummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PRoutingSummary) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramp2proutingsummary_unpack(v)?
return i, unpacked
}
[_allow_multiple_values]
enum CMsgSteamDatagramConnectionClosedERelayMode {
@none = 0
endtoend = 1
closedbypeer = 2
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionclosederelaymode(e CMsgSteamDatagramConnectionClosedERelayMode, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionclosederelaymode(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionClosedERelayMode) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, CMsgSteamDatagramConnectionClosedERelayMode(v)
}
pub struct CMsgSteamDatagramConnectionClosed {
mut:
unknown_fields []vproto.UnknownField
pub mut:
to_connection_id u32
has_to_connection_id bool
from_connection_id u32
has_from_connection_id bool
from_identity_string string
has_from_identity_string bool
legacy_from_identity_binary CMsgSteamNetworkingIdentityLegacyBinary
has_legacy_from_identity_binary bool
legacy_from_steam_id u64
has_legacy_from_steam_id bool
legacy_gameserver_relay_session_id u32
has_legacy_gameserver_relay_session_id bool
to_relay_session_id u32
has_to_relay_session_id bool
from_relay_session_id u32
has_from_relay_session_id bool
forward_target_relay_routing_token []byte
has_forward_target_relay_routing_token bool
forward_target_revision u32
has_forward_target_revision bool
relay_mode CMsgSteamDatagramConnectionClosedERelayMode
has_relay_mode bool
debug string
has_debug bool
reason_code u32
has_reason_code bool
routing_secret u64
has_routing_secret bool
not_primary_session bool
has_not_primary_session bool
not_primary_transport bool
has_not_primary_transport bool
quality_relay CMsgSteamDatagramConnectionQuality
has_quality_relay bool
quality_e2e CMsgSteamDatagramConnectionQuality
has_quality_e2e bool
p2p_routing_summary CMsgSteamDatagramP2PRoutingSummary
has_p2p_routing_summary bool
}
pub fn (o &CMsgSteamDatagramConnectionClosed) pack() []byte {
mut res := []byte{}
if o.has_to_connection_id {
res << vproto.pack_32bit_field(o.to_connection_id, 7)
}

if o.has_from_connection_id {
res << vproto.pack_32bit_field(o.from_connection_id, 8)
}

if o.has_from_identity_string {
res << vproto.pack_string_field(o.from_identity_string, 15)
}

if o.has_legacy_from_identity_binary {
res << zzz_vproto_internal_pack_cmsgsteamnetworkingidentitylegacybinary(o.legacy_from_identity_binary, 13)
}

if o.has_legacy_from_steam_id {
res << vproto.pack_64bit_field(o.legacy_from_steam_id, 3)
}

if o.has_legacy_gameserver_relay_session_id {
res << vproto.pack_uint32_field(o.legacy_gameserver_relay_session_id, 2)
}

if o.has_to_relay_session_id {
res << vproto.pack_32bit_field(o.to_relay_session_id, 9)
}

if o.has_from_relay_session_id {
res << vproto.pack_32bit_field(o.from_relay_session_id, 10)
}

if o.has_forward_target_relay_routing_token {
res << vproto.pack_bytes_field(o.forward_target_relay_routing_token, 11)
}

if o.has_forward_target_revision {
res << vproto.pack_uint32_field(o.forward_target_revision, 12)
}

if o.has_relay_mode {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionclosederelaymode(o.relay_mode, 4)
}

if o.has_debug {
res << vproto.pack_string_field(o.debug, 5)
}

if o.has_reason_code {
res << vproto.pack_uint32_field(o.reason_code, 6)
}

if o.has_routing_secret {
res << vproto.pack_64bit_field(o.routing_secret, 14)
}

if o.has_not_primary_session {
res << vproto.pack_bool_field(o.not_primary_session, 16)
}

if o.has_not_primary_transport {
res << vproto.pack_bool_field(o.not_primary_transport, 19)
}

if o.has_quality_relay {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 17)
}

if o.has_quality_e2e {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 18)
}

if o.has_p2p_routing_summary {
res << zzz_vproto_internal_pack_cmsgsteamdatagramp2proutingsummary(o.p2p_routing_summary, 21)
}

return res
}

pub fn cmsgsteamdatagramconnectionclosed_unpack(buf []byte) ?CMsgSteamDatagramConnectionClosed {
mut res := CMsgSteamDatagramConnectionClosed{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
7 {
res.has_to_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.to_connection_id = v
i = ii
}

8 {
res.has_from_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.from_connection_id = v
i = ii
}

15 {
res.has_from_identity_string = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.from_identity_string = v
i = ii
}

13 {
res.has_legacy_from_identity_binary = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingidentitylegacybinary(cur_buf, tag_wiretype.wire_type)?
res.legacy_from_identity_binary = v
i = ii
}

3 {
res.has_legacy_from_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_from_steam_id = v
i = ii
}

2 {
res.has_legacy_gameserver_relay_session_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_gameserver_relay_session_id = v
i = ii
}

9 {
res.has_to_relay_session_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.to_relay_session_id = v
i = ii
}

10 {
res.has_from_relay_session_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.from_relay_session_id = v
i = ii
}

11 {
res.has_forward_target_relay_routing_token = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.forward_target_relay_routing_token = v
i = ii
}

12 {
res.has_forward_target_revision = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.forward_target_revision = v
i = ii
}

4 {
res.has_relay_mode = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionclosederelaymode(cur_buf, tag_wiretype.wire_type)?
res.relay_mode = v
i = ii
}

5 {
res.has_debug = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.debug = v
i = ii
}

6 {
res.has_reason_code = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.reason_code = v
i = ii
}

14 {
res.has_routing_secret = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.routing_secret = v
i = ii
}

16 {
res.has_not_primary_session = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.not_primary_session = v
i = ii
}

19 {
res.has_not_primary_transport = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.not_primary_transport = v
i = ii
}

17 {
res.has_quality_relay = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_relay = v
i = ii
}

18 {
res.has_quality_e2e = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_e2e = v
i = ii
}

21 {
res.has_p2p_routing_summary = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutingsummary(cur_buf, tag_wiretype.wire_type)?
res.p2p_routing_summary = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionclosed() CMsgSteamDatagramConnectionClosed {
return CMsgSteamDatagramConnectionClosed{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionclosed(o CMsgSteamDatagramConnectionClosed, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionclosed(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionClosed) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramconnectionclosed_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramNoConnection {
mut:
unknown_fields []vproto.UnknownField
pub mut:
to_connection_id u32
has_to_connection_id bool
from_connection_id u32
has_from_connection_id bool
legacy_gameserver_relay_session_id u32
has_legacy_gameserver_relay_session_id bool
to_relay_session_id u32
has_to_relay_session_id bool
from_relay_session_id u32
has_from_relay_session_id bool
from_identity_string string
has_from_identity_string bool
legacy_from_steam_id u64
has_legacy_from_steam_id bool
end_to_end bool
has_end_to_end bool
not_primary_session bool
has_not_primary_session bool
not_primary_transport bool
has_not_primary_transport bool
quality_relay CMsgSteamDatagramConnectionQuality
has_quality_relay bool
quality_e2e CMsgSteamDatagramConnectionQuality
has_quality_e2e bool
p2p_routing_summary CMsgSteamDatagramP2PRoutingSummary
has_p2p_routing_summary bool
routing_secret u64
has_routing_secret bool
dummy_pad u32
has_dummy_pad bool
}
pub fn (o &CMsgSteamDatagramNoConnection) pack() []byte {
mut res := []byte{}
if o.has_to_connection_id {
res << vproto.pack_32bit_field(o.to_connection_id, 5)
}

if o.has_from_connection_id {
res << vproto.pack_32bit_field(o.from_connection_id, 6)
}

if o.has_legacy_gameserver_relay_session_id {
res << vproto.pack_uint32_field(o.legacy_gameserver_relay_session_id, 2)
}

if o.has_to_relay_session_id {
res << vproto.pack_32bit_field(o.to_relay_session_id, 9)
}

if o.has_from_relay_session_id {
res << vproto.pack_32bit_field(o.from_relay_session_id, 10)
}

if o.has_from_identity_string {
res << vproto.pack_string_field(o.from_identity_string, 7)
}

if o.has_legacy_from_steam_id {
res << vproto.pack_64bit_field(o.legacy_from_steam_id, 3)
}

if o.has_end_to_end {
res << vproto.pack_bool_field(o.end_to_end, 4)
}

if o.has_not_primary_session {
res << vproto.pack_bool_field(o.not_primary_session, 12)
}

if o.has_not_primary_transport {
res << vproto.pack_bool_field(o.not_primary_transport, 15)
}

if o.has_quality_relay {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 13)
}

if o.has_quality_e2e {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 14)
}

if o.has_p2p_routing_summary {
res << zzz_vproto_internal_pack_cmsgsteamdatagramp2proutingsummary(o.p2p_routing_summary, 16)
}

if o.has_routing_secret {
res << vproto.pack_64bit_field(o.routing_secret, 11)
}

if o.has_dummy_pad {
res << vproto.pack_32bit_field(o.dummy_pad, 1023)
}

return res
}

pub fn cmsgsteamdatagramnoconnection_unpack(buf []byte) ?CMsgSteamDatagramNoConnection {
mut res := CMsgSteamDatagramNoConnection{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
5 {
res.has_to_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.to_connection_id = v
i = ii
}

6 {
res.has_from_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.from_connection_id = v
i = ii
}

2 {
res.has_legacy_gameserver_relay_session_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_gameserver_relay_session_id = v
i = ii
}

9 {
res.has_to_relay_session_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.to_relay_session_id = v
i = ii
}

10 {
res.has_from_relay_session_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.from_relay_session_id = v
i = ii
}

7 {
res.has_from_identity_string = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.from_identity_string = v
i = ii
}

3 {
res.has_legacy_from_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_from_steam_id = v
i = ii
}

4 {
res.has_end_to_end = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.end_to_end = v
i = ii
}

12 {
res.has_not_primary_session = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.not_primary_session = v
i = ii
}

15 {
res.has_not_primary_transport = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.not_primary_transport = v
i = ii
}

13 {
res.has_quality_relay = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_relay = v
i = ii
}

14 {
res.has_quality_e2e = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_e2e = v
i = ii
}

16 {
res.has_p2p_routing_summary = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutingsummary(cur_buf, tag_wiretype.wire_type)?
res.p2p_routing_summary = v
i = ii
}

11 {
res.has_routing_secret = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.routing_secret = v
i = ii
}

1023 {
res.has_dummy_pad = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.dummy_pad = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramnoconnection() CMsgSteamDatagramNoConnection {
return CMsgSteamDatagramNoConnection{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramnoconnection(o CMsgSteamDatagramNoConnection, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramnoconnection(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramNoConnection) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramnoconnection_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramGameserverSessionRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
ticket []byte
has_ticket bool
challenge_time u32
has_challenge_time bool
challenge u64
has_challenge bool
client_connection_id u32
has_client_connection_id bool
server_connection_id u32
has_server_connection_id bool
network_config_version u32
has_network_config_version bool
protocol_version u32
has_protocol_version bool
}
pub fn (o &CMsgSteamDatagramGameserverSessionRequest) pack() []byte {
mut res := []byte{}
if o.has_ticket {
res << vproto.pack_bytes_field(o.ticket, 1)
}

if o.has_challenge_time {
res << vproto.pack_32bit_field(o.challenge_time, 3)
}

if o.has_challenge {
res << vproto.pack_64bit_field(o.challenge, 4)
}

if o.has_client_connection_id {
res << vproto.pack_32bit_field(o.client_connection_id, 5)
}

if o.has_server_connection_id {
res << vproto.pack_32bit_field(o.server_connection_id, 8)
}

if o.has_network_config_version {
res << vproto.pack_uint32_field(o.network_config_version, 6)
}

if o.has_protocol_version {
res << vproto.pack_uint32_field(o.protocol_version, 7)
}

return res
}

pub fn cmsgsteamdatagramgameserversessionrequest_unpack(buf []byte) ?CMsgSteamDatagramGameserverSessionRequest {
mut res := CMsgSteamDatagramGameserverSessionRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_ticket = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.ticket = v
i = ii
}

3 {
res.has_challenge_time = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.challenge_time = v
i = ii
}

4 {
res.has_challenge = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.challenge = v
i = ii
}

5 {
res.has_client_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.client_connection_id = v
i = ii
}

8 {
res.has_server_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.server_connection_id = v
i = ii
}

6 {
res.has_network_config_version = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.network_config_version = v
i = ii
}

7 {
res.has_protocol_version = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.protocol_version = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserversessionrequest() CMsgSteamDatagramGameserverSessionRequest {
return CMsgSteamDatagramGameserverSessionRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserversessionrequest(o CMsgSteamDatagramGameserverSessionRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversessionrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverSessionRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramgameserversessionrequest_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramGameserverSessionEstablished {
mut:
unknown_fields []vproto.UnknownField
pub mut:
connection_id u32
has_connection_id bool
gameserver_identity_string string
has_gameserver_identity_string bool
seconds_until_shutdown u32
has_seconds_until_shutdown bool
seq_num_r2c u32
has_seq_num_r2c bool
dummy_legacy_identity_binary []byte
has_dummy_legacy_identity_binary bool
legacy_gameserver_steamid u64
has_legacy_gameserver_steamid bool
}
pub fn (o &CMsgSteamDatagramGameserverSessionEstablished) pack() []byte {
mut res := []byte{}
if o.has_connection_id {
res << vproto.pack_32bit_field(o.connection_id, 1)
}

if o.has_gameserver_identity_string {
res << vproto.pack_string_field(o.gameserver_identity_string, 2)
}

if o.has_seconds_until_shutdown {
res << vproto.pack_uint32_field(o.seconds_until_shutdown, 4)
}

if o.has_seq_num_r2c {
res << vproto.pack_uint32_field(o.seq_num_r2c, 6)
}

if o.has_dummy_legacy_identity_binary {
res << vproto.pack_bytes_field(o.dummy_legacy_identity_binary, 7)
}

if o.has_legacy_gameserver_steamid {
res << vproto.pack_64bit_field(o.legacy_gameserver_steamid, 3)
}

return res
}

pub fn cmsgsteamdatagramgameserversessionestablished_unpack(buf []byte) ?CMsgSteamDatagramGameserverSessionEstablished {
mut res := CMsgSteamDatagramGameserverSessionEstablished{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.connection_id = v
i = ii
}

2 {
res.has_gameserver_identity_string = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.gameserver_identity_string = v
i = ii
}

4 {
res.has_seconds_until_shutdown = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_until_shutdown = v
i = ii
}

6 {
res.has_seq_num_r2c = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_r2c = v
i = ii
}

7 {
res.has_dummy_legacy_identity_binary = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.dummy_legacy_identity_binary = v
i = ii
}

3 {
res.has_legacy_gameserver_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_gameserver_steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserversessionestablished() CMsgSteamDatagramGameserverSessionEstablished {
return CMsgSteamDatagramGameserverSessionEstablished{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserversessionestablished(o CMsgSteamDatagramGameserverSessionEstablished, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversessionestablished(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverSessionEstablished) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramgameserversessionestablished_unpack(v)?
return i, unpacked
}
[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsClientToRouterFlags {
ack_request_relay = 1
ack_request_e2e = 2
ack_request_immediate = 4
not_primary_session = 8
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsclienttorouterflags(e CMsgSteamDatagramConnectionStatsClientToRouterFlags, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsclienttorouterflags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsClientToRouterFlags) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, CMsgSteamDatagramConnectionStatsClientToRouterFlags(v)
}
pub struct CMsgSteamDatagramConnectionStatsClientToRouter {
mut:
unknown_fields []vproto.UnknownField
pub mut:
quality_relay CMsgSteamDatagramConnectionQuality
has_quality_relay bool
quality_e2e CMsgSteamDatagramConnectionQuality
has_quality_e2e bool
ack_relay []u32
legacy_ack_e2e []u32
flags u32
has_flags bool
client_connection_id u32
has_client_connection_id bool
seq_num_c2r u32
has_seq_num_c2r bool
seq_num_e2e u32
has_seq_num_e2e bool
}
pub fn (o &CMsgSteamDatagramConnectionStatsClientToRouter) pack() []byte {
mut res := []byte{}
if o.has_quality_relay {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
}

if o.has_quality_e2e {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
}

// [packed=false]
for _, x in o.ack_relay {
res << vproto.pack_32bit_field(x, 4)
}

// [packed=false]
for _, x in o.legacy_ack_e2e {
res << vproto.pack_32bit_field(x, 5)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 6)
}

if o.has_client_connection_id {
res << vproto.pack_32bit_field(o.client_connection_id, 8)
}

if o.has_seq_num_c2r {
res << vproto.pack_uint32_field(o.seq_num_c2r, 9)
}

if o.has_seq_num_e2e {
res << vproto.pack_uint32_field(o.seq_num_e2e, 10)
}

return res
}

pub fn cmsgsteamdatagramconnectionstatsclienttorouter_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsClientToRouter {
mut res := CMsgSteamDatagramConnectionStatsClientToRouter{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_quality_relay = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_relay = v
i = ii
}

2 {
res.has_quality_e2e = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_e2e = v
i = ii
}

4 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.ack_relay << v
i = ii
}

5 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_ack_e2e << v
i = ii
}

6 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

8 {
res.has_client_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.client_connection_id = v
i = ii
}

9 {
res.has_seq_num_c2r = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_c2r = v
i = ii
}

10 {
res.has_seq_num_e2e = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_e2e = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsclienttorouter() CMsgSteamDatagramConnectionStatsClientToRouter {
return CMsgSteamDatagramConnectionStatsClientToRouter{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsclienttorouter(o CMsgSteamDatagramConnectionStatsClientToRouter, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsclienttorouter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsClientToRouter) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramconnectionstatsclienttorouter_unpack(v)?
return i, unpacked
}
[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsRouterToClientFlags {
ack_request_relay = 1
ack_request_e2e = 2
ack_request_immediate = 4
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoclientflags(e CMsgSteamDatagramConnectionStatsRouterToClientFlags, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoclientflags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsRouterToClientFlags) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, CMsgSteamDatagramConnectionStatsRouterToClientFlags(v)
}
pub struct CMsgSteamDatagramConnectionStatsRouterToClient {
mut:
unknown_fields []vproto.UnknownField
pub mut:
quality_relay CMsgSteamDatagramConnectionQuality
has_quality_relay bool
quality_e2e CMsgSteamDatagramConnectionQuality
has_quality_e2e bool
seconds_until_shutdown u32
has_seconds_until_shutdown bool
migrate_request_ip u32
has_migrate_request_ip bool
migrate_request_port u32
has_migrate_request_port bool
scoring_penalty_relay_cluster u32
has_scoring_penalty_relay_cluster bool
ack_relay []u32
legacy_ack_e2e []u32
flags u32
has_flags bool
client_connection_id u32
has_client_connection_id bool
seq_num_r2c u32
has_seq_num_r2c bool
seq_num_e2e u32
has_seq_num_e2e bool
}
pub fn (o &CMsgSteamDatagramConnectionStatsRouterToClient) pack() []byte {
mut res := []byte{}
if o.has_quality_relay {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
}

if o.has_quality_e2e {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
}

if o.has_seconds_until_shutdown {
res << vproto.pack_uint32_field(o.seconds_until_shutdown, 6)
}

if o.has_migrate_request_ip {
res << vproto.pack_32bit_field(o.migrate_request_ip, 10)
}

if o.has_migrate_request_port {
res << vproto.pack_uint32_field(o.migrate_request_port, 11)
}

if o.has_scoring_penalty_relay_cluster {
res << vproto.pack_uint32_field(o.scoring_penalty_relay_cluster, 12)
}

// [packed=false]
for _, x in o.ack_relay {
res << vproto.pack_32bit_field(x, 13)
}

// [packed=false]
for _, x in o.legacy_ack_e2e {
res << vproto.pack_32bit_field(x, 14)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 15)
}

if o.has_client_connection_id {
res << vproto.pack_32bit_field(o.client_connection_id, 7)
}

if o.has_seq_num_r2c {
res << vproto.pack_uint32_field(o.seq_num_r2c, 8)
}

if o.has_seq_num_e2e {
res << vproto.pack_uint32_field(o.seq_num_e2e, 9)
}

return res
}

pub fn cmsgsteamdatagramconnectionstatsroutertoclient_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsRouterToClient {
mut res := CMsgSteamDatagramConnectionStatsRouterToClient{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_quality_relay = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_relay = v
i = ii
}

2 {
res.has_quality_e2e = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_e2e = v
i = ii
}

6 {
res.has_seconds_until_shutdown = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_until_shutdown = v
i = ii
}

10 {
res.has_migrate_request_ip = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.migrate_request_ip = v
i = ii
}

11 {
res.has_migrate_request_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.migrate_request_port = v
i = ii
}

12 {
res.has_scoring_penalty_relay_cluster = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.scoring_penalty_relay_cluster = v
i = ii
}

13 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.ack_relay << v
i = ii
}

14 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_ack_e2e << v
i = ii
}

15 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

7 {
res.has_client_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.client_connection_id = v
i = ii
}

8 {
res.has_seq_num_r2c = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_r2c = v
i = ii
}

9 {
res.has_seq_num_e2e = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_e2e = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsroutertoclient() CMsgSteamDatagramConnectionStatsRouterToClient {
return CMsgSteamDatagramConnectionStatsRouterToClient{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoclient(o CMsgSteamDatagramConnectionStatsRouterToClient, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsRouterToClient) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramconnectionstatsroutertoclient_unpack(v)?
return i, unpacked
}
[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsRouterToServerFlags {
ack_request_relay = 1
ack_request_e2e = 2
ack_request_immediate = 4
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoserverflags(e CMsgSteamDatagramConnectionStatsRouterToServerFlags, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoserverflags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsRouterToServerFlags) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, CMsgSteamDatagramConnectionStatsRouterToServerFlags(v)
}
pub struct CMsgSteamDatagramConnectionStatsRouterToServer {
mut:
unknown_fields []vproto.UnknownField
pub mut:
quality_relay CMsgSteamDatagramConnectionQuality
has_quality_relay bool
quality_e2e CMsgSteamDatagramConnectionQuality
has_quality_e2e bool
ack_relay []u32
legacy_ack_e2e []u32
flags u32
has_flags bool
seq_num_r2s u32
has_seq_num_r2s bool
seq_num_e2e u32
has_seq_num_e2e bool
client_identity_string string
has_client_identity_string bool
legacy_client_steam_id u64
has_legacy_client_steam_id bool
relay_session_id u32
has_relay_session_id bool
client_connection_id u32
has_client_connection_id bool
server_connection_id u32
has_server_connection_id bool
routing_secret u64
has_routing_secret bool
}
pub fn (o &CMsgSteamDatagramConnectionStatsRouterToServer) pack() []byte {
mut res := []byte{}
if o.has_quality_relay {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
}

if o.has_quality_e2e {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
}

// [packed=false]
for _, x in o.ack_relay {
res << vproto.pack_32bit_field(x, 10)
}

// [packed=false]
for _, x in o.legacy_ack_e2e {
res << vproto.pack_32bit_field(x, 11)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 12)
}

if o.has_seq_num_r2s {
res << vproto.pack_uint32_field(o.seq_num_r2s, 5)
}

if o.has_seq_num_e2e {
res << vproto.pack_uint32_field(o.seq_num_e2e, 6)
}

if o.has_client_identity_string {
res << vproto.pack_string_field(o.client_identity_string, 15)
}

if o.has_legacy_client_steam_id {
res << vproto.pack_64bit_field(o.legacy_client_steam_id, 7)
}

if o.has_relay_session_id {
res << vproto.pack_uint32_field(o.relay_session_id, 8)
}

if o.has_client_connection_id {
res << vproto.pack_32bit_field(o.client_connection_id, 9)
}

if o.has_server_connection_id {
res << vproto.pack_32bit_field(o.server_connection_id, 13)
}

if o.has_routing_secret {
res << vproto.pack_64bit_field(o.routing_secret, 14)
}

return res
}

pub fn cmsgsteamdatagramconnectionstatsroutertoserver_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsRouterToServer {
mut res := CMsgSteamDatagramConnectionStatsRouterToServer{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_quality_relay = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_relay = v
i = ii
}

2 {
res.has_quality_e2e = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_e2e = v
i = ii
}

10 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.ack_relay << v
i = ii
}

11 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_ack_e2e << v
i = ii
}

12 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

5 {
res.has_seq_num_r2s = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_r2s = v
i = ii
}

6 {
res.has_seq_num_e2e = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_e2e = v
i = ii
}

15 {
res.has_client_identity_string = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.client_identity_string = v
i = ii
}

7 {
res.has_legacy_client_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_client_steam_id = v
i = ii
}

8 {
res.has_relay_session_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.relay_session_id = v
i = ii
}

9 {
res.has_client_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.client_connection_id = v
i = ii
}

13 {
res.has_server_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.server_connection_id = v
i = ii
}

14 {
res.has_routing_secret = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.routing_secret = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsroutertoserver() CMsgSteamDatagramConnectionStatsRouterToServer {
return CMsgSteamDatagramConnectionStatsRouterToServer{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoserver(o CMsgSteamDatagramConnectionStatsRouterToServer, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoserver(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsRouterToServer) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramconnectionstatsroutertoserver_unpack(v)?
return i, unpacked
}
[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsServerToRouterFlags {
ack_request_relay = 1
ack_request_e2e = 2
ack_request_immediate = 4
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsservertorouterflags(e CMsgSteamDatagramConnectionStatsServerToRouterFlags, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsservertorouterflags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsServerToRouterFlags) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, CMsgSteamDatagramConnectionStatsServerToRouterFlags(v)
}
pub struct CMsgSteamDatagramConnectionStatsServerToRouter {
mut:
unknown_fields []vproto.UnknownField
pub mut:
quality_relay CMsgSteamDatagramConnectionQuality
has_quality_relay bool
quality_e2e CMsgSteamDatagramConnectionQuality
has_quality_e2e bool
ack_relay []u32
legacy_ack_e2e []u32
flags u32
has_flags bool
seq_num_s2r u32
has_seq_num_s2r bool
seq_num_e2e u32
has_seq_num_e2e bool
relay_session_id u32
has_relay_session_id bool
client_connection_id u32
has_client_connection_id bool
server_connection_id u32
has_server_connection_id bool
}
pub fn (o &CMsgSteamDatagramConnectionStatsServerToRouter) pack() []byte {
mut res := []byte{}
if o.has_quality_relay {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
}

if o.has_quality_e2e {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
}

// [packed=false]
for _, x in o.ack_relay {
res << vproto.pack_32bit_field(x, 8)
}

// [packed=false]
for _, x in o.legacy_ack_e2e {
res << vproto.pack_32bit_field(x, 9)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 10)
}

if o.has_seq_num_s2r {
res << vproto.pack_uint32_field(o.seq_num_s2r, 3)
}

if o.has_seq_num_e2e {
res << vproto.pack_uint32_field(o.seq_num_e2e, 4)
}

if o.has_relay_session_id {
res << vproto.pack_uint32_field(o.relay_session_id, 6)
}

if o.has_client_connection_id {
res << vproto.pack_32bit_field(o.client_connection_id, 7)
}

if o.has_server_connection_id {
res << vproto.pack_32bit_field(o.server_connection_id, 11)
}

return res
}

pub fn cmsgsteamdatagramconnectionstatsservertorouter_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsServerToRouter {
mut res := CMsgSteamDatagramConnectionStatsServerToRouter{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_quality_relay = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_relay = v
i = ii
}

2 {
res.has_quality_e2e = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_e2e = v
i = ii
}

8 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.ack_relay << v
i = ii
}

9 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_ack_e2e << v
i = ii
}

10 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

3 {
res.has_seq_num_s2r = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_s2r = v
i = ii
}

4 {
res.has_seq_num_e2e = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_e2e = v
i = ii
}

6 {
res.has_relay_session_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.relay_session_id = v
i = ii
}

7 {
res.has_client_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.client_connection_id = v
i = ii
}

11 {
res.has_server_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.server_connection_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsservertorouter() CMsgSteamDatagramConnectionStatsServerToRouter {
return CMsgSteamDatagramConnectionStatsServerToRouter{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsservertorouter(o CMsgSteamDatagramConnectionStatsServerToRouter, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsservertorouter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsServerToRouter) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramconnectionstatsservertorouter_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramP2PSessionRequestBody {
mut:
unknown_fields []vproto.UnknownField
pub mut:
challenge_time u32
has_challenge_time bool
challenge u64
has_challenge bool
client_connection_id u32
has_client_connection_id bool
legacy_peer_steam_id u64
has_legacy_peer_steam_id bool
peer_identity_string string
has_peer_identity_string bool
peer_connection_id u32
has_peer_connection_id bool
protocol_version u32
has_protocol_version bool
network_config_version u32
has_network_config_version bool
public_ip u32
has_public_ip bool
}
pub fn (o &CMsgSteamDatagramP2PSessionRequestBody) pack() []byte {
mut res := []byte{}
if o.has_challenge_time {
res << vproto.pack_32bit_field(o.challenge_time, 1)
}

if o.has_challenge {
res << vproto.pack_64bit_field(o.challenge, 2)
}

if o.has_client_connection_id {
res << vproto.pack_32bit_field(o.client_connection_id, 3)
}

if o.has_legacy_peer_steam_id {
res << vproto.pack_64bit_field(o.legacy_peer_steam_id, 4)
}

if o.has_peer_identity_string {
res << vproto.pack_string_field(o.peer_identity_string, 11)
}

if o.has_peer_connection_id {
res << vproto.pack_32bit_field(o.peer_connection_id, 5)
}

if o.has_protocol_version {
res << vproto.pack_uint32_field(o.protocol_version, 8)
}

if o.has_network_config_version {
res << vproto.pack_uint32_field(o.network_config_version, 9)
}

if o.has_public_ip {
res << vproto.pack_32bit_field(o.public_ip, 10)
}

return res
}

pub fn cmsgsteamdatagramp2psessionrequestbody_unpack(buf []byte) ?CMsgSteamDatagramP2PSessionRequestBody {
mut res := CMsgSteamDatagramP2PSessionRequestBody{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_challenge_time = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.challenge_time = v
i = ii
}

2 {
res.has_challenge = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.challenge = v
i = ii
}

3 {
res.has_client_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.client_connection_id = v
i = ii
}

4 {
res.has_legacy_peer_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_peer_steam_id = v
i = ii
}

11 {
res.has_peer_identity_string = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.peer_identity_string = v
i = ii
}

5 {
res.has_peer_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.peer_connection_id = v
i = ii
}

8 {
res.has_protocol_version = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.protocol_version = v
i = ii
}

9 {
res.has_network_config_version = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.network_config_version = v
i = ii
}

10 {
res.has_public_ip = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.public_ip = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2psessionrequestbody() CMsgSteamDatagramP2PSessionRequestBody {
return CMsgSteamDatagramP2PSessionRequestBody{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2psessionrequestbody(o CMsgSteamDatagramP2PSessionRequestBody, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2psessionrequestbody(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PSessionRequestBody) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramp2psessionrequestbody_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramP2PSessionRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
cert CMsgSteamDatagramCertificateSigned
has_cert bool
body []byte
has_body bool
signature []byte
has_signature bool
}
pub fn (o &CMsgSteamDatagramP2PSessionRequest) pack() []byte {
mut res := []byte{}
if o.has_cert {
res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 1)
}

if o.has_body {
res << vproto.pack_bytes_field(o.body, 2)
}

if o.has_signature {
res << vproto.pack_bytes_field(o.signature, 3)
}

return res
}

pub fn cmsgsteamdatagramp2psessionrequest_unpack(buf []byte) ?CMsgSteamDatagramP2PSessionRequest {
mut res := CMsgSteamDatagramP2PSessionRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_cert = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf, tag_wiretype.wire_type)?
res.cert = v
i = ii
}

2 {
res.has_body = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.body = v
i = ii
}

3 {
res.has_signature = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.signature = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2psessionrequest() CMsgSteamDatagramP2PSessionRequest {
return CMsgSteamDatagramP2PSessionRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2psessionrequest(o CMsgSteamDatagramP2PSessionRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2psessionrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PSessionRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramp2psessionrequest_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramP2PSessionEstablished {
mut:
unknown_fields []vproto.UnknownField
pub mut:
connection_id u32
has_connection_id bool
seconds_until_shutdown u32
has_seconds_until_shutdown bool
relay_routing_token []byte
has_relay_routing_token bool
seq_num_r2c u32
has_seq_num_r2c bool
}
pub fn (o &CMsgSteamDatagramP2PSessionEstablished) pack() []byte {
mut res := []byte{}
if o.has_connection_id {
res << vproto.pack_32bit_field(o.connection_id, 1)
}

if o.has_seconds_until_shutdown {
res << vproto.pack_uint32_field(o.seconds_until_shutdown, 3)
}

if o.has_relay_routing_token {
res << vproto.pack_bytes_field(o.relay_routing_token, 4)
}

if o.has_seq_num_r2c {
res << vproto.pack_uint32_field(o.seq_num_r2c, 5)
}

return res
}

pub fn cmsgsteamdatagramp2psessionestablished_unpack(buf []byte) ?CMsgSteamDatagramP2PSessionEstablished {
mut res := CMsgSteamDatagramP2PSessionEstablished{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.connection_id = v
i = ii
}

3 {
res.has_seconds_until_shutdown = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_until_shutdown = v
i = ii
}

4 {
res.has_relay_routing_token = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.relay_routing_token = v
i = ii
}

5 {
res.has_seq_num_r2c = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_r2c = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2psessionestablished() CMsgSteamDatagramP2PSessionEstablished {
return CMsgSteamDatagramP2PSessionEstablished{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2psessionestablished(o CMsgSteamDatagramP2PSessionEstablished, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2psessionestablished(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PSessionEstablished) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramp2psessionestablished_unpack(v)?
return i, unpacked
}
[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsP2PClientToRouterFlags {
ack_request_relay = 1
ack_request_e2e = 2
ack_request_immediate = 4
not_primary_session = 8
not_primary_transport_e2e = 16
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2pclienttorouterflags(e CMsgSteamDatagramConnectionStatsP2PClientToRouterFlags, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2pclienttorouterflags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PClientToRouterFlags) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, CMsgSteamDatagramConnectionStatsP2PClientToRouterFlags(v)
}
pub struct CMsgSteamDatagramConnectionStatsP2PClientToRouter {
mut:
unknown_fields []vproto.UnknownField
pub mut:
quality_relay CMsgSteamDatagramConnectionQuality
has_quality_relay bool
quality_e2e CMsgSteamDatagramConnectionQuality
has_quality_e2e bool
p2p_routing_summary CMsgSteamDatagramP2PRoutingSummary
has_p2p_routing_summary bool
ack_relay []u32
legacy_ack_e2e []u32
flags u32
has_flags bool
forward_target_relay_routing_token []byte
has_forward_target_relay_routing_token bool
forward_target_revision u32
has_forward_target_revision bool
routes []byte
has_routes bool
ack_peer_routes_revision u32
has_ack_peer_routes_revision bool
connection_id u32
has_connection_id bool
seq_num_c2r u32
has_seq_num_c2r bool
seq_num_e2e u32
has_seq_num_e2e bool
}
pub fn (o &CMsgSteamDatagramConnectionStatsP2PClientToRouter) pack() []byte {
mut res := []byte{}
if o.has_quality_relay {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
}

if o.has_quality_e2e {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
}

if o.has_p2p_routing_summary {
res << zzz_vproto_internal_pack_cmsgsteamdatagramp2proutingsummary(o.p2p_routing_summary, 14)
}

// [packed=false]
for _, x in o.ack_relay {
res << vproto.pack_32bit_field(x, 3)
}

// [packed=false]
for _, x in o.legacy_ack_e2e {
res << vproto.pack_32bit_field(x, 4)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 5)
}

if o.has_forward_target_relay_routing_token {
res << vproto.pack_bytes_field(o.forward_target_relay_routing_token, 6)
}

if o.has_forward_target_revision {
res << vproto.pack_uint32_field(o.forward_target_revision, 7)
}

if o.has_routes {
res << vproto.pack_bytes_field(o.routes, 8)
}

if o.has_ack_peer_routes_revision {
res << vproto.pack_uint32_field(o.ack_peer_routes_revision, 9)
}

if o.has_connection_id {
res << vproto.pack_32bit_field(o.connection_id, 10)
}

if o.has_seq_num_c2r {
res << vproto.pack_uint32_field(o.seq_num_c2r, 11)
}

if o.has_seq_num_e2e {
res << vproto.pack_uint32_field(o.seq_num_e2e, 12)
}

return res
}

pub fn cmsgsteamdatagramconnectionstatsp2pclienttorouter_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsP2PClientToRouter {
mut res := CMsgSteamDatagramConnectionStatsP2PClientToRouter{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_quality_relay = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_relay = v
i = ii
}

2 {
res.has_quality_e2e = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_e2e = v
i = ii
}

14 {
res.has_p2p_routing_summary = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutingsummary(cur_buf, tag_wiretype.wire_type)?
res.p2p_routing_summary = v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.ack_relay << v
i = ii
}

4 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_ack_e2e << v
i = ii
}

5 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

6 {
res.has_forward_target_relay_routing_token = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.forward_target_relay_routing_token = v
i = ii
}

7 {
res.has_forward_target_revision = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.forward_target_revision = v
i = ii
}

8 {
res.has_routes = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.routes = v
i = ii
}

9 {
res.has_ack_peer_routes_revision = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ack_peer_routes_revision = v
i = ii
}

10 {
res.has_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.connection_id = v
i = ii
}

11 {
res.has_seq_num_c2r = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_c2r = v
i = ii
}

12 {
res.has_seq_num_e2e = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_e2e = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2pclienttorouter() CMsgSteamDatagramConnectionStatsP2PClientToRouter {
return CMsgSteamDatagramConnectionStatsP2PClientToRouter{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2pclienttorouter(o CMsgSteamDatagramConnectionStatsP2PClientToRouter, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2pclienttorouter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PClientToRouter) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramconnectionstatsp2pclienttorouter_unpack(v)?
return i, unpacked
}
[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsP2PRouterToClientFlags {
ack_request_relay = 1
ack_request_e2e = 2
ack_request_immediate = 4
not_primary_transport_e2e = 16
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertoclientflags(e CMsgSteamDatagramConnectionStatsP2PRouterToClientFlags, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertoclientflags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PRouterToClientFlags) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, CMsgSteamDatagramConnectionStatsP2PRouterToClientFlags(v)
}
pub struct CMsgSteamDatagramConnectionStatsP2PRouterToClient {
mut:
unknown_fields []vproto.UnknownField
pub mut:
quality_relay CMsgSteamDatagramConnectionQuality
has_quality_relay bool
quality_e2e CMsgSteamDatagramConnectionQuality
has_quality_e2e bool
seconds_until_shutdown u32
has_seconds_until_shutdown bool
migrate_request_ip u32
has_migrate_request_ip bool
migrate_request_port u32
has_migrate_request_port bool
scoring_penalty_relay_cluster u32
has_scoring_penalty_relay_cluster bool
ack_relay []u32
legacy_ack_e2e []u32
flags u32
has_flags bool
ack_forward_target_revision u32
has_ack_forward_target_revision bool
routes []byte
has_routes bool
ack_peer_routes_revision u32
has_ack_peer_routes_revision bool
connection_id u32
has_connection_id bool
seq_num_r2c u32
has_seq_num_r2c bool
seq_num_e2e u32
has_seq_num_e2e bool
}
pub fn (o &CMsgSteamDatagramConnectionStatsP2PRouterToClient) pack() []byte {
mut res := []byte{}
if o.has_quality_relay {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
}

if o.has_quality_e2e {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
}

if o.has_seconds_until_shutdown {
res << vproto.pack_uint32_field(o.seconds_until_shutdown, 3)
}

if o.has_migrate_request_ip {
res << vproto.pack_32bit_field(o.migrate_request_ip, 4)
}

if o.has_migrate_request_port {
res << vproto.pack_uint32_field(o.migrate_request_port, 5)
}

if o.has_scoring_penalty_relay_cluster {
res << vproto.pack_uint32_field(o.scoring_penalty_relay_cluster, 6)
}

// [packed=false]
for _, x in o.ack_relay {
res << vproto.pack_32bit_field(x, 7)
}

// [packed=false]
for _, x in o.legacy_ack_e2e {
res << vproto.pack_32bit_field(x, 8)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 9)
}

if o.has_ack_forward_target_revision {
res << vproto.pack_uint32_field(o.ack_forward_target_revision, 10)
}

if o.has_routes {
res << vproto.pack_bytes_field(o.routes, 11)
}

if o.has_ack_peer_routes_revision {
res << vproto.pack_uint32_field(o.ack_peer_routes_revision, 12)
}

if o.has_connection_id {
res << vproto.pack_32bit_field(o.connection_id, 13)
}

if o.has_seq_num_r2c {
res << vproto.pack_uint32_field(o.seq_num_r2c, 14)
}

if o.has_seq_num_e2e {
res << vproto.pack_uint32_field(o.seq_num_e2e, 15)
}

return res
}

pub fn cmsgsteamdatagramconnectionstatsp2proutertoclient_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsP2PRouterToClient {
mut res := CMsgSteamDatagramConnectionStatsP2PRouterToClient{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_quality_relay = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_relay = v
i = ii
}

2 {
res.has_quality_e2e = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_e2e = v
i = ii
}

3 {
res.has_seconds_until_shutdown = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_until_shutdown = v
i = ii
}

4 {
res.has_migrate_request_ip = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.migrate_request_ip = v
i = ii
}

5 {
res.has_migrate_request_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.migrate_request_port = v
i = ii
}

6 {
res.has_scoring_penalty_relay_cluster = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.scoring_penalty_relay_cluster = v
i = ii
}

7 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.ack_relay << v
i = ii
}

8 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_ack_e2e << v
i = ii
}

9 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

10 {
res.has_ack_forward_target_revision = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ack_forward_target_revision = v
i = ii
}

11 {
res.has_routes = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.routes = v
i = ii
}

12 {
res.has_ack_peer_routes_revision = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ack_peer_routes_revision = v
i = ii
}

13 {
res.has_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.connection_id = v
i = ii
}

14 {
res.has_seq_num_r2c = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_r2c = v
i = ii
}

15 {
res.has_seq_num_e2e = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_e2e = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2proutertoclient() CMsgSteamDatagramConnectionStatsP2PRouterToClient {
return CMsgSteamDatagramConnectionStatsP2PRouterToClient{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertoclient(o CMsgSteamDatagramConnectionStatsP2PRouterToClient, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertoclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PRouterToClient) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramconnectionstatsp2proutertoclient_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramP2PBadRouteRouterToClient {
mut:
unknown_fields []vproto.UnknownField
pub mut:
connection_id u32
has_connection_id bool
failed_relay_routing_token []byte
has_failed_relay_routing_token bool
ack_forward_target_revision u32
has_ack_forward_target_revision bool
kludge_pad u64
has_kludge_pad bool
}
pub fn (o &CMsgSteamDatagramP2PBadRouteRouterToClient) pack() []byte {
mut res := []byte{}
if o.has_connection_id {
res << vproto.pack_32bit_field(o.connection_id, 1)
}

if o.has_failed_relay_routing_token {
res << vproto.pack_bytes_field(o.failed_relay_routing_token, 2)
}

if o.has_ack_forward_target_revision {
res << vproto.pack_uint32_field(o.ack_forward_target_revision, 3)
}

if o.has_kludge_pad {
res << vproto.pack_64bit_field(o.kludge_pad, 99)
}

return res
}

pub fn cmsgsteamdatagramp2pbadrouteroutertoclient_unpack(buf []byte) ?CMsgSteamDatagramP2PBadRouteRouterToClient {
mut res := CMsgSteamDatagramP2PBadRouteRouterToClient{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_connection_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.connection_id = v
i = ii
}

2 {
res.has_failed_relay_routing_token = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.failed_relay_routing_token = v
i = ii
}

3 {
res.has_ack_forward_target_revision = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ack_forward_target_revision = v
i = ii
}

99 {
res.has_kludge_pad = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.kludge_pad = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2pbadrouteroutertoclient() CMsgSteamDatagramP2PBadRouteRouterToClient {
return CMsgSteamDatagramP2PBadRouteRouterToClient{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2pbadrouteroutertoclient(o CMsgSteamDatagramP2PBadRouteRouterToClient, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2pbadrouteroutertoclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PBadRouteRouterToClient) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramp2pbadrouteroutertoclient_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramP2PRoutesRelayCluster {
mut:
unknown_fields []vproto.UnknownField
pub mut:
pop_id u32
has_pop_id bool
ping_ms u32
has_ping_ms bool
score_penalty u32
has_score_penalty bool
session_relay_routing_token []byte
has_session_relay_routing_token bool
}
pub fn (o &CMsgSteamDatagramP2PRoutesRelayCluster) pack() []byte {
mut res := []byte{}
if o.has_pop_id {
res << vproto.pack_32bit_field(o.pop_id, 1)
}

if o.has_ping_ms {
res << vproto.pack_uint32_field(o.ping_ms, 2)
}

if o.has_score_penalty {
res << vproto.pack_uint32_field(o.score_penalty, 3)
}

if o.has_session_relay_routing_token {
res << vproto.pack_bytes_field(o.session_relay_routing_token, 4)
}

return res
}

pub fn cmsgsteamdatagramp2proutesrelaycluster_unpack(buf []byte) ?CMsgSteamDatagramP2PRoutesRelayCluster {
mut res := CMsgSteamDatagramP2PRoutesRelayCluster{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_pop_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.pop_id = v
i = ii
}

2 {
res.has_ping_ms = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ping_ms = v
i = ii
}

3 {
res.has_score_penalty = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.score_penalty = v
i = ii
}

4 {
res.has_session_relay_routing_token = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.session_relay_routing_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2proutesrelaycluster() CMsgSteamDatagramP2PRoutesRelayCluster {
return CMsgSteamDatagramP2PRoutesRelayCluster{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2proutesrelaycluster(o CMsgSteamDatagramP2PRoutesRelayCluster, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutesrelaycluster(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PRoutesRelayCluster) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramp2proutesrelaycluster_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramP2PRoutesRoute {
mut:
unknown_fields []vproto.UnknownField
pub mut:
my_pop_id u32
has_my_pop_id bool
your_pop_id u32
has_your_pop_id bool
score u32
has_score bool
}
pub fn (o &CMsgSteamDatagramP2PRoutesRoute) pack() []byte {
mut res := []byte{}
if o.has_my_pop_id {
res << vproto.pack_32bit_field(o.my_pop_id, 1)
}

if o.has_your_pop_id {
res << vproto.pack_32bit_field(o.your_pop_id, 2)
}

if o.has_score {
res << vproto.pack_uint32_field(o.score, 3)
}

return res
}

pub fn cmsgsteamdatagramp2proutesroute_unpack(buf []byte) ?CMsgSteamDatagramP2PRoutesRoute {
mut res := CMsgSteamDatagramP2PRoutesRoute{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_my_pop_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.my_pop_id = v
i = ii
}

2 {
res.has_your_pop_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.your_pop_id = v
i = ii
}

3 {
res.has_score = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.score = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2proutesroute() CMsgSteamDatagramP2PRoutesRoute {
return CMsgSteamDatagramP2PRoutesRoute{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2proutesroute(o CMsgSteamDatagramP2PRoutesRoute, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutesroute(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PRoutesRoute) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramp2proutesroute_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramP2PRoutes {
mut:
unknown_fields []vproto.UnknownField
pub mut:
relay_clusters []CMsgSteamDatagramP2PRoutesRelayCluster
routes []CMsgSteamDatagramP2PRoutesRoute
revision u32
has_revision bool
}
pub fn (o &CMsgSteamDatagramP2PRoutes) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.relay_clusters {
res << zzz_vproto_internal_pack_cmsgsteamdatagramp2proutesrelaycluster(x, 1)
}

// [packed=false]
for _, x in o.routes {
res << zzz_vproto_internal_pack_cmsgsteamdatagramp2proutesroute(x, 2)
}

if o.has_revision {
res << vproto.pack_uint32_field(o.revision, 3)
}

return res
}

pub fn cmsgsteamdatagramp2proutes_unpack(buf []byte) ?CMsgSteamDatagramP2PRoutes {
mut res := CMsgSteamDatagramP2PRoutes{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutesrelaycluster(cur_buf, tag_wiretype.wire_type)?
res.relay_clusters << v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutesroute(cur_buf, tag_wiretype.wire_type)?
res.routes << v
i = ii
}

3 {
res.has_revision = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.revision = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2proutes() CMsgSteamDatagramP2PRoutes {
return CMsgSteamDatagramP2PRoutes{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2proutes(o CMsgSteamDatagramP2PRoutes, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutes(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PRoutes) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramp2proutes_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramGameServerSample {
mut:
unknown_fields []vproto.UnknownField
pub mut:
ipv4 u32
has_ipv4 bool
port u32
has_port bool
}
pub fn (o &CMsgSteamDatagramGameServerSample) pack() []byte {
mut res := []byte{}
if o.has_ipv4 {
res << vproto.pack_32bit_field(o.ipv4, 1)
}

if o.has_port {
res << vproto.pack_uint32_field(o.port, 2)
}

return res
}

pub fn cmsgsteamdatagramgameserversample_unpack(buf []byte) ?CMsgSteamDatagramGameServerSample {
mut res := CMsgSteamDatagramGameServerSample{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_ipv4 = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.ipv4 = v
i = ii
}

2 {
res.has_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.port = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserversample() CMsgSteamDatagramGameServerSample {
return CMsgSteamDatagramGameServerSample{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserversample(o CMsgSteamDatagramGameServerSample, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversample(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameServerSample) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramgameserversample_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramGameServerSampleDataCenter {
mut:
unknown_fields []vproto.UnknownField
pub mut:
datacenter_id u32
has_datacenter_id bool
servers []CMsgSteamDatagramGameServerSample
}
pub fn (o &CMsgSteamDatagramGameServerSampleDataCenter) pack() []byte {
mut res := []byte{}
if o.has_datacenter_id {
res << vproto.pack_32bit_field(o.datacenter_id, 1)
}

// [packed=false]
for _, x in o.servers {
res << zzz_vproto_internal_pack_cmsgsteamdatagramgameserversample(x, 3)
}

return res
}

pub fn cmsgsteamdatagramgameserversampledatacenter_unpack(buf []byte) ?CMsgSteamDatagramGameServerSampleDataCenter {
mut res := CMsgSteamDatagramGameServerSampleDataCenter{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_datacenter_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.datacenter_id = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversample(cur_buf, tag_wiretype.wire_type)?
res.servers << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserversampledatacenter() CMsgSteamDatagramGameServerSampleDataCenter {
return CMsgSteamDatagramGameServerSampleDataCenter{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserversampledatacenter(o CMsgSteamDatagramGameServerSampleDataCenter, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversampledatacenter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameServerSampleDataCenter) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramgameserversampledatacenter_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramRelayToRelayPing {
mut:
unknown_fields []vproto.UnknownField
pub mut:
request_timestamp u32
has_request_timestamp bool
request_date u32
has_request_date bool
my_pop_id u32
has_my_pop_id bool
your_pop_id u32
has_your_pop_id bool
checksum u32
has_checksum bool
data_centers []CMsgSteamDatagramGameServerSampleDataCenter
}
pub fn (o &CMsgSteamDatagramRelayToRelayPing) pack() []byte {
mut res := []byte{}
if o.has_request_timestamp {
res << vproto.pack_32bit_field(o.request_timestamp, 1)
}

if o.has_request_date {
res << vproto.pack_32bit_field(o.request_date, 2)
}

if o.has_my_pop_id {
res << vproto.pack_32bit_field(o.my_pop_id, 3)
}

if o.has_your_pop_id {
res << vproto.pack_32bit_field(o.your_pop_id, 4)
}

if o.has_checksum {
res << vproto.pack_32bit_field(o.checksum, 5)
}

// [packed=false]
for _, x in o.data_centers {
res << zzz_vproto_internal_pack_cmsgsteamdatagramgameserversampledatacenter(x, 6)
}

return res
}

pub fn cmsgsteamdatagramrelaytorelayping_unpack(buf []byte) ?CMsgSteamDatagramRelayToRelayPing {
mut res := CMsgSteamDatagramRelayToRelayPing{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_request_timestamp = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.request_timestamp = v
i = ii
}

2 {
res.has_request_date = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.request_date = v
i = ii
}

3 {
res.has_my_pop_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.my_pop_id = v
i = ii
}

4 {
res.has_your_pop_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.your_pop_id = v
i = ii
}

5 {
res.has_checksum = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.checksum = v
i = ii
}

6 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversampledatacenter(cur_buf, tag_wiretype.wire_type)?
res.data_centers << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrelaytorelayping() CMsgSteamDatagramRelayToRelayPing {
return CMsgSteamDatagramRelayToRelayPing{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrelaytorelayping(o CMsgSteamDatagramRelayToRelayPing, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrelaytorelayping(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRelayToRelayPing) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramrelaytorelayping_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramDataCenterStateServer {
mut:
unknown_fields []vproto.UnknownField
pub mut:
address string
has_address bool
ping_ms u32
has_ping_ms bool
}
pub fn (o &CMsgSteamDatagramDataCenterStateServer) pack() []byte {
mut res := []byte{}
if o.has_address {
res << vproto.pack_string_field(o.address, 1)
}

if o.has_ping_ms {
res << vproto.pack_uint32_field(o.ping_ms, 2)
}

return res
}

pub fn cmsgsteamdatagramdatacenterstateserver_unpack(buf []byte) ?CMsgSteamDatagramDataCenterStateServer {
mut res := CMsgSteamDatagramDataCenterStateServer{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_address = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.address = v
i = ii
}

2 {
res.has_ping_ms = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ping_ms = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramdatacenterstateserver() CMsgSteamDatagramDataCenterStateServer {
return CMsgSteamDatagramDataCenterStateServer{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstateserver(o CMsgSteamDatagramDataCenterStateServer, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstateserver(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramDataCenterStateServer) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramdatacenterstateserver_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramDataCenterStateDataCenter {
mut:
unknown_fields []vproto.UnknownField
pub mut:
code string
has_code bool
server_sample []CMsgSteamDatagramDataCenterStateServer
relay_sample []CMsgSteamDatagramDataCenterStateServer
}
pub fn (o &CMsgSteamDatagramDataCenterStateDataCenter) pack() []byte {
mut res := []byte{}
if o.has_code {
res << vproto.pack_string_field(o.code, 1)
}

// [packed=false]
for _, x in o.server_sample {
res << zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstateserver(x, 2)
}

// [packed=false]
for _, x in o.relay_sample {
res << zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstateserver(x, 3)
}

return res
}

pub fn cmsgsteamdatagramdatacenterstatedatacenter_unpack(buf []byte) ?CMsgSteamDatagramDataCenterStateDataCenter {
mut res := CMsgSteamDatagramDataCenterStateDataCenter{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_code = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.code = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstateserver(cur_buf, tag_wiretype.wire_type)?
res.server_sample << v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstateserver(cur_buf, tag_wiretype.wire_type)?
res.relay_sample << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramdatacenterstatedatacenter() CMsgSteamDatagramDataCenterStateDataCenter {
return CMsgSteamDatagramDataCenterStateDataCenter{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstatedatacenter(o CMsgSteamDatagramDataCenterStateDataCenter, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstatedatacenter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramDataCenterStateDataCenter) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramdatacenterstatedatacenter_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramDataCenterState {
mut:
unknown_fields []vproto.UnknownField
pub mut:
data_centers []CMsgSteamDatagramDataCenterStateDataCenter
}
pub fn (o &CMsgSteamDatagramDataCenterState) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.data_centers {
res << zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstatedatacenter(x, 1)
}

return res
}

pub fn cmsgsteamdatagramdatacenterstate_unpack(buf []byte) ?CMsgSteamDatagramDataCenterState {
mut res := CMsgSteamDatagramDataCenterState{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstatedatacenter(cur_buf, tag_wiretype.wire_type)?
res.data_centers << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramdatacenterstate() CMsgSteamDatagramDataCenterState {
return CMsgSteamDatagramDataCenterState{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstate(o CMsgSteamDatagramDataCenterState, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramDataCenterState) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramdatacenterstate_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramRouterHealthDataCenter {
mut:
unknown_fields []vproto.UnknownField
pub mut:
datacenter_id u32
has_datacenter_id bool
state u32
has_state bool
servers []CMsgSteamDatagramGameServerSample
}
pub fn (o &CMsgSteamDatagramRouterHealthDataCenter) pack() []byte {
mut res := []byte{}
if o.has_datacenter_id {
res << vproto.pack_32bit_field(o.datacenter_id, 1)
}

if o.has_state {
res << vproto.pack_uint32_field(o.state, 2)
}

// [packed=false]
for _, x in o.servers {
res << zzz_vproto_internal_pack_cmsgsteamdatagramgameserversample(x, 3)
}

return res
}

pub fn cmsgsteamdatagramrouterhealthdatacenter_unpack(buf []byte) ?CMsgSteamDatagramRouterHealthDataCenter {
mut res := CMsgSteamDatagramRouterHealthDataCenter{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_datacenter_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.datacenter_id = v
i = ii
}

2 {
res.has_state = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.state = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversample(cur_buf, tag_wiretype.wire_type)?
res.servers << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrouterhealthdatacenter() CMsgSteamDatagramRouterHealthDataCenter {
return CMsgSteamDatagramRouterHealthDataCenter{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrouterhealthdatacenter(o CMsgSteamDatagramRouterHealthDataCenter, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrouterhealthdatacenter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRouterHealthDataCenter) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramrouterhealthdatacenter_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramRouterHealth {
mut:
unknown_fields []vproto.UnknownField
pub mut:
cpu_load f32
has_cpu_load bool
cpu_load_raw f32
has_cpu_load_raw bool
active_sessions u32
has_active_sessions bool
data_pkts_sec u32
has_data_pkts_sec bool
other_pkts_sec u32
has_other_pkts_sec bool
seconds_until_shutdown u32
has_seconds_until_shutdown bool
cpu_cost_per_user f32
has_cpu_cost_per_user bool
cpu_cost_per_packet f32
has_cpu_cost_per_packet bool
data_centers []CMsgSteamDatagramRouterHealthDataCenter
magic u64
has_magic bool
}
pub fn (o &CMsgSteamDatagramRouterHealth) pack() []byte {
mut res := []byte{}
if o.has_cpu_load {
res << vproto.pack_float_field(o.cpu_load, 1)
}

if o.has_cpu_load_raw {
res << vproto.pack_float_field(o.cpu_load_raw, 10)
}

if o.has_active_sessions {
res << vproto.pack_uint32_field(o.active_sessions, 2)
}

if o.has_data_pkts_sec {
res << vproto.pack_uint32_field(o.data_pkts_sec, 3)
}

if o.has_other_pkts_sec {
res << vproto.pack_uint32_field(o.other_pkts_sec, 4)
}

if o.has_seconds_until_shutdown {
res << vproto.pack_uint32_field(o.seconds_until_shutdown, 5)
}

if o.has_cpu_cost_per_user {
res << vproto.pack_float_field(o.cpu_cost_per_user, 8)
}

if o.has_cpu_cost_per_packet {
res << vproto.pack_float_field(o.cpu_cost_per_packet, 9)
}

// [packed=false]
for _, x in o.data_centers {
res << zzz_vproto_internal_pack_cmsgsteamdatagramrouterhealthdatacenter(x, 6)
}

if o.has_magic {
res << vproto.pack_64bit_field(o.magic, 7)
}

return res
}

pub fn cmsgsteamdatagramrouterhealth_unpack(buf []byte) ?CMsgSteamDatagramRouterHealth {
mut res := CMsgSteamDatagramRouterHealth{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_cpu_load = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.cpu_load = v
i = ii
}

10 {
res.has_cpu_load_raw = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.cpu_load_raw = v
i = ii
}

2 {
res.has_active_sessions = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.active_sessions = v
i = ii
}

3 {
res.has_data_pkts_sec = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.data_pkts_sec = v
i = ii
}

4 {
res.has_other_pkts_sec = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.other_pkts_sec = v
i = ii
}

5 {
res.has_seconds_until_shutdown = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_until_shutdown = v
i = ii
}

8 {
res.has_cpu_cost_per_user = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.cpu_cost_per_user = v
i = ii
}

9 {
res.has_cpu_cost_per_packet = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.cpu_cost_per_packet = v
i = ii
}

6 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramrouterhealthdatacenter(cur_buf, tag_wiretype.wire_type)?
res.data_centers << v
i = ii
}

7 {
res.has_magic = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.magic = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrouterhealth() CMsgSteamDatagramRouterHealth {
return CMsgSteamDatagramRouterHealth{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrouterhealth(o CMsgSteamDatagramRouterHealth, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrouterhealth(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRouterHealth) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramrouterhealth_unpack(v)?
return i, unpacked
}
[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsP2PRouterToRouterFlags {
ack_request_relay = 1
ack_request_e2e = 2
ack_request_immediate = 4
not_primary_transport_e2e = 16
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertorouterflags(e CMsgSteamDatagramConnectionStatsP2PRouterToRouterFlags, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertorouterflags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PRouterToRouterFlags) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, CMsgSteamDatagramConnectionStatsP2PRouterToRouterFlags(v)
}
pub struct CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
mut:
unknown_fields []vproto.UnknownField
pub mut:
quality_relay CMsgSteamDatagramConnectionQuality
has_quality_relay bool
quality_e2e CMsgSteamDatagramConnectionQuality
has_quality_e2e bool
ack_relay []u32
legacy_ack_e2e []u32
flags u32
has_flags bool
ack_forward_target_revision u32
has_ack_forward_target_revision bool
routes []byte
has_routes bool
ack_peer_routes_revision u32
has_ack_peer_routes_revision bool
seq_num_r2r u32
has_seq_num_r2r bool
seq_num_e2e u32
has_seq_num_e2e bool
from_relay_session_id u32
has_from_relay_session_id bool
to_relay_session_id u32
has_to_relay_session_id bool
}
pub fn (o &CMsgSteamDatagramConnectionStatsP2PRouterToRouter) pack() []byte {
mut res := []byte{}
if o.has_quality_relay {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
}

if o.has_quality_e2e {
res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
}

// [packed=false]
for _, x in o.ack_relay {
res << vproto.pack_32bit_field(x, 3)
}

// [packed=false]
for _, x in o.legacy_ack_e2e {
res << vproto.pack_32bit_field(x, 4)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 5)
}

if o.has_ack_forward_target_revision {
res << vproto.pack_uint32_field(o.ack_forward_target_revision, 6)
}

if o.has_routes {
res << vproto.pack_bytes_field(o.routes, 7)
}

if o.has_ack_peer_routes_revision {
res << vproto.pack_uint32_field(o.ack_peer_routes_revision, 8)
}

if o.has_seq_num_r2r {
res << vproto.pack_uint32_field(o.seq_num_r2r, 26)
}

if o.has_seq_num_e2e {
res << vproto.pack_uint32_field(o.seq_num_e2e, 27)
}

if o.has_from_relay_session_id {
res << vproto.pack_32bit_field(o.from_relay_session_id, 22)
}

if o.has_to_relay_session_id {
res << vproto.pack_32bit_field(o.to_relay_session_id, 25)
}

return res
}

pub fn cmsgsteamdatagramconnectionstatsp2proutertorouter_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
mut res := CMsgSteamDatagramConnectionStatsP2PRouterToRouter{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_quality_relay = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_relay = v
i = ii
}

2 {
res.has_quality_e2e = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf, tag_wiretype.wire_type)?
res.quality_e2e = v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.ack_relay << v
i = ii
}

4 {
// [packed=false]
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_ack_e2e << v
i = ii
}

5 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

6 {
res.has_ack_forward_target_revision = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ack_forward_target_revision = v
i = ii
}

7 {
res.has_routes = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.routes = v
i = ii
}

8 {
res.has_ack_peer_routes_revision = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ack_peer_routes_revision = v
i = ii
}

26 {
res.has_seq_num_r2r = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_r2r = v
i = ii
}

27 {
res.has_seq_num_e2e = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seq_num_e2e = v
i = ii
}

22 {
res.has_from_relay_session_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.from_relay_session_id = v
i = ii
}

25 {
res.has_to_relay_session_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.to_relay_session_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2proutertorouter() CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
return CMsgSteamDatagramConnectionStatsP2PRouterToRouter{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertorouter(o CMsgSteamDatagramConnectionStatsP2PRouterToRouter, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertorouter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PRouterToRouter) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramconnectionstatsp2proutertorouter_unpack(v)?
return i, unpacked
}
