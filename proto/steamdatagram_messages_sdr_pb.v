// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum ESteamDatagramMsgID {
	k_esteamdatagrammsg_invalid = 0
	k_esteamdatagrammsg_routerpingrequest = 1
	k_esteamdatagrammsg_routerpingreply = 2
	k_esteamdatagrammsg_gameserverpingrequest = 3
	k_esteamdatagrammsg_legacygameserverpingreply = 4
	k_esteamdatagrammsg_gameserversessionrequest = 5
	k_esteamdatagrammsg_gameserversessionestablished = 6
	k_esteamdatagrammsg_nosession = 7
	k_esteamdatagrammsg_diagnostic = 8
	k_esteamdatagrammsg_dataclienttorouter = 9
	k_esteamdatagrammsg_dataroutertoserver = 10
	k_esteamdatagrammsg_dataservertorouter = 11
	k_esteamdatagrammsg_dataroutertoclient = 12
	k_esteamdatagrammsg_stats = 13
	k_esteamdatagrammsg_clientpingsamplerequest = 14
	k_esteamdatagrammsg_clientpingsamplereply = 15
	k_esteamdatagrammsg_clienttorouterswitchedprimary = 16
	k_esteamdatagrammsg_relayhealth = 17
	k_esteamdatagrammsg_connectrequest = 18
	k_esteamdatagrammsg_connectok = 19
	k_esteamdatagrammsg_connectionclosed = 20
	k_esteamdatagrammsg_noconnection = 21
	k_esteamdatagrammsg_relaytorelaypingrequest = 22
	k_esteamdatagrammsg_relaytorelaypingreply = 23
	k_esteamdatagrammsg_p2psessionrequest = 24
	k_esteamdatagrammsg_p2psessionestablished = 25
	k_esteamdatagrammsg_p2pstatsclient = 26
	k_esteamdatagrammsg_p2pstatsrelay = 27
	k_esteamdatagrammsg_p2pbadroute = 28
	k_esteamdatagrammsg_gameserverpingreply = 29
	k_esteamdatagrammsg_gameserverregistration = 30
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_esteamdatagrammsgid(e ESteamDatagramMsgID, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_esteamdatagrammsgid_packed(e []ESteamDatagramMsgID, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_esteamdatagrammsgid(buf []byte, tag_wiretype vproto.WireType) ?(int, ESteamDatagramMsgID) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, ESteamDatagramMsgID(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_esteamdatagrammsgid_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []ESteamDatagramMsgID) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramRouterPingReply_RouteException {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	data_center_id     u32
	has_data_center_id bool
	flags              u32
	has_flags          bool
	penalty            u32
	has_penalty        bool
}

pub fn (o &CMsgSteamDatagramRouterPingReply_RouteException) pack() []byte {
	mut res := []byte{}
	if o.has_data_center_id {
		res << vproto.pack_32bit_field(o.data_center_id, 1)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 2)
	}
	if o.has_penalty {
		res << vproto.pack_uint32_field(o.penalty, 3)
	}
	return res
}

pub fn cmsgsteamdatagramrouterpingreply_routeexception_unpack(buf []byte) ?CMsgSteamDatagramRouterPingReply_RouteException {
	mut res := CMsgSteamDatagramRouterPingReply_RouteException{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_data_center_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.data_center_id = v
				i = ii
			}
			2 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			3 {
				res.has_penalty = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.penalty = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrouterpingreply_routeexception() CMsgSteamDatagramRouterPingReply_RouteException {
	return CMsgSteamDatagramRouterPingReply_RouteException{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrouterpingreply_routeexception(o CMsgSteamDatagramRouterPingReply_RouteException, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrouterpingreply_routeexception(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRouterPingReply_RouteException) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramrouterpingreply_routeexception_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramRouterPingReply {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	client_timestamp                  u32
	has_client_timestamp              bool
	latency_datacenter_ids            []u32
	latency_ping_ms                   []u32
	your_public_ip                    u32
	has_your_public_ip                bool
	server_time                       u32
	has_server_time                   bool
	challenge                         u64
	has_challenge                     bool
	seconds_until_shutdown            u32
	has_seconds_until_shutdown        bool
	client_cookie                     u32
	has_client_cookie                 bool
	scoring_penalty_relay_cluster     u32
	has_scoring_penalty_relay_cluster bool
	route_exceptions                  []CMsgSteamDatagramRouterPingReply_RouteException
}

pub fn (o &CMsgSteamDatagramRouterPingReply) pack() []byte {
	mut res := []byte{}
	if o.has_client_timestamp {
		res << vproto.pack_32bit_field(o.client_timestamp, 1)
	}
	// [packed=true]
	res << vproto.pack_32bit_field_packed(o.latency_datacenter_ids, 2)
	// [packed=true]
	res << vproto.pack_uint32_field_packed(o.latency_ping_ms, 3)
	if o.has_your_public_ip {
		res << vproto.pack_32bit_field(o.your_public_ip, 4)
	}
	if o.has_server_time {
		res << vproto.pack_32bit_field(o.server_time, 5)
	}
	if o.has_challenge {
		res << vproto.pack_64bit_field(o.challenge, 6)
	}
	if o.has_seconds_until_shutdown {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 7)
	}
	if o.has_client_cookie {
		res << vproto.pack_32bit_field(o.client_cookie, 8)
	}
	if o.has_scoring_penalty_relay_cluster {
		res << vproto.pack_uint32_field(o.scoring_penalty_relay_cluster, 9)
	}
	// [packed=false]
	for _, x in o.route_exceptions {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramrouterpingreply_routeexception(x, 10)
	}
	return res
}

pub fn cmsgsteamdatagramrouterpingreply_unpack(buf []byte) ?CMsgSteamDatagramRouterPingReply {
	mut res := CMsgSteamDatagramRouterPingReply{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_client_timestamp = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_timestamp = v
				i = ii
			}
			2 {
				// [packed=true]
				ii, v := vproto.unpack_32bit_field_packed(cur_buf, tag_wiretype.wire_type)?
				res.latency_datacenter_ids << v
				i = ii
			}
			3 {
				// [packed=true]
				ii, v := vproto.unpack_uint32_field_packed(cur_buf, tag_wiretype.wire_type)?
				res.latency_ping_ms << v
				i = ii
			}
			4 {
				res.has_your_public_ip = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.your_public_ip = v
				i = ii
			}
			5 {
				res.has_server_time = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.server_time = v
				i = ii
			}
			6 {
				res.has_challenge = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.challenge = v
				i = ii
			}
			7 {
				res.has_seconds_until_shutdown = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_until_shutdown = v
				i = ii
			}
			8 {
				res.has_client_cookie = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_cookie = v
				i = ii
			}
			9 {
				res.has_scoring_penalty_relay_cluster = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scoring_penalty_relay_cluster = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramrouterpingreply_routeexception(cur_buf,
					tag_wiretype.wire_type)?
				res.route_exceptions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrouterpingreply() CMsgSteamDatagramRouterPingReply {
	return CMsgSteamDatagramRouterPingReply{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrouterpingreply(o CMsgSteamDatagramRouterPingReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrouterpingreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRouterPingReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramrouterpingreply_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameserverPingRequest {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	your_public_ip       u32
	has_your_public_ip   bool
	server_time          u32
	has_server_time      bool
	challenge            u64
	has_challenge        bool
	router_timestamp     u32
	has_router_timestamp bool
}

pub fn (o &CMsgSteamDatagramGameserverPingRequest) pack() []byte {
	mut res := []byte{}
	if o.has_your_public_ip {
		res << vproto.pack_32bit_field(o.your_public_ip, 1)
	}
	if o.has_server_time {
		res << vproto.pack_32bit_field(o.server_time, 2)
	}
	if o.has_challenge {
		res << vproto.pack_64bit_field(o.challenge, 3)
	}
	if o.has_router_timestamp {
		res << vproto.pack_32bit_field(o.router_timestamp, 4)
	}
	return res
}

pub fn cmsgsteamdatagramgameserverpingrequest_unpack(buf []byte) ?CMsgSteamDatagramGameserverPingRequest {
	mut res := CMsgSteamDatagramGameserverPingRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_your_public_ip = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.your_public_ip = v
				i = ii
			}
			2 {
				res.has_server_time = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.server_time = v
				i = ii
			}
			3 {
				res.has_challenge = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.challenge = v
				i = ii
			}
			4 {
				res.has_router_timestamp = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.router_timestamp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserverpingrequest() CMsgSteamDatagramGameserverPingRequest {
	return CMsgSteamDatagramGameserverPingRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserverpingrequest(o CMsgSteamDatagramGameserverPingRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserverpingrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverPingRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramgameserverpingrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramLegacyGameserverPingReply {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	router_timestamp     u32
	has_router_timestamp bool
	dummy_pad            u64
	has_dummy_pad        bool
}

pub fn (o &CMsgSteamDatagramLegacyGameserverPingReply) pack() []byte {
	mut res := []byte{}
	if o.has_router_timestamp {
		res << vproto.pack_32bit_field(o.router_timestamp, 4)
	}
	if o.has_dummy_pad {
		res << vproto.pack_64bit_field(o.dummy_pad, 99)
	}
	return res
}

pub fn cmsgsteamdatagramlegacygameserverpingreply_unpack(buf []byte) ?CMsgSteamDatagramLegacyGameserverPingReply {
	mut res := CMsgSteamDatagramLegacyGameserverPingReply{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			4 {
				res.has_router_timestamp = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.router_timestamp = v
				i = ii
			}
			99 {
				res.has_dummy_pad = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.dummy_pad = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramlegacygameserverpingreply() CMsgSteamDatagramLegacyGameserverPingReply {
	return CMsgSteamDatagramLegacyGameserverPingReply{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramlegacygameserverpingreply(o CMsgSteamDatagramLegacyGameserverPingReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramlegacygameserverpingreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramLegacyGameserverPingReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramlegacygameserverpingreply_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameserverPingReply_SignedData {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	challenge_time       u32
	has_challenge_time   bool
	challenge            u64
	has_challenge        bool
	router_timestamp     u32
	has_router_timestamp bool
	data_center_id       u32
	has_data_center_id   bool
	appid                u32
	has_appid            bool
}

pub fn (o &CMsgSteamDatagramGameserverPingReply_SignedData) pack() []byte {
	mut res := []byte{}
	if o.has_challenge_time {
		res << vproto.pack_32bit_field(o.challenge_time, 2)
	}
	if o.has_challenge {
		res << vproto.pack_64bit_field(o.challenge, 3)
	}
	if o.has_router_timestamp {
		res << vproto.pack_32bit_field(o.router_timestamp, 4)
	}
	if o.has_data_center_id {
		res << vproto.pack_32bit_field(o.data_center_id, 5)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 6)
	}
	return res
}

pub fn cmsgsteamdatagramgameserverpingreply_signeddata_unpack(buf []byte) ?CMsgSteamDatagramGameserverPingReply_SignedData {
	mut res := CMsgSteamDatagramGameserverPingReply_SignedData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				res.has_challenge_time = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.challenge_time = v
				i = ii
			}
			3 {
				res.has_challenge = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.challenge = v
				i = ii
			}
			4 {
				res.has_router_timestamp = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.router_timestamp = v
				i = ii
			}
			5 {
				res.has_data_center_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.data_center_id = v
				i = ii
			}
			6 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserverpingreply_signeddata() CMsgSteamDatagramGameserverPingReply_SignedData {
	return CMsgSteamDatagramGameserverPingReply_SignedData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserverpingreply_signeddata(o CMsgSteamDatagramGameserverPingReply_SignedData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserverpingreply_signeddata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverPingReply_SignedData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramgameserverpingreply_signeddata_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameserverPingReply {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	cert            CMsgSteamDatagramCertificateSigned
	has_cert        bool
	signed_data     []byte
	has_signed_data bool
	signature       []byte
	has_signature   bool
}

pub fn (o &CMsgSteamDatagramGameserverPingReply) pack() []byte {
	mut res := []byte{}
	if o.has_cert {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 1)
	}
	if o.has_signed_data {
		res << vproto.pack_bytes_field(o.signed_data, 2)
	}
	if o.has_signature {
		res << vproto.pack_bytes_field(o.signature, 3)
	}
	return res
}

pub fn cmsgsteamdatagramgameserverpingreply_unpack(buf []byte) ?CMsgSteamDatagramGameserverPingReply {
	mut res := CMsgSteamDatagramGameserverPingReply{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_cert = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf,
					tag_wiretype.wire_type)?
				res.cert = v
				i = ii
			}
			2 {
				res.has_signed_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.signed_data = v
				i = ii
			}
			3 {
				res.has_signature = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.signature = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserverpingreply() CMsgSteamDatagramGameserverPingReply {
	return CMsgSteamDatagramGameserverPingReply{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserverpingreply(o CMsgSteamDatagramGameserverPingReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserverpingreply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverPingReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramgameserverpingreply_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramNoSessionRelayToClient {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	connection_id              u32
	has_connection_id          bool
	your_public_ip             u32
	has_your_public_ip         bool
	server_time                u32
	has_server_time            bool
	challenge                  u64
	has_challenge              bool
	seconds_until_shutdown     u32
	has_seconds_until_shutdown bool
}

pub fn (o &CMsgSteamDatagramNoSessionRelayToClient) pack() []byte {
	mut res := []byte{}
	if o.has_connection_id {
		res << vproto.pack_32bit_field(o.connection_id, 7)
	}
	if o.has_your_public_ip {
		res << vproto.pack_32bit_field(o.your_public_ip, 2)
	}
	if o.has_server_time {
		res << vproto.pack_32bit_field(o.server_time, 3)
	}
	if o.has_challenge {
		res << vproto.pack_64bit_field(o.challenge, 4)
	}
	if o.has_seconds_until_shutdown {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 5)
	}
	return res
}

pub fn cmsgsteamdatagramnosessionrelaytoclient_unpack(buf []byte) ?CMsgSteamDatagramNoSessionRelayToClient {
	mut res := CMsgSteamDatagramNoSessionRelayToClient{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			7 {
				res.has_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_id = v
				i = ii
			}
			2 {
				res.has_your_public_ip = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.your_public_ip = v
				i = ii
			}
			3 {
				res.has_server_time = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.server_time = v
				i = ii
			}
			4 {
				res.has_challenge = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.challenge = v
				i = ii
			}
			5 {
				res.has_seconds_until_shutdown = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_until_shutdown = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramnosessionrelaytoclient() CMsgSteamDatagramNoSessionRelayToClient {
	return CMsgSteamDatagramNoSessionRelayToClient{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramnosessionrelaytoclient(o CMsgSteamDatagramNoSessionRelayToClient, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramnosessionrelaytoclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramNoSessionRelayToClient) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramnosessionrelaytoclient_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramNoSessionRelayToPeer {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	legacy_relay_session_id     u32
	has_legacy_relay_session_id bool
	from_relay_session_id       u32
	has_from_relay_session_id   bool
	from_connection_id          u32
	has_from_connection_id      bool
	kludge_pad                  u64
	has_kludge_pad              bool
}

pub fn (o &CMsgSteamDatagramNoSessionRelayToPeer) pack() []byte {
	mut res := []byte{}
	if o.has_legacy_relay_session_id {
		res << vproto.pack_uint32_field(o.legacy_relay_session_id, 1)
	}
	if o.has_from_relay_session_id {
		res << vproto.pack_32bit_field(o.from_relay_session_id, 2)
	}
	if o.has_from_connection_id {
		res << vproto.pack_32bit_field(o.from_connection_id, 7)
	}
	if o.has_kludge_pad {
		res << vproto.pack_64bit_field(o.kludge_pad, 99)
	}
	return res
}

pub fn cmsgsteamdatagramnosessionrelaytopeer_unpack(buf []byte) ?CMsgSteamDatagramNoSessionRelayToPeer {
	mut res := CMsgSteamDatagramNoSessionRelayToPeer{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_legacy_relay_session_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_relay_session_id = v
				i = ii
			}
			2 {
				res.has_from_relay_session_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.from_relay_session_id = v
				i = ii
			}
			7 {
				res.has_from_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.from_connection_id = v
				i = ii
			}
			99 {
				res.has_kludge_pad = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.kludge_pad = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramnosessionrelaytopeer() CMsgSteamDatagramNoSessionRelayToPeer {
	return CMsgSteamDatagramNoSessionRelayToPeer{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramnosessionrelaytopeer(o CMsgSteamDatagramNoSessionRelayToPeer, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramnosessionrelaytopeer(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramNoSessionRelayToPeer) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramnosessionrelaytopeer_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramClientPingSampleRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	connection_id     u32
	has_connection_id bool
}

pub fn (o &CMsgSteamDatagramClientPingSampleRequest) pack() []byte {
	mut res := []byte{}
	if o.has_connection_id {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	return res
}

pub fn cmsgsteamdatagramclientpingsamplerequest_unpack(buf []byte) ?CMsgSteamDatagramClientPingSampleRequest {
	mut res := CMsgSteamDatagramClientPingSampleRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplerequest() CMsgSteamDatagramClientPingSampleRequest {
	return CMsgSteamDatagramClientPingSampleRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplerequest(o CMsgSteamDatagramClientPingSampleRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientPingSampleRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramclientpingsamplerequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	id                u32
	has_id            bool
	front_ping_ms     u32
	has_front_ping_ms bool
	e2e_ping_ms       u32
	has_e2e_ping_ms   bool
}

pub fn (o &CMsgSteamDatagramClientPingSampleReply_RoutingCluster) pack() []byte {
	mut res := []byte{}
	if o.has_id {
		res << vproto.pack_32bit_field(o.id, 1)
	}
	if o.has_front_ping_ms {
		res << vproto.pack_uint32_field(o.front_ping_ms, 2)
	}
	if o.has_e2e_ping_ms {
		res << vproto.pack_uint32_field(o.e2e_ping_ms, 3)
	}
	return res
}

pub fn cmsgsteamdatagramclientpingsamplereply_routingcluster_unpack(buf []byte) ?CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
	mut res := CMsgSteamDatagramClientPingSampleReply_RoutingCluster{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.id = v
				i = ii
			}
			2 {
				res.has_front_ping_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.front_ping_ms = v
				i = ii
			}
			3 {
				res.has_e2e_ping_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.e2e_ping_ms = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplereply_routingcluster() CMsgSteamDatagramClientPingSampleReply_RoutingCluster {
	return CMsgSteamDatagramClientPingSampleReply_RoutingCluster{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereply_routingcluster(o CMsgSteamDatagramClientPingSampleReply_RoutingCluster, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereply_routingcluster(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientPingSampleReply_RoutingCluster) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramclientpingsamplereply_routingcluster_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramClientPingSampleReply_DataCenter {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	data_center_id     u32
	has_data_center_id bool
	via_relay_id       u32
	has_via_relay_id   bool
	e2e_ping_ms        u32
	has_e2e_ping_ms    bool
}

pub fn (o &CMsgSteamDatagramClientPingSampleReply_DataCenter) pack() []byte {
	mut res := []byte{}
	if o.has_data_center_id {
		res << vproto.pack_32bit_field(o.data_center_id, 1)
	}
	if o.has_via_relay_id {
		res << vproto.pack_32bit_field(o.via_relay_id, 2)
	}
	if o.has_e2e_ping_ms {
		res << vproto.pack_uint32_field(o.e2e_ping_ms, 3)
	}
	return res
}

pub fn cmsgsteamdatagramclientpingsamplereply_datacenter_unpack(buf []byte) ?CMsgSteamDatagramClientPingSampleReply_DataCenter {
	mut res := CMsgSteamDatagramClientPingSampleReply_DataCenter{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_data_center_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.data_center_id = v
				i = ii
			}
			2 {
				res.has_via_relay_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.via_relay_id = v
				i = ii
			}
			3 {
				res.has_e2e_ping_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.e2e_ping_ms = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplereply_datacenter() CMsgSteamDatagramClientPingSampleReply_DataCenter {
	return CMsgSteamDatagramClientPingSampleReply_DataCenter{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereply_datacenter(o CMsgSteamDatagramClientPingSampleReply_DataCenter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereply_datacenter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientPingSampleReply_DataCenter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramclientpingsamplereply_datacenter_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramClientPingSampleReply {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	connection_id     u32
	has_connection_id bool
	routing_clusters  []CMsgSteamDatagramClientPingSampleReply_RoutingCluster
	data_centers      []CMsgSteamDatagramClientPingSampleReply_DataCenter
}

pub fn (o &CMsgSteamDatagramClientPingSampleReply) pack() []byte {
	mut res := []byte{}
	if o.has_connection_id {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	// [packed=false]
	for _, x in o.routing_clusters {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereply_routingcluster(x, 2)
	}
	// [packed=false]
	for _, x in o.data_centers {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereply_datacenter(x, 3)
	}
	return res
}

pub fn cmsgsteamdatagramclientpingsamplereply_unpack(buf []byte) ?CMsgSteamDatagramClientPingSampleReply {
	mut res := CMsgSteamDatagramClientPingSampleReply{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereply_routingcluster(cur_buf,
					tag_wiretype.wire_type)?
				res.routing_clusters << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereply_datacenter(cur_buf,
					tag_wiretype.wire_type)?
				res.data_centers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientpingsamplereply() CMsgSteamDatagramClientPingSampleReply {
	return CMsgSteamDatagramClientPingSampleReply{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientpingsamplereply(o CMsgSteamDatagramClientPingSampleReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientpingsamplereply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientPingSampleReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramclientpingsamplereply_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	score                  u32
	has_score              bool
	front_ping             u32
	has_front_ping         bool
	back_ping              u32
	has_back_ping          bool
	seconds_until_down     u32
	has_seconds_until_down bool
}

pub fn (o &CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) pack() []byte {
	mut res := []byte{}
	if o.has_score {
		res << vproto.pack_uint32_field(o.score, 1)
	}
	if o.has_front_ping {
		res << vproto.pack_uint32_field(o.front_ping, 2)
	}
	if o.has_back_ping {
		res << vproto.pack_uint32_field(o.back_ping, 3)
	}
	if o.has_seconds_until_down {
		res << vproto.pack_uint32_field(o.seconds_until_down, 4)
	}
	return res
}

pub fn cmsgsteamdatagramclientswitchedprimary_routerquality_unpack(buf []byte) ?CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
	mut res := CMsgSteamDatagramClientSwitchedPrimary_RouterQuality{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_score = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.score = v
				i = ii
			}
			2 {
				res.has_front_ping = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.front_ping = v
				i = ii
			}
			3 {
				res.has_back_ping = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.back_ping = v
				i = ii
			}
			4 {
				res.has_seconds_until_down = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_until_down = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientswitchedprimary_routerquality() CMsgSteamDatagramClientSwitchedPrimary_RouterQuality {
	return CMsgSteamDatagramClientSwitchedPrimary_RouterQuality{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimary_routerquality(o CMsgSteamDatagramClientSwitchedPrimary_RouterQuality, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimary_routerquality(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientSwitchedPrimary_RouterQuality) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramclientswitchedprimary_routerquality_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramClientSwitchedPrimary {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	connection_id                u32
	has_connection_id            bool
	from_ip                      u32
	has_from_ip                  bool
	from_port                    u32
	has_from_port                bool
	from_router_cluster          u32
	has_from_router_cluster      bool
	from_active_time             u32
	has_from_active_time         bool
	from_active_packets_recv     u32
	has_from_active_packets_recv bool
	from_dropped_reason          string
	has_from_dropped_reason      bool
	gap_ms                       u32
	has_gap_ms                   bool
	from_quality_now             CMsgSteamDatagramClientSwitchedPrimary_RouterQuality
	has_from_quality_now         bool
	to_quality_now               CMsgSteamDatagramClientSwitchedPrimary_RouterQuality
	has_to_quality_now           bool
	from_quality_then            CMsgSteamDatagramClientSwitchedPrimary_RouterQuality
	has_from_quality_then        bool
	to_quality_then              CMsgSteamDatagramClientSwitchedPrimary_RouterQuality
	has_to_quality_then          bool
}

pub fn (o &CMsgSteamDatagramClientSwitchedPrimary) pack() []byte {
	mut res := []byte{}
	if o.has_connection_id {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	if o.has_from_ip {
		res << vproto.pack_32bit_field(o.from_ip, 2)
	}
	if o.has_from_port {
		res << vproto.pack_uint32_field(o.from_port, 3)
	}
	if o.has_from_router_cluster {
		res << vproto.pack_32bit_field(o.from_router_cluster, 4)
	}
	if o.has_from_active_time {
		res << vproto.pack_uint32_field(o.from_active_time, 5)
	}
	if o.has_from_active_packets_recv {
		res << vproto.pack_uint32_field(o.from_active_packets_recv, 6)
	}
	if o.has_from_dropped_reason {
		res << vproto.pack_string_field(o.from_dropped_reason, 7)
	}
	if o.has_gap_ms {
		res << vproto.pack_uint32_field(o.gap_ms, 8)
	}
	if o.has_from_quality_now {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimary_routerquality(o.from_quality_now, 9)
	}
	if o.has_to_quality_now {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimary_routerquality(o.to_quality_now, 10)
	}
	if o.has_from_quality_then {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimary_routerquality(o.from_quality_then, 11)
	}
	if o.has_to_quality_then {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimary_routerquality(o.to_quality_then, 12)
	}
	return res
}

pub fn cmsgsteamdatagramclientswitchedprimary_unpack(buf []byte) ?CMsgSteamDatagramClientSwitchedPrimary {
	mut res := CMsgSteamDatagramClientSwitchedPrimary{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_id = v
				i = ii
			}
			2 {
				res.has_from_ip = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.from_ip = v
				i = ii
			}
			3 {
				res.has_from_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.from_port = v
				i = ii
			}
			4 {
				res.has_from_router_cluster = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.from_router_cluster = v
				i = ii
			}
			5 {
				res.has_from_active_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.from_active_time = v
				i = ii
			}
			6 {
				res.has_from_active_packets_recv = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.from_active_packets_recv = v
				i = ii
			}
			7 {
				res.has_from_dropped_reason = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.from_dropped_reason = v
				i = ii
			}
			8 {
				res.has_gap_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.gap_ms = v
				i = ii
			}
			9 {
				res.has_from_quality_now = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimary_routerquality(cur_buf,
					tag_wiretype.wire_type)?
				res.from_quality_now = v
				i = ii
			}
			10 {
				res.has_to_quality_now = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimary_routerquality(cur_buf,
					tag_wiretype.wire_type)?
				res.to_quality_now = v
				i = ii
			}
			11 {
				res.has_from_quality_then = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimary_routerquality(cur_buf,
					tag_wiretype.wire_type)?
				res.from_quality_then = v
				i = ii
			}
			12 {
				res.has_to_quality_then = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimary_routerquality(cur_buf,
					tag_wiretype.wire_type)?
				res.to_quality_then = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramclientswitchedprimary() CMsgSteamDatagramClientSwitchedPrimary {
	return CMsgSteamDatagramClientSwitchedPrimary{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramclientswitchedprimary(o CMsgSteamDatagramClientSwitchedPrimary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramclientswitchedprimary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramClientSwitchedPrimary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramclientswitchedprimary_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramConnectRequest {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	connection_id                   u32
	has_connection_id               bool
	my_timestamp                    u64
	has_my_timestamp                bool
	ping_est_ms                     u32
	has_ping_est_ms                 bool
	virtual_port                    u32
	has_virtual_port                bool
	gameserver_relay_session_id     u32
	has_gameserver_relay_session_id bool
	crypt                           CMsgSteamDatagramSessionCryptInfoSigned
	has_crypt                       bool
	cert                            CMsgSteamDatagramCertificateSigned
	has_cert                        bool
	routing_secret                  u64
	has_routing_secret              bool
	legacy_client_steam_id          u64
	has_legacy_client_steam_id      bool
}

pub fn (o &CMsgSteamDatagramConnectRequest) pack() []byte {
	mut res := []byte{}
	if o.has_connection_id {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	if o.has_my_timestamp {
		res << vproto.pack_64bit_field(o.my_timestamp, 4)
	}
	if o.has_ping_est_ms {
		res << vproto.pack_uint32_field(o.ping_est_ms, 5)
	}
	if o.has_virtual_port {
		res << vproto.pack_uint32_field(o.virtual_port, 9)
	}
	if o.has_gameserver_relay_session_id {
		res << vproto.pack_uint32_field(o.gameserver_relay_session_id, 2)
	}
	if o.has_crypt {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfosigned(o.crypt, 6)
	}
	if o.has_cert {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 7)
	}
	if o.has_routing_secret {
		res << vproto.pack_64bit_field(o.routing_secret, 10)
	}
	if o.has_legacy_client_steam_id {
		res << vproto.pack_64bit_field(o.legacy_client_steam_id, 3)
	}
	return res
}

pub fn cmsgsteamdatagramconnectrequest_unpack(buf []byte) ?CMsgSteamDatagramConnectRequest {
	mut res := CMsgSteamDatagramConnectRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_id = v
				i = ii
			}
			4 {
				res.has_my_timestamp = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.my_timestamp = v
				i = ii
			}
			5 {
				res.has_ping_est_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_est_ms = v
				i = ii
			}
			9 {
				res.has_virtual_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.virtual_port = v
				i = ii
			}
			2 {
				res.has_gameserver_relay_session_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.gameserver_relay_session_id = v
				i = ii
			}
			6 {
				res.has_crypt = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfosigned(cur_buf,
					tag_wiretype.wire_type)?
				res.crypt = v
				i = ii
			}
			7 {
				res.has_cert = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf,
					tag_wiretype.wire_type)?
				res.cert = v
				i = ii
			}
			10 {
				res.has_routing_secret = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.routing_secret = v
				i = ii
			}
			3 {
				res.has_legacy_client_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_client_steam_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectrequest() CMsgSteamDatagramConnectRequest {
	return CMsgSteamDatagramConnectRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectrequest(o CMsgSteamDatagramConnectRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramconnectrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramConnectOK {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	client_connection_id            u32
	has_client_connection_id        bool
	server_connection_id            u32
	has_server_connection_id        bool
	your_timestamp                  u64
	has_your_timestamp              bool
	delay_time_usec                 u32
	has_delay_time_usec             bool
	gameserver_relay_session_id     u32
	has_gameserver_relay_session_id bool
	crypt                           CMsgSteamDatagramSessionCryptInfoSigned
	has_crypt                       bool
	cert                            CMsgSteamDatagramCertificateSigned
	has_cert                        bool
}

pub fn (o &CMsgSteamDatagramConnectOK) pack() []byte {
	mut res := []byte{}
	if o.has_client_connection_id {
		res << vproto.pack_32bit_field(o.client_connection_id, 1)
	}
	if o.has_server_connection_id {
		res << vproto.pack_32bit_field(o.server_connection_id, 7)
	}
	if o.has_your_timestamp {
		res << vproto.pack_64bit_field(o.your_timestamp, 3)
	}
	if o.has_delay_time_usec {
		res << vproto.pack_uint32_field(o.delay_time_usec, 4)
	}
	if o.has_gameserver_relay_session_id {
		res << vproto.pack_uint32_field(o.gameserver_relay_session_id, 2)
	}
	if o.has_crypt {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfosigned(o.crypt, 5)
	}
	if o.has_cert {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 6)
	}
	return res
}

pub fn cmsgsteamdatagramconnectok_unpack(buf []byte) ?CMsgSteamDatagramConnectOK {
	mut res := CMsgSteamDatagramConnectOK{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_client_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_connection_id = v
				i = ii
			}
			7 {
				res.has_server_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.server_connection_id = v
				i = ii
			}
			3 {
				res.has_your_timestamp = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.your_timestamp = v
				i = ii
			}
			4 {
				res.has_delay_time_usec = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.delay_time_usec = v
				i = ii
			}
			2 {
				res.has_gameserver_relay_session_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.gameserver_relay_session_id = v
				i = ii
			}
			5 {
				res.has_crypt = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfosigned(cur_buf,
					tag_wiretype.wire_type)?
				res.crypt = v
				i = ii
			}
			6 {
				res.has_cert = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf,
					tag_wiretype.wire_type)?
				res.cert = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectok() CMsgSteamDatagramConnectOK {
	return CMsgSteamDatagramConnectOK{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectok(o CMsgSteamDatagramConnectOK, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectok(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectOK) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramconnectok_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamNetworkingP2PSDRRoutingSummary {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	initial_ping                  u32
	has_initial_ping              bool
	initial_ping_front_local      u32
	has_initial_ping_front_local  bool
	initial_ping_front_remote     u32
	has_initial_ping_front_remote bool
	initial_score                 u32
	has_initial_score             bool
	initial_pop_local             u32
	has_initial_pop_local         bool
	initial_pop_remote            u32
	has_initial_pop_remote        bool
	negotiation_ms                u32
	has_negotiation_ms            bool
	selected_seconds              u32
	has_selected_seconds          bool
}

pub fn (o &CMsgSteamNetworkingP2PSDRRoutingSummary) pack() []byte {
	mut res := []byte{}
	if o.has_initial_ping {
		res << vproto.pack_uint32_field(o.initial_ping, 1)
	}
	if o.has_initial_ping_front_local {
		res << vproto.pack_uint32_field(o.initial_ping_front_local, 2)
	}
	if o.has_initial_ping_front_remote {
		res << vproto.pack_uint32_field(o.initial_ping_front_remote, 3)
	}
	if o.has_initial_score {
		res << vproto.pack_uint32_field(o.initial_score, 4)
	}
	if o.has_initial_pop_local {
		res << vproto.pack_32bit_field(o.initial_pop_local, 5)
	}
	if o.has_initial_pop_remote {
		res << vproto.pack_32bit_field(o.initial_pop_remote, 6)
	}
	if o.has_negotiation_ms {
		res << vproto.pack_uint32_field(o.negotiation_ms, 7)
	}
	if o.has_selected_seconds {
		res << vproto.pack_uint32_field(o.selected_seconds, 8)
	}
	return res
}

pub fn cmsgsteamnetworkingp2psdrroutingsummary_unpack(buf []byte) ?CMsgSteamNetworkingP2PSDRRoutingSummary {
	mut res := CMsgSteamNetworkingP2PSDRRoutingSummary{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_initial_ping = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_ping = v
				i = ii
			}
			2 {
				res.has_initial_ping_front_local = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_ping_front_local = v
				i = ii
			}
			3 {
				res.has_initial_ping_front_remote = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_ping_front_remote = v
				i = ii
			}
			4 {
				res.has_initial_score = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_score = v
				i = ii
			}
			5 {
				res.has_initial_pop_local = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_pop_local = v
				i = ii
			}
			6 {
				res.has_initial_pop_remote = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_pop_remote = v
				i = ii
			}
			7 {
				res.has_negotiation_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.negotiation_ms = v
				i = ii
			}
			8 {
				res.has_selected_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.selected_seconds = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingp2psdrroutingsummary() CMsgSteamNetworkingP2PSDRRoutingSummary {
	return CMsgSteamNetworkingP2PSDRRoutingSummary{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingp2psdrroutingsummary(o CMsgSteamNetworkingP2PSDRRoutingSummary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingp2psdrroutingsummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingP2PSDRRoutingSummary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamnetworkingp2psdrroutingsummary_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PRoutingSummary {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ice            CMsgSteamNetworkingICESessionSummary
	has_ice        bool
	sdr            CMsgSteamNetworkingP2PSDRRoutingSummary
	has_sdr        bool
}

pub fn (o &CMsgSteamDatagramP2PRoutingSummary) pack() []byte {
	mut res := []byte{}
	if o.has_ice {
		res << zzz_vproto_internal_pack_cmsgsteamnetworkingicesessionsummary(o.ice, 2)
	}
	if o.has_sdr {
		res << zzz_vproto_internal_pack_cmsgsteamnetworkingp2psdrroutingsummary(o.sdr, 3)
	}
	return res
}

pub fn cmsgsteamdatagramp2proutingsummary_unpack(buf []byte) ?CMsgSteamDatagramP2PRoutingSummary {
	mut res := CMsgSteamDatagramP2PRoutingSummary{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				res.has_ice = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingicesessionsummary(cur_buf,
					tag_wiretype.wire_type)?
				res.ice = v
				i = ii
			}
			3 {
				res.has_sdr = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingp2psdrroutingsummary(cur_buf,
					tag_wiretype.wire_type)?
				res.sdr = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2proutingsummary() CMsgSteamDatagramP2PRoutingSummary {
	return CMsgSteamDatagramP2PRoutingSummary{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2proutingsummary(o CMsgSteamDatagramP2PRoutingSummary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutingsummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PRoutingSummary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramp2proutingsummary_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionClosed_ERelayMode {
	@none = 0
	endtoend = 1
	closedbypeer = 2
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionclosed_erelaymode(e CMsgSteamDatagramConnectionClosed_ERelayMode, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionclosed_erelaymode_packed(e []CMsgSteamDatagramConnectionClosed_ERelayMode, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionclosed_erelaymode(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionClosed_ERelayMode) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CMsgSteamDatagramConnectionClosed_ERelayMode(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionclosed_erelaymode_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionClosed_ERelayMode) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionClosed {
mut:
	unknown_fields                         []vproto.UnknownField
pub mut:
	to_connection_id                       u32
	has_to_connection_id                   bool
	from_connection_id                     u32
	has_from_connection_id                 bool
	from_identity_string                   string
	has_from_identity_string               bool
	legacy_from_identity_binary            CMsgSteamNetworkingIdentityLegacyBinary
	has_legacy_from_identity_binary        bool
	legacy_from_steam_id                   u64
	has_legacy_from_steam_id               bool
	legacy_gameserver_relay_session_id     u32
	has_legacy_gameserver_relay_session_id bool
	to_relay_session_id                    u32
	has_to_relay_session_id                bool
	from_relay_session_id                  u32
	has_from_relay_session_id              bool
	forward_target_relay_routing_token     []byte
	has_forward_target_relay_routing_token bool
	forward_target_revision                u32
	has_forward_target_revision            bool
	relay_mode                             CMsgSteamDatagramConnectionClosed_ERelayMode
	has_relay_mode                         bool
	debug                                  string
	has_debug                              bool
	reason_code                            u32
	has_reason_code                        bool
	routing_secret                         u64
	has_routing_secret                     bool
	not_primary_session                    bool
	has_not_primary_session                bool
	not_primary_transport                  bool
	has_not_primary_transport              bool
	quality_relay                          CMsgSteamDatagramConnectionQuality
	has_quality_relay                      bool
	quality_e2e                            CMsgSteamDatagramConnectionQuality
	has_quality_e2e                        bool
	p2p_routing_summary                    CMsgSteamDatagramP2PRoutingSummary
	has_p2p_routing_summary                bool
}

pub fn (o &CMsgSteamDatagramConnectionClosed) pack() []byte {
	mut res := []byte{}
	if o.has_to_connection_id {
		res << vproto.pack_32bit_field(o.to_connection_id, 7)
	}
	if o.has_from_connection_id {
		res << vproto.pack_32bit_field(o.from_connection_id, 8)
	}
	if o.has_from_identity_string {
		res << vproto.pack_string_field(o.from_identity_string, 15)
	}
	if o.has_legacy_from_identity_binary {
		res <<
			zzz_vproto_internal_pack_cmsgsteamnetworkingidentitylegacybinary(o.legacy_from_identity_binary, 13)
	}
	if o.has_legacy_from_steam_id {
		res << vproto.pack_64bit_field(o.legacy_from_steam_id, 3)
	}
	if o.has_legacy_gameserver_relay_session_id {
		res << vproto.pack_uint32_field(o.legacy_gameserver_relay_session_id, 2)
	}
	if o.has_to_relay_session_id {
		res << vproto.pack_32bit_field(o.to_relay_session_id, 9)
	}
	if o.has_from_relay_session_id {
		res << vproto.pack_32bit_field(o.from_relay_session_id, 10)
	}
	if o.has_forward_target_relay_routing_token {
		res << vproto.pack_bytes_field(o.forward_target_relay_routing_token, 11)
	}
	if o.has_forward_target_revision {
		res << vproto.pack_uint32_field(o.forward_target_revision, 12)
	}
	if o.has_relay_mode {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramconnectionclosed_erelaymode(o.relay_mode, 4)
	}
	if o.has_debug {
		res << vproto.pack_string_field(o.debug, 5)
	}
	if o.has_reason_code {
		res << vproto.pack_uint32_field(o.reason_code, 6)
	}
	if o.has_routing_secret {
		res << vproto.pack_64bit_field(o.routing_secret, 14)
	}
	if o.has_not_primary_session {
		res << vproto.pack_bool_field(o.not_primary_session, 16)
	}
	if o.has_not_primary_transport {
		res << vproto.pack_bool_field(o.not_primary_transport, 19)
	}
	if o.has_quality_relay {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 17)
	}
	if o.has_quality_e2e {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 18)
	}
	if o.has_p2p_routing_summary {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramp2proutingsummary(o.p2p_routing_summary, 21)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionclosed_unpack(buf []byte) ?CMsgSteamDatagramConnectionClosed {
	mut res := CMsgSteamDatagramConnectionClosed{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			7 {
				res.has_to_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.to_connection_id = v
				i = ii
			}
			8 {
				res.has_from_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.from_connection_id = v
				i = ii
			}
			15 {
				res.has_from_identity_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.from_identity_string = v
				i = ii
			}
			13 {
				res.has_legacy_from_identity_binary = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingidentitylegacybinary(cur_buf,
					tag_wiretype.wire_type)?
				res.legacy_from_identity_binary = v
				i = ii
			}
			3 {
				res.has_legacy_from_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_from_steam_id = v
				i = ii
			}
			2 {
				res.has_legacy_gameserver_relay_session_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_gameserver_relay_session_id = v
				i = ii
			}
			9 {
				res.has_to_relay_session_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.to_relay_session_id = v
				i = ii
			}
			10 {
				res.has_from_relay_session_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.from_relay_session_id = v
				i = ii
			}
			11 {
				res.has_forward_target_relay_routing_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.forward_target_relay_routing_token = v
				i = ii
			}
			12 {
				res.has_forward_target_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.forward_target_revision = v
				i = ii
			}
			4 {
				res.has_relay_mode = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionclosed_erelaymode(cur_buf,
					tag_wiretype.wire_type)?
				res.relay_mode = v
				i = ii
			}
			5 {
				res.has_debug = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.debug = v
				i = ii
			}
			6 {
				res.has_reason_code = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.reason_code = v
				i = ii
			}
			14 {
				res.has_routing_secret = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.routing_secret = v
				i = ii
			}
			16 {
				res.has_not_primary_session = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.not_primary_session = v
				i = ii
			}
			19 {
				res.has_not_primary_transport = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.not_primary_transport = v
				i = ii
			}
			17 {
				res.has_quality_relay = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_relay = v
				i = ii
			}
			18 {
				res.has_quality_e2e = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_e2e = v
				i = ii
			}
			21 {
				res.has_p2p_routing_summary = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutingsummary(cur_buf,
					tag_wiretype.wire_type)?
				res.p2p_routing_summary = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionclosed() CMsgSteamDatagramConnectionClosed {
	return CMsgSteamDatagramConnectionClosed{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionclosed(o CMsgSteamDatagramConnectionClosed, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionclosed(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionClosed) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramconnectionclosed_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramNoConnection {
mut:
	unknown_fields                         []vproto.UnknownField
pub mut:
	to_connection_id                       u32
	has_to_connection_id                   bool
	from_connection_id                     u32
	has_from_connection_id                 bool
	legacy_gameserver_relay_session_id     u32
	has_legacy_gameserver_relay_session_id bool
	to_relay_session_id                    u32
	has_to_relay_session_id                bool
	from_relay_session_id                  u32
	has_from_relay_session_id              bool
	from_identity_string                   string
	has_from_identity_string               bool
	legacy_from_steam_id                   u64
	has_legacy_from_steam_id               bool
	end_to_end                             bool
	has_end_to_end                         bool
	not_primary_session                    bool
	has_not_primary_session                bool
	not_primary_transport                  bool
	has_not_primary_transport              bool
	quality_relay                          CMsgSteamDatagramConnectionQuality
	has_quality_relay                      bool
	quality_e2e                            CMsgSteamDatagramConnectionQuality
	has_quality_e2e                        bool
	p2p_routing_summary                    CMsgSteamDatagramP2PRoutingSummary
	has_p2p_routing_summary                bool
	routing_secret                         u64
	has_routing_secret                     bool
	dummy_pad                              u32
	has_dummy_pad                          bool
}

pub fn (o &CMsgSteamDatagramNoConnection) pack() []byte {
	mut res := []byte{}
	if o.has_to_connection_id {
		res << vproto.pack_32bit_field(o.to_connection_id, 5)
	}
	if o.has_from_connection_id {
		res << vproto.pack_32bit_field(o.from_connection_id, 6)
	}
	if o.has_legacy_gameserver_relay_session_id {
		res << vproto.pack_uint32_field(o.legacy_gameserver_relay_session_id, 2)
	}
	if o.has_to_relay_session_id {
		res << vproto.pack_32bit_field(o.to_relay_session_id, 9)
	}
	if o.has_from_relay_session_id {
		res << vproto.pack_32bit_field(o.from_relay_session_id, 10)
	}
	if o.has_from_identity_string {
		res << vproto.pack_string_field(o.from_identity_string, 7)
	}
	if o.has_legacy_from_steam_id {
		res << vproto.pack_64bit_field(o.legacy_from_steam_id, 3)
	}
	if o.has_end_to_end {
		res << vproto.pack_bool_field(o.end_to_end, 4)
	}
	if o.has_not_primary_session {
		res << vproto.pack_bool_field(o.not_primary_session, 12)
	}
	if o.has_not_primary_transport {
		res << vproto.pack_bool_field(o.not_primary_transport, 15)
	}
	if o.has_quality_relay {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 13)
	}
	if o.has_quality_e2e {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 14)
	}
	if o.has_p2p_routing_summary {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramp2proutingsummary(o.p2p_routing_summary, 16)
	}
	if o.has_routing_secret {
		res << vproto.pack_64bit_field(o.routing_secret, 11)
	}
	if o.has_dummy_pad {
		res << vproto.pack_32bit_field(o.dummy_pad, 1023)
	}
	return res
}

pub fn cmsgsteamdatagramnoconnection_unpack(buf []byte) ?CMsgSteamDatagramNoConnection {
	mut res := CMsgSteamDatagramNoConnection{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			5 {
				res.has_to_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.to_connection_id = v
				i = ii
			}
			6 {
				res.has_from_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.from_connection_id = v
				i = ii
			}
			2 {
				res.has_legacy_gameserver_relay_session_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_gameserver_relay_session_id = v
				i = ii
			}
			9 {
				res.has_to_relay_session_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.to_relay_session_id = v
				i = ii
			}
			10 {
				res.has_from_relay_session_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.from_relay_session_id = v
				i = ii
			}
			7 {
				res.has_from_identity_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.from_identity_string = v
				i = ii
			}
			3 {
				res.has_legacy_from_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_from_steam_id = v
				i = ii
			}
			4 {
				res.has_end_to_end = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.end_to_end = v
				i = ii
			}
			12 {
				res.has_not_primary_session = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.not_primary_session = v
				i = ii
			}
			15 {
				res.has_not_primary_transport = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.not_primary_transport = v
				i = ii
			}
			13 {
				res.has_quality_relay = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_relay = v
				i = ii
			}
			14 {
				res.has_quality_e2e = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_e2e = v
				i = ii
			}
			16 {
				res.has_p2p_routing_summary = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutingsummary(cur_buf,
					tag_wiretype.wire_type)?
				res.p2p_routing_summary = v
				i = ii
			}
			11 {
				res.has_routing_secret = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.routing_secret = v
				i = ii
			}
			1023 {
				res.has_dummy_pad = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.dummy_pad = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramnoconnection() CMsgSteamDatagramNoConnection {
	return CMsgSteamDatagramNoConnection{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramnoconnection(o CMsgSteamDatagramNoConnection, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramnoconnection(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramNoConnection) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramnoconnection_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameserverSessionRequest {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	ticket                     []byte
	has_ticket                 bool
	challenge_time             u32
	has_challenge_time         bool
	challenge                  u64
	has_challenge              bool
	client_connection_id       u32
	has_client_connection_id   bool
	server_connection_id       u32
	has_server_connection_id   bool
	network_config_version     u32
	has_network_config_version bool
	protocol_version           u32
	has_protocol_version       bool
}

pub fn (o &CMsgSteamDatagramGameserverSessionRequest) pack() []byte {
	mut res := []byte{}
	if o.has_ticket {
		res << vproto.pack_bytes_field(o.ticket, 1)
	}
	if o.has_challenge_time {
		res << vproto.pack_32bit_field(o.challenge_time, 3)
	}
	if o.has_challenge {
		res << vproto.pack_64bit_field(o.challenge, 4)
	}
	if o.has_client_connection_id {
		res << vproto.pack_32bit_field(o.client_connection_id, 5)
	}
	if o.has_server_connection_id {
		res << vproto.pack_32bit_field(o.server_connection_id, 8)
	}
	if o.has_network_config_version {
		res << vproto.pack_uint32_field(o.network_config_version, 6)
	}
	if o.has_protocol_version {
		res << vproto.pack_uint32_field(o.protocol_version, 7)
	}
	return res
}

pub fn cmsgsteamdatagramgameserversessionrequest_unpack(buf []byte) ?CMsgSteamDatagramGameserverSessionRequest {
	mut res := CMsgSteamDatagramGameserverSessionRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ticket = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.ticket = v
				i = ii
			}
			3 {
				res.has_challenge_time = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.challenge_time = v
				i = ii
			}
			4 {
				res.has_challenge = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.challenge = v
				i = ii
			}
			5 {
				res.has_client_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_connection_id = v
				i = ii
			}
			8 {
				res.has_server_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.server_connection_id = v
				i = ii
			}
			6 {
				res.has_network_config_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.network_config_version = v
				i = ii
			}
			7 {
				res.has_protocol_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.protocol_version = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserversessionrequest() CMsgSteamDatagramGameserverSessionRequest {
	return CMsgSteamDatagramGameserverSessionRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserversessionrequest(o CMsgSteamDatagramGameserverSessionRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversessionrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverSessionRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramgameserversessionrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameserverSessionEstablished {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	connection_id                    u32
	has_connection_id                bool
	gameserver_identity_string       string
	has_gameserver_identity_string   bool
	seconds_until_shutdown           u32
	has_seconds_until_shutdown       bool
	seq_num_r2c                      u32
	has_seq_num_r2c                  bool
	dummy_legacy_identity_binary     []byte
	has_dummy_legacy_identity_binary bool
	legacy_gameserver_steamid        u64
	has_legacy_gameserver_steamid    bool
}

pub fn (o &CMsgSteamDatagramGameserverSessionEstablished) pack() []byte {
	mut res := []byte{}
	if o.has_connection_id {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	if o.has_gameserver_identity_string {
		res << vproto.pack_string_field(o.gameserver_identity_string, 2)
	}
	if o.has_seconds_until_shutdown {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 4)
	}
	if o.has_seq_num_r2c {
		res << vproto.pack_uint32_field(o.seq_num_r2c, 6)
	}
	if o.has_dummy_legacy_identity_binary {
		res << vproto.pack_bytes_field(o.dummy_legacy_identity_binary, 7)
	}
	if o.has_legacy_gameserver_steamid {
		res << vproto.pack_64bit_field(o.legacy_gameserver_steamid, 3)
	}
	return res
}

pub fn cmsgsteamdatagramgameserversessionestablished_unpack(buf []byte) ?CMsgSteamDatagramGameserverSessionEstablished {
	mut res := CMsgSteamDatagramGameserverSessionEstablished{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_id = v
				i = ii
			}
			2 {
				res.has_gameserver_identity_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.gameserver_identity_string = v
				i = ii
			}
			4 {
				res.has_seconds_until_shutdown = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_until_shutdown = v
				i = ii
			}
			6 {
				res.has_seq_num_r2c = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_r2c = v
				i = ii
			}
			7 {
				res.has_dummy_legacy_identity_binary = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.dummy_legacy_identity_binary = v
				i = ii
			}
			3 {
				res.has_legacy_gameserver_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_gameserver_steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserversessionestablished() CMsgSteamDatagramGameserverSessionEstablished {
	return CMsgSteamDatagramGameserverSessionEstablished{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserversessionestablished(o CMsgSteamDatagramGameserverSessionEstablished, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversessionestablished(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameserverSessionEstablished) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramgameserversessionestablished_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsClientToRouter_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
	not_primary_session = 8
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsclienttorouter_flags(e CMsgSteamDatagramConnectionStatsClientToRouter_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsclienttorouter_flags_packed(e []CMsgSteamDatagramConnectionStatsClientToRouter_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsclienttorouter_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsClientToRouter_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CMsgSteamDatagramConnectionStatsClientToRouter_Flags(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsclienttorouter_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsClientToRouter_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsClientToRouter {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	quality_relay            CMsgSteamDatagramConnectionQuality
	has_quality_relay        bool
	quality_e2e              CMsgSteamDatagramConnectionQuality
	has_quality_e2e          bool
	ack_relay                []u32
	legacy_ack_e2e           []u32
	flags                    u32
	has_flags                bool
	client_connection_id     u32
	has_client_connection_id bool
	seq_num_c2r              u32
	has_seq_num_c2r          bool
	seq_num_e2e              u32
	has_seq_num_e2e          bool
}

pub fn (o &CMsgSteamDatagramConnectionStatsClientToRouter) pack() []byte {
	mut res := []byte{}
	if o.has_quality_relay {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.has_quality_e2e {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 4)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 5)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 6)
	}
	if o.has_client_connection_id {
		res << vproto.pack_32bit_field(o.client_connection_id, 8)
	}
	if o.has_seq_num_c2r {
		res << vproto.pack_uint32_field(o.seq_num_c2r, 9)
	}
	if o.has_seq_num_e2e {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 10)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsclienttorouter_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsClientToRouter {
	mut res := CMsgSteamDatagramConnectionStatsClientToRouter{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_quality_relay = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_relay = v
				i = ii
			}
			2 {
				res.has_quality_e2e = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_e2e = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_relay << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_ack_e2e << v
				i = ii
			}
			6 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			8 {
				res.has_client_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_connection_id = v
				i = ii
			}
			9 {
				res.has_seq_num_c2r = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_c2r = v
				i = ii
			}
			10 {
				res.has_seq_num_e2e = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_e2e = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsclienttorouter() CMsgSteamDatagramConnectionStatsClientToRouter {
	return CMsgSteamDatagramConnectionStatsClientToRouter{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsclienttorouter(o CMsgSteamDatagramConnectionStatsClientToRouter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsclienttorouter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsClientToRouter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramconnectionstatsclienttorouter_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsRouterToClient_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoclient_flags(e CMsgSteamDatagramConnectionStatsRouterToClient_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoclient_flags_packed(e []CMsgSteamDatagramConnectionStatsRouterToClient_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoclient_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsRouterToClient_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CMsgSteamDatagramConnectionStatsRouterToClient_Flags(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoclient_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsRouterToClient_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsRouterToClient {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	quality_relay                     CMsgSteamDatagramConnectionQuality
	has_quality_relay                 bool
	quality_e2e                       CMsgSteamDatagramConnectionQuality
	has_quality_e2e                   bool
	seconds_until_shutdown            u32
	has_seconds_until_shutdown        bool
	migrate_request_ip                u32
	has_migrate_request_ip            bool
	migrate_request_port              u32
	has_migrate_request_port          bool
	scoring_penalty_relay_cluster     u32
	has_scoring_penalty_relay_cluster bool
	ack_relay                         []u32
	legacy_ack_e2e                    []u32
	flags                             u32
	has_flags                         bool
	client_connection_id              u32
	has_client_connection_id          bool
	seq_num_r2c                       u32
	has_seq_num_r2c                   bool
	seq_num_e2e                       u32
	has_seq_num_e2e                   bool
}

pub fn (o &CMsgSteamDatagramConnectionStatsRouterToClient) pack() []byte {
	mut res := []byte{}
	if o.has_quality_relay {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.has_quality_e2e {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	if o.has_seconds_until_shutdown {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 6)
	}
	if o.has_migrate_request_ip {
		res << vproto.pack_32bit_field(o.migrate_request_ip, 10)
	}
	if o.has_migrate_request_port {
		res << vproto.pack_uint32_field(o.migrate_request_port, 11)
	}
	if o.has_scoring_penalty_relay_cluster {
		res << vproto.pack_uint32_field(o.scoring_penalty_relay_cluster, 12)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 13)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 14)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 15)
	}
	if o.has_client_connection_id {
		res << vproto.pack_32bit_field(o.client_connection_id, 7)
	}
	if o.has_seq_num_r2c {
		res << vproto.pack_uint32_field(o.seq_num_r2c, 8)
	}
	if o.has_seq_num_e2e {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 9)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsroutertoclient_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsRouterToClient {
	mut res := CMsgSteamDatagramConnectionStatsRouterToClient{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_quality_relay = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_relay = v
				i = ii
			}
			2 {
				res.has_quality_e2e = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_e2e = v
				i = ii
			}
			6 {
				res.has_seconds_until_shutdown = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_until_shutdown = v
				i = ii
			}
			10 {
				res.has_migrate_request_ip = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.migrate_request_ip = v
				i = ii
			}
			11 {
				res.has_migrate_request_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.migrate_request_port = v
				i = ii
			}
			12 {
				res.has_scoring_penalty_relay_cluster = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scoring_penalty_relay_cluster = v
				i = ii
			}
			13 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_relay << v
				i = ii
			}
			14 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_ack_e2e << v
				i = ii
			}
			15 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			7 {
				res.has_client_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_connection_id = v
				i = ii
			}
			8 {
				res.has_seq_num_r2c = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_r2c = v
				i = ii
			}
			9 {
				res.has_seq_num_e2e = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_e2e = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsroutertoclient() CMsgSteamDatagramConnectionStatsRouterToClient {
	return CMsgSteamDatagramConnectionStatsRouterToClient{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoclient(o CMsgSteamDatagramConnectionStatsRouterToClient, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsRouterToClient) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramconnectionstatsroutertoclient_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsRouterToServer_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoserver_flags(e CMsgSteamDatagramConnectionStatsRouterToServer_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoserver_flags_packed(e []CMsgSteamDatagramConnectionStatsRouterToServer_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoserver_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsRouterToServer_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CMsgSteamDatagramConnectionStatsRouterToServer_Flags(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoserver_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsRouterToServer_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsRouterToServer {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	quality_relay              CMsgSteamDatagramConnectionQuality
	has_quality_relay          bool
	quality_e2e                CMsgSteamDatagramConnectionQuality
	has_quality_e2e            bool
	ack_relay                  []u32
	legacy_ack_e2e             []u32
	flags                      u32
	has_flags                  bool
	seq_num_r2s                u32
	has_seq_num_r2s            bool
	seq_num_e2e                u32
	has_seq_num_e2e            bool
	client_identity_string     string
	has_client_identity_string bool
	legacy_client_steam_id     u64
	has_legacy_client_steam_id bool
	relay_session_id           u32
	has_relay_session_id       bool
	client_connection_id       u32
	has_client_connection_id   bool
	server_connection_id       u32
	has_server_connection_id   bool
	routing_secret             u64
	has_routing_secret         bool
}

pub fn (o &CMsgSteamDatagramConnectionStatsRouterToServer) pack() []byte {
	mut res := []byte{}
	if o.has_quality_relay {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.has_quality_e2e {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 10)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 11)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 12)
	}
	if o.has_seq_num_r2s {
		res << vproto.pack_uint32_field(o.seq_num_r2s, 5)
	}
	if o.has_seq_num_e2e {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 6)
	}
	if o.has_client_identity_string {
		res << vproto.pack_string_field(o.client_identity_string, 15)
	}
	if o.has_legacy_client_steam_id {
		res << vproto.pack_64bit_field(o.legacy_client_steam_id, 7)
	}
	if o.has_relay_session_id {
		res << vproto.pack_uint32_field(o.relay_session_id, 8)
	}
	if o.has_client_connection_id {
		res << vproto.pack_32bit_field(o.client_connection_id, 9)
	}
	if o.has_server_connection_id {
		res << vproto.pack_32bit_field(o.server_connection_id, 13)
	}
	if o.has_routing_secret {
		res << vproto.pack_64bit_field(o.routing_secret, 14)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsroutertoserver_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsRouterToServer {
	mut res := CMsgSteamDatagramConnectionStatsRouterToServer{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_quality_relay = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_relay = v
				i = ii
			}
			2 {
				res.has_quality_e2e = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_e2e = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_relay << v
				i = ii
			}
			11 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_ack_e2e << v
				i = ii
			}
			12 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			5 {
				res.has_seq_num_r2s = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_r2s = v
				i = ii
			}
			6 {
				res.has_seq_num_e2e = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_e2e = v
				i = ii
			}
			15 {
				res.has_client_identity_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.client_identity_string = v
				i = ii
			}
			7 {
				res.has_legacy_client_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_client_steam_id = v
				i = ii
			}
			8 {
				res.has_relay_session_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.relay_session_id = v
				i = ii
			}
			9 {
				res.has_client_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_connection_id = v
				i = ii
			}
			13 {
				res.has_server_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.server_connection_id = v
				i = ii
			}
			14 {
				res.has_routing_secret = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.routing_secret = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsroutertoserver() CMsgSteamDatagramConnectionStatsRouterToServer {
	return CMsgSteamDatagramConnectionStatsRouterToServer{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsroutertoserver(o CMsgSteamDatagramConnectionStatsRouterToServer, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsroutertoserver(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsRouterToServer) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramconnectionstatsroutertoserver_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsServerToRouter_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsservertorouter_flags(e CMsgSteamDatagramConnectionStatsServerToRouter_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsservertorouter_flags_packed(e []CMsgSteamDatagramConnectionStatsServerToRouter_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsservertorouter_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsServerToRouter_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CMsgSteamDatagramConnectionStatsServerToRouter_Flags(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsservertorouter_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsServerToRouter_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsServerToRouter {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	quality_relay            CMsgSteamDatagramConnectionQuality
	has_quality_relay        bool
	quality_e2e              CMsgSteamDatagramConnectionQuality
	has_quality_e2e          bool
	ack_relay                []u32
	legacy_ack_e2e           []u32
	flags                    u32
	has_flags                bool
	seq_num_s2r              u32
	has_seq_num_s2r          bool
	seq_num_e2e              u32
	has_seq_num_e2e          bool
	relay_session_id         u32
	has_relay_session_id     bool
	client_connection_id     u32
	has_client_connection_id bool
	server_connection_id     u32
	has_server_connection_id bool
}

pub fn (o &CMsgSteamDatagramConnectionStatsServerToRouter) pack() []byte {
	mut res := []byte{}
	if o.has_quality_relay {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.has_quality_e2e {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 8)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 9)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 10)
	}
	if o.has_seq_num_s2r {
		res << vproto.pack_uint32_field(o.seq_num_s2r, 3)
	}
	if o.has_seq_num_e2e {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 4)
	}
	if o.has_relay_session_id {
		res << vproto.pack_uint32_field(o.relay_session_id, 6)
	}
	if o.has_client_connection_id {
		res << vproto.pack_32bit_field(o.client_connection_id, 7)
	}
	if o.has_server_connection_id {
		res << vproto.pack_32bit_field(o.server_connection_id, 11)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsservertorouter_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsServerToRouter {
	mut res := CMsgSteamDatagramConnectionStatsServerToRouter{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_quality_relay = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_relay = v
				i = ii
			}
			2 {
				res.has_quality_e2e = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_e2e = v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_relay << v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_ack_e2e << v
				i = ii
			}
			10 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			3 {
				res.has_seq_num_s2r = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_s2r = v
				i = ii
			}
			4 {
				res.has_seq_num_e2e = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_e2e = v
				i = ii
			}
			6 {
				res.has_relay_session_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.relay_session_id = v
				i = ii
			}
			7 {
				res.has_client_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_connection_id = v
				i = ii
			}
			11 {
				res.has_server_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.server_connection_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsservertorouter() CMsgSteamDatagramConnectionStatsServerToRouter {
	return CMsgSteamDatagramConnectionStatsServerToRouter{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsservertorouter(o CMsgSteamDatagramConnectionStatsServerToRouter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsservertorouter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsServerToRouter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramconnectionstatsservertorouter_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PSessionRequestBody {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	challenge_time             u32
	has_challenge_time         bool
	challenge                  u64
	has_challenge              bool
	client_connection_id       u32
	has_client_connection_id   bool
	legacy_peer_steam_id       u64
	has_legacy_peer_steam_id   bool
	peer_identity_string       string
	has_peer_identity_string   bool
	peer_connection_id         u32
	has_peer_connection_id     bool
	protocol_version           u32
	has_protocol_version       bool
	network_config_version     u32
	has_network_config_version bool
	public_ip                  u32
	has_public_ip              bool
}

pub fn (o &CMsgSteamDatagramP2PSessionRequestBody) pack() []byte {
	mut res := []byte{}
	if o.has_challenge_time {
		res << vproto.pack_32bit_field(o.challenge_time, 1)
	}
	if o.has_challenge {
		res << vproto.pack_64bit_field(o.challenge, 2)
	}
	if o.has_client_connection_id {
		res << vproto.pack_32bit_field(o.client_connection_id, 3)
	}
	if o.has_legacy_peer_steam_id {
		res << vproto.pack_64bit_field(o.legacy_peer_steam_id, 4)
	}
	if o.has_peer_identity_string {
		res << vproto.pack_string_field(o.peer_identity_string, 11)
	}
	if o.has_peer_connection_id {
		res << vproto.pack_32bit_field(o.peer_connection_id, 5)
	}
	if o.has_protocol_version {
		res << vproto.pack_uint32_field(o.protocol_version, 8)
	}
	if o.has_network_config_version {
		res << vproto.pack_uint32_field(o.network_config_version, 9)
	}
	if o.has_public_ip {
		res << vproto.pack_32bit_field(o.public_ip, 10)
	}
	return res
}

pub fn cmsgsteamdatagramp2psessionrequestbody_unpack(buf []byte) ?CMsgSteamDatagramP2PSessionRequestBody {
	mut res := CMsgSteamDatagramP2PSessionRequestBody{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_challenge_time = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.challenge_time = v
				i = ii
			}
			2 {
				res.has_challenge = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.challenge = v
				i = ii
			}
			3 {
				res.has_client_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_connection_id = v
				i = ii
			}
			4 {
				res.has_legacy_peer_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_peer_steam_id = v
				i = ii
			}
			11 {
				res.has_peer_identity_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.peer_identity_string = v
				i = ii
			}
			5 {
				res.has_peer_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.peer_connection_id = v
				i = ii
			}
			8 {
				res.has_protocol_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.protocol_version = v
				i = ii
			}
			9 {
				res.has_network_config_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.network_config_version = v
				i = ii
			}
			10 {
				res.has_public_ip = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.public_ip = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2psessionrequestbody() CMsgSteamDatagramP2PSessionRequestBody {
	return CMsgSteamDatagramP2PSessionRequestBody{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2psessionrequestbody(o CMsgSteamDatagramP2PSessionRequestBody, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2psessionrequestbody(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PSessionRequestBody) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramp2psessionrequestbody_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PSessionRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	cert           CMsgSteamDatagramCertificateSigned
	has_cert       bool
	body           []byte
	has_body       bool
	signature      []byte
	has_signature  bool
}

pub fn (o &CMsgSteamDatagramP2PSessionRequest) pack() []byte {
	mut res := []byte{}
	if o.has_cert {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 1)
	}
	if o.has_body {
		res << vproto.pack_bytes_field(o.body, 2)
	}
	if o.has_signature {
		res << vproto.pack_bytes_field(o.signature, 3)
	}
	return res
}

pub fn cmsgsteamdatagramp2psessionrequest_unpack(buf []byte) ?CMsgSteamDatagramP2PSessionRequest {
	mut res := CMsgSteamDatagramP2PSessionRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_cert = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf,
					tag_wiretype.wire_type)?
				res.cert = v
				i = ii
			}
			2 {
				res.has_body = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.body = v
				i = ii
			}
			3 {
				res.has_signature = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.signature = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2psessionrequest() CMsgSteamDatagramP2PSessionRequest {
	return CMsgSteamDatagramP2PSessionRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2psessionrequest(o CMsgSteamDatagramP2PSessionRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2psessionrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PSessionRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramp2psessionrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PSessionEstablished {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	connection_id              u32
	has_connection_id          bool
	seconds_until_shutdown     u32
	has_seconds_until_shutdown bool
	relay_routing_token        []byte
	has_relay_routing_token    bool
	seq_num_r2c                u32
	has_seq_num_r2c            bool
}

pub fn (o &CMsgSteamDatagramP2PSessionEstablished) pack() []byte {
	mut res := []byte{}
	if o.has_connection_id {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	if o.has_seconds_until_shutdown {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 3)
	}
	if o.has_relay_routing_token {
		res << vproto.pack_bytes_field(o.relay_routing_token, 4)
	}
	if o.has_seq_num_r2c {
		res << vproto.pack_uint32_field(o.seq_num_r2c, 5)
	}
	return res
}

pub fn cmsgsteamdatagramp2psessionestablished_unpack(buf []byte) ?CMsgSteamDatagramP2PSessionEstablished {
	mut res := CMsgSteamDatagramP2PSessionEstablished{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_id = v
				i = ii
			}
			3 {
				res.has_seconds_until_shutdown = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_until_shutdown = v
				i = ii
			}
			4 {
				res.has_relay_routing_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.relay_routing_token = v
				i = ii
			}
			5 {
				res.has_seq_num_r2c = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_r2c = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2psessionestablished() CMsgSteamDatagramP2PSessionEstablished {
	return CMsgSteamDatagramP2PSessionEstablished{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2psessionestablished(o CMsgSteamDatagramP2PSessionEstablished, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2psessionestablished(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PSessionEstablished) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramp2psessionestablished_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
	not_primary_session = 8
	not_primary_transport_e2e = 16
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2pclienttorouter_flags(e CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2pclienttorouter_flags_packed(e []CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2pclienttorouter_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2pclienttorouter_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsP2PClientToRouter_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsP2PClientToRouter {
mut:
	unknown_fields                         []vproto.UnknownField
pub mut:
	quality_relay                          CMsgSteamDatagramConnectionQuality
	has_quality_relay                      bool
	quality_e2e                            CMsgSteamDatagramConnectionQuality
	has_quality_e2e                        bool
	p2p_routing_summary                    CMsgSteamDatagramP2PRoutingSummary
	has_p2p_routing_summary                bool
	ack_relay                              []u32
	legacy_ack_e2e                         []u32
	flags                                  u32
	has_flags                              bool
	forward_target_relay_routing_token     []byte
	has_forward_target_relay_routing_token bool
	forward_target_revision                u32
	has_forward_target_revision            bool
	routes                                 []byte
	has_routes                             bool
	ack_peer_routes_revision               u32
	has_ack_peer_routes_revision           bool
	connection_id                          u32
	has_connection_id                      bool
	seq_num_c2r                            u32
	has_seq_num_c2r                        bool
	seq_num_e2e                            u32
	has_seq_num_e2e                        bool
}

pub fn (o &CMsgSteamDatagramConnectionStatsP2PClientToRouter) pack() []byte {
	mut res := []byte{}
	if o.has_quality_relay {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.has_quality_e2e {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	if o.has_p2p_routing_summary {
		res <<
			zzz_vproto_internal_pack_cmsgsteamdatagramp2proutingsummary(o.p2p_routing_summary, 14)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 3)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 4)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 5)
	}
	if o.has_forward_target_relay_routing_token {
		res << vproto.pack_bytes_field(o.forward_target_relay_routing_token, 6)
	}
	if o.has_forward_target_revision {
		res << vproto.pack_uint32_field(o.forward_target_revision, 7)
	}
	if o.has_routes {
		res << vproto.pack_bytes_field(o.routes, 8)
	}
	if o.has_ack_peer_routes_revision {
		res << vproto.pack_uint32_field(o.ack_peer_routes_revision, 9)
	}
	if o.has_connection_id {
		res << vproto.pack_32bit_field(o.connection_id, 10)
	}
	if o.has_seq_num_c2r {
		res << vproto.pack_uint32_field(o.seq_num_c2r, 11)
	}
	if o.has_seq_num_e2e {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 12)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsp2pclienttorouter_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsP2PClientToRouter {
	mut res := CMsgSteamDatagramConnectionStatsP2PClientToRouter{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_quality_relay = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_relay = v
				i = ii
			}
			2 {
				res.has_quality_e2e = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_e2e = v
				i = ii
			}
			14 {
				res.has_p2p_routing_summary = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutingsummary(cur_buf,
					tag_wiretype.wire_type)?
				res.p2p_routing_summary = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_relay << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_ack_e2e << v
				i = ii
			}
			5 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			6 {
				res.has_forward_target_relay_routing_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.forward_target_relay_routing_token = v
				i = ii
			}
			7 {
				res.has_forward_target_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.forward_target_revision = v
				i = ii
			}
			8 {
				res.has_routes = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.routes = v
				i = ii
			}
			9 {
				res.has_ack_peer_routes_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_peer_routes_revision = v
				i = ii
			}
			10 {
				res.has_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_id = v
				i = ii
			}
			11 {
				res.has_seq_num_c2r = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_c2r = v
				i = ii
			}
			12 {
				res.has_seq_num_e2e = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_e2e = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2pclienttorouter() CMsgSteamDatagramConnectionStatsP2PClientToRouter {
	return CMsgSteamDatagramConnectionStatsP2PClientToRouter{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2pclienttorouter(o CMsgSteamDatagramConnectionStatsP2PClientToRouter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2pclienttorouter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PClientToRouter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramconnectionstatsp2pclienttorouter_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
	not_primary_transport_e2e = 16
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertoclient_flags(e CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertoclient_flags_packed(e []CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertoclient_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertoclient_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsP2PRouterToClient_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsP2PRouterToClient {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	quality_relay                     CMsgSteamDatagramConnectionQuality
	has_quality_relay                 bool
	quality_e2e                       CMsgSteamDatagramConnectionQuality
	has_quality_e2e                   bool
	seconds_until_shutdown            u32
	has_seconds_until_shutdown        bool
	migrate_request_ip                u32
	has_migrate_request_ip            bool
	migrate_request_port              u32
	has_migrate_request_port          bool
	scoring_penalty_relay_cluster     u32
	has_scoring_penalty_relay_cluster bool
	ack_relay                         []u32
	legacy_ack_e2e                    []u32
	flags                             u32
	has_flags                         bool
	ack_forward_target_revision       u32
	has_ack_forward_target_revision   bool
	routes                            []byte
	has_routes                        bool
	ack_peer_routes_revision          u32
	has_ack_peer_routes_revision      bool
	connection_id                     u32
	has_connection_id                 bool
	seq_num_r2c                       u32
	has_seq_num_r2c                   bool
	seq_num_e2e                       u32
	has_seq_num_e2e                   bool
}

pub fn (o &CMsgSteamDatagramConnectionStatsP2PRouterToClient) pack() []byte {
	mut res := []byte{}
	if o.has_quality_relay {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.has_quality_e2e {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	if o.has_seconds_until_shutdown {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 3)
	}
	if o.has_migrate_request_ip {
		res << vproto.pack_32bit_field(o.migrate_request_ip, 4)
	}
	if o.has_migrate_request_port {
		res << vproto.pack_uint32_field(o.migrate_request_port, 5)
	}
	if o.has_scoring_penalty_relay_cluster {
		res << vproto.pack_uint32_field(o.scoring_penalty_relay_cluster, 6)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 7)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 8)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 9)
	}
	if o.has_ack_forward_target_revision {
		res << vproto.pack_uint32_field(o.ack_forward_target_revision, 10)
	}
	if o.has_routes {
		res << vproto.pack_bytes_field(o.routes, 11)
	}
	if o.has_ack_peer_routes_revision {
		res << vproto.pack_uint32_field(o.ack_peer_routes_revision, 12)
	}
	if o.has_connection_id {
		res << vproto.pack_32bit_field(o.connection_id, 13)
	}
	if o.has_seq_num_r2c {
		res << vproto.pack_uint32_field(o.seq_num_r2c, 14)
	}
	if o.has_seq_num_e2e {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 15)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsp2proutertoclient_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsP2PRouterToClient {
	mut res := CMsgSteamDatagramConnectionStatsP2PRouterToClient{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_quality_relay = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_relay = v
				i = ii
			}
			2 {
				res.has_quality_e2e = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_e2e = v
				i = ii
			}
			3 {
				res.has_seconds_until_shutdown = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_until_shutdown = v
				i = ii
			}
			4 {
				res.has_migrate_request_ip = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.migrate_request_ip = v
				i = ii
			}
			5 {
				res.has_migrate_request_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.migrate_request_port = v
				i = ii
			}
			6 {
				res.has_scoring_penalty_relay_cluster = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scoring_penalty_relay_cluster = v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_relay << v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_ack_e2e << v
				i = ii
			}
			9 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			10 {
				res.has_ack_forward_target_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_forward_target_revision = v
				i = ii
			}
			11 {
				res.has_routes = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.routes = v
				i = ii
			}
			12 {
				res.has_ack_peer_routes_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_peer_routes_revision = v
				i = ii
			}
			13 {
				res.has_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_id = v
				i = ii
			}
			14 {
				res.has_seq_num_r2c = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_r2c = v
				i = ii
			}
			15 {
				res.has_seq_num_e2e = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_e2e = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2proutertoclient() CMsgSteamDatagramConnectionStatsP2PRouterToClient {
	return CMsgSteamDatagramConnectionStatsP2PRouterToClient{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertoclient(o CMsgSteamDatagramConnectionStatsP2PRouterToClient, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertoclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PRouterToClient) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramconnectionstatsp2proutertoclient_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PBadRouteRouterToClient {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	connection_id                   u32
	has_connection_id               bool
	failed_relay_routing_token      []byte
	has_failed_relay_routing_token  bool
	ack_forward_target_revision     u32
	has_ack_forward_target_revision bool
	kludge_pad                      u64
	has_kludge_pad                  bool
}

pub fn (o &CMsgSteamDatagramP2PBadRouteRouterToClient) pack() []byte {
	mut res := []byte{}
	if o.has_connection_id {
		res << vproto.pack_32bit_field(o.connection_id, 1)
	}
	if o.has_failed_relay_routing_token {
		res << vproto.pack_bytes_field(o.failed_relay_routing_token, 2)
	}
	if o.has_ack_forward_target_revision {
		res << vproto.pack_uint32_field(o.ack_forward_target_revision, 3)
	}
	if o.has_kludge_pad {
		res << vproto.pack_64bit_field(o.kludge_pad, 99)
	}
	return res
}

pub fn cmsgsteamdatagramp2pbadrouteroutertoclient_unpack(buf []byte) ?CMsgSteamDatagramP2PBadRouteRouterToClient {
	mut res := CMsgSteamDatagramP2PBadRouteRouterToClient{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_id = v
				i = ii
			}
			2 {
				res.has_failed_relay_routing_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.failed_relay_routing_token = v
				i = ii
			}
			3 {
				res.has_ack_forward_target_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_forward_target_revision = v
				i = ii
			}
			99 {
				res.has_kludge_pad = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.kludge_pad = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2pbadrouteroutertoclient() CMsgSteamDatagramP2PBadRouteRouterToClient {
	return CMsgSteamDatagramP2PBadRouteRouterToClient{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2pbadrouteroutertoclient(o CMsgSteamDatagramP2PBadRouteRouterToClient, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2pbadrouteroutertoclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PBadRouteRouterToClient) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramp2pbadrouteroutertoclient_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PRoutes_RelayCluster {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	pop_id                          u32
	has_pop_id                      bool
	ping_ms                         u32
	has_ping_ms                     bool
	score_penalty                   u32
	has_score_penalty               bool
	session_relay_routing_token     []byte
	has_session_relay_routing_token bool
}

pub fn (o &CMsgSteamDatagramP2PRoutes_RelayCluster) pack() []byte {
	mut res := []byte{}
	if o.has_pop_id {
		res << vproto.pack_32bit_field(o.pop_id, 1)
	}
	if o.has_ping_ms {
		res << vproto.pack_uint32_field(o.ping_ms, 2)
	}
	if o.has_score_penalty {
		res << vproto.pack_uint32_field(o.score_penalty, 3)
	}
	if o.has_session_relay_routing_token {
		res << vproto.pack_bytes_field(o.session_relay_routing_token, 4)
	}
	return res
}

pub fn cmsgsteamdatagramp2proutes_relaycluster_unpack(buf []byte) ?CMsgSteamDatagramP2PRoutes_RelayCluster {
	mut res := CMsgSteamDatagramP2PRoutes_RelayCluster{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_pop_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.pop_id = v
				i = ii
			}
			2 {
				res.has_ping_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_ms = v
				i = ii
			}
			3 {
				res.has_score_penalty = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.score_penalty = v
				i = ii
			}
			4 {
				res.has_session_relay_routing_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.session_relay_routing_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2proutes_relaycluster() CMsgSteamDatagramP2PRoutes_RelayCluster {
	return CMsgSteamDatagramP2PRoutes_RelayCluster{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2proutes_relaycluster(o CMsgSteamDatagramP2PRoutes_RelayCluster, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutes_relaycluster(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PRoutes_RelayCluster) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramp2proutes_relaycluster_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PRoutes_Route {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	my_pop_id       u32
	has_my_pop_id   bool
	your_pop_id     u32
	has_your_pop_id bool
	score           u32
	has_score       bool
}

pub fn (o &CMsgSteamDatagramP2PRoutes_Route) pack() []byte {
	mut res := []byte{}
	if o.has_my_pop_id {
		res << vproto.pack_32bit_field(o.my_pop_id, 1)
	}
	if o.has_your_pop_id {
		res << vproto.pack_32bit_field(o.your_pop_id, 2)
	}
	if o.has_score {
		res << vproto.pack_uint32_field(o.score, 3)
	}
	return res
}

pub fn cmsgsteamdatagramp2proutes_route_unpack(buf []byte) ?CMsgSteamDatagramP2PRoutes_Route {
	mut res := CMsgSteamDatagramP2PRoutes_Route{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_my_pop_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.my_pop_id = v
				i = ii
			}
			2 {
				res.has_your_pop_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.your_pop_id = v
				i = ii
			}
			3 {
				res.has_score = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.score = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2proutes_route() CMsgSteamDatagramP2PRoutes_Route {
	return CMsgSteamDatagramP2PRoutes_Route{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2proutes_route(o CMsgSteamDatagramP2PRoutes_Route, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutes_route(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PRoutes_Route) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramp2proutes_route_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramP2PRoutes {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	relay_clusters []CMsgSteamDatagramP2PRoutes_RelayCluster
	routes         []CMsgSteamDatagramP2PRoutes_Route
	revision       u32
	has_revision   bool
}

pub fn (o &CMsgSteamDatagramP2PRoutes) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.relay_clusters {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramp2proutes_relaycluster(x, 1)
	}
	// [packed=false]
	for _, x in o.routes {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramp2proutes_route(x, 2)
	}
	if o.has_revision {
		res << vproto.pack_uint32_field(o.revision, 3)
	}
	return res
}

pub fn cmsgsteamdatagramp2proutes_unpack(buf []byte) ?CMsgSteamDatagramP2PRoutes {
	mut res := CMsgSteamDatagramP2PRoutes{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutes_relaycluster(cur_buf,
					tag_wiretype.wire_type)?
				res.relay_clusters << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutes_route(cur_buf,
					tag_wiretype.wire_type)?
				res.routes << v
				i = ii
			}
			3 {
				res.has_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.revision = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramp2proutes() CMsgSteamDatagramP2PRoutes {
	return CMsgSteamDatagramP2PRoutes{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramp2proutes(o CMsgSteamDatagramP2PRoutes, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramp2proutes(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramP2PRoutes) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramp2proutes_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameServerSample {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ipv4           u32
	has_ipv4       bool
	port           u32
	has_port       bool
}

pub fn (o &CMsgSteamDatagramGameServerSample) pack() []byte {
	mut res := []byte{}
	if o.has_ipv4 {
		res << vproto.pack_32bit_field(o.ipv4, 1)
	}
	if o.has_port {
		res << vproto.pack_uint32_field(o.port, 2)
	}
	return res
}

pub fn cmsgsteamdatagramgameserversample_unpack(buf []byte) ?CMsgSteamDatagramGameServerSample {
	mut res := CMsgSteamDatagramGameServerSample{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ipv4 = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ipv4 = v
				i = ii
			}
			2 {
				res.has_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.port = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserversample() CMsgSteamDatagramGameServerSample {
	return CMsgSteamDatagramGameServerSample{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserversample(o CMsgSteamDatagramGameServerSample, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversample(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameServerSample) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramgameserversample_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramGameServerSampleDataCenter {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	datacenter_id     u32
	has_datacenter_id bool
	servers           []CMsgSteamDatagramGameServerSample
}

pub fn (o &CMsgSteamDatagramGameServerSampleDataCenter) pack() []byte {
	mut res := []byte{}
	if o.has_datacenter_id {
		res << vproto.pack_32bit_field(o.datacenter_id, 1)
	}
	// [packed=false]
	for _, x in o.servers {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramgameserversample(x, 3)
	}
	return res
}

pub fn cmsgsteamdatagramgameserversampledatacenter_unpack(buf []byte) ?CMsgSteamDatagramGameServerSampleDataCenter {
	mut res := CMsgSteamDatagramGameServerSampleDataCenter{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_datacenter_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.datacenter_id = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversample(cur_buf,
					tag_wiretype.wire_type)?
				res.servers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgameserversampledatacenter() CMsgSteamDatagramGameServerSampleDataCenter {
	return CMsgSteamDatagramGameServerSampleDataCenter{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgameserversampledatacenter(o CMsgSteamDatagramGameServerSampleDataCenter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversampledatacenter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameServerSampleDataCenter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramgameserversampledatacenter_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramRelayToRelayPing {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	request_timestamp     u32
	has_request_timestamp bool
	request_date          u32
	has_request_date      bool
	my_pop_id             u32
	has_my_pop_id         bool
	your_pop_id           u32
	has_your_pop_id       bool
	checksum              u32
	has_checksum          bool
	data_centers          []CMsgSteamDatagramGameServerSampleDataCenter
}

pub fn (o &CMsgSteamDatagramRelayToRelayPing) pack() []byte {
	mut res := []byte{}
	if o.has_request_timestamp {
		res << vproto.pack_32bit_field(o.request_timestamp, 1)
	}
	if o.has_request_date {
		res << vproto.pack_32bit_field(o.request_date, 2)
	}
	if o.has_my_pop_id {
		res << vproto.pack_32bit_field(o.my_pop_id, 3)
	}
	if o.has_your_pop_id {
		res << vproto.pack_32bit_field(o.your_pop_id, 4)
	}
	if o.has_checksum {
		res << vproto.pack_32bit_field(o.checksum, 5)
	}
	// [packed=false]
	for _, x in o.data_centers {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramgameserversampledatacenter(x, 6)
	}
	return res
}

pub fn cmsgsteamdatagramrelaytorelayping_unpack(buf []byte) ?CMsgSteamDatagramRelayToRelayPing {
	mut res := CMsgSteamDatagramRelayToRelayPing{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_request_timestamp = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.request_timestamp = v
				i = ii
			}
			2 {
				res.has_request_date = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.request_date = v
				i = ii
			}
			3 {
				res.has_my_pop_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.my_pop_id = v
				i = ii
			}
			4 {
				res.has_your_pop_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.your_pop_id = v
				i = ii
			}
			5 {
				res.has_checksum = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.checksum = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversampledatacenter(cur_buf,
					tag_wiretype.wire_type)?
				res.data_centers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrelaytorelayping() CMsgSteamDatagramRelayToRelayPing {
	return CMsgSteamDatagramRelayToRelayPing{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrelaytorelayping(o CMsgSteamDatagramRelayToRelayPing, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrelaytorelayping(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRelayToRelayPing) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramrelaytorelayping_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramDataCenterState_Server {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	address        string
	has_address    bool
	ping_ms        u32
	has_ping_ms    bool
}

pub fn (o &CMsgSteamDatagramDataCenterState_Server) pack() []byte {
	mut res := []byte{}
	if o.has_address {
		res << vproto.pack_string_field(o.address, 1)
	}
	if o.has_ping_ms {
		res << vproto.pack_uint32_field(o.ping_ms, 2)
	}
	return res
}

pub fn cmsgsteamdatagramdatacenterstate_server_unpack(buf []byte) ?CMsgSteamDatagramDataCenterState_Server {
	mut res := CMsgSteamDatagramDataCenterState_Server{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.address = v
				i = ii
			}
			2 {
				res.has_ping_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_ms = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramdatacenterstate_server() CMsgSteamDatagramDataCenterState_Server {
	return CMsgSteamDatagramDataCenterState_Server{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstate_server(o CMsgSteamDatagramDataCenterState_Server, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstate_server(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramDataCenterState_Server) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramdatacenterstate_server_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramDataCenterState_DataCenter {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	code           string
	has_code       bool
	server_sample  []CMsgSteamDatagramDataCenterState_Server
	relay_sample   []CMsgSteamDatagramDataCenterState_Server
}

pub fn (o &CMsgSteamDatagramDataCenterState_DataCenter) pack() []byte {
	mut res := []byte{}
	if o.has_code {
		res << vproto.pack_string_field(o.code, 1)
	}
	// [packed=false]
	for _, x in o.server_sample {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstate_server(x, 2)
	}
	// [packed=false]
	for _, x in o.relay_sample {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstate_server(x, 3)
	}
	return res
}

pub fn cmsgsteamdatagramdatacenterstate_datacenter_unpack(buf []byte) ?CMsgSteamDatagramDataCenterState_DataCenter {
	mut res := CMsgSteamDatagramDataCenterState_DataCenter{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.code = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstate_server(cur_buf,
					tag_wiretype.wire_type)?
				res.server_sample << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstate_server(cur_buf,
					tag_wiretype.wire_type)?
				res.relay_sample << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramdatacenterstate_datacenter() CMsgSteamDatagramDataCenterState_DataCenter {
	return CMsgSteamDatagramDataCenterState_DataCenter{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstate_datacenter(o CMsgSteamDatagramDataCenterState_DataCenter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstate_datacenter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramDataCenterState_DataCenter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramdatacenterstate_datacenter_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramDataCenterState {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	data_centers   []CMsgSteamDatagramDataCenterState_DataCenter
}

pub fn (o &CMsgSteamDatagramDataCenterState) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.data_centers {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstate_datacenter(x, 1)
	}
	return res
}

pub fn cmsgsteamdatagramdatacenterstate_unpack(buf []byte) ?CMsgSteamDatagramDataCenterState {
	mut res := CMsgSteamDatagramDataCenterState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstate_datacenter(cur_buf,
					tag_wiretype.wire_type)?
				res.data_centers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramdatacenterstate() CMsgSteamDatagramDataCenterState {
	return CMsgSteamDatagramDataCenterState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramdatacenterstate(o CMsgSteamDatagramDataCenterState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramdatacenterstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramDataCenterState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramdatacenterstate_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramRouterHealth_DataCenter {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	datacenter_id     u32
	has_datacenter_id bool
	state             u32
	has_state         bool
	servers           []CMsgSteamDatagramGameServerSample
}

pub fn (o &CMsgSteamDatagramRouterHealth_DataCenter) pack() []byte {
	mut res := []byte{}
	if o.has_datacenter_id {
		res << vproto.pack_32bit_field(o.datacenter_id, 1)
	}
	if o.has_state {
		res << vproto.pack_uint32_field(o.state, 2)
	}
	// [packed=false]
	for _, x in o.servers {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramgameserversample(x, 3)
	}
	return res
}

pub fn cmsgsteamdatagramrouterhealth_datacenter_unpack(buf []byte) ?CMsgSteamDatagramRouterHealth_DataCenter {
	mut res := CMsgSteamDatagramRouterHealth_DataCenter{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_datacenter_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.datacenter_id = v
				i = ii
			}
			2 {
				res.has_state = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramgameserversample(cur_buf,
					tag_wiretype.wire_type)?
				res.servers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrouterhealth_datacenter() CMsgSteamDatagramRouterHealth_DataCenter {
	return CMsgSteamDatagramRouterHealth_DataCenter{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrouterhealth_datacenter(o CMsgSteamDatagramRouterHealth_DataCenter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrouterhealth_datacenter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRouterHealth_DataCenter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramrouterhealth_datacenter_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramRouterHealth {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	cpu_load                   f32
	has_cpu_load               bool
	cpu_load_raw               f32
	has_cpu_load_raw           bool
	active_sessions            u32
	has_active_sessions        bool
	data_pkts_sec              u32
	has_data_pkts_sec          bool
	other_pkts_sec             u32
	has_other_pkts_sec         bool
	seconds_until_shutdown     u32
	has_seconds_until_shutdown bool
	cpu_cost_per_user          f32
	has_cpu_cost_per_user      bool
	cpu_cost_per_packet        f32
	has_cpu_cost_per_packet    bool
	data_centers               []CMsgSteamDatagramRouterHealth_DataCenter
	magic                      u64
	has_magic                  bool
}

pub fn (o &CMsgSteamDatagramRouterHealth) pack() []byte {
	mut res := []byte{}
	if o.has_cpu_load {
		res << vproto.pack_float_field(o.cpu_load, 1)
	}
	if o.has_cpu_load_raw {
		res << vproto.pack_float_field(o.cpu_load_raw, 10)
	}
	if o.has_active_sessions {
		res << vproto.pack_uint32_field(o.active_sessions, 2)
	}
	if o.has_data_pkts_sec {
		res << vproto.pack_uint32_field(o.data_pkts_sec, 3)
	}
	if o.has_other_pkts_sec {
		res << vproto.pack_uint32_field(o.other_pkts_sec, 4)
	}
	if o.has_seconds_until_shutdown {
		res << vproto.pack_uint32_field(o.seconds_until_shutdown, 5)
	}
	if o.has_cpu_cost_per_user {
		res << vproto.pack_float_field(o.cpu_cost_per_user, 8)
	}
	if o.has_cpu_cost_per_packet {
		res << vproto.pack_float_field(o.cpu_cost_per_packet, 9)
	}
	// [packed=false]
	for _, x in o.data_centers {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramrouterhealth_datacenter(x, 6)
	}
	if o.has_magic {
		res << vproto.pack_64bit_field(o.magic, 7)
	}
	return res
}

pub fn cmsgsteamdatagramrouterhealth_unpack(buf []byte) ?CMsgSteamDatagramRouterHealth {
	mut res := CMsgSteamDatagramRouterHealth{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_cpu_load = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.cpu_load = v
				i = ii
			}
			10 {
				res.has_cpu_load_raw = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.cpu_load_raw = v
				i = ii
			}
			2 {
				res.has_active_sessions = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.active_sessions = v
				i = ii
			}
			3 {
				res.has_data_pkts_sec = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.data_pkts_sec = v
				i = ii
			}
			4 {
				res.has_other_pkts_sec = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.other_pkts_sec = v
				i = ii
			}
			5 {
				res.has_seconds_until_shutdown = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_until_shutdown = v
				i = ii
			}
			8 {
				res.has_cpu_cost_per_user = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.cpu_cost_per_user = v
				i = ii
			}
			9 {
				res.has_cpu_cost_per_packet = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.cpu_cost_per_packet = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramrouterhealth_datacenter(cur_buf,
					tag_wiretype.wire_type)?
				res.data_centers << v
				i = ii
			}
			7 {
				res.has_magic = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.magic = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrouterhealth() CMsgSteamDatagramRouterHealth {
	return CMsgSteamDatagramRouterHealth{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrouterhealth(o CMsgSteamDatagramRouterHealth, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrouterhealth(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRouterHealth) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramrouterhealth_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags {
	ack_request_relay = 1
	ack_request_e2e = 2
	ack_request_immediate = 4
	not_primary_transport_e2e = 16
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertorouter_flags(e CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertorouter_flags_packed(e []CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertorouter_flags(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertorouter_flags_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramConnectionStatsP2PRouterToRouter_Flags) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	quality_relay                   CMsgSteamDatagramConnectionQuality
	has_quality_relay               bool
	quality_e2e                     CMsgSteamDatagramConnectionQuality
	has_quality_e2e                 bool
	ack_relay                       []u32
	legacy_ack_e2e                  []u32
	flags                           u32
	has_flags                       bool
	ack_forward_target_revision     u32
	has_ack_forward_target_revision bool
	routes                          []byte
	has_routes                      bool
	ack_peer_routes_revision        u32
	has_ack_peer_routes_revision    bool
	seq_num_r2r                     u32
	has_seq_num_r2r                 bool
	seq_num_e2e                     u32
	has_seq_num_e2e                 bool
	from_relay_session_id           u32
	has_from_relay_session_id       bool
	to_relay_session_id             u32
	has_to_relay_session_id         bool
}

pub fn (o &CMsgSteamDatagramConnectionStatsP2PRouterToRouter) pack() []byte {
	mut res := []byte{}
	if o.has_quality_relay {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_relay, 1)
	}
	if o.has_quality_e2e {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o.quality_e2e, 2)
	}
	// [packed=false]
	for _, x in o.ack_relay {
		res << vproto.pack_32bit_field(x, 3)
	}
	// [packed=false]
	for _, x in o.legacy_ack_e2e {
		res << vproto.pack_32bit_field(x, 4)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 5)
	}
	if o.has_ack_forward_target_revision {
		res << vproto.pack_uint32_field(o.ack_forward_target_revision, 6)
	}
	if o.has_routes {
		res << vproto.pack_bytes_field(o.routes, 7)
	}
	if o.has_ack_peer_routes_revision {
		res << vproto.pack_uint32_field(o.ack_peer_routes_revision, 8)
	}
	if o.has_seq_num_r2r {
		res << vproto.pack_uint32_field(o.seq_num_r2r, 26)
	}
	if o.has_seq_num_e2e {
		res << vproto.pack_uint32_field(o.seq_num_e2e, 27)
	}
	if o.has_from_relay_session_id {
		res << vproto.pack_32bit_field(o.from_relay_session_id, 22)
	}
	if o.has_to_relay_session_id {
		res << vproto.pack_32bit_field(o.to_relay_session_id, 25)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionstatsp2proutertorouter_unpack(buf []byte) ?CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
	mut res := CMsgSteamDatagramConnectionStatsP2PRouterToRouter{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_quality_relay = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_relay = v
				i = ii
			}
			2 {
				res.has_quality_e2e = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(cur_buf,
					tag_wiretype.wire_type)?
				res.quality_e2e = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_relay << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.legacy_ack_e2e << v
				i = ii
			}
			5 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			6 {
				res.has_ack_forward_target_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_forward_target_revision = v
				i = ii
			}
			7 {
				res.has_routes = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.routes = v
				i = ii
			}
			8 {
				res.has_ack_peer_routes_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_peer_routes_revision = v
				i = ii
			}
			26 {
				res.has_seq_num_r2r = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_r2r = v
				i = ii
			}
			27 {
				res.has_seq_num_e2e = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num_e2e = v
				i = ii
			}
			22 {
				res.has_from_relay_session_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.from_relay_session_id = v
				i = ii
			}
			25 {
				res.has_to_relay_session_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.to_relay_session_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionstatsp2proutertorouter() CMsgSteamDatagramConnectionStatsP2PRouterToRouter {
	return CMsgSteamDatagramConnectionStatsP2PRouterToRouter{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionstatsp2proutertorouter(o CMsgSteamDatagramConnectionStatsP2PRouterToRouter, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionstatsp2proutertorouter(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionStatsP2PRouterToRouter) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramconnectionstatsp2proutertorouter_unpack(v)?
	return i, unpacked
}
