// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CContentServerDirectoryGetServersForSteamPipeRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	cell_id           u32
	has_cell_id       bool
	max_servers       u32
	has_max_servers   bool
	ip_override       string
	has_ip_override   bool
	launcher_type     int
	has_launcher_type bool
}

pub fn (o &CContentServerDirectoryGetServersForSteamPipeRequest) pack() []byte {
	mut res := []byte{}
	if o.has_cell_id {
		res << vproto.pack_uint32_field(o.cell_id, 1)
	}
	if o.has_max_servers {
		res << vproto.pack_uint32_field(o.max_servers, 2)
	}
	if o.has_ip_override {
		res << vproto.pack_string_field(o.ip_override, 3)
	}
	if o.has_launcher_type {
		res << vproto.pack_int32_field(o.launcher_type, 4)
	}
	return res
}

pub fn ccontentserverdirectorygetserversforsteampiperequest_unpack(buf []byte) ?CContentServerDirectoryGetServersForSteamPipeRequest {
	mut res := CContentServerDirectoryGetServersForSteamPipeRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_cell_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			2 {
				res.has_max_servers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_servers = v
				i = ii
			}
			3 {
				res.has_ip_override = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.ip_override = v
				i = ii
			}
			4 {
				res.has_launcher_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.launcher_type = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentserverdirectorygetserversforsteampiperequest() CContentServerDirectoryGetServersForSteamPipeRequest {
	return CContentServerDirectoryGetServersForSteamPipeRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentserverdirectorygetserversforsteampiperequest(o CContentServerDirectoryGetServersForSteamPipeRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentserverdirectorygetserversforsteampiperequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentServerDirectoryGetServersForSteamPipeRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentserverdirectorygetserversforsteampiperequest_unpack(v)?
	return i, unpacked
}

pub struct CContentServerDirectoryServerInfo {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	@type                           string
	has_type                        bool
	source_id                       int
	has_source_id                   bool
	cell_id                         int
	has_cell_id                     bool
	load                            int
	has_load                        bool
	weighted_load                   f32
	has_weighted_load               bool
	num_entries_in_client_list      int
	has_num_entries_in_client_list  bool
	steam_china_only                bool
	has_steam_china_only            bool
	host                            string
	has_host                        bool
	vhost                           string
	has_vhost                       bool
	use_as_proxy                    bool
	has_use_as_proxy                bool
	proxy_request_path_template     string
	has_proxy_request_path_template bool
	https_support                   string
	has_https_support               bool
	allowed_app_ids                 []u32
	preferred_server                bool
	has_preferred_server            bool
}

pub fn (o &CContentServerDirectoryServerInfo) pack() []byte {
	mut res := []byte{}
	if o.has_type {
		res << vproto.pack_string_field(o.@type, 1)
	}
	if o.has_source_id {
		res << vproto.pack_int32_field(o.source_id, 2)
	}
	if o.has_cell_id {
		res << vproto.pack_int32_field(o.cell_id, 3)
	}
	if o.has_load {
		res << vproto.pack_int32_field(o.load, 4)
	}
	if o.has_weighted_load {
		res << vproto.pack_float_field(o.weighted_load, 5)
	}
	if o.has_num_entries_in_client_list {
		res << vproto.pack_int32_field(o.num_entries_in_client_list, 6)
	}
	if o.has_steam_china_only {
		res << vproto.pack_bool_field(o.steam_china_only, 7)
	}
	if o.has_host {
		res << vproto.pack_string_field(o.host, 8)
	}
	if o.has_vhost {
		res << vproto.pack_string_field(o.vhost, 9)
	}
	if o.has_use_as_proxy {
		res << vproto.pack_bool_field(o.use_as_proxy, 10)
	}
	if o.has_proxy_request_path_template {
		res << vproto.pack_string_field(o.proxy_request_path_template, 11)
	}
	if o.has_https_support {
		res << vproto.pack_string_field(o.https_support, 12)
	}
	// [packed=false]
	for _, x in o.allowed_app_ids {
		res << vproto.pack_uint32_field(x, 13)
	}
	if o.has_preferred_server {
		res << vproto.pack_bool_field(o.preferred_server, 14)
	}
	return res
}

pub fn ccontentserverdirectoryserverinfo_unpack(buf []byte) ?CContentServerDirectoryServerInfo {
	mut res := CContentServerDirectoryServerInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			2 {
				res.has_source_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.source_id = v
				i = ii
			}
			3 {
				res.has_cell_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			4 {
				res.has_load = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.load = v
				i = ii
			}
			5 {
				res.has_weighted_load = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.weighted_load = v
				i = ii
			}
			6 {
				res.has_num_entries_in_client_list = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_entries_in_client_list = v
				i = ii
			}
			7 {
				res.has_steam_china_only = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_china_only = v
				i = ii
			}
			8 {
				res.has_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.host = v
				i = ii
			}
			9 {
				res.has_vhost = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.vhost = v
				i = ii
			}
			10 {
				res.has_use_as_proxy = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_as_proxy = v
				i = ii
			}
			11 {
				res.has_proxy_request_path_template = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.proxy_request_path_template = v
				i = ii
			}
			12 {
				res.has_https_support = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.https_support = v
				i = ii
			}
			13 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.allowed_app_ids << v
				i = ii
			}
			14 {
				res.has_preferred_server = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.preferred_server = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentserverdirectoryserverinfo() CContentServerDirectoryServerInfo {
	return CContentServerDirectoryServerInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentserverdirectoryserverinfo(o CContentServerDirectoryServerInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentserverdirectoryserverinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentServerDirectoryServerInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentserverdirectoryserverinfo_unpack(v)?
	return i, unpacked
}

pub struct CContentServerDirectoryGetServersForSteamPipeResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	servers        []CContentServerDirectoryServerInfo
}

pub fn (o &CContentServerDirectoryGetServersForSteamPipeResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.servers {
		res << zzz_vproto_internal_pack_ccontentserverdirectoryserverinfo(x, 1)
	}
	return res
}

pub fn ccontentserverdirectorygetserversforsteampiperesponse_unpack(buf []byte) ?CContentServerDirectoryGetServersForSteamPipeResponse {
	mut res := CContentServerDirectoryGetServersForSteamPipeResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccontentserverdirectoryserverinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.servers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentserverdirectorygetserversforsteampiperesponse() CContentServerDirectoryGetServersForSteamPipeResponse {
	return CContentServerDirectoryGetServersForSteamPipeResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentserverdirectorygetserversforsteampiperesponse(o CContentServerDirectoryGetServersForSteamPipeResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentserverdirectorygetserversforsteampiperesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentServerDirectoryGetServersForSteamPipeResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentserverdirectorygetserversforsteampiperesponse_unpack(v)?
	return i, unpacked
}

pub struct CContentServerDirectoryGetDepotPatchInfoRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	appid                 u32
	has_appid             bool
	depotid               u32
	has_depotid           bool
	source_manifestid     u64
	has_source_manifestid bool
	target_manifestid     u64
	has_target_manifestid bool
}

pub fn (o &CContentServerDirectoryGetDepotPatchInfoRequest) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_depotid {
		res << vproto.pack_uint32_field(o.depotid, 2)
	}
	if o.has_source_manifestid {
		res << vproto.pack_uint64_field(o.source_manifestid, 3)
	}
	if o.has_target_manifestid {
		res << vproto.pack_uint64_field(o.target_manifestid, 4)
	}
	return res
}

pub fn ccontentserverdirectorygetdepotpatchinforequest_unpack(buf []byte) ?CContentServerDirectoryGetDepotPatchInfoRequest {
	mut res := CContentServerDirectoryGetDepotPatchInfoRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_depotid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depotid = v
				i = ii
			}
			3 {
				res.has_source_manifestid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.source_manifestid = v
				i = ii
			}
			4 {
				res.has_target_manifestid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.target_manifestid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentserverdirectorygetdepotpatchinforequest() CContentServerDirectoryGetDepotPatchInfoRequest {
	return CContentServerDirectoryGetDepotPatchInfoRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentserverdirectorygetdepotpatchinforequest(o CContentServerDirectoryGetDepotPatchInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentserverdirectorygetdepotpatchinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentServerDirectoryGetDepotPatchInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentserverdirectorygetdepotpatchinforequest_unpack(v)?
	return i, unpacked
}

pub struct CContentServerDirectoryGetDepotPatchInfoResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	is_available     bool
	has_is_available bool
}

pub fn (o &CContentServerDirectoryGetDepotPatchInfoResponse) pack() []byte {
	mut res := []byte{}
	if o.has_is_available {
		res << vproto.pack_bool_field(o.is_available, 1)
	}
	return res
}

pub fn ccontentserverdirectorygetdepotpatchinforesponse_unpack(buf []byte) ?CContentServerDirectoryGetDepotPatchInfoResponse {
	mut res := CContentServerDirectoryGetDepotPatchInfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_is_available = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_available = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccontentserverdirectorygetdepotpatchinforesponse() CContentServerDirectoryGetDepotPatchInfoResponse {
	return CContentServerDirectoryGetDepotPatchInfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccontentserverdirectorygetdepotpatchinforesponse(o CContentServerDirectoryGetDepotPatchInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccontentserverdirectorygetdepotpatchinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CContentServerDirectoryGetDepotPatchInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccontentserverdirectorygetdepotpatchinforesponse_unpack(v)?
	return i, unpacked
}
