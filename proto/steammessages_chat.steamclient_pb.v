// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EChatRoomJoinState {
	k_echatroomjoinstate_default = 0
	k_echatroomjoinstate_none = 1
	k_echatroomjoinstate_joined = 2
	k_echatroomjoinstate_testinvalid = 99
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroomjoinstate(e EChatRoomJoinState, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroomjoinstate(buf []byte, tag_wiretype vproto.WireType) ?(int, EChatRoomJoinState) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EChatRoomJoinState(v)
}

[_allow_multiple_values]
enum EChatRoomGroupRank {
	k_echatroomgrouprank_default = 0
	k_echatroomgrouprank_viewer = 10
	k_echatroomgrouprank_guest = 15
	k_echatroomgrouprank_member = 20
	k_echatroomgrouprank_moderator = 30
	k_echatroomgrouprank_officer = 40
	k_echatroomgrouprank_owner = 50
	k_echatroomgrouprank_testinvalid = 99
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroomgrouprank(e EChatRoomGroupRank, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroomgrouprank(buf []byte, tag_wiretype vproto.WireType) ?(int, EChatRoomGroupRank) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EChatRoomGroupRank(v)
}

[_allow_multiple_values]
enum EChatRoomNotificationLevel {
	k_echatroomnotificationlevel_invalid = 0
	k_echatroomnotificationlevel_none = 1
	k_echatroomnotificationlevel_mentionme = 2
	k_echatroomnotificationlevel_mentionall = 3
	k_echatroomnotificationlevel_allmessages = 4
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroomnotificationlevel(e EChatRoomNotificationLevel, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroomnotificationlevel(buf []byte, tag_wiretype vproto.WireType) ?(int, EChatRoomNotificationLevel) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EChatRoomNotificationLevel(v)
}

[_allow_multiple_values]
enum EChatRoomServerMessage {
	k_echatroomservermsg_invalid = 0
	k_echatroomservermsg_renamechatroom = 1
	k_echatroomservermsg_joined = 2
	k_echatroomservermsg_parted = 3
	k_echatroomservermsg_kicked = 4
	k_echatroomservermsg_invited = 5
	k_echatroomservermsg_invitedismissed = 8
	k_echatroomservermsg_chatroomtaglinechanged = 9
	k_echatroomservermsg_chatroomavatarchanged = 10
	k_echatroomservermsg_appcustom = 11
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroomservermessage(e EChatRoomServerMessage, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroomservermessage(buf []byte, tag_wiretype vproto.WireType) ?(int, EChatRoomServerMessage) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EChatRoomServerMessage(v)
}

[_allow_multiple_values]
enum EChatRoomMemberStateChange {
	k_echatroommemberstatechange_invalid = 0
	k_echatroommemberstatechange_joined = 1
	k_echatroommemberstatechange_parted = 2
	k_echatroommemberstatechange_kicked = 3
	k_echatroommemberstatechange_invited = 4
	k_echatroommemberstatechange_rankchanged = 7
	k_echatroommemberstatechange_invitedismissed = 8
	k_echatroommemberstatechange_muted = 9
	k_echatroommemberstatechange_banned = 10
	k_echatroommemberstatechange_roleschanged = 12
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroommemberstatechange(e EChatRoomMemberStateChange, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroommemberstatechange(buf []byte, tag_wiretype vproto.WireType) ?(int, EChatRoomMemberStateChange) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EChatRoomMemberStateChange(v)
}

pub struct CChatRequestFriendPersonaStatesRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRequestFriendPersonaStatesRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatrequestfriendpersonastatesrequest_unpack(buf []byte) ?CChatRequestFriendPersonaStatesRequest {
	res := CChatRequestFriendPersonaStatesRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatrequestfriendpersonastatesrequest() CChatRequestFriendPersonaStatesRequest {
	return CChatRequestFriendPersonaStatesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatrequestfriendpersonastatesrequest(o CChatRequestFriendPersonaStatesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatrequestfriendpersonastatesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRequestFriendPersonaStatesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatrequestfriendpersonastatesrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRequestFriendPersonaStatesResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRequestFriendPersonaStatesResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatrequestfriendpersonastatesresponse_unpack(buf []byte) ?CChatRequestFriendPersonaStatesResponse {
	res := CChatRequestFriendPersonaStatesResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatrequestfriendpersonastatesresponse() CChatRequestFriendPersonaStatesResponse {
	return CChatRequestFriendPersonaStatesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatrequestfriendpersonastatesresponse(o CChatRequestFriendPersonaStatesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatrequestfriendpersonastatesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRequestFriendPersonaStatesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatrequestfriendpersonastatesresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomCreateChatRoomGroupRequest {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	steamid_partner                   u64
	has_steamid_partner               bool
	steamid_invited                   u64
	has_steamid_invited               bool
	name                              string
	has_name                          bool
	steamid_invitees                  []u64
	watching_broadcast_accountid      u32
	has_watching_broadcast_accountid  bool
	watching_broadcast_channel_id     u64
	has_watching_broadcast_channel_id bool
}

pub fn (o &CChatRoomCreateChatRoomGroupRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_partner {
		res << vproto.pack_64bit_field(o.steamid_partner, 1)
	}
	if o.has_steamid_invited {
		res << vproto.pack_64bit_field(o.steamid_invited, 2)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 3)
	}
	// [packed=false]
	for _, x in o.steamid_invitees {
		res << vproto.pack_64bit_field(x, 4)
	}
	if o.has_watching_broadcast_accountid {
		res << vproto.pack_uint32_field(o.watching_broadcast_accountid, 6)
	}
	if o.has_watching_broadcast_channel_id {
		res << vproto.pack_uint64_field(o.watching_broadcast_channel_id, 7)
	}
	return res
}

pub fn cchatroomcreatechatroomgrouprequest_unpack(buf []byte) ?CChatRoomCreateChatRoomGroupRequest {
	mut res := CChatRoomCreateChatRoomGroupRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_partner = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_partner = v
				i = ii
			}
			2 {
				res.has_steamid_invited = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_invited = v
				i = ii
			}
			3 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_invitees << v
				i = ii
			}
			6 {
				res.has_watching_broadcast_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_accountid = v
				i = ii
			}
			7 {
				res.has_watching_broadcast_channel_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_channel_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomcreatechatroomgrouprequest() CChatRoomCreateChatRoomGroupRequest {
	return CChatRoomCreateChatRoomGroupRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomcreatechatroomgrouprequest(o CChatRoomCreateChatRoomGroupRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomcreatechatroomgrouprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomCreateChatRoomGroupRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomcreatechatroomgrouprequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRole {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	role_id        u64
	has_role_id    bool
	name           string
	has_name       bool
	ordinal        u32
	has_ordinal    bool
}

pub fn (o &CChatRole) pack() []byte {
	mut res := []byte{}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 3)
	}
	return res
}

pub fn cchatrole_unpack(buf []byte) ?CChatRole {
	mut res := CChatRole{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatrole() CChatRole {
	return CChatRole{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatrole(o CChatRole, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatrole(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRole) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatrole_unpack(v)?
	return i, unpacked
}

pub struct CChatRoleActions {
mut:
	unknown_fields                       []vproto.UnknownField
pub mut:
	role_id                              u64
	has_role_id                          bool
	can_create_rename_delete_channel     bool
	has_can_create_rename_delete_channel bool
	can_kick                             bool
	has_can_kick                         bool
	can_ban                              bool
	has_can_ban                          bool
	can_invite                           bool
	has_can_invite                       bool
	can_change_tagline_avatar_name       bool
	has_can_change_tagline_avatar_name   bool
	can_chat                             bool
	has_can_chat                         bool
	can_view_history                     bool
	has_can_view_history                 bool
	can_change_group_roles               bool
	has_can_change_group_roles           bool
	can_change_user_roles                bool
	has_can_change_user_roles            bool
	can_mention_all                      bool
	has_can_mention_all                  bool
	can_set_watching_broadcast           bool
	has_can_set_watching_broadcast       bool
}

pub fn (o &CChatRoleActions) pack() []byte {
	mut res := []byte{}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 1)
	}
	if o.has_can_create_rename_delete_channel {
		res << vproto.pack_bool_field(o.can_create_rename_delete_channel, 2)
	}
	if o.has_can_kick {
		res << vproto.pack_bool_field(o.can_kick, 3)
	}
	if o.has_can_ban {
		res << vproto.pack_bool_field(o.can_ban, 4)
	}
	if o.has_can_invite {
		res << vproto.pack_bool_field(o.can_invite, 5)
	}
	if o.has_can_change_tagline_avatar_name {
		res << vproto.pack_bool_field(o.can_change_tagline_avatar_name, 6)
	}
	if o.has_can_chat {
		res << vproto.pack_bool_field(o.can_chat, 7)
	}
	if o.has_can_view_history {
		res << vproto.pack_bool_field(o.can_view_history, 8)
	}
	if o.has_can_change_group_roles {
		res << vproto.pack_bool_field(o.can_change_group_roles, 9)
	}
	if o.has_can_change_user_roles {
		res << vproto.pack_bool_field(o.can_change_user_roles, 10)
	}
	if o.has_can_mention_all {
		res << vproto.pack_bool_field(o.can_mention_all, 11)
	}
	if o.has_can_set_watching_broadcast {
		res << vproto.pack_bool_field(o.can_set_watching_broadcast, 12)
	}
	return res
}

pub fn cchatroleactions_unpack(buf []byte) ?CChatRoleActions {
	mut res := CChatRoleActions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			2 {
				res.has_can_create_rename_delete_channel = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_create_rename_delete_channel = v
				i = ii
			}
			3 {
				res.has_can_kick = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_kick = v
				i = ii
			}
			4 {
				res.has_can_ban = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_ban = v
				i = ii
			}
			5 {
				res.has_can_invite = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_invite = v
				i = ii
			}
			6 {
				res.has_can_change_tagline_avatar_name = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_change_tagline_avatar_name = v
				i = ii
			}
			7 {
				res.has_can_chat = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_chat = v
				i = ii
			}
			8 {
				res.has_can_view_history = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_view_history = v
				i = ii
			}
			9 {
				res.has_can_change_group_roles = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_change_group_roles = v
				i = ii
			}
			10 {
				res.has_can_change_user_roles = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_change_user_roles = v
				i = ii
			}
			11 {
				res.has_can_mention_all = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_mention_all = v
				i = ii
			}
			12 {
				res.has_can_set_watching_broadcast = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_set_watching_broadcast = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroleactions() CChatRoleActions {
	return CChatRoleActions{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroleactions(o CChatRoleActions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroleactions(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoleActions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroleactions_unpack(v)?
	return i, unpacked
}

pub struct CChatPartyBeacon {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	app_id            u32
	has_app_id        bool
	steamid_owner     u64
	has_steamid_owner bool
	beacon_id         u64
	has_beacon_id     bool
	game_metadata     string
	has_game_metadata bool
}

pub fn (o &CChatPartyBeacon) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steamid_owner {
		res << vproto.pack_64bit_field(o.steamid_owner, 2)
	}
	if o.has_beacon_id {
		res << vproto.pack_64bit_field(o.beacon_id, 3)
	}
	if o.has_game_metadata {
		res << vproto.pack_string_field(o.game_metadata, 4)
	}
	return res
}

pub fn cchatpartybeacon_unpack(buf []byte) ?CChatPartyBeacon {
	mut res := CChatPartyBeacon{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steamid_owner = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_owner = v
				i = ii
			}
			3 {
				res.has_beacon_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.beacon_id = v
				i = ii
			}
			4 {
				res.has_game_metadata = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_metadata = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatpartybeacon() CChatPartyBeacon {
	return CChatPartyBeacon{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatpartybeacon(o CChatPartyBeacon, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatpartybeacon(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatPartyBeacon) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatpartybeacon_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGroupHeaderState {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	chat_group_id                     u64
	has_chat_group_id                 bool
	chat_name                         string
	has_chat_name                     bool
	clanid                            u32
	has_clanid                        bool
	accountid_owner                   u32
	has_accountid_owner               bool
	appid                             u32
	has_appid                         bool
	tagline                           string
	has_tagline                       bool
	avatar_sha                        []byte
	has_avatar_sha                    bool
	default_role_id                   u64
	has_default_role_id               bool
	roles                             []CChatRole
	role_actions                      []CChatRoleActions
	watching_broadcast_accountid      u32
	has_watching_broadcast_accountid  bool
	party_beacons                     []CChatPartyBeacon
	watching_broadcast_channel_id     u64
	has_watching_broadcast_channel_id bool
	active_minigame_id                u64
	has_active_minigame_id            bool
	avatar_ugc_url                    string
	has_avatar_ugc_url                bool
}

pub fn (o &CChatRoomGroupHeaderState) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_name {
		res << vproto.pack_string_field(o.chat_name, 2)
	}
	if o.has_clanid {
		res << vproto.pack_uint32_field(o.clanid, 13)
	}
	if o.has_accountid_owner {
		res << vproto.pack_uint32_field(o.accountid_owner, 14)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 21)
	}
	if o.has_tagline {
		res << vproto.pack_string_field(o.tagline, 15)
	}
	if o.has_avatar_sha {
		res << vproto.pack_bytes_field(o.avatar_sha, 16)
	}
	if o.has_default_role_id {
		res << vproto.pack_uint64_field(o.default_role_id, 17)
	}
	// [packed=false]
	for _, x in o.roles {
		res << zzz_vproto_internal_pack_cchatrole(x, 18)
	}
	// [packed=false]
	for _, x in o.role_actions {
		res << zzz_vproto_internal_pack_cchatroleactions(x, 19)
	}
	if o.has_watching_broadcast_accountid {
		res << vproto.pack_uint32_field(o.watching_broadcast_accountid, 20)
	}
	// [packed=false]
	for _, x in o.party_beacons {
		res << zzz_vproto_internal_pack_cchatpartybeacon(x, 22)
	}
	if o.has_watching_broadcast_channel_id {
		res << vproto.pack_uint64_field(o.watching_broadcast_channel_id, 23)
	}
	if o.has_active_minigame_id {
		res << vproto.pack_uint64_field(o.active_minigame_id, 24)
	}
	if o.has_avatar_ugc_url {
		res << vproto.pack_string_field(o.avatar_ugc_url, 25)
	}
	return res
}

pub fn cchatroomgroupheaderstate_unpack(buf []byte) ?CChatRoomGroupHeaderState {
	mut res := CChatRoomGroupHeaderState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_name = v
				i = ii
			}
			13 {
				res.has_clanid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.clanid = v
				i = ii
			}
			14 {
				res.has_accountid_owner = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_owner = v
				i = ii
			}
			21 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			15 {
				res.has_tagline = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tagline = v
				i = ii
			}
			16 {
				res.has_avatar_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.avatar_sha = v
				i = ii
			}
			17 {
				res.has_default_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.default_role_id = v
				i = ii
			}
			18 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatrole(cur_buf, tag_wiretype.wire_type)?
				res.roles << v
				i = ii
			}
			19 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroleactions(cur_buf, tag_wiretype.wire_type)?
				res.role_actions << v
				i = ii
			}
			20 {
				res.has_watching_broadcast_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_accountid = v
				i = ii
			}
			22 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatpartybeacon(cur_buf, tag_wiretype.wire_type)?
				res.party_beacons << v
				i = ii
			}
			23 {
				res.has_watching_broadcast_channel_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_channel_id = v
				i = ii
			}
			24 {
				res.has_active_minigame_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.active_minigame_id = v
				i = ii
			}
			25 {
				res.has_avatar_ugc_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.avatar_ugc_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgroupheaderstate() CChatRoomGroupHeaderState {
	return CChatRoomGroupHeaderState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgroupheaderstate(o CChatRoomGroupHeaderState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgroupheaderstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGroupHeaderState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgroupheaderstate_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomMember {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	accountid            u32
	has_accountid        bool
	state                EChatRoomJoinState
	has_state            bool
	rank                 EChatRoomGroupRank
	has_rank             bool
	time_kick_expire     u32
	has_time_kick_expire bool
	role_ids             []u64
}

pub fn (o &CChatRoomMember) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 1)
	}
	if o.has_state {
		res << zzz_vproto_internal_pack_echatroomjoinstate(o.state, 3)
	}
	if o.has_rank {
		res << zzz_vproto_internal_pack_echatroomgrouprank(o.rank, 4)
	}
	if o.has_time_kick_expire {
		res << vproto.pack_uint32_field(o.time_kick_expire, 6)
	}
	// [packed=false]
	for _, x in o.role_ids {
		res << vproto.pack_uint64_field(x, 7)
	}
	return res
}

pub fn cchatroommember_unpack(buf []byte) ?CChatRoomMember {
	mut res := CChatRoomMember{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			3 {
				res.has_state = true
				ii, v := zzz_vproto_internal_unpack_echatroomjoinstate(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			4 {
				res.has_rank = true
				ii, v := zzz_vproto_internal_unpack_echatroomgrouprank(cur_buf, tag_wiretype.wire_type)?
				res.rank = v
				i = ii
			}
			6 {
				res.has_time_kick_expire = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_kick_expire = v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroommember() CChatRoomMember {
	return CChatRoomMember{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroommember(o CChatRoomMember, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroommember(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomMember) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroommember_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomState {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	chat_id                    u64
	has_chat_id                bool
	chat_name                  string
	has_chat_name              bool
	voice_allowed              bool
	has_voice_allowed          bool
	members_in_voice           []u32
	time_last_message          u32
	has_time_last_message      bool
	sort_order                 u32
	has_sort_order             bool
	last_message               string
	has_last_message           bool
	accountid_last_message     u32
	has_accountid_last_message bool
}

pub fn (o &CChatRoomState) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 1)
	}
	if o.has_chat_name {
		res << vproto.pack_string_field(o.chat_name, 2)
	}
	if o.has_voice_allowed {
		res << vproto.pack_bool_field(o.voice_allowed, 3)
	}
	// [packed=false]
	for _, x in o.members_in_voice {
		res << vproto.pack_uint32_field(x, 4)
	}
	if o.has_time_last_message {
		res << vproto.pack_uint32_field(o.time_last_message, 5)
	}
	if o.has_sort_order {
		res << vproto.pack_uint32_field(o.sort_order, 6)
	}
	if o.has_last_message {
		res << vproto.pack_string_field(o.last_message, 7)
	}
	if o.has_accountid_last_message {
		res << vproto.pack_uint32_field(o.accountid_last_message, 8)
	}
	return res
}

pub fn cchatroomstate_unpack(buf []byte) ?CChatRoomState {
	mut res := CChatRoomState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_chat_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_name = v
				i = ii
			}
			3 {
				res.has_voice_allowed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_allowed = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.members_in_voice << v
				i = ii
			}
			5 {
				res.has_time_last_message = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last_message = v
				i = ii
			}
			6 {
				res.has_sort_order = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sort_order = v
				i = ii
			}
			7 {
				res.has_last_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.last_message = v
				i = ii
			}
			8 {
				res.has_accountid_last_message = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_last_message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomstate() CChatRoomState {
	return CChatRoomState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomstate(o CChatRoomState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomstate_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGroupState {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	header_state        CChatRoomGroupHeaderState
	has_header_state    bool
	members             []CChatRoomMember
	default_chat_id     u64
	has_default_chat_id bool
	chat_rooms          []CChatRoomState
	kicked              []CChatRoomMember
}

pub fn (o &CChatRoomGroupState) pack() []byte {
	mut res := []byte{}
	if o.has_header_state {
		res << zzz_vproto_internal_pack_cchatroomgroupheaderstate(o.header_state, 1)
	}
	// [packed=false]
	for _, x in o.members {
		res << zzz_vproto_internal_pack_cchatroommember(x, 2)
	}
	if o.has_default_chat_id {
		res << vproto.pack_uint64_field(o.default_chat_id, 4)
	}
	// [packed=false]
	for _, x in o.chat_rooms {
		res << zzz_vproto_internal_pack_cchatroomstate(x, 5)
	}
	// [packed=false]
	for _, x in o.kicked {
		res << zzz_vproto_internal_pack_cchatroommember(x, 7)
	}
	return res
}

pub fn cchatroomgroupstate_unpack(buf []byte) ?CChatRoomGroupState {
	mut res := CChatRoomGroupState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_header_state = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupheaderstate(cur_buf,
					tag_wiretype.wire_type)?
				res.header_state = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroommember(cur_buf, tag_wiretype.wire_type)?
				res.members << v
				i = ii
			}
			4 {
				res.has_default_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.default_chat_id = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomstate(cur_buf, tag_wiretype.wire_type)?
				res.chat_rooms << v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroommember(cur_buf, tag_wiretype.wire_type)?
				res.kicked << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgroupstate() CChatRoomGroupState {
	return CChatRoomGroupState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgroupstate(o CChatRoomGroupState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgroupstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGroupState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgroupstate_unpack(v)?
	return i, unpacked
}

pub struct CUserChatRoomState {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	chat_id                        u64
	has_chat_id                    bool
	time_joined                    u32
	has_time_joined                bool
	time_last_ack                  u32
	has_time_last_ack              bool
	desktop_notification_level     EChatRoomNotificationLevel
	has_desktop_notification_level bool
	mobile_notification_level      EChatRoomNotificationLevel
	has_mobile_notification_level  bool
	time_last_mention              u32
	has_time_last_mention          bool
	unread_indicator_muted         bool
	has_unread_indicator_muted     bool
	time_first_unread              u32
	has_time_first_unread          bool
}

pub fn (o &CUserChatRoomState) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 1)
	}
	if o.has_time_joined {
		res << vproto.pack_uint32_field(o.time_joined, 2)
	}
	if o.has_time_last_ack {
		res << vproto.pack_uint32_field(o.time_last_ack, 3)
	}
	if o.has_desktop_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.desktop_notification_level, 4)
	}
	if o.has_mobile_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.mobile_notification_level, 5)
	}
	if o.has_time_last_mention {
		res << vproto.pack_uint32_field(o.time_last_mention, 6)
	}
	if o.has_unread_indicator_muted {
		res << vproto.pack_bool_field(o.unread_indicator_muted, 7)
	}
	if o.has_time_first_unread {
		res << vproto.pack_uint32_field(o.time_first_unread, 8)
	}
	return res
}

pub fn cuserchatroomstate_unpack(buf []byte) ?CUserChatRoomState {
	mut res := CUserChatRoomState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_time_joined = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_joined = v
				i = ii
			}
			3 {
				res.has_time_last_ack = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last_ack = v
				i = ii
			}
			4 {
				res.has_desktop_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.desktop_notification_level = v
				i = ii
			}
			5 {
				res.has_mobile_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.mobile_notification_level = v
				i = ii
			}
			6 {
				res.has_time_last_mention = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last_mention = v
				i = ii
			}
			7 {
				res.has_unread_indicator_muted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.unread_indicator_muted = v
				i = ii
			}
			8 {
				res.has_time_first_unread = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_first_unread = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuserchatroomstate() CUserChatRoomState {
	return CUserChatRoomState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuserchatroomstate(o CUserChatRoomState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuserchatroomstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserChatRoomState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuserchatroomstate_unpack(v)?
	return i, unpacked
}

pub struct CUserChatRoomGroupState {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	chat_group_id                  u64
	has_chat_group_id              bool
	time_joined                    u32
	has_time_joined                bool
	user_chat_room_state           []CUserChatRoomState
	desktop_notification_level     EChatRoomNotificationLevel
	has_desktop_notification_level bool
	mobile_notification_level      EChatRoomNotificationLevel
	has_mobile_notification_level  bool
	time_last_group_ack            u32
	has_time_last_group_ack        bool
	unread_indicator_muted         bool
	has_unread_indicator_muted     bool
}

pub fn (o &CUserChatRoomGroupState) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_time_joined {
		res << vproto.pack_uint32_field(o.time_joined, 2)
	}
	// [packed=false]
	for _, x in o.user_chat_room_state {
		res << zzz_vproto_internal_pack_cuserchatroomstate(x, 3)
	}
	if o.has_desktop_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.desktop_notification_level, 4)
	}
	if o.has_mobile_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.mobile_notification_level, 5)
	}
	if o.has_time_last_group_ack {
		res << vproto.pack_uint32_field(o.time_last_group_ack, 6)
	}
	if o.has_unread_indicator_muted {
		res << vproto.pack_bool_field(o.unread_indicator_muted, 7)
	}
	return res
}

pub fn cuserchatroomgroupstate_unpack(buf []byte) ?CUserChatRoomGroupState {
	mut res := CUserChatRoomGroupState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_time_joined = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_joined = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cuserchatroomstate(cur_buf, tag_wiretype.wire_type)?
				res.user_chat_room_state << v
				i = ii
			}
			4 {
				res.has_desktop_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.desktop_notification_level = v
				i = ii
			}
			5 {
				res.has_mobile_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.mobile_notification_level = v
				i = ii
			}
			6 {
				res.has_time_last_group_ack = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last_group_ack = v
				i = ii
			}
			7 {
				res.has_unread_indicator_muted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.unread_indicator_muted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuserchatroomgroupstate() CUserChatRoomGroupState {
	return CUserChatRoomGroupState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuserchatroomgroupstate(o CUserChatRoomGroupState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuserchatroomgroupstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserChatRoomGroupState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuserchatroomgroupstate_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomCreateChatRoomGroupResponse {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	chat_group_id       u64
	has_chat_group_id   bool
	state               CChatRoomGroupState
	has_state           bool
	user_chat_state     CUserChatRoomGroupState
	has_user_chat_state bool
}

pub fn (o &CChatRoomCreateChatRoomGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_state {
		res << zzz_vproto_internal_pack_cchatroomgroupstate(o.state, 2)
	}
	if o.has_user_chat_state {
		res << zzz_vproto_internal_pack_cuserchatroomgroupstate(o.user_chat_state, 3)
	}
	return res
}

pub fn cchatroomcreatechatroomgroupresponse_unpack(buf []byte) ?CChatRoomCreateChatRoomGroupResponse {
	mut res := CChatRoomCreateChatRoomGroupResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_state = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			3 {
				res.has_user_chat_state = true
				ii, v := zzz_vproto_internal_unpack_cuserchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.user_chat_state = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomcreatechatroomgroupresponse() CChatRoomCreateChatRoomGroupResponse {
	return CChatRoomCreateChatRoomGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomcreatechatroomgroupresponse(o CChatRoomCreateChatRoomGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomcreatechatroomgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomCreateChatRoomGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomcreatechatroomgroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSaveChatRoomGroupRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	name              string
	has_name          bool
}

pub fn (o &CChatRoomSaveChatRoomGroupRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	return res
}

pub fn cchatroomsavechatroomgrouprequest_unpack(buf []byte) ?CChatRoomSaveChatRoomGroupRequest {
	mut res := CChatRoomSaveChatRoomGroupRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsavechatroomgrouprequest() CChatRoomSaveChatRoomGroupRequest {
	return CChatRoomSaveChatRoomGroupRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsavechatroomgrouprequest(o CChatRoomSaveChatRoomGroupRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsavechatroomgrouprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSaveChatRoomGroupRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsavechatroomgrouprequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSaveChatRoomGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomSaveChatRoomGroupResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomsavechatroomgroupresponse_unpack(buf []byte) ?CChatRoomSaveChatRoomGroupResponse {
	res := CChatRoomSaveChatRoomGroupResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsavechatroomgroupresponse() CChatRoomSaveChatRoomGroupResponse {
	return CChatRoomSaveChatRoomGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsavechatroomgroupresponse(o CChatRoomSaveChatRoomGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsavechatroomgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSaveChatRoomGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsavechatroomgroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomRenameChatRoomGroupRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	name              string
	has_name          bool
}

pub fn (o &CChatRoomRenameChatRoomGroupRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	return res
}

pub fn cchatroomrenamechatroomgrouprequest_unpack(buf []byte) ?CChatRoomRenameChatRoomGroupRequest {
	mut res := CChatRoomRenameChatRoomGroupRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomrenamechatroomgrouprequest() CChatRoomRenameChatRoomGroupRequest {
	return CChatRoomRenameChatRoomGroupRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomrenamechatroomgrouprequest(o CChatRoomRenameChatRoomGroupRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomrenamechatroomgrouprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomRenameChatRoomGroupRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomrenamechatroomgrouprequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomRenameChatRoomGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
}

pub fn (o &CChatRoomRenameChatRoomGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	return res
}

pub fn cchatroomrenamechatroomgroupresponse_unpack(buf []byte) ?CChatRoomRenameChatRoomGroupResponse {
	mut res := CChatRoomRenameChatRoomGroupResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomrenamechatroomgroupresponse() CChatRoomRenameChatRoomGroupResponse {
	return CChatRoomRenameChatRoomGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomrenamechatroomgroupresponse(o CChatRoomRenameChatRoomGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomrenamechatroomgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomRenameChatRoomGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomrenamechatroomgroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetChatRoomGroupTaglineRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	tagline           string
	has_tagline       bool
}

pub fn (o &CChatRoomSetChatRoomGroupTaglineRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_tagline {
		res << vproto.pack_string_field(o.tagline, 2)
	}
	return res
}

pub fn cchatroomsetchatroomgrouptaglinerequest_unpack(buf []byte) ?CChatRoomSetChatRoomGroupTaglineRequest {
	mut res := CChatRoomSetChatRoomGroupTaglineRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_tagline = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tagline = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetchatroomgrouptaglinerequest() CChatRoomSetChatRoomGroupTaglineRequest {
	return CChatRoomSetChatRoomGroupTaglineRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetchatroomgrouptaglinerequest(o CChatRoomSetChatRoomGroupTaglineRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetchatroomgrouptaglinerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetChatRoomGroupTaglineRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetchatroomgrouptaglinerequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetChatRoomGroupTaglineResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomSetChatRoomGroupTaglineResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomsetchatroomgrouptaglineresponse_unpack(buf []byte) ?CChatRoomSetChatRoomGroupTaglineResponse {
	res := CChatRoomSetChatRoomGroupTaglineResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetchatroomgrouptaglineresponse() CChatRoomSetChatRoomGroupTaglineResponse {
	return CChatRoomSetChatRoomGroupTaglineResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetchatroomgrouptaglineresponse(o CChatRoomSetChatRoomGroupTaglineResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetchatroomgrouptaglineresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetChatRoomGroupTaglineResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetchatroomgrouptaglineresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetChatRoomGroupAvatarRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	avatar_sha        []byte
	has_avatar_sha    bool
}

pub fn (o &CChatRoomSetChatRoomGroupAvatarRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_avatar_sha {
		res << vproto.pack_bytes_field(o.avatar_sha, 2)
	}
	return res
}

pub fn cchatroomsetchatroomgroupavatarrequest_unpack(buf []byte) ?CChatRoomSetChatRoomGroupAvatarRequest {
	mut res := CChatRoomSetChatRoomGroupAvatarRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_avatar_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.avatar_sha = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetchatroomgroupavatarrequest() CChatRoomSetChatRoomGroupAvatarRequest {
	return CChatRoomSetChatRoomGroupAvatarRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetchatroomgroupavatarrequest(o CChatRoomSetChatRoomGroupAvatarRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetchatroomgroupavatarrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetChatRoomGroupAvatarRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetchatroomgroupavatarrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetChatRoomGroupAvatarResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomSetChatRoomGroupAvatarResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomsetchatroomgroupavatarresponse_unpack(buf []byte) ?CChatRoomSetChatRoomGroupAvatarResponse {
	res := CChatRoomSetChatRoomGroupAvatarResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetchatroomgroupavatarresponse() CChatRoomSetChatRoomGroupAvatarResponse {
	return CChatRoomSetChatRoomGroupAvatarResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetchatroomgroupavatarresponse(o CChatRoomSetChatRoomGroupAvatarResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetchatroomgroupavatarresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetChatRoomGroupAvatarResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetchatroomgroupavatarresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetChatRoomGroupWatchingBroadcastRequest {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	chat_group_id                     u64
	has_chat_group_id                 bool
	watching_broadcast_accountid      u32
	has_watching_broadcast_accountid  bool
	watching_broadcast_channel_id     u64
	has_watching_broadcast_channel_id bool
}

pub fn (o &CChatRoomSetChatRoomGroupWatchingBroadcastRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_watching_broadcast_accountid {
		res << vproto.pack_uint32_field(o.watching_broadcast_accountid, 2)
	}
	if o.has_watching_broadcast_channel_id {
		res << vproto.pack_uint64_field(o.watching_broadcast_channel_id, 3)
	}
	return res
}

pub fn cchatroomsetchatroomgroupwatchingbroadcastrequest_unpack(buf []byte) ?CChatRoomSetChatRoomGroupWatchingBroadcastRequest {
	mut res := CChatRoomSetChatRoomGroupWatchingBroadcastRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_watching_broadcast_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_accountid = v
				i = ii
			}
			3 {
				res.has_watching_broadcast_channel_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_channel_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetchatroomgroupwatchingbroadcastrequest() CChatRoomSetChatRoomGroupWatchingBroadcastRequest {
	return CChatRoomSetChatRoomGroupWatchingBroadcastRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetchatroomgroupwatchingbroadcastrequest(o CChatRoomSetChatRoomGroupWatchingBroadcastRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetchatroomgroupwatchingbroadcastrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetChatRoomGroupWatchingBroadcastRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetchatroomgroupwatchingbroadcastrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetChatRoomGroupWatchingBroadcastResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomSetChatRoomGroupWatchingBroadcastResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomsetchatroomgroupwatchingbroadcastresponse_unpack(buf []byte) ?CChatRoomSetChatRoomGroupWatchingBroadcastResponse {
	res := CChatRoomSetChatRoomGroupWatchingBroadcastResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetchatroomgroupwatchingbroadcastresponse() CChatRoomSetChatRoomGroupWatchingBroadcastResponse {
	return CChatRoomSetChatRoomGroupWatchingBroadcastResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetchatroomgroupwatchingbroadcastresponse(o CChatRoomSetChatRoomGroupWatchingBroadcastResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetchatroomgroupwatchingbroadcastresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetChatRoomGroupWatchingBroadcastResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetchatroomgroupwatchingbroadcastresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomJoinMiniGameForChatRoomGroupRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
}

pub fn (o &CChatRoomJoinMiniGameForChatRoomGroupRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	return res
}

pub fn cchatroomjoinminigameforchatroomgrouprequest_unpack(buf []byte) ?CChatRoomJoinMiniGameForChatRoomGroupRequest {
	mut res := CChatRoomJoinMiniGameForChatRoomGroupRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomjoinminigameforchatroomgrouprequest() CChatRoomJoinMiniGameForChatRoomGroupRequest {
	return CChatRoomJoinMiniGameForChatRoomGroupRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomjoinminigameforchatroomgrouprequest(o CChatRoomJoinMiniGameForChatRoomGroupRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomjoinminigameforchatroomgrouprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomJoinMiniGameForChatRoomGroupRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomjoinminigameforchatroomgrouprequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomJoinMiniGameForChatRoomGroupResponse {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	minigame_id     u64
	has_minigame_id bool
}

pub fn (o &CChatRoomJoinMiniGameForChatRoomGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.has_minigame_id {
		res << vproto.pack_uint64_field(o.minigame_id, 1)
	}
	return res
}

pub fn cchatroomjoinminigameforchatroomgroupresponse_unpack(buf []byte) ?CChatRoomJoinMiniGameForChatRoomGroupResponse {
	mut res := CChatRoomJoinMiniGameForChatRoomGroupResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_minigame_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.minigame_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomjoinminigameforchatroomgroupresponse() CChatRoomJoinMiniGameForChatRoomGroupResponse {
	return CChatRoomJoinMiniGameForChatRoomGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomjoinminigameforchatroomgroupresponse(o CChatRoomJoinMiniGameForChatRoomGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomjoinminigameforchatroomgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomJoinMiniGameForChatRoomGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomjoinminigameforchatroomgroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomEndMiniGameForChatRoomGroupRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
	minigame_id       u64
	has_minigame_id   bool
}

pub fn (o &CChatRoomEndMiniGameForChatRoomGroupRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_minigame_id {
		res << vproto.pack_uint64_field(o.minigame_id, 3)
	}
	return res
}

pub fn cchatroomendminigameforchatroomgrouprequest_unpack(buf []byte) ?CChatRoomEndMiniGameForChatRoomGroupRequest {
	mut res := CChatRoomEndMiniGameForChatRoomGroupRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_minigame_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.minigame_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomendminigameforchatroomgrouprequest() CChatRoomEndMiniGameForChatRoomGroupRequest {
	return CChatRoomEndMiniGameForChatRoomGroupRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomendminigameforchatroomgrouprequest(o CChatRoomEndMiniGameForChatRoomGroupRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomendminigameforchatroomgrouprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomEndMiniGameForChatRoomGroupRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomendminigameforchatroomgrouprequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomEndMiniGameForChatRoomGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomEndMiniGameForChatRoomGroupResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomendminigameforchatroomgroupresponse_unpack(buf []byte) ?CChatRoomEndMiniGameForChatRoomGroupResponse {
	res := CChatRoomEndMiniGameForChatRoomGroupResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomendminigameforchatroomgroupresponse() CChatRoomEndMiniGameForChatRoomGroupResponse {
	return CChatRoomEndMiniGameForChatRoomGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomendminigameforchatroomgroupresponse(o CChatRoomEndMiniGameForChatRoomGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomendminigameforchatroomgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomEndMiniGameForChatRoomGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomendminigameforchatroomgroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomMuteUserRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	steamid           u64
	has_steamid       bool
	expiration        int
	has_expiration    bool
}

pub fn (o &CChatRoomMuteUserRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	if o.has_expiration {
		res << vproto.pack_int32_field(o.expiration, 3)
	}
	return res
}

pub fn cchatroommuteuserrequest_unpack(buf []byte) ?CChatRoomMuteUserRequest {
	mut res := CChatRoomMuteUserRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_expiration = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.expiration = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroommuteuserrequest() CChatRoomMuteUserRequest {
	return CChatRoomMuteUserRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroommuteuserrequest(o CChatRoomMuteUserRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroommuteuserrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomMuteUserRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroommuteuserrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomMuteUserResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomMuteUserResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroommuteuserresponse_unpack(buf []byte) ?CChatRoomMuteUserResponse {
	res := CChatRoomMuteUserResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroommuteuserresponse() CChatRoomMuteUserResponse {
	return CChatRoomMuteUserResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroommuteuserresponse(o CChatRoomMuteUserResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroommuteuserresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomMuteUserResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroommuteuserresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomKickUserRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	steamid           u64
	has_steamid       bool
	expiration        int
	has_expiration    bool
}

pub fn (o &CChatRoomKickUserRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	if o.has_expiration {
		res << vproto.pack_int32_field(o.expiration, 3)
	}
	return res
}

pub fn cchatroomkickuserrequest_unpack(buf []byte) ?CChatRoomKickUserRequest {
	mut res := CChatRoomKickUserRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_expiration = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.expiration = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomkickuserrequest() CChatRoomKickUserRequest {
	return CChatRoomKickUserRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomkickuserrequest(o CChatRoomKickUserRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomkickuserrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomKickUserRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomkickuserrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomKickUserResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomKickUserResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomkickuserresponse_unpack(buf []byte) ?CChatRoomKickUserResponse {
	res := CChatRoomKickUserResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomkickuserresponse() CChatRoomKickUserResponse {
	return CChatRoomKickUserResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomkickuserresponse(o CChatRoomKickUserResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomkickuserresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomKickUserResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomkickuserresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetUserBanStateRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	steamid           u64
	has_steamid       bool
	ban_state         bool
	has_ban_state     bool
}

pub fn (o &CChatRoomSetUserBanStateRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	if o.has_ban_state {
		res << vproto.pack_bool_field(o.ban_state, 3)
	}
	return res
}

pub fn cchatroomsetuserbanstaterequest_unpack(buf []byte) ?CChatRoomSetUserBanStateRequest {
	mut res := CChatRoomSetUserBanStateRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_ban_state = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ban_state = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetuserbanstaterequest() CChatRoomSetUserBanStateRequest {
	return CChatRoomSetUserBanStateRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetuserbanstaterequest(o CChatRoomSetUserBanStateRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetuserbanstaterequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetUserBanStateRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetuserbanstaterequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetUserBanStateResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomSetUserBanStateResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomsetuserbanstateresponse_unpack(buf []byte) ?CChatRoomSetUserBanStateResponse {
	res := CChatRoomSetUserBanStateResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetuserbanstateresponse() CChatRoomSetUserBanStateResponse {
	return CChatRoomSetUserBanStateResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetuserbanstateresponse(o CChatRoomSetUserBanStateResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetuserbanstateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetUserBanStateResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetuserbanstateresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomRevokeInviteRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	steamid           u64
	has_steamid       bool
}

pub fn (o &CChatRoomRevokeInviteRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	return res
}

pub fn cchatroomrevokeinviterequest_unpack(buf []byte) ?CChatRoomRevokeInviteRequest {
	mut res := CChatRoomRevokeInviteRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomrevokeinviterequest() CChatRoomRevokeInviteRequest {
	return CChatRoomRevokeInviteRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomrevokeinviterequest(o CChatRoomRevokeInviteRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomrevokeinviterequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomRevokeInviteRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomrevokeinviterequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomRevokeInviteResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomRevokeInviteResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomrevokeinviteresponse_unpack(buf []byte) ?CChatRoomRevokeInviteResponse {
	res := CChatRoomRevokeInviteResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomrevokeinviteresponse() CChatRoomRevokeInviteResponse {
	return CChatRoomRevokeInviteResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomrevokeinviteresponse(o CChatRoomRevokeInviteResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomrevokeinviteresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomRevokeInviteResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomrevokeinviteresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomCreateRoleRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	name              string
	has_name          bool
}

pub fn (o &CChatRoomCreateRoleRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	return res
}

pub fn cchatroomcreaterolerequest_unpack(buf []byte) ?CChatRoomCreateRoleRequest {
	mut res := CChatRoomCreateRoleRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomcreaterolerequest() CChatRoomCreateRoleRequest {
	return CChatRoomCreateRoleRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomcreaterolerequest(o CChatRoomCreateRoleRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomcreaterolerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomCreateRoleRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomcreaterolerequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomCreateRoleResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	actions        CChatRoleActions
	has_actions    bool
}

pub fn (o &CChatRoomCreateRoleResponse) pack() []byte {
	mut res := []byte{}
	if o.has_actions {
		res << zzz_vproto_internal_pack_cchatroleactions(o.actions, 2)
	}
	return res
}

pub fn cchatroomcreateroleresponse_unpack(buf []byte) ?CChatRoomCreateRoleResponse {
	mut res := CChatRoomCreateRoleResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				res.has_actions = true
				ii, v := zzz_vproto_internal_unpack_cchatroleactions(cur_buf, tag_wiretype.wire_type)?
				res.actions = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomcreateroleresponse() CChatRoomCreateRoleResponse {
	return CChatRoomCreateRoleResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomcreateroleresponse(o CChatRoomCreateRoleResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomcreateroleresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomCreateRoleResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomcreateroleresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetRolesRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoomGetRolesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroomgetrolesrequest_unpack(buf []byte) ?CChatRoomGetRolesRequest {
	mut res := CChatRoomGetRolesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetrolesrequest() CChatRoomGetRolesRequest {
	return CChatRoomGetRolesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetrolesrequest(o CChatRoomGetRolesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetrolesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetRolesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetrolesrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetRolesResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	roles          []CChatRole
}

pub fn (o &CChatRoomGetRolesResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.roles {
		res << zzz_vproto_internal_pack_cchatrole(x, 1)
	}
	return res
}

pub fn cchatroomgetrolesresponse_unpack(buf []byte) ?CChatRoomGetRolesResponse {
	mut res := CChatRoomGetRolesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatrole(cur_buf, tag_wiretype.wire_type)?
				res.roles << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetrolesresponse() CChatRoomGetRolesResponse {
	return CChatRoomGetRolesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetrolesresponse(o CChatRoomGetRolesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetrolesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetRolesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetrolesresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomRenameRoleRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
	name              string
	has_name          bool
}

pub fn (o &CChatRoomRenameRoleRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 2)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 3)
	}
	return res
}

pub fn cchatroomrenamerolerequest_unpack(buf []byte) ?CChatRoomRenameRoleRequest {
	mut res := CChatRoomRenameRoleRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			3 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomrenamerolerequest() CChatRoomRenameRoleRequest {
	return CChatRoomRenameRoleRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomrenamerolerequest(o CChatRoomRenameRoleRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomrenamerolerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomRenameRoleRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomrenamerolerequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomRenameRoleResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomRenameRoleResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomrenameroleresponse_unpack(buf []byte) ?CChatRoomRenameRoleResponse {
	res := CChatRoomRenameRoleResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomrenameroleresponse() CChatRoomRenameRoleResponse {
	return CChatRoomRenameRoleResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomrenameroleresponse(o CChatRoomRenameRoleResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomrenameroleresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomRenameRoleResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomrenameroleresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomReorderRoleRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
	ordinal           u32
	has_ordinal       bool
}

pub fn (o &CChatRoomReorderRoleRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 2)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 3)
	}
	return res
}

pub fn cchatroomreorderrolerequest_unpack(buf []byte) ?CChatRoomReorderRoleRequest {
	mut res := CChatRoomReorderRoleRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			3 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomreorderrolerequest() CChatRoomReorderRoleRequest {
	return CChatRoomReorderRoleRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomreorderrolerequest(o CChatRoomReorderRoleRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomreorderrolerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomReorderRoleRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomreorderrolerequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomReorderRoleResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomReorderRoleResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomreorderroleresponse_unpack(buf []byte) ?CChatRoomReorderRoleResponse {
	res := CChatRoomReorderRoleResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomreorderroleresponse() CChatRoomReorderRoleResponse {
	return CChatRoomReorderRoleResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomreorderroleresponse(o CChatRoomReorderRoleResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomreorderroleresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomReorderRoleResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomreorderroleresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomDeleteRoleRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
}

pub fn (o &CChatRoomDeleteRoleRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 2)
	}
	return res
}

pub fn cchatroomdeleterolerequest_unpack(buf []byte) ?CChatRoomDeleteRoleRequest {
	mut res := CChatRoomDeleteRoleRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomdeleterolerequest() CChatRoomDeleteRoleRequest {
	return CChatRoomDeleteRoleRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomdeleterolerequest(o CChatRoomDeleteRoleRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomdeleterolerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomDeleteRoleRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomdeleterolerequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomDeleteRoleResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomDeleteRoleResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomdeleteroleresponse_unpack(buf []byte) ?CChatRoomDeleteRoleResponse {
	res := CChatRoomDeleteRoleResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomdeleteroleresponse() CChatRoomDeleteRoleResponse {
	return CChatRoomDeleteRoleResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomdeleteroleresponse(o CChatRoomDeleteRoleResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomdeleteroleresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomDeleteRoleResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomdeleteroleresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetRoleActionsRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
}

pub fn (o &CChatRoomGetRoleActionsRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 2)
	}
	return res
}

pub fn cchatroomgetroleactionsrequest_unpack(buf []byte) ?CChatRoomGetRoleActionsRequest {
	mut res := CChatRoomGetRoleActionsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetroleactionsrequest() CChatRoomGetRoleActionsRequest {
	return CChatRoomGetRoleActionsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetroleactionsrequest(o CChatRoomGetRoleActionsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetroleactionsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetRoleActionsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetroleactionsrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetRoleActionsResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	actions        []CChatRoleActions
}

pub fn (o &CChatRoomGetRoleActionsResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.actions {
		res << zzz_vproto_internal_pack_cchatroleactions(x, 1)
	}
	return res
}

pub fn cchatroomgetroleactionsresponse_unpack(buf []byte) ?CChatRoomGetRoleActionsResponse {
	mut res := CChatRoomGetRoleActionsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroleactions(cur_buf, tag_wiretype.wire_type)?
				res.actions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetroleactionsresponse() CChatRoomGetRoleActionsResponse {
	return CChatRoomGetRoleActionsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetroleactionsresponse(o CChatRoomGetRoleActionsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetroleactionsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetRoleActionsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetroleactionsresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomReplaceRoleActionsRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
	actions           CChatRoleActions
	has_actions       bool
}

pub fn (o &CChatRoomReplaceRoleActionsRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 2)
	}
	if o.has_actions {
		res << zzz_vproto_internal_pack_cchatroleactions(o.actions, 4)
	}
	return res
}

pub fn cchatroomreplaceroleactionsrequest_unpack(buf []byte) ?CChatRoomReplaceRoleActionsRequest {
	mut res := CChatRoomReplaceRoleActionsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			4 {
				res.has_actions = true
				ii, v := zzz_vproto_internal_unpack_cchatroleactions(cur_buf, tag_wiretype.wire_type)?
				res.actions = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomreplaceroleactionsrequest() CChatRoomReplaceRoleActionsRequest {
	return CChatRoomReplaceRoleActionsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomreplaceroleactionsrequest(o CChatRoomReplaceRoleActionsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomreplaceroleactionsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomReplaceRoleActionsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomreplaceroleactionsrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomReplaceRoleActionsResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomReplaceRoleActionsResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomreplaceroleactionsresponse_unpack(buf []byte) ?CChatRoomReplaceRoleActionsResponse {
	res := CChatRoomReplaceRoleActionsResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomreplaceroleactionsresponse() CChatRoomReplaceRoleActionsResponse {
	return CChatRoomReplaceRoleActionsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomreplaceroleactionsresponse(o CChatRoomReplaceRoleActionsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomreplaceroleactionsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomReplaceRoleActionsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomreplaceroleactionsresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomAddRoleToUserRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
	steamid           u64
	has_steamid       bool
}

pub fn (o &CChatRoomAddRoleToUserRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 3)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 4)
	}
	return res
}

pub fn cchatroomaddroletouserrequest_unpack(buf []byte) ?CChatRoomAddRoleToUserRequest {
	mut res := CChatRoomAddRoleToUserRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			3 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			4 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomaddroletouserrequest() CChatRoomAddRoleToUserRequest {
	return CChatRoomAddRoleToUserRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomaddroletouserrequest(o CChatRoomAddRoleToUserRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomaddroletouserrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomAddRoleToUserRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomaddroletouserrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomAddRoleToUserResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomAddRoleToUserResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomaddroletouserresponse_unpack(buf []byte) ?CChatRoomAddRoleToUserResponse {
	res := CChatRoomAddRoleToUserResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomaddroletouserresponse() CChatRoomAddRoleToUserResponse {
	return CChatRoomAddRoleToUserResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomaddroletouserresponse(o CChatRoomAddRoleToUserResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomaddroletouserresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomAddRoleToUserResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomaddroletouserresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetRolesForUserRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	steamid           u64
	has_steamid       bool
}

pub fn (o &CChatRoomGetRolesForUserRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 3)
	}
	return res
}

pub fn cchatroomgetrolesforuserrequest_unpack(buf []byte) ?CChatRoomGetRolesForUserRequest {
	mut res := CChatRoomGetRolesForUserRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			3 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetrolesforuserrequest() CChatRoomGetRolesForUserRequest {
	return CChatRoomGetRolesForUserRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetrolesforuserrequest(o CChatRoomGetRolesForUserRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetrolesforuserrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetRolesForUserRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetrolesforuserrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetRolesForUserResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	role_ids       []u64
}

pub fn (o &CChatRoomGetRolesForUserResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.role_ids {
		res << vproto.pack_uint64_field(x, 1)
	}
	return res
}

pub fn cchatroomgetrolesforuserresponse_unpack(buf []byte) ?CChatRoomGetRolesForUserResponse {
	mut res := CChatRoomGetRolesForUserResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetrolesforuserresponse() CChatRoomGetRolesForUserResponse {
	return CChatRoomGetRolesForUserResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetrolesforuserresponse(o CChatRoomGetRolesForUserResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetrolesforuserresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetRolesForUserResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetrolesforuserresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomDeleteRoleFromUserRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
	steamid           u64
	has_steamid       bool
}

pub fn (o &CChatRoomDeleteRoleFromUserRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 3)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 4)
	}
	return res
}

pub fn cchatroomdeleterolefromuserrequest_unpack(buf []byte) ?CChatRoomDeleteRoleFromUserRequest {
	mut res := CChatRoomDeleteRoleFromUserRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			3 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			4 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomdeleterolefromuserrequest() CChatRoomDeleteRoleFromUserRequest {
	return CChatRoomDeleteRoleFromUserRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomdeleterolefromuserrequest(o CChatRoomDeleteRoleFromUserRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomdeleterolefromuserrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomDeleteRoleFromUserRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomdeleterolefromuserrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomDeleteRoleFromUserResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomDeleteRoleFromUserResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomdeleterolefromuserresponse_unpack(buf []byte) ?CChatRoomDeleteRoleFromUserResponse {
	res := CChatRoomDeleteRoleFromUserResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomdeleterolefromuserresponse() CChatRoomDeleteRoleFromUserResponse {
	return CChatRoomDeleteRoleFromUserResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomdeleterolefromuserresponse(o CChatRoomDeleteRoleFromUserResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomdeleterolefromuserresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomDeleteRoleFromUserResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomdeleterolefromuserresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomJoinChatRoomGroupRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	invite_code       string
	has_invite_code   bool
	chat_id           u64
	has_chat_id       bool
}

pub fn (o &CChatRoomJoinChatRoomGroupRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_invite_code {
		res << vproto.pack_string_field(o.invite_code, 2)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 3)
	}
	return res
}

pub fn cchatroomjoinchatroomgrouprequest_unpack(buf []byte) ?CChatRoomJoinChatRoomGroupRequest {
	mut res := CChatRoomJoinChatRoomGroupRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_invite_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_code = v
				i = ii
			}
			3 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomjoinchatroomgrouprequest() CChatRoomJoinChatRoomGroupRequest {
	return CChatRoomJoinChatRoomGroupRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomjoinchatroomgrouprequest(o CChatRoomJoinChatRoomGroupRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomjoinchatroomgrouprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomJoinChatRoomGroupRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomjoinchatroomgrouprequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomJoinChatRoomGroupResponse {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	state               CChatRoomGroupState
	has_state           bool
	user_chat_state     CUserChatRoomGroupState
	has_user_chat_state bool
	join_chat_id        u64
	has_join_chat_id    bool
	time_expire         u32
	has_time_expire     bool
}

pub fn (o &CChatRoomJoinChatRoomGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.has_state {
		res << zzz_vproto_internal_pack_cchatroomgroupstate(o.state, 1)
	}
	if o.has_user_chat_state {
		res << zzz_vproto_internal_pack_cuserchatroomgroupstate(o.user_chat_state, 3)
	}
	if o.has_join_chat_id {
		res << vproto.pack_uint64_field(o.join_chat_id, 4)
	}
	if o.has_time_expire {
		res << vproto.pack_uint32_field(o.time_expire, 5)
	}
	return res
}

pub fn cchatroomjoinchatroomgroupresponse_unpack(buf []byte) ?CChatRoomJoinChatRoomGroupResponse {
	mut res := CChatRoomJoinChatRoomGroupResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_state = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			3 {
				res.has_user_chat_state = true
				ii, v := zzz_vproto_internal_unpack_cuserchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.user_chat_state = v
				i = ii
			}
			4 {
				res.has_join_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.join_chat_id = v
				i = ii
			}
			5 {
				res.has_time_expire = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_expire = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomjoinchatroomgroupresponse() CChatRoomJoinChatRoomGroupResponse {
	return CChatRoomJoinChatRoomGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomjoinchatroomgroupresponse(o CChatRoomJoinChatRoomGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomjoinchatroomgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomJoinChatRoomGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomjoinchatroomgroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomInviteFriendToChatRoomGroupRequest {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	chat_group_id            u64
	has_chat_group_id        bool
	steamid                  u64
	has_steamid              bool
	chat_id                  u64
	has_chat_id              bool
	skip_friendsui_check     bool
	has_skip_friendsui_check bool
}

pub fn (o &CChatRoomInviteFriendToChatRoomGroupRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 3)
	}
	if o.has_skip_friendsui_check {
		res << vproto.pack_bool_field(o.skip_friendsui_check, 4)
	}
	return res
}

pub fn cchatroominvitefriendtochatroomgrouprequest_unpack(buf []byte) ?CChatRoomInviteFriendToChatRoomGroupRequest {
	mut res := CChatRoomInviteFriendToChatRoomGroupRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			4 {
				res.has_skip_friendsui_check = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.skip_friendsui_check = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroominvitefriendtochatroomgrouprequest() CChatRoomInviteFriendToChatRoomGroupRequest {
	return CChatRoomInviteFriendToChatRoomGroupRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroominvitefriendtochatroomgrouprequest(o CChatRoomInviteFriendToChatRoomGroupRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroominvitefriendtochatroomgrouprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomInviteFriendToChatRoomGroupRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroominvitefriendtochatroomgrouprequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomInviteFriendToChatRoomGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomInviteFriendToChatRoomGroupResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroominvitefriendtochatroomgroupresponse_unpack(buf []byte) ?CChatRoomInviteFriendToChatRoomGroupResponse {
	res := CChatRoomInviteFriendToChatRoomGroupResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroominvitefriendtochatroomgroupresponse() CChatRoomInviteFriendToChatRoomGroupResponse {
	return CChatRoomInviteFriendToChatRoomGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroominvitefriendtochatroomgroupresponse(o CChatRoomInviteFriendToChatRoomGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroominvitefriendtochatroomgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomInviteFriendToChatRoomGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroominvitefriendtochatroomgroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomLeaveChatRoomGroupRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoomLeaveChatRoomGroupRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroomleavechatroomgrouprequest_unpack(buf []byte) ?CChatRoomLeaveChatRoomGroupRequest {
	mut res := CChatRoomLeaveChatRoomGroupRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomleavechatroomgrouprequest() CChatRoomLeaveChatRoomGroupRequest {
	return CChatRoomLeaveChatRoomGroupRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomleavechatroomgrouprequest(o CChatRoomLeaveChatRoomGroupRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomleavechatroomgrouprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomLeaveChatRoomGroupRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomleavechatroomgrouprequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomLeaveChatRoomGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomLeaveChatRoomGroupResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomleavechatroomgroupresponse_unpack(buf []byte) ?CChatRoomLeaveChatRoomGroupResponse {
	res := CChatRoomLeaveChatRoomGroupResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomleavechatroomgroupresponse() CChatRoomLeaveChatRoomGroupResponse {
	return CChatRoomLeaveChatRoomGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomleavechatroomgroupresponse(o CChatRoomLeaveChatRoomGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomleavechatroomgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomLeaveChatRoomGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomleavechatroomgroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomCreateChatRoomRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	name              string
	has_name          bool
	allow_voice       bool
	has_allow_voice   bool
}

pub fn (o &CChatRoomCreateChatRoomRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	if o.has_allow_voice {
		res << vproto.pack_bool_field(o.allow_voice, 3)
	}
	return res
}

pub fn cchatroomcreatechatroomrequest_unpack(buf []byte) ?CChatRoomCreateChatRoomRequest {
	mut res := CChatRoomCreateChatRoomRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				res.has_allow_voice = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.allow_voice = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomcreatechatroomrequest() CChatRoomCreateChatRoomRequest {
	return CChatRoomCreateChatRoomRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomcreatechatroomrequest(o CChatRoomCreateChatRoomRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomcreatechatroomrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomCreateChatRoomRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomcreatechatroomrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomCreateChatRoomResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	chat_room      CChatRoomState
	has_chat_room  bool
}

pub fn (o &CChatRoomCreateChatRoomResponse) pack() []byte {
	mut res := []byte{}
	if o.has_chat_room {
		res << zzz_vproto_internal_pack_cchatroomstate(o.chat_room, 1)
	}
	return res
}

pub fn cchatroomcreatechatroomresponse_unpack(buf []byte) ?CChatRoomCreateChatRoomResponse {
	mut res := CChatRoomCreateChatRoomResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_room = true
				ii, v := zzz_vproto_internal_unpack_cchatroomstate(cur_buf, tag_wiretype.wire_type)?
				res.chat_room = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomcreatechatroomresponse() CChatRoomCreateChatRoomResponse {
	return CChatRoomCreateChatRoomResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomcreatechatroomresponse(o CChatRoomCreateChatRoomResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomcreatechatroomresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomCreateChatRoomResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomcreatechatroomresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomDeleteChatRoomRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
}

pub fn (o &CChatRoomDeleteChatRoomRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	return res
}

pub fn cchatroomdeletechatroomrequest_unpack(buf []byte) ?CChatRoomDeleteChatRoomRequest {
	mut res := CChatRoomDeleteChatRoomRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomdeletechatroomrequest() CChatRoomDeleteChatRoomRequest {
	return CChatRoomDeleteChatRoomRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomdeletechatroomrequest(o CChatRoomDeleteChatRoomRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomdeletechatroomrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomDeleteChatRoomRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomdeletechatroomrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomDeleteChatRoomResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomDeleteChatRoomResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomdeletechatroomresponse_unpack(buf []byte) ?CChatRoomDeleteChatRoomResponse {
	res := CChatRoomDeleteChatRoomResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomdeletechatroomresponse() CChatRoomDeleteChatRoomResponse {
	return CChatRoomDeleteChatRoomResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomdeletechatroomresponse(o CChatRoomDeleteChatRoomResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomdeletechatroomresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomDeleteChatRoomResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomdeletechatroomresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomRenameChatRoomRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
	name              string
	has_name          bool
}

pub fn (o &CChatRoomRenameChatRoomRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 3)
	}
	return res
}

pub fn cchatroomrenamechatroomrequest_unpack(buf []byte) ?CChatRoomRenameChatRoomRequest {
	mut res := CChatRoomRenameChatRoomRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomrenamechatroomrequest() CChatRoomRenameChatRoomRequest {
	return CChatRoomRenameChatRoomRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomrenamechatroomrequest(o CChatRoomRenameChatRoomRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomrenamechatroomrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomRenameChatRoomRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomrenamechatroomrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomRenameChatRoomResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomRenameChatRoomResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomrenamechatroomresponse_unpack(buf []byte) ?CChatRoomRenameChatRoomResponse {
	res := CChatRoomRenameChatRoomResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomrenamechatroomresponse() CChatRoomRenameChatRoomResponse {
	return CChatRoomRenameChatRoomResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomrenamechatroomresponse(o CChatRoomRenameChatRoomResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomrenamechatroomresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomRenameChatRoomResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomrenamechatroomresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomReorderChatRoomRequest {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	chat_group_id          u64
	has_chat_group_id      bool
	chat_id                u64
	has_chat_id            bool
	move_after_chat_id     u64
	has_move_after_chat_id bool
}

pub fn (o &CChatRoomReorderChatRoomRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_move_after_chat_id {
		res << vproto.pack_uint64_field(o.move_after_chat_id, 3)
	}
	return res
}

pub fn cchatroomreorderchatroomrequest_unpack(buf []byte) ?CChatRoomReorderChatRoomRequest {
	mut res := CChatRoomReorderChatRoomRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_move_after_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.move_after_chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomreorderchatroomrequest() CChatRoomReorderChatRoomRequest {
	return CChatRoomReorderChatRoomRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomreorderchatroomrequest(o CChatRoomReorderChatRoomRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomreorderchatroomrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomReorderChatRoomRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomreorderchatroomrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomReorderChatRoomResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomReorderChatRoomResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomreorderchatroomresponse_unpack(buf []byte) ?CChatRoomReorderChatRoomResponse {
	res := CChatRoomReorderChatRoomResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomreorderchatroomresponse() CChatRoomReorderChatRoomResponse {
	return CChatRoomReorderChatRoomResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomreorderchatroomresponse(o CChatRoomReorderChatRoomResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomreorderchatroomresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomReorderChatRoomResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomreorderchatroomresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSendChatMessageRequest {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	chat_group_id      u64
	has_chat_group_id  bool
	chat_id            u64
	has_chat_id        bool
	message            string
	has_message        bool
	echo_to_sender     bool
	has_echo_to_sender bool
}

pub fn (o &CChatRoomSendChatMessageRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 3)
	}
	if o.has_echo_to_sender {
		res << vproto.pack_bool_field(o.echo_to_sender, 4)
	}
	return res
}

pub fn cchatroomsendchatmessagerequest_unpack(buf []byte) ?CChatRoomSendChatMessageRequest {
	mut res := CChatRoomSendChatMessageRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			4 {
				res.has_echo_to_sender = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.echo_to_sender = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsendchatmessagerequest() CChatRoomSendChatMessageRequest {
	return CChatRoomSendChatMessageRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsendchatmessagerequest(o CChatRoomSendChatMessageRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsendchatmessagerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSendChatMessageRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsendchatmessagerequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSendChatMessageResponse {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	modified_message            string
	has_modified_message        bool
	server_timestamp            u32
	has_server_timestamp        bool
	ordinal                     u32
	has_ordinal                 bool
	message_without_bb_code     string
	has_message_without_bb_code bool
}

pub fn (o &CChatRoomSendChatMessageResponse) pack() []byte {
	mut res := []byte{}
	if o.has_modified_message {
		res << vproto.pack_string_field(o.modified_message, 1)
	}
	if o.has_server_timestamp {
		res << vproto.pack_uint32_field(o.server_timestamp, 2)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 3)
	}
	if o.has_message_without_bb_code {
		res << vproto.pack_string_field(o.message_without_bb_code, 4)
	}
	return res
}

pub fn cchatroomsendchatmessageresponse_unpack(buf []byte) ?CChatRoomSendChatMessageResponse {
	mut res := CChatRoomSendChatMessageResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_modified_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.modified_message = v
				i = ii
			}
			2 {
				res.has_server_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.server_timestamp = v
				i = ii
			}
			3 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			4 {
				res.has_message_without_bb_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message_without_bb_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsendchatmessageresponse() CChatRoomSendChatMessageResponse {
	return CChatRoomSendChatMessageResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsendchatmessageresponse(o CChatRoomSendChatMessageResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsendchatmessageresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSendChatMessageResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsendchatmessageresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomJoinVoiceChatRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
}

pub fn (o &CChatRoomJoinVoiceChatRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	return res
}

pub fn cchatroomjoinvoicechatrequest_unpack(buf []byte) ?CChatRoomJoinVoiceChatRequest {
	mut res := CChatRoomJoinVoiceChatRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomjoinvoicechatrequest() CChatRoomJoinVoiceChatRequest {
	return CChatRoomJoinVoiceChatRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomjoinvoicechatrequest(o CChatRoomJoinVoiceChatRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomjoinvoicechatrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomJoinVoiceChatRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomjoinvoicechatrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomJoinVoiceChatResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	voice_chatid     u64
	has_voice_chatid bool
}

pub fn (o &CChatRoomJoinVoiceChatResponse) pack() []byte {
	mut res := []byte{}
	if o.has_voice_chatid {
		res << vproto.pack_uint64_field(o.voice_chatid, 1)
	}
	return res
}

pub fn cchatroomjoinvoicechatresponse_unpack(buf []byte) ?CChatRoomJoinVoiceChatResponse {
	mut res := CChatRoomJoinVoiceChatResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_voice_chatid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_chatid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomjoinvoicechatresponse() CChatRoomJoinVoiceChatResponse {
	return CChatRoomJoinVoiceChatResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomjoinvoicechatresponse(o CChatRoomJoinVoiceChatResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomjoinvoicechatresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomJoinVoiceChatResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomjoinvoicechatresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomLeaveVoiceChatRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
}

pub fn (o &CChatRoomLeaveVoiceChatRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	return res
}

pub fn cchatroomleavevoicechatrequest_unpack(buf []byte) ?CChatRoomLeaveVoiceChatRequest {
	mut res := CChatRoomLeaveVoiceChatRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomleavevoicechatrequest() CChatRoomLeaveVoiceChatRequest {
	return CChatRoomLeaveVoiceChatRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomleavevoicechatrequest(o CChatRoomLeaveVoiceChatRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomleavevoicechatrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomLeaveVoiceChatRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomleavevoicechatrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomLeaveVoiceChatResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomLeaveVoiceChatResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomleavevoicechatresponse_unpack(buf []byte) ?CChatRoomLeaveVoiceChatResponse {
	res := CChatRoomLeaveVoiceChatResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomleavevoicechatresponse() CChatRoomLeaveVoiceChatResponse {
	return CChatRoomLeaveVoiceChatResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomleavevoicechatresponse(o CChatRoomLeaveVoiceChatResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomleavevoicechatresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomLeaveVoiceChatResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomleavevoicechatresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetMessageHistoryRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
	last_time         u32
	has_last_time     bool
	last_ordinal      u32
	has_last_ordinal  bool
	start_time        u32
	has_start_time    bool
	start_ordinal     u32
	has_start_ordinal bool
	max_count         u32
	has_max_count     bool
}

pub fn (o &CChatRoomGetMessageHistoryRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_last_time {
		res << vproto.pack_uint32_field(o.last_time, 3)
	}
	if o.has_last_ordinal {
		res << vproto.pack_uint32_field(o.last_ordinal, 4)
	}
	if o.has_start_time {
		res << vproto.pack_uint32_field(o.start_time, 5)
	}
	if o.has_start_ordinal {
		res << vproto.pack_uint32_field(o.start_ordinal, 6)
	}
	if o.has_max_count {
		res << vproto.pack_uint32_field(o.max_count, 7)
	}
	return res
}

pub fn cchatroomgetmessagehistoryrequest_unpack(buf []byte) ?CChatRoomGetMessageHistoryRequest {
	mut res := CChatRoomGetMessageHistoryRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_last_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_time = v
				i = ii
			}
			4 {
				res.has_last_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_ordinal = v
				i = ii
			}
			5 {
				res.has_start_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_time = v
				i = ii
			}
			6 {
				res.has_start_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_ordinal = v
				i = ii
			}
			7 {
				res.has_max_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetmessagehistoryrequest() CChatRoomGetMessageHistoryRequest {
	return CChatRoomGetMessageHistoryRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetmessagehistoryrequest(o CChatRoomGetMessageHistoryRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetmessagehistoryrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetMessageHistoryRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetmessagehistoryrequest_unpack(v)?
	return i, unpacked
}

pub struct ServerMessage {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	message             EChatRoomServerMessage
	has_message         bool
	string_param        string
	has_string_param    bool
	accountid_param     u32
	has_accountid_param bool
}

pub fn (o &ServerMessage) pack() []byte {
	mut res := []byte{}
	if o.has_message {
		res << zzz_vproto_internal_pack_echatroomservermessage(o.message, 1)
	}
	if o.has_string_param {
		res << vproto.pack_string_field(o.string_param, 2)
	}
	if o.has_accountid_param {
		res << vproto.pack_uint32_field(o.accountid_param, 3)
	}
	return res
}

pub fn servermessage_unpack(buf []byte) ?ServerMessage {
	mut res := ServerMessage{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_message = true
				ii, v := zzz_vproto_internal_unpack_echatroomservermessage(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			2 {
				res.has_string_param = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.string_param = v
				i = ii
			}
			3 {
				res.has_accountid_param = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_param = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_servermessage() ServerMessage {
	return ServerMessage{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_servermessage(o ServerMessage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_servermessage(buf []byte, tag_wiretype vproto.WireType) ?(int, ServerMessage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := servermessage_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetMessageHistoryResponseChatMessage {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	sender               u32
	has_sender           bool
	server_timestamp     u32
	has_server_timestamp bool
	message              string
	has_message          bool
	ordinal              u32
	has_ordinal          bool
	server_message       ServerMessage
	has_server_message   bool
	deleted              bool
	has_deleted          bool
}

pub fn (o &CChatRoomGetMessageHistoryResponseChatMessage) pack() []byte {
	mut res := []byte{}
	if o.has_sender {
		res << vproto.pack_uint32_field(o.sender, 1)
	}
	if o.has_server_timestamp {
		res << vproto.pack_uint32_field(o.server_timestamp, 2)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 3)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 4)
	}
	if o.has_server_message {
		res << zzz_vproto_internal_pack_servermessage(o.server_message, 5)
	}
	if o.has_deleted {
		res << vproto.pack_bool_field(o.deleted, 6)
	}
	return res
}

pub fn cchatroomgetmessagehistoryresponsechatmessage_unpack(buf []byte) ?CChatRoomGetMessageHistoryResponseChatMessage {
	mut res := CChatRoomGetMessageHistoryResponseChatMessage{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sender = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sender = v
				i = ii
			}
			2 {
				res.has_server_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.server_timestamp = v
				i = ii
			}
			3 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			4 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			5 {
				res.has_server_message = true
				ii, v := zzz_vproto_internal_unpack_servermessage(cur_buf, tag_wiretype.wire_type)?
				res.server_message = v
				i = ii
			}
			6 {
				res.has_deleted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.deleted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetmessagehistoryresponsechatmessage() CChatRoomGetMessageHistoryResponseChatMessage {
	return CChatRoomGetMessageHistoryResponseChatMessage{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetmessagehistoryresponsechatmessage(o CChatRoomGetMessageHistoryResponseChatMessage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetmessagehistoryresponsechatmessage(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetMessageHistoryResponseChatMessage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetmessagehistoryresponsechatmessage_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetMessageHistoryResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	messages           []CChatRoomGetMessageHistoryResponseChatMessage
	more_available     bool
	has_more_available bool
}

pub fn (o &CChatRoomGetMessageHistoryResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.messages {
		res << zzz_vproto_internal_pack_cchatroomgetmessagehistoryresponsechatmessage(x, 1)
	}
	if o.has_more_available {
		res << vproto.pack_bool_field(o.more_available, 4)
	}
	return res
}

pub fn cchatroomgetmessagehistoryresponse_unpack(buf []byte) ?CChatRoomGetMessageHistoryResponse {
	mut res := CChatRoomGetMessageHistoryResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomgetmessagehistoryresponsechatmessage(cur_buf,
					tag_wiretype.wire_type)?
				res.messages << v
				i = ii
			}
			4 {
				res.has_more_available = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.more_available = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetmessagehistoryresponse() CChatRoomGetMessageHistoryResponse {
	return CChatRoomGetMessageHistoryResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetmessagehistoryresponse(o CChatRoomGetMessageHistoryResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetmessagehistoryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetMessageHistoryResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetmessagehistoryresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetMyChatRoomGroupsRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomGetMyChatRoomGroupsRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomgetmychatroomgroupsrequest_unpack(buf []byte) ?CChatRoomGetMyChatRoomGroupsRequest {
	res := CChatRoomGetMyChatRoomGroupsRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetmychatroomgroupsrequest() CChatRoomGetMyChatRoomGroupsRequest {
	return CChatRoomGetMyChatRoomGroupsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetmychatroomgroupsrequest(o CChatRoomGetMyChatRoomGroupsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetmychatroomgroupsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetMyChatRoomGroupsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetmychatroomgroupsrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetChatRoomGroupSummaryResponse {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	chat_group_id                     u64
	has_chat_group_id                 bool
	chat_group_name                   string
	has_chat_group_name               bool
	active_member_count               u32
	has_active_member_count           bool
	active_voice_member_count         u32
	has_active_voice_member_count     bool
	default_chat_id                   u64
	has_default_chat_id               bool
	chat_rooms                        []CChatRoomState
	clanid                            u32
	has_clanid                        bool
	chat_group_tagline                string
	has_chat_group_tagline            bool
	accountid_owner                   u32
	has_accountid_owner               bool
	top_members                       []u32
	chat_group_avatar_sha             []byte
	has_chat_group_avatar_sha         bool
	rank                              EChatRoomGroupRank
	has_rank                          bool
	default_role_id                   u64
	has_default_role_id               bool
	role_ids                          []u64
	role_actions                      []CChatRoleActions
	watching_broadcast_accountid      u32
	has_watching_broadcast_accountid  bool
	appid                             u32
	has_appid                         bool
	party_beacons                     []CChatPartyBeacon
	watching_broadcast_channel_id     u64
	has_watching_broadcast_channel_id bool
	active_minigame_id                u64
	has_active_minigame_id            bool
	avatar_ugc_url                    string
	has_avatar_ugc_url                bool
}

pub fn (o &CChatRoomGetChatRoomGroupSummaryResponse) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_group_name {
		res << vproto.pack_string_field(o.chat_group_name, 2)
	}
	if o.has_active_member_count {
		res << vproto.pack_uint32_field(o.active_member_count, 3)
	}
	if o.has_active_voice_member_count {
		res << vproto.pack_uint32_field(o.active_voice_member_count, 4)
	}
	if o.has_default_chat_id {
		res << vproto.pack_uint64_field(o.default_chat_id, 5)
	}
	// [packed=false]
	for _, x in o.chat_rooms {
		res << zzz_vproto_internal_pack_cchatroomstate(x, 6)
	}
	if o.has_clanid {
		res << vproto.pack_uint32_field(o.clanid, 7)
	}
	if o.has_chat_group_tagline {
		res << vproto.pack_string_field(o.chat_group_tagline, 8)
	}
	if o.has_accountid_owner {
		res << vproto.pack_uint32_field(o.accountid_owner, 9)
	}
	// [packed=false]
	for _, x in o.top_members {
		res << vproto.pack_uint32_field(x, 10)
	}
	if o.has_chat_group_avatar_sha {
		res << vproto.pack_bytes_field(o.chat_group_avatar_sha, 11)
	}
	if o.has_rank {
		res << zzz_vproto_internal_pack_echatroomgrouprank(o.rank, 12)
	}
	if o.has_default_role_id {
		res << vproto.pack_uint64_field(o.default_role_id, 13)
	}
	// [packed=false]
	for _, x in o.role_ids {
		res << vproto.pack_uint64_field(x, 14)
	}
	// [packed=false]
	for _, x in o.role_actions {
		res << zzz_vproto_internal_pack_cchatroleactions(x, 15)
	}
	if o.has_watching_broadcast_accountid {
		res << vproto.pack_uint32_field(o.watching_broadcast_accountid, 16)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 17)
	}
	// [packed=false]
	for _, x in o.party_beacons {
		res << zzz_vproto_internal_pack_cchatpartybeacon(x, 18)
	}
	if o.has_watching_broadcast_channel_id {
		res << vproto.pack_uint64_field(o.watching_broadcast_channel_id, 19)
	}
	if o.has_active_minigame_id {
		res << vproto.pack_uint64_field(o.active_minigame_id, 20)
	}
	if o.has_avatar_ugc_url {
		res << vproto.pack_string_field(o.avatar_ugc_url, 21)
	}
	return res
}

pub fn cchatroomgetchatroomgroupsummaryresponse_unpack(buf []byte) ?CChatRoomGetChatRoomGroupSummaryResponse {
	mut res := CChatRoomGetChatRoomGroupSummaryResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_group_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_name = v
				i = ii
			}
			3 {
				res.has_active_member_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.active_member_count = v
				i = ii
			}
			4 {
				res.has_active_voice_member_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.active_voice_member_count = v
				i = ii
			}
			5 {
				res.has_default_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.default_chat_id = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomstate(cur_buf, tag_wiretype.wire_type)?
				res.chat_rooms << v
				i = ii
			}
			7 {
				res.has_clanid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.clanid = v
				i = ii
			}
			8 {
				res.has_chat_group_tagline = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_tagline = v
				i = ii
			}
			9 {
				res.has_accountid_owner = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_owner = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.top_members << v
				i = ii
			}
			11 {
				res.has_chat_group_avatar_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_avatar_sha = v
				i = ii
			}
			12 {
				res.has_rank = true
				ii, v := zzz_vproto_internal_unpack_echatroomgrouprank(cur_buf, tag_wiretype.wire_type)?
				res.rank = v
				i = ii
			}
			13 {
				res.has_default_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.default_role_id = v
				i = ii
			}
			14 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_ids << v
				i = ii
			}
			15 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroleactions(cur_buf, tag_wiretype.wire_type)?
				res.role_actions << v
				i = ii
			}
			16 {
				res.has_watching_broadcast_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_accountid = v
				i = ii
			}
			17 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			18 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatpartybeacon(cur_buf, tag_wiretype.wire_type)?
				res.party_beacons << v
				i = ii
			}
			19 {
				res.has_watching_broadcast_channel_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_channel_id = v
				i = ii
			}
			20 {
				res.has_active_minigame_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.active_minigame_id = v
				i = ii
			}
			21 {
				res.has_avatar_ugc_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.avatar_ugc_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetchatroomgroupsummaryresponse() CChatRoomGetChatRoomGroupSummaryResponse {
	return CChatRoomGetChatRoomGroupSummaryResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetchatroomgroupsummaryresponse(o CChatRoomGetChatRoomGroupSummaryResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetchatroomgroupsummaryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetChatRoomGroupSummaryResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetchatroomgroupsummaryresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSummaryPair {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	user_chat_group_state     CUserChatRoomGroupState
	has_user_chat_group_state bool
	group_summary             CChatRoomGetChatRoomGroupSummaryResponse
	has_group_summary         bool
}

pub fn (o &CChatRoomSummaryPair) pack() []byte {
	mut res := []byte{}
	if o.has_user_chat_group_state {
		res << zzz_vproto_internal_pack_cuserchatroomgroupstate(o.user_chat_group_state, 1)
	}
	if o.has_group_summary {
		res <<
			zzz_vproto_internal_pack_cchatroomgetchatroomgroupsummaryresponse(o.group_summary, 2)
	}
	return res
}

pub fn cchatroomsummarypair_unpack(buf []byte) ?CChatRoomSummaryPair {
	mut res := CChatRoomSummaryPair{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_user_chat_group_state = true
				ii, v := zzz_vproto_internal_unpack_cuserchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.user_chat_group_state = v
				i = ii
			}
			2 {
				res.has_group_summary = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgetchatroomgroupsummaryresponse(cur_buf,
					tag_wiretype.wire_type)?
				res.group_summary = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsummarypair() CChatRoomSummaryPair {
	return CChatRoomSummaryPair{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsummarypair(o CChatRoomSummaryPair, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsummarypair(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSummaryPair) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsummarypair_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetMyChatRoomGroupsResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	chat_room_groups []CChatRoomSummaryPair
}

pub fn (o &CChatRoomGetMyChatRoomGroupsResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.chat_room_groups {
		res << zzz_vproto_internal_pack_cchatroomsummarypair(x, 1)
	}
	return res
}

pub fn cchatroomgetmychatroomgroupsresponse_unpack(buf []byte) ?CChatRoomGetMyChatRoomGroupsResponse {
	mut res := CChatRoomGetMyChatRoomGroupsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomsummarypair(cur_buf, tag_wiretype.wire_type)?
				res.chat_room_groups << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetmychatroomgroupsresponse() CChatRoomGetMyChatRoomGroupsResponse {
	return CChatRoomGetMyChatRoomGroupsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetmychatroomgroupsresponse(o CChatRoomGetMyChatRoomGroupsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetmychatroomgroupsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetMyChatRoomGroupsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetmychatroomgroupsresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetChatRoomGroupStateRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoomGetChatRoomGroupStateRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroomgetchatroomgroupstaterequest_unpack(buf []byte) ?CChatRoomGetChatRoomGroupStateRequest {
	mut res := CChatRoomGetChatRoomGroupStateRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetchatroomgroupstaterequest() CChatRoomGetChatRoomGroupStateRequest {
	return CChatRoomGetChatRoomGroupStateRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetchatroomgroupstaterequest(o CChatRoomGetChatRoomGroupStateRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetchatroomgroupstaterequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetChatRoomGroupStateRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetchatroomgroupstaterequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetChatRoomGroupStateResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	state          CChatRoomGroupState
	has_state      bool
}

pub fn (o &CChatRoomGetChatRoomGroupStateResponse) pack() []byte {
	mut res := []byte{}
	if o.has_state {
		res << zzz_vproto_internal_pack_cchatroomgroupstate(o.state, 1)
	}
	return res
}

pub fn cchatroomgetchatroomgroupstateresponse_unpack(buf []byte) ?CChatRoomGetChatRoomGroupStateResponse {
	mut res := CChatRoomGetChatRoomGroupStateResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_state = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetchatroomgroupstateresponse() CChatRoomGetChatRoomGroupStateResponse {
	return CChatRoomGetChatRoomGroupStateResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetchatroomgroupstateresponse(o CChatRoomGetChatRoomGroupStateResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetchatroomgroupstateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetChatRoomGroupStateResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetchatroomgroupstateresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetChatRoomGroupSummaryRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoomGetChatRoomGroupSummaryRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroomgetchatroomgroupsummaryrequest_unpack(buf []byte) ?CChatRoomGetChatRoomGroupSummaryRequest {
	mut res := CChatRoomGetChatRoomGroupSummaryRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetchatroomgroupsummaryrequest() CChatRoomGetChatRoomGroupSummaryRequest {
	return CChatRoomGetChatRoomGroupSummaryRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetchatroomgroupsummaryrequest(o CChatRoomGetChatRoomGroupSummaryRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetchatroomgroupsummaryrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetChatRoomGroupSummaryRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetchatroomgroupsummaryrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetAppChatRoomGroupForceActiveRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	chat_group_id         u64
	has_chat_group_id     bool
	requesting_app_id     u32
	has_requesting_app_id bool
}

pub fn (o &CChatRoomSetAppChatRoomGroupForceActiveRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_requesting_app_id {
		res << vproto.pack_uint32_field(o.requesting_app_id, 2)
	}
	return res
}

pub fn cchatroomsetappchatroomgroupforceactiverequest_unpack(buf []byte) ?CChatRoomSetAppChatRoomGroupForceActiveRequest {
	mut res := CChatRoomSetAppChatRoomGroupForceActiveRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_requesting_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.requesting_app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetappchatroomgroupforceactiverequest() CChatRoomSetAppChatRoomGroupForceActiveRequest {
	return CChatRoomSetAppChatRoomGroupForceActiveRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetappchatroomgroupforceactiverequest(o CChatRoomSetAppChatRoomGroupForceActiveRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetappchatroomgroupforceactiverequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetAppChatRoomGroupForceActiveRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetappchatroomgroupforceactiverequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetAppChatRoomGroupForceActiveResponse {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	result              u32
	has_result          bool
	accounts_in_channel []u32
}

pub fn (o &CChatRoomSetAppChatRoomGroupForceActiveResponse) pack() []byte {
	mut res := []byte{}
	if o.has_result {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	// [packed=false]
	for _, x in o.accounts_in_channel {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cchatroomsetappchatroomgroupforceactiveresponse_unpack(buf []byte) ?CChatRoomSetAppChatRoomGroupForceActiveResponse {
	mut res := CChatRoomSetAppChatRoomGroupForceActiveResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accounts_in_channel << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetappchatroomgroupforceactiveresponse() CChatRoomSetAppChatRoomGroupForceActiveResponse {
	return CChatRoomSetAppChatRoomGroupForceActiveResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetappchatroomgroupforceactiveresponse(o CChatRoomSetAppChatRoomGroupForceActiveResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetappchatroomgroupforceactiveresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetAppChatRoomGroupForceActiveResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetappchatroomgroupforceactiveresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetAppChatRoomGroupStopForceActiveNotification {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	chat_group_id         u64
	has_chat_group_id     bool
	requesting_app_id     u32
	has_requesting_app_id bool
}

pub fn (o &CChatRoomSetAppChatRoomGroupStopForceActiveNotification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_requesting_app_id {
		res << vproto.pack_uint32_field(o.requesting_app_id, 2)
	}
	return res
}

pub fn cchatroomsetappchatroomgroupstopforceactivenotification_unpack(buf []byte) ?CChatRoomSetAppChatRoomGroupStopForceActiveNotification {
	mut res := CChatRoomSetAppChatRoomGroupStopForceActiveNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_requesting_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.requesting_app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetappchatroomgroupstopforceactivenotification() CChatRoomSetAppChatRoomGroupStopForceActiveNotification {
	return CChatRoomSetAppChatRoomGroupStopForceActiveNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetappchatroomgroupstopforceactivenotification(o CChatRoomSetAppChatRoomGroupStopForceActiveNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetappchatroomgroupstopforceactivenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetAppChatRoomGroupStopForceActiveNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetappchatroomgroupstopforceactivenotification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomAckChatMessageNotification {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
	timestamp         u32
	has_timestamp     bool
}

pub fn (o &CChatRoomAckChatMessageNotification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 3)
	}
	return res
}

pub fn cchatroomackchatmessagenotification_unpack(buf []byte) ?CChatRoomAckChatMessageNotification {
	mut res := CChatRoomAckChatMessageNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomackchatmessagenotification() CChatRoomAckChatMessageNotification {
	return CChatRoomAckChatMessageNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomackchatmessagenotification(o CChatRoomAckChatMessageNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomackchatmessagenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomAckChatMessageNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomackchatmessagenotification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomCreateInviteLinkRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	seconds_valid     u32
	has_seconds_valid bool
	chat_id           u64
	has_chat_id       bool
}

pub fn (o &CChatRoomCreateInviteLinkRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_seconds_valid {
		res << vproto.pack_uint32_field(o.seconds_valid, 2)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 3)
	}
	return res
}

pub fn cchatroomcreateinvitelinkrequest_unpack(buf []byte) ?CChatRoomCreateInviteLinkRequest {
	mut res := CChatRoomCreateInviteLinkRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_seconds_valid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_valid = v
				i = ii
			}
			3 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomcreateinvitelinkrequest() CChatRoomCreateInviteLinkRequest {
	return CChatRoomCreateInviteLinkRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomcreateinvitelinkrequest(o CChatRoomCreateInviteLinkRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomcreateinvitelinkrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomCreateInviteLinkRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomcreateinvitelinkrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomCreateInviteLinkResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	invite_code       string
	has_invite_code   bool
	seconds_valid     u32
	has_seconds_valid bool
}

pub fn (o &CChatRoomCreateInviteLinkResponse) pack() []byte {
	mut res := []byte{}
	if o.has_invite_code {
		res << vproto.pack_string_field(o.invite_code, 1)
	}
	if o.has_seconds_valid {
		res << vproto.pack_uint32_field(o.seconds_valid, 2)
	}
	return res
}

pub fn cchatroomcreateinvitelinkresponse_unpack(buf []byte) ?CChatRoomCreateInviteLinkResponse {
	mut res := CChatRoomCreateInviteLinkResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_invite_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_code = v
				i = ii
			}
			2 {
				res.has_seconds_valid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_valid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomcreateinvitelinkresponse() CChatRoomCreateInviteLinkResponse {
	return CChatRoomCreateInviteLinkResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomcreateinvitelinkresponse(o CChatRoomCreateInviteLinkResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomcreateinvitelinkresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomCreateInviteLinkResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomcreateinvitelinkresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetInviteLinkInfoRequest {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	invite_code     string
	has_invite_code bool
}

pub fn (o &CChatRoomGetInviteLinkInfoRequest) pack() []byte {
	mut res := []byte{}
	if o.has_invite_code {
		res << vproto.pack_string_field(o.invite_code, 1)
	}
	return res
}

pub fn cchatroomgetinvitelinkinforequest_unpack(buf []byte) ?CChatRoomGetInviteLinkInfoRequest {
	mut res := CChatRoomGetInviteLinkInfoRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_invite_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetinvitelinkinforequest() CChatRoomGetInviteLinkInfoRequest {
	return CChatRoomGetInviteLinkInfoRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetinvitelinkinforequest(o CChatRoomGetInviteLinkInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetinvitelinkinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetInviteLinkInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetinvitelinkinforequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetInviteLinkInfoResponse {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	steamid_sender            u64
	has_steamid_sender        bool
	time_expires              u32
	has_time_expires          bool
	chat_id                   u64
	has_chat_id               bool
	group_summary             CChatRoomGetChatRoomGroupSummaryResponse
	has_group_summary         bool
	user_chat_group_state     CUserChatRoomGroupState
	has_user_chat_group_state bool
	time_kick_expire          u32
	has_time_kick_expire      bool
	banned                    bool
	has_banned                bool
}

pub fn (o &CChatRoomGetInviteLinkInfoResponse) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_sender {
		res << vproto.pack_64bit_field(o.steamid_sender, 3)
	}
	if o.has_time_expires {
		res << vproto.pack_uint32_field(o.time_expires, 4)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 6)
	}
	if o.has_group_summary {
		res <<
			zzz_vproto_internal_pack_cchatroomgetchatroomgroupsummaryresponse(o.group_summary, 8)
	}
	if o.has_user_chat_group_state {
		res << zzz_vproto_internal_pack_cuserchatroomgroupstate(o.user_chat_group_state, 9)
	}
	if o.has_time_kick_expire {
		res << vproto.pack_uint32_field(o.time_kick_expire, 10)
	}
	if o.has_banned {
		res << vproto.pack_bool_field(o.banned, 11)
	}
	return res
}

pub fn cchatroomgetinvitelinkinforesponse_unpack(buf []byte) ?CChatRoomGetInviteLinkInfoResponse {
	mut res := CChatRoomGetInviteLinkInfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			3 {
				res.has_steamid_sender = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_sender = v
				i = ii
			}
			4 {
				res.has_time_expires = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_expires = v
				i = ii
			}
			6 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			8 {
				res.has_group_summary = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgetchatroomgroupsummaryresponse(cur_buf,
					tag_wiretype.wire_type)?
				res.group_summary = v
				i = ii
			}
			9 {
				res.has_user_chat_group_state = true
				ii, v := zzz_vproto_internal_unpack_cuserchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.user_chat_group_state = v
				i = ii
			}
			10 {
				res.has_time_kick_expire = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_kick_expire = v
				i = ii
			}
			11 {
				res.has_banned = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.banned = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetinvitelinkinforesponse() CChatRoomGetInviteLinkInfoResponse {
	return CChatRoomGetInviteLinkInfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetinvitelinkinforesponse(o CChatRoomGetInviteLinkInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetinvitelinkinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetInviteLinkInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetinvitelinkinforesponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetInviteInfoRequest {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	steamid_invitee     u64
	has_steamid_invitee bool
	chat_group_id       u64
	has_chat_group_id   bool
	chat_id             u64
	has_chat_id         bool
	invite_code         string
	has_invite_code     bool
}

pub fn (o &CChatRoomGetInviteInfoRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_invitee {
		res << vproto.pack_64bit_field(o.steamid_invitee, 1)
	}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 2)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 3)
	}
	if o.has_invite_code {
		res << vproto.pack_string_field(o.invite_code, 4)
	}
	return res
}

pub fn cchatroomgetinviteinforequest_unpack(buf []byte) ?CChatRoomGetInviteInfoRequest {
	mut res := CChatRoomGetInviteInfoRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_invitee = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_invitee = v
				i = ii
			}
			2 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			3 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			4 {
				res.has_invite_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetinviteinforequest() CChatRoomGetInviteInfoRequest {
	return CChatRoomGetInviteInfoRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetinviteinforequest(o CChatRoomGetInviteInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetinviteinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetInviteInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetinviteinforequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetInviteInfoResponse {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	group_summary        CChatRoomGetChatRoomGroupSummaryResponse
	has_group_summary    bool
	time_kick_expire     u32
	has_time_kick_expire bool
	banned               bool
	has_banned           bool
}

pub fn (o &CChatRoomGetInviteInfoResponse) pack() []byte {
	mut res := []byte{}
	if o.has_group_summary {
		res <<
			zzz_vproto_internal_pack_cchatroomgetchatroomgroupsummaryresponse(o.group_summary, 1)
	}
	if o.has_time_kick_expire {
		res << vproto.pack_uint32_field(o.time_kick_expire, 2)
	}
	if o.has_banned {
		res << vproto.pack_bool_field(o.banned, 3)
	}
	return res
}

pub fn cchatroomgetinviteinforesponse_unpack(buf []byte) ?CChatRoomGetInviteInfoResponse {
	mut res := CChatRoomGetInviteInfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_group_summary = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgetchatroomgroupsummaryresponse(cur_buf,
					tag_wiretype.wire_type)?
				res.group_summary = v
				i = ii
			}
			2 {
				res.has_time_kick_expire = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_kick_expire = v
				i = ii
			}
			3 {
				res.has_banned = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.banned = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetinviteinforesponse() CChatRoomGetInviteInfoResponse {
	return CChatRoomGetInviteInfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetinviteinforesponse(o CChatRoomGetInviteInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetinviteinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetInviteInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetinviteinforesponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetInviteLinksForGroupRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoomGetInviteLinksForGroupRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroomgetinvitelinksforgrouprequest_unpack(buf []byte) ?CChatRoomGetInviteLinksForGroupRequest {
	mut res := CChatRoomGetInviteLinksForGroupRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetinvitelinksforgrouprequest() CChatRoomGetInviteLinksForGroupRequest {
	return CChatRoomGetInviteLinksForGroupRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetinvitelinksforgrouprequest(o CChatRoomGetInviteLinksForGroupRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetinvitelinksforgrouprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetInviteLinksForGroupRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetinvitelinksforgrouprequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetInviteLinksForGroupResponseLinkInfo {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	invite_code         string
	has_invite_code     bool
	steamid_creator     u64
	has_steamid_creator bool
	time_expires        u32
	has_time_expires    bool
	chat_id             u64
	has_chat_id         bool
}

pub fn (o &CChatRoomGetInviteLinksForGroupResponseLinkInfo) pack() []byte {
	mut res := []byte{}
	if o.has_invite_code {
		res << vproto.pack_string_field(o.invite_code, 1)
	}
	if o.has_steamid_creator {
		res << vproto.pack_64bit_field(o.steamid_creator, 2)
	}
	if o.has_time_expires {
		res << vproto.pack_uint32_field(o.time_expires, 3)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 4)
	}
	return res
}

pub fn cchatroomgetinvitelinksforgroupresponselinkinfo_unpack(buf []byte) ?CChatRoomGetInviteLinksForGroupResponseLinkInfo {
	mut res := CChatRoomGetInviteLinksForGroupResponseLinkInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_invite_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_code = v
				i = ii
			}
			2 {
				res.has_steamid_creator = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_creator = v
				i = ii
			}
			3 {
				res.has_time_expires = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_expires = v
				i = ii
			}
			4 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetinvitelinksforgroupresponselinkinfo() CChatRoomGetInviteLinksForGroupResponseLinkInfo {
	return CChatRoomGetInviteLinksForGroupResponseLinkInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetinvitelinksforgroupresponselinkinfo(o CChatRoomGetInviteLinksForGroupResponseLinkInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetinvitelinksforgroupresponselinkinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetInviteLinksForGroupResponseLinkInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetinvitelinksforgroupresponselinkinfo_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetInviteLinksForGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	invite_links   []CChatRoomGetInviteLinksForGroupResponseLinkInfo
}

pub fn (o &CChatRoomGetInviteLinksForGroupResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.invite_links {
		res << zzz_vproto_internal_pack_cchatroomgetinvitelinksforgroupresponselinkinfo(x, 1)
	}
	return res
}

pub fn cchatroomgetinvitelinksforgroupresponse_unpack(buf []byte) ?CChatRoomGetInviteLinksForGroupResponse {
	mut res := CChatRoomGetInviteLinksForGroupResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomgetinvitelinksforgroupresponselinkinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.invite_links << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetinvitelinksforgroupresponse() CChatRoomGetInviteLinksForGroupResponse {
	return CChatRoomGetInviteLinksForGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetinvitelinksforgroupresponse(o CChatRoomGetInviteLinksForGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetinvitelinksforgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetInviteLinksForGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetinvitelinksforgroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetBanListRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoomGetBanListRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroomgetbanlistrequest_unpack(buf []byte) ?CChatRoomGetBanListRequest {
	mut res := CChatRoomGetBanListRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetbanlistrequest() CChatRoomGetBanListRequest {
	return CChatRoomGetBanListRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetbanlistrequest(o CChatRoomGetBanListRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetbanlistrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetBanListRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetbanlistrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetBanListResponseBanInfo {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	accountid           u32
	has_accountid       bool
	accountid_actor     u32
	has_accountid_actor bool
	time_banned         u32
	has_time_banned     bool
	ban_reason          string
	has_ban_reason      bool
}

pub fn (o &CChatRoomGetBanListResponseBanInfo) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 1)
	}
	if o.has_accountid_actor {
		res << vproto.pack_uint32_field(o.accountid_actor, 2)
	}
	if o.has_time_banned {
		res << vproto.pack_uint32_field(o.time_banned, 3)
	}
	if o.has_ban_reason {
		res << vproto.pack_string_field(o.ban_reason, 4)
	}
	return res
}

pub fn cchatroomgetbanlistresponsebaninfo_unpack(buf []byte) ?CChatRoomGetBanListResponseBanInfo {
	mut res := CChatRoomGetBanListResponseBanInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_accountid_actor = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_actor = v
				i = ii
			}
			3 {
				res.has_time_banned = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_banned = v
				i = ii
			}
			4 {
				res.has_ban_reason = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.ban_reason = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetbanlistresponsebaninfo() CChatRoomGetBanListResponseBanInfo {
	return CChatRoomGetBanListResponseBanInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetbanlistresponsebaninfo(o CChatRoomGetBanListResponseBanInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetbanlistresponsebaninfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetBanListResponseBanInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetbanlistresponsebaninfo_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetBanListResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bans           []CChatRoomGetBanListResponseBanInfo
}

pub fn (o &CChatRoomGetBanListResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.bans {
		res << zzz_vproto_internal_pack_cchatroomgetbanlistresponsebaninfo(x, 1)
	}
	return res
}

pub fn cchatroomgetbanlistresponse_unpack(buf []byte) ?CChatRoomGetBanListResponse {
	mut res := CChatRoomGetBanListResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomgetbanlistresponsebaninfo(cur_buf,
					tag_wiretype.wire_type)?
				res.bans << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetbanlistresponse() CChatRoomGetBanListResponse {
	return CChatRoomGetBanListResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetbanlistresponse(o CChatRoomGetBanListResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetbanlistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetBanListResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetbanlistresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetInviteListRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoomGetInviteListRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroomgetinvitelistrequest_unpack(buf []byte) ?CChatRoomGetInviteListRequest {
	mut res := CChatRoomGetInviteListRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetinvitelistrequest() CChatRoomGetInviteListRequest {
	return CChatRoomGetInviteListRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetinvitelistrequest(o CChatRoomGetInviteListRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetinvitelistrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetInviteListRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetinvitelistrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGroupInvite {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	accountid           u32
	has_accountid       bool
	accountid_actor     u32
	has_accountid_actor bool
	time_invited        u32
	has_time_invited    bool
}

pub fn (o &CChatRoomGroupInvite) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 1)
	}
	if o.has_accountid_actor {
		res << vproto.pack_uint32_field(o.accountid_actor, 2)
	}
	if o.has_time_invited {
		res << vproto.pack_uint32_field(o.time_invited, 3)
	}
	return res
}

pub fn cchatroomgroupinvite_unpack(buf []byte) ?CChatRoomGroupInvite {
	mut res := CChatRoomGroupInvite{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_accountid_actor = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_actor = v
				i = ii
			}
			3 {
				res.has_time_invited = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_invited = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgroupinvite() CChatRoomGroupInvite {
	return CChatRoomGroupInvite{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgroupinvite(o CChatRoomGroupInvite, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgroupinvite(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGroupInvite) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgroupinvite_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGetInviteListResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	invites        []CChatRoomGroupInvite
}

pub fn (o &CChatRoomGetInviteListResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.invites {
		res << zzz_vproto_internal_pack_cchatroomgroupinvite(x, 1)
	}
	return res
}

pub fn cchatroomgetinvitelistresponse_unpack(buf []byte) ?CChatRoomGetInviteListResponse {
	mut res := CChatRoomGetInviteListResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupinvite(cur_buf, tag_wiretype.wire_type)?
				res.invites << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgetinvitelistresponse() CChatRoomGetInviteListResponse {
	return CChatRoomGetInviteListResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgetinvitelistresponse(o CChatRoomGetInviteListResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgetinvitelistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGetInviteListResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgetinvitelistresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomDeleteInviteLinkRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	invite_code       string
	has_invite_code   bool
}

pub fn (o &CChatRoomDeleteInviteLinkRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_invite_code {
		res << vproto.pack_string_field(o.invite_code, 2)
	}
	return res
}

pub fn cchatroomdeleteinvitelinkrequest_unpack(buf []byte) ?CChatRoomDeleteInviteLinkRequest {
	mut res := CChatRoomDeleteInviteLinkRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_invite_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomdeleteinvitelinkrequest() CChatRoomDeleteInviteLinkRequest {
	return CChatRoomDeleteInviteLinkRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomdeleteinvitelinkrequest(o CChatRoomDeleteInviteLinkRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomdeleteinvitelinkrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomDeleteInviteLinkRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomdeleteinvitelinkrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomDeleteInviteLinkResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomDeleteInviteLinkResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomdeleteinvitelinkresponse_unpack(buf []byte) ?CChatRoomDeleteInviteLinkResponse {
	res := CChatRoomDeleteInviteLinkResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomdeleteinvitelinkresponse() CChatRoomDeleteInviteLinkResponse {
	return CChatRoomDeleteInviteLinkResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomdeleteinvitelinkresponse(o CChatRoomDeleteInviteLinkResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomdeleteinvitelinkresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomDeleteInviteLinkResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomdeleteinvitelinkresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetSessionActiveChatRoomGroupsRequest {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	chat_group_ids                   []u64
	chat_groups_data_requested       []u64
	virtualize_members_threshold     int
	has_virtualize_members_threshold bool
}

pub fn (o &CChatRoomSetSessionActiveChatRoomGroupsRequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.chat_group_ids {
		res << vproto.pack_uint64_field(x, 1)
	}
	// [packed=false]
	for _, x in o.chat_groups_data_requested {
		res << vproto.pack_uint64_field(x, 2)
	}
	if o.has_virtualize_members_threshold {
		res << vproto.pack_int32_field(o.virtualize_members_threshold, 3)
	}
	return res
}

pub fn cchatroomsetsessionactivechatroomgroupsrequest_unpack(buf []byte) ?CChatRoomSetSessionActiveChatRoomGroupsRequest {
	mut res := CChatRoomSetSessionActiveChatRoomGroupsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_ids << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_groups_data_requested << v
				i = ii
			}
			3 {
				res.has_virtualize_members_threshold = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.virtualize_members_threshold = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetsessionactivechatroomgroupsrequest() CChatRoomSetSessionActiveChatRoomGroupsRequest {
	return CChatRoomSetSessionActiveChatRoomGroupsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetsessionactivechatroomgroupsrequest(o CChatRoomSetSessionActiveChatRoomGroupsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetsessionactivechatroomgroupsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetSessionActiveChatRoomGroupsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetsessionactivechatroomgroupsrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetSessionActiveChatRoomGroupsResponse {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	chat_states                       []CChatRoomGroupState
	virtualize_members_chat_group_ids []u64
}

pub fn (o &CChatRoomSetSessionActiveChatRoomGroupsResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.chat_states {
		res << zzz_vproto_internal_pack_cchatroomgroupstate(x, 1)
	}
	// [packed=false]
	for _, x in o.virtualize_members_chat_group_ids {
		res << vproto.pack_uint64_field(x, 2)
	}
	return res
}

pub fn cchatroomsetsessionactivechatroomgroupsresponse_unpack(buf []byte) ?CChatRoomSetSessionActiveChatRoomGroupsResponse {
	mut res := CChatRoomSetSessionActiveChatRoomGroupsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.chat_states << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.virtualize_members_chat_group_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetsessionactivechatroomgroupsresponse() CChatRoomSetSessionActiveChatRoomGroupsResponse {
	return CChatRoomSetSessionActiveChatRoomGroupsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetsessionactivechatroomgroupsresponse(o CChatRoomSetSessionActiveChatRoomGroupsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetsessionactivechatroomgroupsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetSessionActiveChatRoomGroupsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetsessionactivechatroomgroupsresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetUserChatGroupPreferencesRequestChatGroupPreferences {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	desktop_notification_level     EChatRoomNotificationLevel
	has_desktop_notification_level bool
	mobile_notification_level      EChatRoomNotificationLevel
	has_mobile_notification_level  bool
	unread_indicator_muted         bool
	has_unread_indicator_muted     bool
}

pub fn (o &CChatRoomSetUserChatGroupPreferencesRequestChatGroupPreferences) pack() []byte {
	mut res := []byte{}
	if o.has_desktop_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.desktop_notification_level, 1)
	}
	if o.has_mobile_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.mobile_notification_level, 2)
	}
	if o.has_unread_indicator_muted {
		res << vproto.pack_bool_field(o.unread_indicator_muted, 3)
	}
	return res
}

pub fn cchatroomsetuserchatgrouppreferencesrequestchatgrouppreferences_unpack(buf []byte) ?CChatRoomSetUserChatGroupPreferencesRequestChatGroupPreferences {
	mut res := CChatRoomSetUserChatGroupPreferencesRequestChatGroupPreferences{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_desktop_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.desktop_notification_level = v
				i = ii
			}
			2 {
				res.has_mobile_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.mobile_notification_level = v
				i = ii
			}
			3 {
				res.has_unread_indicator_muted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.unread_indicator_muted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetuserchatgrouppreferencesrequestchatgrouppreferences() CChatRoomSetUserChatGroupPreferencesRequestChatGroupPreferences {
	return CChatRoomSetUserChatGroupPreferencesRequestChatGroupPreferences{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetuserchatgrouppreferencesrequestchatgrouppreferences(o CChatRoomSetUserChatGroupPreferencesRequestChatGroupPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetuserchatgrouppreferencesrequestchatgrouppreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetUserChatGroupPreferencesRequestChatGroupPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetuserchatgrouppreferencesrequestchatgrouppreferences_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetUserChatGroupPreferencesRequestChatRoomPreferences {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	chat_id                        u64
	has_chat_id                    bool
	desktop_notification_level     EChatRoomNotificationLevel
	has_desktop_notification_level bool
	mobile_notification_level      EChatRoomNotificationLevel
	has_mobile_notification_level  bool
	unread_indicator_muted         bool
	has_unread_indicator_muted     bool
}

pub fn (o &CChatRoomSetUserChatGroupPreferencesRequestChatRoomPreferences) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 1)
	}
	if o.has_desktop_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.desktop_notification_level, 2)
	}
	if o.has_mobile_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.mobile_notification_level, 3)
	}
	if o.has_unread_indicator_muted {
		res << vproto.pack_bool_field(o.unread_indicator_muted, 4)
	}
	return res
}

pub fn cchatroomsetuserchatgrouppreferencesrequestchatroompreferences_unpack(buf []byte) ?CChatRoomSetUserChatGroupPreferencesRequestChatRoomPreferences {
	mut res := CChatRoomSetUserChatGroupPreferencesRequestChatRoomPreferences{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_desktop_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.desktop_notification_level = v
				i = ii
			}
			3 {
				res.has_mobile_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.mobile_notification_level = v
				i = ii
			}
			4 {
				res.has_unread_indicator_muted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.unread_indicator_muted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetuserchatgrouppreferencesrequestchatroompreferences() CChatRoomSetUserChatGroupPreferencesRequestChatRoomPreferences {
	return CChatRoomSetUserChatGroupPreferencesRequestChatRoomPreferences{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetuserchatgrouppreferencesrequestchatroompreferences(o CChatRoomSetUserChatGroupPreferencesRequestChatRoomPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetuserchatgrouppreferencesrequestchatroompreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetUserChatGroupPreferencesRequestChatRoomPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetuserchatgrouppreferencesrequestchatroompreferences_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetUserChatGroupPreferencesRequest {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	chat_group_id              u64
	has_chat_group_id          bool
	chat_group_preferences     CChatRoomSetUserChatGroupPreferencesRequestChatGroupPreferences
	has_chat_group_preferences bool
	chat_room_preferences      []CChatRoomSetUserChatGroupPreferencesRequestChatRoomPreferences
}

pub fn (o &CChatRoomSetUserChatGroupPreferencesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_group_preferences {
		res <<
			zzz_vproto_internal_pack_cchatroomsetuserchatgrouppreferencesrequestchatgrouppreferences(o.chat_group_preferences, 2)
	}
	// [packed=false]
	for _, x in o.chat_room_preferences {
		res <<
			zzz_vproto_internal_pack_cchatroomsetuserchatgrouppreferencesrequestchatroompreferences(x, 3)
	}
	return res
}

pub fn cchatroomsetuserchatgrouppreferencesrequest_unpack(buf []byte) ?CChatRoomSetUserChatGroupPreferencesRequest {
	mut res := CChatRoomSetUserChatGroupPreferencesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_group_preferences = true
				ii, v := zzz_vproto_internal_unpack_cchatroomsetuserchatgrouppreferencesrequestchatgrouppreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.chat_group_preferences = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomsetuserchatgrouppreferencesrequestchatroompreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.chat_room_preferences << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetuserchatgrouppreferencesrequest() CChatRoomSetUserChatGroupPreferencesRequest {
	return CChatRoomSetUserChatGroupPreferencesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetuserchatgrouppreferencesrequest(o CChatRoomSetUserChatGroupPreferencesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetuserchatgrouppreferencesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetUserChatGroupPreferencesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetuserchatgrouppreferencesrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSetUserChatGroupPreferencesResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomSetUserChatGroupPreferencesResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomsetuserchatgrouppreferencesresponse_unpack(buf []byte) ?CChatRoomSetUserChatGroupPreferencesResponse {
	res := CChatRoomSetUserChatGroupPreferencesResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsetuserchatgrouppreferencesresponse() CChatRoomSetUserChatGroupPreferencesResponse {
	return CChatRoomSetUserChatGroupPreferencesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsetuserchatgrouppreferencesresponse(o CChatRoomSetUserChatGroupPreferencesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsetuserchatgrouppreferencesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSetUserChatGroupPreferencesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsetuserchatgrouppreferencesresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomDeleteChatMessagesRequestMessage {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	server_timestamp     u32
	has_server_timestamp bool
	ordinal              u32
	has_ordinal          bool
}

pub fn (o &CChatRoomDeleteChatMessagesRequestMessage) pack() []byte {
	mut res := []byte{}
	if o.has_server_timestamp {
		res << vproto.pack_uint32_field(o.server_timestamp, 1)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 2)
	}
	return res
}

pub fn cchatroomdeletechatmessagesrequestmessage_unpack(buf []byte) ?CChatRoomDeleteChatMessagesRequestMessage {
	mut res := CChatRoomDeleteChatMessagesRequestMessage{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_server_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.server_timestamp = v
				i = ii
			}
			2 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomdeletechatmessagesrequestmessage() CChatRoomDeleteChatMessagesRequestMessage {
	return CChatRoomDeleteChatMessagesRequestMessage{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomdeletechatmessagesrequestmessage(o CChatRoomDeleteChatMessagesRequestMessage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomdeletechatmessagesrequestmessage(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomDeleteChatMessagesRequestMessage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomdeletechatmessagesrequestmessage_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomDeleteChatMessagesRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
	messages          []CChatRoomDeleteChatMessagesRequestMessage
}

pub fn (o &CChatRoomDeleteChatMessagesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	// [packed=false]
	for _, x in o.messages {
		res << zzz_vproto_internal_pack_cchatroomdeletechatmessagesrequestmessage(x, 3)
	}
	return res
}

pub fn cchatroomdeletechatmessagesrequest_unpack(buf []byte) ?CChatRoomDeleteChatMessagesRequest {
	mut res := CChatRoomDeleteChatMessagesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomdeletechatmessagesrequestmessage(cur_buf,
					tag_wiretype.wire_type)?
				res.messages << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomdeletechatmessagesrequest() CChatRoomDeleteChatMessagesRequest {
	return CChatRoomDeleteChatMessagesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomdeletechatmessagesrequest(o CChatRoomDeleteChatMessagesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomdeletechatmessagesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomDeleteChatMessagesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomdeletechatmessagesrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomDeleteChatMessagesResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoomDeleteChatMessagesResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroomdeletechatmessagesresponse_unpack(buf []byte) ?CChatRoomDeleteChatMessagesResponse {
	res := CChatRoomDeleteChatMessagesResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomdeletechatmessagesresponse() CChatRoomDeleteChatMessagesResponse {
	return CChatRoomDeleteChatMessagesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomdeletechatmessagesresponse(o CChatRoomDeleteChatMessagesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomdeletechatmessagesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomDeleteChatMessagesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomdeletechatmessagesresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomUpdateMemberListViewNotification {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	chat_group_id                  u64
	has_chat_group_id              bool
	view_id                        u64
	has_view_id                    bool
	start                          int
	has_start                      bool
	end                            int
	has_end                        bool
	client_changenumber            int
	has_client_changenumber        bool
	delete_view                    bool
	has_delete_view                bool
	persona_subscribe_accountids   []int
	persona_unsubscribe_accountids []int
}

pub fn (o &CChatRoomUpdateMemberListViewNotification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_view_id {
		res << vproto.pack_uint64_field(o.view_id, 2)
	}
	if o.has_start {
		res << vproto.pack_int32_field(o.start, 3)
	}
	if o.has_end {
		res << vproto.pack_int32_field(o.end, 4)
	}
	if o.has_client_changenumber {
		res << vproto.pack_int32_field(o.client_changenumber, 5)
	}
	if o.has_delete_view {
		res << vproto.pack_bool_field(o.delete_view, 6)
	}
	// [packed=false]
	for _, x in o.persona_subscribe_accountids {
		res << vproto.pack_int32_field(x, 7)
	}
	// [packed=false]
	for _, x in o.persona_unsubscribe_accountids {
		res << vproto.pack_int32_field(x, 8)
	}
	return res
}

pub fn cchatroomupdatememberlistviewnotification_unpack(buf []byte) ?CChatRoomUpdateMemberListViewNotification {
	mut res := CChatRoomUpdateMemberListViewNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_view_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.view_id = v
				i = ii
			}
			3 {
				res.has_start = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.start = v
				i = ii
			}
			4 {
				res.has_end = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.end = v
				i = ii
			}
			5 {
				res.has_client_changenumber = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_changenumber = v
				i = ii
			}
			6 {
				res.has_delete_view = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.delete_view = v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_subscribe_accountids << v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_unsubscribe_accountids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomupdatememberlistviewnotification() CChatRoomUpdateMemberListViewNotification {
	return CChatRoomUpdateMemberListViewNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomupdatememberlistviewnotification(o CChatRoomUpdateMemberListViewNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomupdatememberlistviewnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomUpdateMemberListViewNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomupdatememberlistviewnotification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSearchMembersRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	search_id         u64
	has_search_id     bool
	search_text       string
	has_search_text   bool
	max_results       int
	has_max_results   bool
}

pub fn (o &CChatRoomSearchMembersRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_search_id {
		res << vproto.pack_uint64_field(o.search_id, 2)
	}
	if o.has_search_text {
		res << vproto.pack_string_field(o.search_text, 3)
	}
	if o.has_max_results {
		res << vproto.pack_int32_field(o.max_results, 4)
	}
	return res
}

pub fn cchatroomsearchmembersrequest_unpack(buf []byte) ?CChatRoomSearchMembersRequest {
	mut res := CChatRoomSearchMembersRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_search_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.search_id = v
				i = ii
			}
			3 {
				res.has_search_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.search_text = v
				i = ii
			}
			4 {
				res.has_max_results = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_results = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsearchmembersrequest() CChatRoomSearchMembersRequest {
	return CChatRoomSearchMembersRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsearchmembersrequest(o CChatRoomSearchMembersRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsearchmembersrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSearchMembersRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsearchmembersrequest_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSearchMembersResponseMemberMatch {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	accountid      int
	has_accountid  bool
	persona        CMsgClientPersonaStateFriend
	has_persona    bool
}

pub fn (o &CChatRoomSearchMembersResponseMemberMatch) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_int32_field(o.accountid, 1)
	}
	if o.has_persona {
		res << zzz_vproto_internal_pack_cmsgclientpersonastatefriend(o.persona, 2)
	}
	return res
}

pub fn cchatroomsearchmembersresponsemembermatch_unpack(buf []byte) ?CChatRoomSearchMembersResponseMemberMatch {
	mut res := CChatRoomSearchMembersResponseMemberMatch{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_persona = true
				ii, v := zzz_vproto_internal_unpack_cmsgclientpersonastatefriend(cur_buf,
					tag_wiretype.wire_type)?
				res.persona = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsearchmembersresponsemembermatch() CChatRoomSearchMembersResponseMemberMatch {
	return CChatRoomSearchMembersResponseMemberMatch{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsearchmembersresponsemembermatch(o CChatRoomSearchMembersResponseMemberMatch, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsearchmembersresponsemembermatch(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSearchMembersResponseMemberMatch) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsearchmembersresponsemembermatch_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSearchMembersResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	matching_members []CChatRoomSearchMembersResponseMemberMatch
	status_flags     u32
	has_status_flags bool
}

pub fn (o &CChatRoomSearchMembersResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.matching_members {
		res << zzz_vproto_internal_pack_cchatroomsearchmembersresponsemembermatch(x, 1)
	}
	if o.has_status_flags {
		res << vproto.pack_uint32_field(o.status_flags, 2)
	}
	return res
}

pub fn cchatroomsearchmembersresponse_unpack(buf []byte) ?CChatRoomSearchMembersResponse {
	mut res := CChatRoomSearchMembersResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomsearchmembersresponsemembermatch(cur_buf,
					tag_wiretype.wire_type)?
				res.matching_members << v
				i = ii
			}
			2 {
				res.has_status_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.status_flags = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsearchmembersresponse() CChatRoomSearchMembersResponse {
	return CChatRoomSearchMembersResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsearchmembersresponse(o CChatRoomSearchMembersResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsearchmembersresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSearchMembersResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsearchmembersresponse_unpack(v)?
	return i, unpacked
}

pub struct CClanChatRoomsGetClanChatRoomInfoRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	autocreate     bool
	has_autocreate bool
}

pub fn (o &CClanChatRoomsGetClanChatRoomInfoRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_autocreate {
		res << vproto.pack_bool_field(o.autocreate, 2)
	}
	return res
}

pub fn cclanchatroomsgetclanchatroominforequest_unpack(buf []byte) ?CClanChatRoomsGetClanChatRoomInfoRequest {
	mut res := CClanChatRoomsGetClanChatRoomInfoRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_autocreate = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.autocreate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclanchatroomsgetclanchatroominforequest() CClanChatRoomsGetClanChatRoomInfoRequest {
	return CClanChatRoomsGetClanChatRoomInfoRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclanchatroomsgetclanchatroominforequest(o CClanChatRoomsGetClanChatRoomInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclanchatroomsgetclanchatroominforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanChatRoomsGetClanChatRoomInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclanchatroomsgetclanchatroominforequest_unpack(v)?
	return i, unpacked
}

pub struct CClanChatRoomsGetClanChatRoomInfoResponse {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	chat_group_summary     CChatRoomGetChatRoomGroupSummaryResponse
	has_chat_group_summary bool
}

pub fn (o &CClanChatRoomsGetClanChatRoomInfoResponse) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_summary {
		res <<
			zzz_vproto_internal_pack_cchatroomgetchatroomgroupsummaryresponse(o.chat_group_summary, 1)
	}
	return res
}

pub fn cclanchatroomsgetclanchatroominforesponse_unpack(buf []byte) ?CClanChatRoomsGetClanChatRoomInfoResponse {
	mut res := CClanChatRoomsGetClanChatRoomInfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_summary = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgetchatroomgroupsummaryresponse(cur_buf,
					tag_wiretype.wire_type)?
				res.chat_group_summary = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclanchatroomsgetclanchatroominforesponse() CClanChatRoomsGetClanChatRoomInfoResponse {
	return CClanChatRoomsGetClanChatRoomInfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclanchatroomsgetclanchatroominforesponse(o CClanChatRoomsGetClanChatRoomInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclanchatroomsgetclanchatroominforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanChatRoomsGetClanChatRoomInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclanchatroomsgetclanchatroominforesponse_unpack(v)?
	return i, unpacked
}

pub struct CClanChatRoomsSetClanChatRoomPrivateRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steamid               u64
	has_steamid           bool
	chat_room_private     bool
	has_chat_room_private bool
}

pub fn (o &CClanChatRoomsSetClanChatRoomPrivateRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_chat_room_private {
		res << vproto.pack_bool_field(o.chat_room_private, 2)
	}
	return res
}

pub fn cclanchatroomssetclanchatroomprivaterequest_unpack(buf []byte) ?CClanChatRoomsSetClanChatRoomPrivateRequest {
	mut res := CClanChatRoomsSetClanChatRoomPrivateRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_chat_room_private = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_room_private = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclanchatroomssetclanchatroomprivaterequest() CClanChatRoomsSetClanChatRoomPrivateRequest {
	return CClanChatRoomsSetClanChatRoomPrivateRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclanchatroomssetclanchatroomprivaterequest(o CClanChatRoomsSetClanChatRoomPrivateRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclanchatroomssetclanchatroomprivaterequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanChatRoomsSetClanChatRoomPrivateRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclanchatroomssetclanchatroomprivaterequest_unpack(v)?
	return i, unpacked
}

pub struct CClanChatRoomsSetClanChatRoomPrivateResponse {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	chat_room_private     bool
	has_chat_room_private bool
}

pub fn (o &CClanChatRoomsSetClanChatRoomPrivateResponse) pack() []byte {
	mut res := []byte{}
	if o.has_chat_room_private {
		res << vproto.pack_bool_field(o.chat_room_private, 1)
	}
	return res
}

pub fn cclanchatroomssetclanchatroomprivateresponse_unpack(buf []byte) ?CClanChatRoomsSetClanChatRoomPrivateResponse {
	mut res := CClanChatRoomsSetClanChatRoomPrivateResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_room_private = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_room_private = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclanchatroomssetclanchatroomprivateresponse() CClanChatRoomsSetClanChatRoomPrivateResponse {
	return CClanChatRoomsSetClanChatRoomPrivateResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclanchatroomssetclanchatroomprivateresponse(o CClanChatRoomsSetClanChatRoomPrivateResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclanchatroomssetclanchatroomprivateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanChatRoomsSetClanChatRoomPrivateResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclanchatroomssetclanchatroomprivateresponse_unpack(v)?
	return i, unpacked
}

pub struct CChatMentions {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	mention_all        bool
	has_mention_all    bool
	mention_here       bool
	has_mention_here   bool
	mention_accountids []u32
}

pub fn (o &CChatMentions) pack() []byte {
	mut res := []byte{}
	if o.has_mention_all {
		res << vproto.pack_bool_field(o.mention_all, 1)
	}
	if o.has_mention_here {
		res << vproto.pack_bool_field(o.mention_here, 2)
	}
	// [packed=false]
	for _, x in o.mention_accountids {
		res << vproto.pack_uint32_field(x, 3)
	}
	return res
}

pub fn cchatmentions_unpack(buf []byte) ?CChatMentions {
	mut res := CChatMentions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_mention_all = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.mention_all = v
				i = ii
			}
			2 {
				res.has_mention_here = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.mention_here = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.mention_accountids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatmentions() CChatMentions {
	return CChatMentions{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatmentions(o CChatMentions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatmentions(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatMentions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatmentions_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomIncomingChatMessageNotification {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	chat_group_id         u64
	has_chat_group_id     bool
	chat_id               u64
	has_chat_id           bool
	steamid_sender        u64
	has_steamid_sender    bool
	message               string
	has_message           bool
	timestamp             u32
	has_timestamp         bool
	mentions              CChatMentions
	has_mentions          bool
	ordinal               u32
	has_ordinal           bool
	server_message        ServerMessage
	has_server_message    bool
	message_no_bbcode     string
	has_message_no_bbcode bool
	chat_name             string
	has_chat_name         bool
}

pub fn (o &CChatRoomIncomingChatMessageNotification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_steamid_sender {
		res << vproto.pack_64bit_field(o.steamid_sender, 3)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 4)
	}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 5)
	}
	if o.has_mentions {
		res << zzz_vproto_internal_pack_cchatmentions(o.mentions, 6)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 7)
	}
	if o.has_server_message {
		res << zzz_vproto_internal_pack_servermessage(o.server_message, 8)
	}
	if o.has_message_no_bbcode {
		res << vproto.pack_string_field(o.message_no_bbcode, 9)
	}
	if o.has_chat_name {
		res << vproto.pack_string_field(o.chat_name, 10)
	}
	return res
}

pub fn cchatroomincomingchatmessagenotification_unpack(buf []byte) ?CChatRoomIncomingChatMessageNotification {
	mut res := CChatRoomIncomingChatMessageNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_steamid_sender = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_sender = v
				i = ii
			}
			4 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			5 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			6 {
				res.has_mentions = true
				ii, v := zzz_vproto_internal_unpack_cchatmentions(cur_buf, tag_wiretype.wire_type)?
				res.mentions = v
				i = ii
			}
			7 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			8 {
				res.has_server_message = true
				ii, v := zzz_vproto_internal_unpack_servermessage(cur_buf, tag_wiretype.wire_type)?
				res.server_message = v
				i = ii
			}
			9 {
				res.has_message_no_bbcode = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message_no_bbcode = v
				i = ii
			}
			10 {
				res.has_chat_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomincomingchatmessagenotification() CChatRoomIncomingChatMessageNotification {
	return CChatRoomIncomingChatMessageNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomincomingchatmessagenotification(o CChatRoomIncomingChatMessageNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomincomingchatmessagenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomIncomingChatMessageNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomincomingchatmessagenotification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomChatMessageModifiedNotificationChatMessage {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	server_timestamp     u32
	has_server_timestamp bool
	ordinal              u32
	has_ordinal          bool
	deleted              bool
	has_deleted          bool
}

pub fn (o &CChatRoomChatMessageModifiedNotificationChatMessage) pack() []byte {
	mut res := []byte{}
	if o.has_server_timestamp {
		res << vproto.pack_uint32_field(o.server_timestamp, 1)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 2)
	}
	if o.has_deleted {
		res << vproto.pack_bool_field(o.deleted, 3)
	}
	return res
}

pub fn cchatroomchatmessagemodifiednotificationchatmessage_unpack(buf []byte) ?CChatRoomChatMessageModifiedNotificationChatMessage {
	mut res := CChatRoomChatMessageModifiedNotificationChatMessage{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_server_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.server_timestamp = v
				i = ii
			}
			2 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			3 {
				res.has_deleted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.deleted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomchatmessagemodifiednotificationchatmessage() CChatRoomChatMessageModifiedNotificationChatMessage {
	return CChatRoomChatMessageModifiedNotificationChatMessage{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomchatmessagemodifiednotificationchatmessage(o CChatRoomChatMessageModifiedNotificationChatMessage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomchatmessagemodifiednotificationchatmessage(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomChatMessageModifiedNotificationChatMessage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomchatmessagemodifiednotificationchatmessage_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomChatMessageModifiedNotification {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
	messages          []CChatRoomChatMessageModifiedNotificationChatMessage
}

pub fn (o &CChatRoomChatMessageModifiedNotification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	// [packed=false]
	for _, x in o.messages {
		res << zzz_vproto_internal_pack_cchatroomchatmessagemodifiednotificationchatmessage(x, 3)
	}
	return res
}

pub fn cchatroomchatmessagemodifiednotification_unpack(buf []byte) ?CChatRoomChatMessageModifiedNotification {
	mut res := CChatRoomChatMessageModifiedNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomchatmessagemodifiednotificationchatmessage(cur_buf,
					tag_wiretype.wire_type)?
				res.messages << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomchatmessagemodifiednotification() CChatRoomChatMessageModifiedNotification {
	return CChatRoomChatMessageModifiedNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomchatmessagemodifiednotification(o CChatRoomChatMessageModifiedNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomchatmessagemodifiednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomChatMessageModifiedNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomchatmessagemodifiednotification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomMemberStateChangeNotification {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	member            CChatRoomMember
	has_member        bool
	change            EChatRoomMemberStateChange
	has_change        bool
}

pub fn (o &CChatRoomMemberStateChangeNotification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_member {
		res << zzz_vproto_internal_pack_cchatroommember(o.member, 2)
	}
	if o.has_change {
		res << zzz_vproto_internal_pack_echatroommemberstatechange(o.change, 3)
	}
	return res
}

pub fn cchatroommemberstatechangenotification_unpack(buf []byte) ?CChatRoomMemberStateChangeNotification {
	mut res := CChatRoomMemberStateChangeNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_member = true
				ii, v := zzz_vproto_internal_unpack_cchatroommember(cur_buf, tag_wiretype.wire_type)?
				res.member = v
				i = ii
			}
			3 {
				res.has_change = true
				ii, v := zzz_vproto_internal_unpack_echatroommemberstatechange(cur_buf,
					tag_wiretype.wire_type)?
				res.change = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroommemberstatechangenotification() CChatRoomMemberStateChangeNotification {
	return CChatRoomMemberStateChangeNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroommemberstatechangenotification(o CChatRoomMemberStateChangeNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroommemberstatechangenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomMemberStateChangeNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroommemberstatechangenotification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomChatRoomHeaderStateNotification {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	header_state     CChatRoomGroupHeaderState
	has_header_state bool
}

pub fn (o &CChatRoomChatRoomHeaderStateNotification) pack() []byte {
	mut res := []byte{}
	if o.has_header_state {
		res << zzz_vproto_internal_pack_cchatroomgroupheaderstate(o.header_state, 1)
	}
	return res
}

pub fn cchatroomchatroomheaderstatenotification_unpack(buf []byte) ?CChatRoomChatRoomHeaderStateNotification {
	mut res := CChatRoomChatRoomHeaderStateNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_header_state = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupheaderstate(cur_buf,
					tag_wiretype.wire_type)?
				res.header_state = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomchatroomheaderstatenotification() CChatRoomChatRoomHeaderStateNotification {
	return CChatRoomChatRoomHeaderStateNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomchatroomheaderstatenotification(o CChatRoomChatRoomHeaderStateNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomchatroomheaderstatenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomChatRoomHeaderStateNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomchatroomheaderstatenotification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomChatRoomGroupRoomsChangeNotification {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	chat_group_id       u64
	has_chat_group_id   bool
	default_chat_id     u64
	has_default_chat_id bool
	chat_rooms          []CChatRoomState
}

pub fn (o &CChatRoomChatRoomGroupRoomsChangeNotification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_default_chat_id {
		res << vproto.pack_uint64_field(o.default_chat_id, 2)
	}
	// [packed=false]
	for _, x in o.chat_rooms {
		res << zzz_vproto_internal_pack_cchatroomstate(x, 3)
	}
	return res
}

pub fn cchatroomchatroomgrouproomschangenotification_unpack(buf []byte) ?CChatRoomChatRoomGroupRoomsChangeNotification {
	mut res := CChatRoomChatRoomGroupRoomsChangeNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_default_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.default_chat_id = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomstate(cur_buf, tag_wiretype.wire_type)?
				res.chat_rooms << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomchatroomgrouproomschangenotification() CChatRoomChatRoomGroupRoomsChangeNotification {
	return CChatRoomChatRoomGroupRoomsChangeNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomchatroomgrouproomschangenotification(o CChatRoomChatRoomGroupRoomsChangeNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomchatroomgrouproomschangenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomChatRoomGroupRoomsChangeNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomchatroomgrouproomschangenotification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomNotifyShouldRejoinChatRoomVoiceChatNotification {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_id           u64
	has_chat_id       bool
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoomNotifyShouldRejoinChatRoomVoiceChatNotification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 1)
	}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 2)
	}
	return res
}

pub fn cchatroomnotifyshouldrejoinchatroomvoicechatnotification_unpack(buf []byte) ?CChatRoomNotifyShouldRejoinChatRoomVoiceChatNotification {
	mut res := CChatRoomNotifyShouldRejoinChatRoomVoiceChatNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomnotifyshouldrejoinchatroomvoicechatnotification() CChatRoomNotifyShouldRejoinChatRoomVoiceChatNotification {
	return CChatRoomNotifyShouldRejoinChatRoomVoiceChatNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomnotifyshouldrejoinchatroomvoicechatnotification(o CChatRoomNotifyShouldRejoinChatRoomVoiceChatNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomnotifyshouldrejoinchatroomvoicechatnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomNotifyShouldRejoinChatRoomVoiceChatNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomnotifyshouldrejoinchatroomvoicechatnotification_unpack(v)?
	return i, unpacked
}

pub struct ChatRoomClientNotifyChatGroupUserStateChangedNotification {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	chat_group_id             u64
	has_chat_group_id         bool
	user_chat_group_state     CUserChatRoomGroupState
	has_user_chat_group_state bool
	group_summary             CChatRoomGetChatRoomGroupSummaryResponse
	has_group_summary         bool
	user_action               EChatRoomMemberStateChange
	has_user_action           bool
}

pub fn (o &ChatRoomClientNotifyChatGroupUserStateChangedNotification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_user_chat_group_state {
		res << zzz_vproto_internal_pack_cuserchatroomgroupstate(o.user_chat_group_state, 2)
	}
	if o.has_group_summary {
		res <<
			zzz_vproto_internal_pack_cchatroomgetchatroomgroupsummaryresponse(o.group_summary, 3)
	}
	if o.has_user_action {
		res << zzz_vproto_internal_pack_echatroommemberstatechange(o.user_action, 4)
	}
	return res
}

pub fn chatroomclientnotifychatgroupuserstatechangednotification_unpack(buf []byte) ?ChatRoomClientNotifyChatGroupUserStateChangedNotification {
	mut res := ChatRoomClientNotifyChatGroupUserStateChangedNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_user_chat_group_state = true
				ii, v := zzz_vproto_internal_unpack_cuserchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.user_chat_group_state = v
				i = ii
			}
			3 {
				res.has_group_summary = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgetchatroomgroupsummaryresponse(cur_buf,
					tag_wiretype.wire_type)?
				res.group_summary = v
				i = ii
			}
			4 {
				res.has_user_action = true
				ii, v := zzz_vproto_internal_unpack_echatroommemberstatechange(cur_buf,
					tag_wiretype.wire_type)?
				res.user_action = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chatroomclientnotifychatgroupuserstatechangednotification() ChatRoomClientNotifyChatGroupUserStateChangedNotification {
	return ChatRoomClientNotifyChatGroupUserStateChangedNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chatroomclientnotifychatgroupuserstatechangednotification(o ChatRoomClientNotifyChatGroupUserStateChangedNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chatroomclientnotifychatgroupuserstatechangednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, ChatRoomClientNotifyChatGroupUserStateChangedNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chatroomclientnotifychatgroupuserstatechangednotification_unpack(v)?
	return i, unpacked
}

pub struct ChatRoomClientNotifyChatRoomDisconnectNotification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	chat_group_ids []u64
}

pub fn (o &ChatRoomClientNotifyChatRoomDisconnectNotification) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.chat_group_ids {
		res << vproto.pack_uint64_field(x, 1)
	}
	return res
}

pub fn chatroomclientnotifychatroomdisconnectnotification_unpack(buf []byte) ?ChatRoomClientNotifyChatRoomDisconnectNotification {
	mut res := ChatRoomClientNotifyChatRoomDisconnectNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chatroomclientnotifychatroomdisconnectnotification() ChatRoomClientNotifyChatRoomDisconnectNotification {
	return ChatRoomClientNotifyChatRoomDisconnectNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chatroomclientnotifychatroomdisconnectnotification(o ChatRoomClientNotifyChatRoomDisconnectNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chatroomclientnotifychatroomdisconnectnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, ChatRoomClientNotifyChatRoomDisconnectNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chatroomclientnotifychatroomdisconnectnotification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomMemberListView {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	start                   int
	has_start               bool
	end                     int
	has_end                 bool
	total_count             int
	has_total_count         bool
	client_changenumber     int
	has_client_changenumber bool
	server_changenumber     int
	has_server_changenumber bool
}

pub fn (o &CChatRoomMemberListView) pack() []byte {
	mut res := []byte{}
	if o.has_start {
		res << vproto.pack_int32_field(o.start, 3)
	}
	if o.has_end {
		res << vproto.pack_int32_field(o.end, 4)
	}
	if o.has_total_count {
		res << vproto.pack_int32_field(o.total_count, 5)
	}
	if o.has_client_changenumber {
		res << vproto.pack_int32_field(o.client_changenumber, 6)
	}
	if o.has_server_changenumber {
		res << vproto.pack_int32_field(o.server_changenumber, 7)
	}
	return res
}

pub fn cchatroommemberlistview_unpack(buf []byte) ?CChatRoomMemberListView {
	mut res := CChatRoomMemberListView{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			3 {
				res.has_start = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.start = v
				i = ii
			}
			4 {
				res.has_end = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.end = v
				i = ii
			}
			5 {
				res.has_total_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_count = v
				i = ii
			}
			6 {
				res.has_client_changenumber = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_changenumber = v
				i = ii
			}
			7 {
				res.has_server_changenumber = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.server_changenumber = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroommemberlistview() CChatRoomMemberListView {
	return CChatRoomMemberListView{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroommemberlistview(o CChatRoomMemberListView, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroommemberlistview(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomMemberListView) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroommemberlistview_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomMemberSummaryCounts {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ingame         int
	has_ingame     bool
	online         int
	has_online     bool
	offline        int
	has_offline    bool
}

pub fn (o &CChatRoomMemberSummaryCounts) pack() []byte {
	mut res := []byte{}
	if o.has_ingame {
		res << vproto.pack_int32_field(o.ingame, 1)
	}
	if o.has_online {
		res << vproto.pack_int32_field(o.online, 2)
	}
	if o.has_offline {
		res << vproto.pack_int32_field(o.offline, 3)
	}
	return res
}

pub fn cchatroommembersummarycounts_unpack(buf []byte) ?CChatRoomMemberSummaryCounts {
	mut res := CChatRoomMemberSummaryCounts{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ingame = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ingame = v
				i = ii
			}
			2 {
				res.has_online = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.online = v
				i = ii
			}
			3 {
				res.has_offline = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.offline = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroommembersummarycounts() CChatRoomMemberSummaryCounts {
	return CChatRoomMemberSummaryCounts{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroommembersummarycounts(o CChatRoomMemberSummaryCounts, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroommembersummarycounts(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomMemberSummaryCounts) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroommembersummarycounts_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomClientMemberListViewUpdatedNotificationMemberListViewEntry {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	rank           int
	has_rank       bool
	accountid      u32
	has_accountid  bool
	persona        CMsgClientPersonaStateFriend
	has_persona    bool
}

pub fn (o &CChatRoomClientMemberListViewUpdatedNotificationMemberListViewEntry) pack() []byte {
	mut res := []byte{}
	if o.has_rank {
		res << vproto.pack_int32_field(o.rank, 1)
	}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 2)
	}
	if o.has_persona {
		res << zzz_vproto_internal_pack_cmsgclientpersonastatefriend(o.persona, 3)
	}
	return res
}

pub fn cchatroomclientmemberlistviewupdatednotificationmemberlistviewentry_unpack(buf []byte) ?CChatRoomClientMemberListViewUpdatedNotificationMemberListViewEntry {
	mut res := CChatRoomClientMemberListViewUpdatedNotificationMemberListViewEntry{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_rank = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.rank = v
				i = ii
			}
			2 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			3 {
				res.has_persona = true
				ii, v := zzz_vproto_internal_unpack_cmsgclientpersonastatefriend(cur_buf,
					tag_wiretype.wire_type)?
				res.persona = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomclientmemberlistviewupdatednotificationmemberlistviewentry() CChatRoomClientMemberListViewUpdatedNotificationMemberListViewEntry {
	return CChatRoomClientMemberListViewUpdatedNotificationMemberListViewEntry{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomclientmemberlistviewupdatednotificationmemberlistviewentry(o CChatRoomClientMemberListViewUpdatedNotificationMemberListViewEntry, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomclientmemberlistviewupdatednotificationmemberlistviewentry(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomClientMemberListViewUpdatedNotificationMemberListViewEntry) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomclientmemberlistviewupdatednotificationmemberlistviewentry_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomClientMemberListViewUpdatedNotification {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	chat_group_id       u64
	has_chat_group_id   bool
	view_id             u64
	has_view_id         bool
	view                CChatRoomMemberListView
	has_view            bool
	members             []CChatRoomClientMemberListViewUpdatedNotificationMemberListViewEntry
	status_flags        u32
	has_status_flags    bool
	member_summary      CChatRoomMemberSummaryCounts
	has_member_summary  bool
	subscribed_personas []CMsgClientPersonaStateFriend
}

pub fn (o &CChatRoomClientMemberListViewUpdatedNotification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_view_id {
		res << vproto.pack_uint64_field(o.view_id, 2)
	}
	if o.has_view {
		res << zzz_vproto_internal_pack_cchatroommemberlistview(o.view, 3)
	}
	// [packed=false]
	for _, x in o.members {
		res <<
			zzz_vproto_internal_pack_cchatroomclientmemberlistviewupdatednotificationmemberlistviewentry(x, 4)
	}
	if o.has_status_flags {
		res << vproto.pack_uint32_field(o.status_flags, 5)
	}
	if o.has_member_summary {
		res << zzz_vproto_internal_pack_cchatroommembersummarycounts(o.member_summary, 6)
	}
	// [packed=false]
	for _, x in o.subscribed_personas {
		res << zzz_vproto_internal_pack_cmsgclientpersonastatefriend(x, 7)
	}
	return res
}

pub fn cchatroomclientmemberlistviewupdatednotification_unpack(buf []byte) ?CChatRoomClientMemberListViewUpdatedNotification {
	mut res := CChatRoomClientMemberListViewUpdatedNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_view_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.view_id = v
				i = ii
			}
			3 {
				res.has_view = true
				ii, v := zzz_vproto_internal_unpack_cchatroommemberlistview(cur_buf, tag_wiretype.wire_type)?
				res.view = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomclientmemberlistviewupdatednotificationmemberlistviewentry(cur_buf,
					tag_wiretype.wire_type)?
				res.members << v
				i = ii
			}
			5 {
				res.has_status_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.status_flags = v
				i = ii
			}
			6 {
				res.has_member_summary = true
				ii, v := zzz_vproto_internal_unpack_cchatroommembersummarycounts(cur_buf,
					tag_wiretype.wire_type)?
				res.member_summary = v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpersonastatefriend(cur_buf,
					tag_wiretype.wire_type)?
				res.subscribed_personas << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomclientmemberlistviewupdatednotification() CChatRoomClientMemberListViewUpdatedNotification {
	return CChatRoomClientMemberListViewUpdatedNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomclientmemberlistviewupdatednotification(o CChatRoomClientMemberListViewUpdatedNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomclientmemberlistviewupdatednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomClientMemberListViewUpdatedNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomclientmemberlistviewupdatednotification_unpack(v)?
	return i, unpacked
}

pub struct CChatUsabilityClientUsabilityMetricsNotificationSettings {
mut:
	unknown_fields                                []vproto.UnknownField
pub mut:
	notifications_show_ingame                     bool
	has_notifications_show_ingame                 bool
	notifications_show_online                     bool
	has_notifications_show_online                 bool
	notifications_show_message                    bool
	has_notifications_show_message                bool
	notifications_events_and_announcements        bool
	has_notifications_events_and_announcements    bool
	sounds_play_ingame                            bool
	has_sounds_play_ingame                        bool
	sounds_play_online                            bool
	has_sounds_play_online                        bool
	sounds_play_message                           bool
	has_sounds_play_message                       bool
	sounds_events_and_announcements               bool
	has_sounds_events_and_announcements           bool
	always_new_chat_window                        bool
	has_always_new_chat_window                    bool
	force_alphabetic_friend_sorting               bool
	has_force_alphabetic_friend_sorting           bool
	chat_flash_mode                               int
	has_chat_flash_mode                           bool
	remember_open_chats                           bool
	has_remember_open_chats                       bool
	compact_quick_access                          bool
	has_compact_quick_access                      bool
	compact_friends_list                          bool
	has_compact_friends_list                      bool
	notifications_show_chat_room_notification     bool
	has_notifications_show_chat_room_notification bool
	sounds_play_chat_room_notification            bool
	has_sounds_play_chat_room_notification        bool
	hide_offline_friends_in_tag_groups            bool
	has_hide_offline_friends_in_tag_groups        bool
	hide_categorized_friends                      bool
	has_hide_categorized_friends                  bool
	categorize_in_game_friends_by_game            bool
	has_categorize_in_game_friends_by_game        bool
	chat_font_size                                int
	has_chat_font_size                            bool
	use24hour_clock                               bool
	has_use24hour_clock                           bool
	do_not_disturb_mode                           bool
	has_do_not_disturb_mode                       bool
	disable_embed_inlining                        bool
	has_disable_embed_inlining                    bool
	sign_into_friends                             bool
	has_sign_into_friends                         bool
	animated_avatars                              bool
	has_animated_avatars                          bool
}

pub fn (o &CChatUsabilityClientUsabilityMetricsNotificationSettings) pack() []byte {
	mut res := []byte{}
	if o.has_notifications_show_ingame {
		res << vproto.pack_bool_field(o.notifications_show_ingame, 1)
	}
	if o.has_notifications_show_online {
		res << vproto.pack_bool_field(o.notifications_show_online, 2)
	}
	if o.has_notifications_show_message {
		res << vproto.pack_bool_field(o.notifications_show_message, 3)
	}
	if o.has_notifications_events_and_announcements {
		res << vproto.pack_bool_field(o.notifications_events_and_announcements, 4)
	}
	if o.has_sounds_play_ingame {
		res << vproto.pack_bool_field(o.sounds_play_ingame, 5)
	}
	if o.has_sounds_play_online {
		res << vproto.pack_bool_field(o.sounds_play_online, 6)
	}
	if o.has_sounds_play_message {
		res << vproto.pack_bool_field(o.sounds_play_message, 7)
	}
	if o.has_sounds_events_and_announcements {
		res << vproto.pack_bool_field(o.sounds_events_and_announcements, 8)
	}
	if o.has_always_new_chat_window {
		res << vproto.pack_bool_field(o.always_new_chat_window, 9)
	}
	if o.has_force_alphabetic_friend_sorting {
		res << vproto.pack_bool_field(o.force_alphabetic_friend_sorting, 10)
	}
	if o.has_chat_flash_mode {
		res << vproto.pack_int32_field(o.chat_flash_mode, 11)
	}
	if o.has_remember_open_chats {
		res << vproto.pack_bool_field(o.remember_open_chats, 12)
	}
	if o.has_compact_quick_access {
		res << vproto.pack_bool_field(o.compact_quick_access, 13)
	}
	if o.has_compact_friends_list {
		res << vproto.pack_bool_field(o.compact_friends_list, 14)
	}
	if o.has_notifications_show_chat_room_notification {
		res << vproto.pack_bool_field(o.notifications_show_chat_room_notification, 15)
	}
	if o.has_sounds_play_chat_room_notification {
		res << vproto.pack_bool_field(o.sounds_play_chat_room_notification, 16)
	}
	if o.has_hide_offline_friends_in_tag_groups {
		res << vproto.pack_bool_field(o.hide_offline_friends_in_tag_groups, 17)
	}
	if o.has_hide_categorized_friends {
		res << vproto.pack_bool_field(o.hide_categorized_friends, 18)
	}
	if o.has_categorize_in_game_friends_by_game {
		res << vproto.pack_bool_field(o.categorize_in_game_friends_by_game, 19)
	}
	if o.has_chat_font_size {
		res << vproto.pack_int32_field(o.chat_font_size, 20)
	}
	if o.has_use24hour_clock {
		res << vproto.pack_bool_field(o.use24hour_clock, 21)
	}
	if o.has_do_not_disturb_mode {
		res << vproto.pack_bool_field(o.do_not_disturb_mode, 22)
	}
	if o.has_disable_embed_inlining {
		res << vproto.pack_bool_field(o.disable_embed_inlining, 23)
	}
	if o.has_sign_into_friends {
		res << vproto.pack_bool_field(o.sign_into_friends, 24)
	}
	if o.has_animated_avatars {
		res << vproto.pack_bool_field(o.animated_avatars, 25)
	}
	return res
}

pub fn cchatusabilityclientusabilitymetricsnotificationsettings_unpack(buf []byte) ?CChatUsabilityClientUsabilityMetricsNotificationSettings {
	mut res := CChatUsabilityClientUsabilityMetricsNotificationSettings{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_notifications_show_ingame = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notifications_show_ingame = v
				i = ii
			}
			2 {
				res.has_notifications_show_online = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notifications_show_online = v
				i = ii
			}
			3 {
				res.has_notifications_show_message = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notifications_show_message = v
				i = ii
			}
			4 {
				res.has_notifications_events_and_announcements = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notifications_events_and_announcements = v
				i = ii
			}
			5 {
				res.has_sounds_play_ingame = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.sounds_play_ingame = v
				i = ii
			}
			6 {
				res.has_sounds_play_online = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.sounds_play_online = v
				i = ii
			}
			7 {
				res.has_sounds_play_message = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.sounds_play_message = v
				i = ii
			}
			8 {
				res.has_sounds_events_and_announcements = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.sounds_events_and_announcements = v
				i = ii
			}
			9 {
				res.has_always_new_chat_window = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.always_new_chat_window = v
				i = ii
			}
			10 {
				res.has_force_alphabetic_friend_sorting = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.force_alphabetic_friend_sorting = v
				i = ii
			}
			11 {
				res.has_chat_flash_mode = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_flash_mode = v
				i = ii
			}
			12 {
				res.has_remember_open_chats = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.remember_open_chats = v
				i = ii
			}
			13 {
				res.has_compact_quick_access = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.compact_quick_access = v
				i = ii
			}
			14 {
				res.has_compact_friends_list = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.compact_friends_list = v
				i = ii
			}
			15 {
				res.has_notifications_show_chat_room_notification = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notifications_show_chat_room_notification = v
				i = ii
			}
			16 {
				res.has_sounds_play_chat_room_notification = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.sounds_play_chat_room_notification = v
				i = ii
			}
			17 {
				res.has_hide_offline_friends_in_tag_groups = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_offline_friends_in_tag_groups = v
				i = ii
			}
			18 {
				res.has_hide_categorized_friends = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_categorized_friends = v
				i = ii
			}
			19 {
				res.has_categorize_in_game_friends_by_game = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.categorize_in_game_friends_by_game = v
				i = ii
			}
			20 {
				res.has_chat_font_size = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_font_size = v
				i = ii
			}
			21 {
				res.has_use24hour_clock = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use24hour_clock = v
				i = ii
			}
			22 {
				res.has_do_not_disturb_mode = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.do_not_disturb_mode = v
				i = ii
			}
			23 {
				res.has_disable_embed_inlining = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.disable_embed_inlining = v
				i = ii
			}
			24 {
				res.has_sign_into_friends = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.sign_into_friends = v
				i = ii
			}
			25 {
				res.has_animated_avatars = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.animated_avatars = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusabilityclientusabilitymetricsnotificationsettings() CChatUsabilityClientUsabilityMetricsNotificationSettings {
	return CChatUsabilityClientUsabilityMetricsNotificationSettings{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusabilityclientusabilitymetricsnotificationsettings(o CChatUsabilityClientUsabilityMetricsNotificationSettings, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusabilityclientusabilitymetricsnotificationsettings(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsabilityClientUsabilityMetricsNotificationSettings) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusabilityclientusabilitymetricsnotificationsettings_unpack(v)?
	return i, unpacked
}

pub struct CChatUsabilityClientUsabilityMetricsNotificationVoiceSettings {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	voice_input_gain                 f32
	has_voice_input_gain             bool
	voice_output_gain                f32
	has_voice_output_gain            bool
	noise_gate_level                 int
	has_noise_gate_level             bool
	voice_use_echo_cancellation      bool
	has_voice_use_echo_cancellation  bool
	voice_use_noise_cancellation     bool
	has_voice_use_noise_cancellation bool
	voice_use_auto_gain_control      bool
	has_voice_use_auto_gain_control  bool
	selected_non_default_mic         bool
	has_selected_non_default_mic     bool
	selected_non_default_output      bool
	has_selected_non_default_output  bool
	push_to_talk_enabled             bool
	has_push_to_talk_enabled         bool
	push_to_mute_enabled             bool
	has_push_to_mute_enabled         bool
	play_ptt_sounds                  bool
	has_play_ptt_sounds              bool
}

pub fn (o &CChatUsabilityClientUsabilityMetricsNotificationVoiceSettings) pack() []byte {
	mut res := []byte{}
	if o.has_voice_input_gain {
		res << vproto.pack_float_field(o.voice_input_gain, 1)
	}
	if o.has_voice_output_gain {
		res << vproto.pack_float_field(o.voice_output_gain, 2)
	}
	if o.has_noise_gate_level {
		res << vproto.pack_int32_field(o.noise_gate_level, 3)
	}
	if o.has_voice_use_echo_cancellation {
		res << vproto.pack_bool_field(o.voice_use_echo_cancellation, 4)
	}
	if o.has_voice_use_noise_cancellation {
		res << vproto.pack_bool_field(o.voice_use_noise_cancellation, 5)
	}
	if o.has_voice_use_auto_gain_control {
		res << vproto.pack_bool_field(o.voice_use_auto_gain_control, 6)
	}
	if o.has_selected_non_default_mic {
		res << vproto.pack_bool_field(o.selected_non_default_mic, 7)
	}
	if o.has_selected_non_default_output {
		res << vproto.pack_bool_field(o.selected_non_default_output, 8)
	}
	if o.has_push_to_talk_enabled {
		res << vproto.pack_bool_field(o.push_to_talk_enabled, 9)
	}
	if o.has_push_to_mute_enabled {
		res << vproto.pack_bool_field(o.push_to_mute_enabled, 10)
	}
	if o.has_play_ptt_sounds {
		res << vproto.pack_bool_field(o.play_ptt_sounds, 11)
	}
	return res
}

pub fn cchatusabilityclientusabilitymetricsnotificationvoicesettings_unpack(buf []byte) ?CChatUsabilityClientUsabilityMetricsNotificationVoiceSettings {
	mut res := CChatUsabilityClientUsabilityMetricsNotificationVoiceSettings{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_voice_input_gain = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_input_gain = v
				i = ii
			}
			2 {
				res.has_voice_output_gain = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_output_gain = v
				i = ii
			}
			3 {
				res.has_noise_gate_level = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.noise_gate_level = v
				i = ii
			}
			4 {
				res.has_voice_use_echo_cancellation = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_use_echo_cancellation = v
				i = ii
			}
			5 {
				res.has_voice_use_noise_cancellation = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_use_noise_cancellation = v
				i = ii
			}
			6 {
				res.has_voice_use_auto_gain_control = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_use_auto_gain_control = v
				i = ii
			}
			7 {
				res.has_selected_non_default_mic = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.selected_non_default_mic = v
				i = ii
			}
			8 {
				res.has_selected_non_default_output = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.selected_non_default_output = v
				i = ii
			}
			9 {
				res.has_push_to_talk_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.push_to_talk_enabled = v
				i = ii
			}
			10 {
				res.has_push_to_mute_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.push_to_mute_enabled = v
				i = ii
			}
			11 {
				res.has_play_ptt_sounds = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.play_ptt_sounds = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusabilityclientusabilitymetricsnotificationvoicesettings() CChatUsabilityClientUsabilityMetricsNotificationVoiceSettings {
	return CChatUsabilityClientUsabilityMetricsNotificationVoiceSettings{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusabilityclientusabilitymetricsnotificationvoicesettings(o CChatUsabilityClientUsabilityMetricsNotificationVoiceSettings, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusabilityclientusabilitymetricsnotificationvoicesettings(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsabilityClientUsabilityMetricsNotificationVoiceSettings) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusabilityclientusabilitymetricsnotificationvoicesettings_unpack(v)?
	return i, unpacked
}

pub struct CChatUsabilityClientUsabilityMetricsNotificationUIstateCategoryCollapseState {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	in_game_collapsed         bool
	has_in_game_collapsed     bool
	online_collapsed          bool
	has_online_collapsed      bool
	offline_collapsed         bool
	has_offline_collapsed     bool
	game_groups_collapsed     int
	has_game_groups_collapsed bool
	categories_collapsed      int
	has_categories_collapsed  bool
}

pub fn (o &CChatUsabilityClientUsabilityMetricsNotificationUIstateCategoryCollapseState) pack() []byte {
	mut res := []byte{}
	if o.has_in_game_collapsed {
		res << vproto.pack_bool_field(o.in_game_collapsed, 1)
	}
	if o.has_online_collapsed {
		res << vproto.pack_bool_field(o.online_collapsed, 2)
	}
	if o.has_offline_collapsed {
		res << vproto.pack_bool_field(o.offline_collapsed, 3)
	}
	if o.has_game_groups_collapsed {
		res << vproto.pack_int32_field(o.game_groups_collapsed, 4)
	}
	if o.has_categories_collapsed {
		res << vproto.pack_int32_field(o.categories_collapsed, 5)
	}
	return res
}

pub fn cchatusabilityclientusabilitymetricsnotificationuistatecategorycollapsestate_unpack(buf []byte) ?CChatUsabilityClientUsabilityMetricsNotificationUIstateCategoryCollapseState {
	mut res := CChatUsabilityClientUsabilityMetricsNotificationUIstateCategoryCollapseState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_in_game_collapsed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.in_game_collapsed = v
				i = ii
			}
			2 {
				res.has_online_collapsed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.online_collapsed = v
				i = ii
			}
			3 {
				res.has_offline_collapsed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.offline_collapsed = v
				i = ii
			}
			4 {
				res.has_game_groups_collapsed = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_groups_collapsed = v
				i = ii
			}
			5 {
				res.has_categories_collapsed = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.categories_collapsed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusabilityclientusabilitymetricsnotificationuistatecategorycollapsestate() CChatUsabilityClientUsabilityMetricsNotificationUIstateCategoryCollapseState {
	return CChatUsabilityClientUsabilityMetricsNotificationUIstateCategoryCollapseState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusabilityclientusabilitymetricsnotificationuistatecategorycollapsestate(o CChatUsabilityClientUsabilityMetricsNotificationUIstateCategoryCollapseState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusabilityclientusabilitymetricsnotificationuistatecategorycollapsestate(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsabilityClientUsabilityMetricsNotificationUIstateCategoryCollapseState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusabilityclientusabilitymetricsnotificationuistatecategorycollapsestate_unpack(v)?
	return i, unpacked
}

pub struct CChatUsabilityClientUsabilityMetricsNotificationUIstate {
mut:
	unknown_fields                      []vproto.UnknownField
pub mut:
	friends_list_height                 int
	has_friends_list_height             bool
	friends_list_width                  int
	has_friends_list_width              bool
	friends_list_docked                 bool
	has_friends_list_docked             bool
	friends_list_collapsed              bool
	has_friends_list_collapsed          bool
	friends_list_group_chats_height     int
	has_friends_list_group_chats_height bool
	friends_list_visible                bool
	has_friends_list_visible            bool
	chat_popups_opened                  int
	has_chat_popups_opened              bool
	group_chat_tabs_opened              int
	has_group_chat_tabs_opened          bool
	friend_chat_tabs_opened             int
	has_friend_chat_tabs_opened         bool
	chat_window_width                   int
	has_chat_window_width               bool
	chat_window_height                  int
	has_chat_window_height              bool
	category_collapse                   CChatUsabilityClientUsabilityMetricsNotificationUIstateCategoryCollapseState
	has_category_collapse               bool
	group_chat_left_col_collapsed       int
	has_group_chat_left_col_collapsed   bool
	group_chat_right_col_collapsed      int
	has_group_chat_right_col_collapsed  bool
	in_one_on_one_voice_chat            bool
	has_in_one_on_one_voice_chat        bool
	in_group_voice_chat                 bool
	has_in_group_voice_chat             bool
}

pub fn (o &CChatUsabilityClientUsabilityMetricsNotificationUIstate) pack() []byte {
	mut res := []byte{}
	if o.has_friends_list_height {
		res << vproto.pack_int32_field(o.friends_list_height, 1)
	}
	if o.has_friends_list_width {
		res << vproto.pack_int32_field(o.friends_list_width, 2)
	}
	if o.has_friends_list_docked {
		res << vproto.pack_bool_field(o.friends_list_docked, 3)
	}
	if o.has_friends_list_collapsed {
		res << vproto.pack_bool_field(o.friends_list_collapsed, 4)
	}
	if o.has_friends_list_group_chats_height {
		res << vproto.pack_int32_field(o.friends_list_group_chats_height, 5)
	}
	if o.has_friends_list_visible {
		res << vproto.pack_bool_field(o.friends_list_visible, 6)
	}
	if o.has_chat_popups_opened {
		res << vproto.pack_int32_field(o.chat_popups_opened, 7)
	}
	if o.has_group_chat_tabs_opened {
		res << vproto.pack_int32_field(o.group_chat_tabs_opened, 8)
	}
	if o.has_friend_chat_tabs_opened {
		res << vproto.pack_int32_field(o.friend_chat_tabs_opened, 9)
	}
	if o.has_chat_window_width {
		res << vproto.pack_int32_field(o.chat_window_width, 10)
	}
	if o.has_chat_window_height {
		res << vproto.pack_int32_field(o.chat_window_height, 11)
	}
	if o.has_category_collapse {
		res <<
			zzz_vproto_internal_pack_cchatusabilityclientusabilitymetricsnotificationuistatecategorycollapsestate(o.category_collapse, 12)
	}
	if o.has_group_chat_left_col_collapsed {
		res << vproto.pack_int32_field(o.group_chat_left_col_collapsed, 13)
	}
	if o.has_group_chat_right_col_collapsed {
		res << vproto.pack_int32_field(o.group_chat_right_col_collapsed, 14)
	}
	if o.has_in_one_on_one_voice_chat {
		res << vproto.pack_bool_field(o.in_one_on_one_voice_chat, 15)
	}
	if o.has_in_group_voice_chat {
		res << vproto.pack_bool_field(o.in_group_voice_chat, 16)
	}
	return res
}

pub fn cchatusabilityclientusabilitymetricsnotificationuistate_unpack(buf []byte) ?CChatUsabilityClientUsabilityMetricsNotificationUIstate {
	mut res := CChatUsabilityClientUsabilityMetricsNotificationUIstate{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_friends_list_height = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_list_height = v
				i = ii
			}
			2 {
				res.has_friends_list_width = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_list_width = v
				i = ii
			}
			3 {
				res.has_friends_list_docked = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_list_docked = v
				i = ii
			}
			4 {
				res.has_friends_list_collapsed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_list_collapsed = v
				i = ii
			}
			5 {
				res.has_friends_list_group_chats_height = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_list_group_chats_height = v
				i = ii
			}
			6 {
				res.has_friends_list_visible = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_list_visible = v
				i = ii
			}
			7 {
				res.has_chat_popups_opened = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_popups_opened = v
				i = ii
			}
			8 {
				res.has_group_chat_tabs_opened = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.group_chat_tabs_opened = v
				i = ii
			}
			9 {
				res.has_friend_chat_tabs_opened = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friend_chat_tabs_opened = v
				i = ii
			}
			10 {
				res.has_chat_window_width = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_window_width = v
				i = ii
			}
			11 {
				res.has_chat_window_height = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_window_height = v
				i = ii
			}
			12 {
				res.has_category_collapse = true
				ii, v := zzz_vproto_internal_unpack_cchatusabilityclientusabilitymetricsnotificationuistatecategorycollapsestate(cur_buf,
					tag_wiretype.wire_type)?
				res.category_collapse = v
				i = ii
			}
			13 {
				res.has_group_chat_left_col_collapsed = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.group_chat_left_col_collapsed = v
				i = ii
			}
			14 {
				res.has_group_chat_right_col_collapsed = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.group_chat_right_col_collapsed = v
				i = ii
			}
			15 {
				res.has_in_one_on_one_voice_chat = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.in_one_on_one_voice_chat = v
				i = ii
			}
			16 {
				res.has_in_group_voice_chat = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.in_group_voice_chat = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusabilityclientusabilitymetricsnotificationuistate() CChatUsabilityClientUsabilityMetricsNotificationUIstate {
	return CChatUsabilityClientUsabilityMetricsNotificationUIstate{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusabilityclientusabilitymetricsnotificationuistate(o CChatUsabilityClientUsabilityMetricsNotificationUIstate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusabilityclientusabilitymetricsnotificationuistate(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsabilityClientUsabilityMetricsNotificationUIstate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusabilityclientusabilitymetricsnotificationuistate_unpack(v)?
	return i, unpacked
}

pub struct CChatUsabilityClientUsabilityMetricsNotificationMetrics {
mut:
	unknown_fields                      []vproto.UnknownField
pub mut:
	friends_count                       int
	has_friends_count                   bool
	friends_category_count              int
	has_friends_category_count          bool
	friends_categorized_count           int
	has_friends_categorized_count       bool
	friends_online_count                int
	has_friends_online_count            bool
	friends_in_game_count               int
	has_friends_in_game_count           bool
	friends_in_game_singleton_count     int
	has_friends_in_game_singleton_count bool
	game_group_count                    int
	has_game_group_count                bool
	friends_favorite_count              int
	has_friends_favorite_count          bool
	group_chat_count                    int
	has_group_chat_count                bool
	group_chat_favorite_count           int
	has_group_chat_favorite_count       bool
}

pub fn (o &CChatUsabilityClientUsabilityMetricsNotificationMetrics) pack() []byte {
	mut res := []byte{}
	if o.has_friends_count {
		res << vproto.pack_int32_field(o.friends_count, 1)
	}
	if o.has_friends_category_count {
		res << vproto.pack_int32_field(o.friends_category_count, 2)
	}
	if o.has_friends_categorized_count {
		res << vproto.pack_int32_field(o.friends_categorized_count, 3)
	}
	if o.has_friends_online_count {
		res << vproto.pack_int32_field(o.friends_online_count, 4)
	}
	if o.has_friends_in_game_count {
		res << vproto.pack_int32_field(o.friends_in_game_count, 5)
	}
	if o.has_friends_in_game_singleton_count {
		res << vproto.pack_int32_field(o.friends_in_game_singleton_count, 6)
	}
	if o.has_game_group_count {
		res << vproto.pack_int32_field(o.game_group_count, 7)
	}
	if o.has_friends_favorite_count {
		res << vproto.pack_int32_field(o.friends_favorite_count, 8)
	}
	if o.has_group_chat_count {
		res << vproto.pack_int32_field(o.group_chat_count, 9)
	}
	if o.has_group_chat_favorite_count {
		res << vproto.pack_int32_field(o.group_chat_favorite_count, 10)
	}
	return res
}

pub fn cchatusabilityclientusabilitymetricsnotificationmetrics_unpack(buf []byte) ?CChatUsabilityClientUsabilityMetricsNotificationMetrics {
	mut res := CChatUsabilityClientUsabilityMetricsNotificationMetrics{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_friends_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_count = v
				i = ii
			}
			2 {
				res.has_friends_category_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_category_count = v
				i = ii
			}
			3 {
				res.has_friends_categorized_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_categorized_count = v
				i = ii
			}
			4 {
				res.has_friends_online_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_online_count = v
				i = ii
			}
			5 {
				res.has_friends_in_game_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_in_game_count = v
				i = ii
			}
			6 {
				res.has_friends_in_game_singleton_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_in_game_singleton_count = v
				i = ii
			}
			7 {
				res.has_game_group_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_group_count = v
				i = ii
			}
			8 {
				res.has_friends_favorite_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_favorite_count = v
				i = ii
			}
			9 {
				res.has_group_chat_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.group_chat_count = v
				i = ii
			}
			10 {
				res.has_group_chat_favorite_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.group_chat_favorite_count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusabilityclientusabilitymetricsnotificationmetrics() CChatUsabilityClientUsabilityMetricsNotificationMetrics {
	return CChatUsabilityClientUsabilityMetricsNotificationMetrics{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusabilityclientusabilitymetricsnotificationmetrics(o CChatUsabilityClientUsabilityMetricsNotificationMetrics, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusabilityclientusabilitymetricsnotificationmetrics(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsabilityClientUsabilityMetricsNotificationMetrics) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusabilityclientusabilitymetricsnotificationmetrics_unpack(v)?
	return i, unpacked
}

pub struct CChatUsabilityClientUsabilityMetricsNotification {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	metrics_run_id      u32
	has_metrics_run_id  bool
	client_build        u32
	has_client_build    bool
	metrics_version     u32
	has_metrics_version bool
	in_web              bool
	has_in_web          bool
	settings            CChatUsabilityClientUsabilityMetricsNotificationSettings
	has_settings        bool
	voice_settings      CChatUsabilityClientUsabilityMetricsNotificationVoiceSettings
	has_voice_settings  bool
	ui_state            CChatUsabilityClientUsabilityMetricsNotificationUIstate
	has_ui_state        bool
	metrics             CChatUsabilityClientUsabilityMetricsNotificationMetrics
	has_metrics         bool
}

pub fn (o &CChatUsabilityClientUsabilityMetricsNotification) pack() []byte {
	mut res := []byte{}
	if o.has_metrics_run_id {
		res << vproto.pack_uint32_field(o.metrics_run_id, 1)
	}
	if o.has_client_build {
		res << vproto.pack_uint32_field(o.client_build, 2)
	}
	if o.has_metrics_version {
		res << vproto.pack_uint32_field(o.metrics_version, 3)
	}
	if o.has_in_web {
		res << vproto.pack_bool_field(o.in_web, 4)
	}
	if o.has_settings {
		res <<
			zzz_vproto_internal_pack_cchatusabilityclientusabilitymetricsnotificationsettings(o.settings, 10)
	}
	if o.has_voice_settings {
		res <<
			zzz_vproto_internal_pack_cchatusabilityclientusabilitymetricsnotificationvoicesettings(o.voice_settings, 11)
	}
	if o.has_ui_state {
		res <<
			zzz_vproto_internal_pack_cchatusabilityclientusabilitymetricsnotificationuistate(o.ui_state, 12)
	}
	if o.has_metrics {
		res <<
			zzz_vproto_internal_pack_cchatusabilityclientusabilitymetricsnotificationmetrics(o.metrics, 13)
	}
	return res
}

pub fn cchatusabilityclientusabilitymetricsnotification_unpack(buf []byte) ?CChatUsabilityClientUsabilityMetricsNotification {
	mut res := CChatUsabilityClientUsabilityMetricsNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_metrics_run_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.metrics_run_id = v
				i = ii
			}
			2 {
				res.has_client_build = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_build = v
				i = ii
			}
			3 {
				res.has_metrics_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.metrics_version = v
				i = ii
			}
			4 {
				res.has_in_web = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.in_web = v
				i = ii
			}
			10 {
				res.has_settings = true
				ii, v := zzz_vproto_internal_unpack_cchatusabilityclientusabilitymetricsnotificationsettings(cur_buf,
					tag_wiretype.wire_type)?
				res.settings = v
				i = ii
			}
			11 {
				res.has_voice_settings = true
				ii, v := zzz_vproto_internal_unpack_cchatusabilityclientusabilitymetricsnotificationvoicesettings(cur_buf,
					tag_wiretype.wire_type)?
				res.voice_settings = v
				i = ii
			}
			12 {
				res.has_ui_state = true
				ii, v := zzz_vproto_internal_unpack_cchatusabilityclientusabilitymetricsnotificationuistate(cur_buf,
					tag_wiretype.wire_type)?
				res.ui_state = v
				i = ii
			}
			13 {
				res.has_metrics = true
				ii, v := zzz_vproto_internal_unpack_cchatusabilityclientusabilitymetricsnotificationmetrics(cur_buf,
					tag_wiretype.wire_type)?
				res.metrics = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusabilityclientusabilitymetricsnotification() CChatUsabilityClientUsabilityMetricsNotification {
	return CChatUsabilityClientUsabilityMetricsNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusabilityclientusabilitymetricsnotification(o CChatUsabilityClientUsabilityMetricsNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusabilityclientusabilitymetricsnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsabilityClientUsabilityMetricsNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusabilityclientusabilitymetricsnotification_unpack(v)?
	return i, unpacked
}

pub struct CChatUsabilityRequestClientUsabilityMetricsNotification {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	metrics_run_id     u32
	has_metrics_run_id bool
}

pub fn (o &CChatUsabilityRequestClientUsabilityMetricsNotification) pack() []byte {
	mut res := []byte{}
	if o.has_metrics_run_id {
		res << vproto.pack_uint32_field(o.metrics_run_id, 1)
	}
	return res
}

pub fn cchatusabilityrequestclientusabilitymetricsnotification_unpack(buf []byte) ?CChatUsabilityRequestClientUsabilityMetricsNotification {
	mut res := CChatUsabilityRequestClientUsabilityMetricsNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_metrics_run_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.metrics_run_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusabilityrequestclientusabilitymetricsnotification() CChatUsabilityRequestClientUsabilityMetricsNotification {
	return CChatUsabilityRequestClientUsabilityMetricsNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusabilityrequestclientusabilitymetricsnotification(o CChatUsabilityRequestClientUsabilityMetricsNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusabilityrequestclientusabilitymetricsnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsabilityRequestClientUsabilityMetricsNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusabilityrequestclientusabilitymetricsnotification_unpack(v)?
	return i, unpacked
}
