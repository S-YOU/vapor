// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EChatRoomJoinState {
	k_echatroomjoinstate_default = 0
	k_echatroomjoinstate_none = 1
	k_echatroomjoinstate_joined = 2
	k_echatroomjoinstate_testinvalid = 99
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroomjoinstate(e EChatRoomJoinState, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroomjoinstate_packed(e []EChatRoomJoinState, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroomjoinstate(buf []byte, tag_wiretype vproto.WireType) ?(int, EChatRoomJoinState) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EChatRoomJoinState(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroomjoinstate_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EChatRoomJoinState) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EChatRoomGroupRank {
	k_echatroomgrouprank_default = 0
	k_echatroomgrouprank_viewer = 10
	k_echatroomgrouprank_guest = 15
	k_echatroomgrouprank_member = 20
	k_echatroomgrouprank_moderator = 30
	k_echatroomgrouprank_officer = 40
	k_echatroomgrouprank_owner = 50
	k_echatroomgrouprank_testinvalid = 99
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroomgrouprank(e EChatRoomGroupRank, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroomgrouprank_packed(e []EChatRoomGroupRank, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroomgrouprank(buf []byte, tag_wiretype vproto.WireType) ?(int, EChatRoomGroupRank) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EChatRoomGroupRank(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroomgrouprank_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EChatRoomGroupRank) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EChatRoomNotificationLevel {
	k_echatroomnotificationlevel_invalid = 0
	k_echatroomnotificationlevel_none = 1
	k_echatroomnotificationlevel_mentionme = 2
	k_echatroomnotificationlevel_mentionall = 3
	k_echatroomnotificationlevel_allmessages = 4
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroomnotificationlevel(e EChatRoomNotificationLevel, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroomnotificationlevel_packed(e []EChatRoomNotificationLevel, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroomnotificationlevel(buf []byte, tag_wiretype vproto.WireType) ?(int, EChatRoomNotificationLevel) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EChatRoomNotificationLevel(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroomnotificationlevel_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EChatRoomNotificationLevel) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EChatRoomServerMessage {
	k_echatroomservermsg_invalid = 0
	k_echatroomservermsg_renamechatroom = 1
	k_echatroomservermsg_joined = 2
	k_echatroomservermsg_parted = 3
	k_echatroomservermsg_kicked = 4
	k_echatroomservermsg_invited = 5
	k_echatroomservermsg_invitedismissed = 8
	k_echatroomservermsg_chatroomtaglinechanged = 9
	k_echatroomservermsg_chatroomavatarchanged = 10
	k_echatroomservermsg_appcustom = 11
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroomservermessage(e EChatRoomServerMessage, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroomservermessage_packed(e []EChatRoomServerMessage, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroomservermessage(buf []byte, tag_wiretype vproto.WireType) ?(int, EChatRoomServerMessage) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EChatRoomServerMessage(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroomservermessage_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EChatRoomServerMessage) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EChatRoomMemberStateChange {
	k_echatroommemberstatechange_invalid = 0
	k_echatroommemberstatechange_joined = 1
	k_echatroommemberstatechange_parted = 2
	k_echatroommemberstatechange_kicked = 3
	k_echatroommemberstatechange_invited = 4
	k_echatroommemberstatechange_rankchanged = 7
	k_echatroommemberstatechange_invitedismissed = 8
	k_echatroommemberstatechange_muted = 9
	k_echatroommemberstatechange_banned = 10
	k_echatroommemberstatechange_roleschanged = 12
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroommemberstatechange(e EChatRoomMemberStateChange, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_echatroommemberstatechange_packed(e []EChatRoomMemberStateChange, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroommemberstatechange(buf []byte, tag_wiretype vproto.WireType) ?(int, EChatRoomMemberStateChange) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EChatRoomMemberStateChange(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_echatroommemberstatechange_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EChatRoomMemberStateChange) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CChat_RequestFriendPersonaStates_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChat_RequestFriendPersonaStates_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchat_requestfriendpersonastates_request_unpack(buf []byte) ?CChat_RequestFriendPersonaStates_Request {
	res := CChat_RequestFriendPersonaStates_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchat_requestfriendpersonastates_request() CChat_RequestFriendPersonaStates_Request {
	return CChat_RequestFriendPersonaStates_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchat_requestfriendpersonastates_request(o CChat_RequestFriendPersonaStates_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchat_requestfriendpersonastates_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChat_RequestFriendPersonaStates_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchat_requestfriendpersonastates_request_unpack(v)?
	return i, unpacked
}

pub struct CChat_RequestFriendPersonaStates_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChat_RequestFriendPersonaStates_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchat_requestfriendpersonastates_response_unpack(buf []byte) ?CChat_RequestFriendPersonaStates_Response {
	res := CChat_RequestFriendPersonaStates_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchat_requestfriendpersonastates_response() CChat_RequestFriendPersonaStates_Response {
	return CChat_RequestFriendPersonaStates_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchat_requestfriendpersonastates_response(o CChat_RequestFriendPersonaStates_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchat_requestfriendpersonastates_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChat_RequestFriendPersonaStates_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchat_requestfriendpersonastates_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_CreateChatRoomGroup_Request {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	steamid_partner                   u64
	has_steamid_partner               bool
	steamid_invited                   u64
	has_steamid_invited               bool
	name                              string
	has_name                          bool
	steamid_invitees                  []u64
	watching_broadcast_accountid      u32
	has_watching_broadcast_accountid  bool
	watching_broadcast_channel_id     u64
	has_watching_broadcast_channel_id bool
}

pub fn (o &CChatRoom_CreateChatRoomGroup_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_partner {
		res << vproto.pack_64bit_field(o.steamid_partner, 1)
	}
	if o.has_steamid_invited {
		res << vproto.pack_64bit_field(o.steamid_invited, 2)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 3)
	}
	// [packed=false]
	for _, x in o.steamid_invitees {
		res << vproto.pack_64bit_field(x, 4)
	}
	if o.has_watching_broadcast_accountid {
		res << vproto.pack_uint32_field(o.watching_broadcast_accountid, 6)
	}
	if o.has_watching_broadcast_channel_id {
		res << vproto.pack_uint64_field(o.watching_broadcast_channel_id, 7)
	}
	return res
}

pub fn cchatroom_createchatroomgroup_request_unpack(buf []byte) ?CChatRoom_CreateChatRoomGroup_Request {
	mut res := CChatRoom_CreateChatRoomGroup_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_partner = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_partner = v
				i = ii
			}
			2 {
				res.has_steamid_invited = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_invited = v
				i = ii
			}
			3 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_invitees << v
				i = ii
			}
			6 {
				res.has_watching_broadcast_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_accountid = v
				i = ii
			}
			7 {
				res.has_watching_broadcast_channel_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_channel_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_createchatroomgroup_request() CChatRoom_CreateChatRoomGroup_Request {
	return CChatRoom_CreateChatRoomGroup_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_createchatroomgroup_request(o CChatRoom_CreateChatRoomGroup_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_createchatroomgroup_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_CreateChatRoomGroup_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_createchatroomgroup_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRole {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	role_id        u64
	has_role_id    bool
	name           string
	has_name       bool
	ordinal        u32
	has_ordinal    bool
}

pub fn (o &CChatRole) pack() []byte {
	mut res := []byte{}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 3)
	}
	return res
}

pub fn cchatrole_unpack(buf []byte) ?CChatRole {
	mut res := CChatRole{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatrole() CChatRole {
	return CChatRole{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatrole(o CChatRole, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatrole(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRole) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatrole_unpack(v)?
	return i, unpacked
}

pub struct CChatRoleActions {
mut:
	unknown_fields                       []vproto.UnknownField
pub mut:
	role_id                              u64
	has_role_id                          bool
	can_create_rename_delete_channel     bool
	has_can_create_rename_delete_channel bool
	can_kick                             bool
	has_can_kick                         bool
	can_ban                              bool
	has_can_ban                          bool
	can_invite                           bool
	has_can_invite                       bool
	can_change_tagline_avatar_name       bool
	has_can_change_tagline_avatar_name   bool
	can_chat                             bool
	has_can_chat                         bool
	can_view_history                     bool
	has_can_view_history                 bool
	can_change_group_roles               bool
	has_can_change_group_roles           bool
	can_change_user_roles                bool
	has_can_change_user_roles            bool
	can_mention_all                      bool
	has_can_mention_all                  bool
	can_set_watching_broadcast           bool
	has_can_set_watching_broadcast       bool
}

pub fn (o &CChatRoleActions) pack() []byte {
	mut res := []byte{}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 1)
	}
	if o.has_can_create_rename_delete_channel {
		res << vproto.pack_bool_field(o.can_create_rename_delete_channel, 2)
	}
	if o.has_can_kick {
		res << vproto.pack_bool_field(o.can_kick, 3)
	}
	if o.has_can_ban {
		res << vproto.pack_bool_field(o.can_ban, 4)
	}
	if o.has_can_invite {
		res << vproto.pack_bool_field(o.can_invite, 5)
	}
	if o.has_can_change_tagline_avatar_name {
		res << vproto.pack_bool_field(o.can_change_tagline_avatar_name, 6)
	}
	if o.has_can_chat {
		res << vproto.pack_bool_field(o.can_chat, 7)
	}
	if o.has_can_view_history {
		res << vproto.pack_bool_field(o.can_view_history, 8)
	}
	if o.has_can_change_group_roles {
		res << vproto.pack_bool_field(o.can_change_group_roles, 9)
	}
	if o.has_can_change_user_roles {
		res << vproto.pack_bool_field(o.can_change_user_roles, 10)
	}
	if o.has_can_mention_all {
		res << vproto.pack_bool_field(o.can_mention_all, 11)
	}
	if o.has_can_set_watching_broadcast {
		res << vproto.pack_bool_field(o.can_set_watching_broadcast, 12)
	}
	return res
}

pub fn cchatroleactions_unpack(buf []byte) ?CChatRoleActions {
	mut res := CChatRoleActions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			2 {
				res.has_can_create_rename_delete_channel = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_create_rename_delete_channel = v
				i = ii
			}
			3 {
				res.has_can_kick = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_kick = v
				i = ii
			}
			4 {
				res.has_can_ban = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_ban = v
				i = ii
			}
			5 {
				res.has_can_invite = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_invite = v
				i = ii
			}
			6 {
				res.has_can_change_tagline_avatar_name = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_change_tagline_avatar_name = v
				i = ii
			}
			7 {
				res.has_can_chat = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_chat = v
				i = ii
			}
			8 {
				res.has_can_view_history = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_view_history = v
				i = ii
			}
			9 {
				res.has_can_change_group_roles = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_change_group_roles = v
				i = ii
			}
			10 {
				res.has_can_change_user_roles = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_change_user_roles = v
				i = ii
			}
			11 {
				res.has_can_mention_all = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_mention_all = v
				i = ii
			}
			12 {
				res.has_can_set_watching_broadcast = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_set_watching_broadcast = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroleactions() CChatRoleActions {
	return CChatRoleActions{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroleactions(o CChatRoleActions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroleactions(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoleActions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroleactions_unpack(v)?
	return i, unpacked
}

pub struct CChatPartyBeacon {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	app_id            u32
	has_app_id        bool
	steamid_owner     u64
	has_steamid_owner bool
	beacon_id         u64
	has_beacon_id     bool
	game_metadata     string
	has_game_metadata bool
}

pub fn (o &CChatPartyBeacon) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_steamid_owner {
		res << vproto.pack_64bit_field(o.steamid_owner, 2)
	}
	if o.has_beacon_id {
		res << vproto.pack_64bit_field(o.beacon_id, 3)
	}
	if o.has_game_metadata {
		res << vproto.pack_string_field(o.game_metadata, 4)
	}
	return res
}

pub fn cchatpartybeacon_unpack(buf []byte) ?CChatPartyBeacon {
	mut res := CChatPartyBeacon{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_steamid_owner = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_owner = v
				i = ii
			}
			3 {
				res.has_beacon_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.beacon_id = v
				i = ii
			}
			4 {
				res.has_game_metadata = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_metadata = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatpartybeacon() CChatPartyBeacon {
	return CChatPartyBeacon{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatpartybeacon(o CChatPartyBeacon, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatpartybeacon(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatPartyBeacon) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatpartybeacon_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGroupHeaderState {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	chat_group_id                     u64
	has_chat_group_id                 bool
	chat_name                         string
	has_chat_name                     bool
	clanid                            u32
	has_clanid                        bool
	accountid_owner                   u32
	has_accountid_owner               bool
	appid                             u32
	has_appid                         bool
	tagline                           string
	has_tagline                       bool
	avatar_sha                        []byte
	has_avatar_sha                    bool
	default_role_id                   u64
	has_default_role_id               bool
	roles                             []CChatRole
	role_actions                      []CChatRoleActions
	watching_broadcast_accountid      u32
	has_watching_broadcast_accountid  bool
	party_beacons                     []CChatPartyBeacon
	watching_broadcast_channel_id     u64
	has_watching_broadcast_channel_id bool
	active_minigame_id                u64
	has_active_minigame_id            bool
	avatar_ugc_url                    string
	has_avatar_ugc_url                bool
}

pub fn (o &CChatRoomGroupHeaderState) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_name {
		res << vproto.pack_string_field(o.chat_name, 2)
	}
	if o.has_clanid {
		res << vproto.pack_uint32_field(o.clanid, 13)
	}
	if o.has_accountid_owner {
		res << vproto.pack_uint32_field(o.accountid_owner, 14)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 21)
	}
	if o.has_tagline {
		res << vproto.pack_string_field(o.tagline, 15)
	}
	if o.has_avatar_sha {
		res << vproto.pack_bytes_field(o.avatar_sha, 16)
	}
	if o.has_default_role_id {
		res << vproto.pack_uint64_field(o.default_role_id, 17)
	}
	// [packed=false]
	for _, x in o.roles {
		res << zzz_vproto_internal_pack_cchatrole(x, 18)
	}
	// [packed=false]
	for _, x in o.role_actions {
		res << zzz_vproto_internal_pack_cchatroleactions(x, 19)
	}
	if o.has_watching_broadcast_accountid {
		res << vproto.pack_uint32_field(o.watching_broadcast_accountid, 20)
	}
	// [packed=false]
	for _, x in o.party_beacons {
		res << zzz_vproto_internal_pack_cchatpartybeacon(x, 22)
	}
	if o.has_watching_broadcast_channel_id {
		res << vproto.pack_uint64_field(o.watching_broadcast_channel_id, 23)
	}
	if o.has_active_minigame_id {
		res << vproto.pack_uint64_field(o.active_minigame_id, 24)
	}
	if o.has_avatar_ugc_url {
		res << vproto.pack_string_field(o.avatar_ugc_url, 25)
	}
	return res
}

pub fn cchatroomgroupheaderstate_unpack(buf []byte) ?CChatRoomGroupHeaderState {
	mut res := CChatRoomGroupHeaderState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_name = v
				i = ii
			}
			13 {
				res.has_clanid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.clanid = v
				i = ii
			}
			14 {
				res.has_accountid_owner = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_owner = v
				i = ii
			}
			21 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			15 {
				res.has_tagline = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tagline = v
				i = ii
			}
			16 {
				res.has_avatar_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.avatar_sha = v
				i = ii
			}
			17 {
				res.has_default_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.default_role_id = v
				i = ii
			}
			18 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatrole(cur_buf, tag_wiretype.wire_type)?
				res.roles << v
				i = ii
			}
			19 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroleactions(cur_buf, tag_wiretype.wire_type)?
				res.role_actions << v
				i = ii
			}
			20 {
				res.has_watching_broadcast_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_accountid = v
				i = ii
			}
			22 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatpartybeacon(cur_buf, tag_wiretype.wire_type)?
				res.party_beacons << v
				i = ii
			}
			23 {
				res.has_watching_broadcast_channel_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_channel_id = v
				i = ii
			}
			24 {
				res.has_active_minigame_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.active_minigame_id = v
				i = ii
			}
			25 {
				res.has_avatar_ugc_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.avatar_ugc_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgroupheaderstate() CChatRoomGroupHeaderState {
	return CChatRoomGroupHeaderState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgroupheaderstate(o CChatRoomGroupHeaderState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgroupheaderstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGroupHeaderState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgroupheaderstate_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomMember {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	accountid            u32
	has_accountid        bool
	state                EChatRoomJoinState
	has_state            bool
	rank                 EChatRoomGroupRank
	has_rank             bool
	time_kick_expire     u32
	has_time_kick_expire bool
	role_ids             []u64
}

pub fn (o &CChatRoomMember) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 1)
	}
	if o.has_state {
		res << zzz_vproto_internal_pack_echatroomjoinstate(o.state, 3)
	}
	if o.has_rank {
		res << zzz_vproto_internal_pack_echatroomgrouprank(o.rank, 4)
	}
	if o.has_time_kick_expire {
		res << vproto.pack_uint32_field(o.time_kick_expire, 6)
	}
	// [packed=false]
	for _, x in o.role_ids {
		res << vproto.pack_uint64_field(x, 7)
	}
	return res
}

pub fn cchatroommember_unpack(buf []byte) ?CChatRoomMember {
	mut res := CChatRoomMember{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			3 {
				res.has_state = true
				ii, v := zzz_vproto_internal_unpack_echatroomjoinstate(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			4 {
				res.has_rank = true
				ii, v := zzz_vproto_internal_unpack_echatroomgrouprank(cur_buf, tag_wiretype.wire_type)?
				res.rank = v
				i = ii
			}
			6 {
				res.has_time_kick_expire = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_kick_expire = v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroommember() CChatRoomMember {
	return CChatRoomMember{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroommember(o CChatRoomMember, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroommember(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomMember) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroommember_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomState {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	chat_id                    u64
	has_chat_id                bool
	chat_name                  string
	has_chat_name              bool
	voice_allowed              bool
	has_voice_allowed          bool
	members_in_voice           []u32
	time_last_message          u32
	has_time_last_message      bool
	sort_order                 u32
	has_sort_order             bool
	last_message               string
	has_last_message           bool
	accountid_last_message     u32
	has_accountid_last_message bool
}

pub fn (o &CChatRoomState) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 1)
	}
	if o.has_chat_name {
		res << vproto.pack_string_field(o.chat_name, 2)
	}
	if o.has_voice_allowed {
		res << vproto.pack_bool_field(o.voice_allowed, 3)
	}
	// [packed=false]
	for _, x in o.members_in_voice {
		res << vproto.pack_uint32_field(x, 4)
	}
	if o.has_time_last_message {
		res << vproto.pack_uint32_field(o.time_last_message, 5)
	}
	if o.has_sort_order {
		res << vproto.pack_uint32_field(o.sort_order, 6)
	}
	if o.has_last_message {
		res << vproto.pack_string_field(o.last_message, 7)
	}
	if o.has_accountid_last_message {
		res << vproto.pack_uint32_field(o.accountid_last_message, 8)
	}
	return res
}

pub fn cchatroomstate_unpack(buf []byte) ?CChatRoomState {
	mut res := CChatRoomState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_chat_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_name = v
				i = ii
			}
			3 {
				res.has_voice_allowed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_allowed = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.members_in_voice << v
				i = ii
			}
			5 {
				res.has_time_last_message = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last_message = v
				i = ii
			}
			6 {
				res.has_sort_order = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sort_order = v
				i = ii
			}
			7 {
				res.has_last_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.last_message = v
				i = ii
			}
			8 {
				res.has_accountid_last_message = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_last_message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomstate() CChatRoomState {
	return CChatRoomState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomstate(o CChatRoomState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomstate_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGroupState {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	header_state        CChatRoomGroupHeaderState
	has_header_state    bool
	members             []CChatRoomMember
	default_chat_id     u64
	has_default_chat_id bool
	chat_rooms          []CChatRoomState
	kicked              []CChatRoomMember
}

pub fn (o &CChatRoomGroupState) pack() []byte {
	mut res := []byte{}
	if o.has_header_state {
		res << zzz_vproto_internal_pack_cchatroomgroupheaderstate(o.header_state, 1)
	}
	// [packed=false]
	for _, x in o.members {
		res << zzz_vproto_internal_pack_cchatroommember(x, 2)
	}
	if o.has_default_chat_id {
		res << vproto.pack_uint64_field(o.default_chat_id, 4)
	}
	// [packed=false]
	for _, x in o.chat_rooms {
		res << zzz_vproto_internal_pack_cchatroomstate(x, 5)
	}
	// [packed=false]
	for _, x in o.kicked {
		res << zzz_vproto_internal_pack_cchatroommember(x, 7)
	}
	return res
}

pub fn cchatroomgroupstate_unpack(buf []byte) ?CChatRoomGroupState {
	mut res := CChatRoomGroupState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_header_state = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupheaderstate(cur_buf,
					tag_wiretype.wire_type)?
				res.header_state = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroommember(cur_buf, tag_wiretype.wire_type)?
				res.members << v
				i = ii
			}
			4 {
				res.has_default_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.default_chat_id = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomstate(cur_buf, tag_wiretype.wire_type)?
				res.chat_rooms << v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroommember(cur_buf, tag_wiretype.wire_type)?
				res.kicked << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgroupstate() CChatRoomGroupState {
	return CChatRoomGroupState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgroupstate(o CChatRoomGroupState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgroupstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGroupState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgroupstate_unpack(v)?
	return i, unpacked
}

pub struct CUserChatRoomState {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	chat_id                        u64
	has_chat_id                    bool
	time_joined                    u32
	has_time_joined                bool
	time_last_ack                  u32
	has_time_last_ack              bool
	desktop_notification_level     EChatRoomNotificationLevel
	has_desktop_notification_level bool
	mobile_notification_level      EChatRoomNotificationLevel
	has_mobile_notification_level  bool
	time_last_mention              u32
	has_time_last_mention          bool
	unread_indicator_muted         bool
	has_unread_indicator_muted     bool
	time_first_unread              u32
	has_time_first_unread          bool
}

pub fn (o &CUserChatRoomState) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 1)
	}
	if o.has_time_joined {
		res << vproto.pack_uint32_field(o.time_joined, 2)
	}
	if o.has_time_last_ack {
		res << vproto.pack_uint32_field(o.time_last_ack, 3)
	}
	if o.has_desktop_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.desktop_notification_level, 4)
	}
	if o.has_mobile_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.mobile_notification_level, 5)
	}
	if o.has_time_last_mention {
		res << vproto.pack_uint32_field(o.time_last_mention, 6)
	}
	if o.has_unread_indicator_muted {
		res << vproto.pack_bool_field(o.unread_indicator_muted, 7)
	}
	if o.has_time_first_unread {
		res << vproto.pack_uint32_field(o.time_first_unread, 8)
	}
	return res
}

pub fn cuserchatroomstate_unpack(buf []byte) ?CUserChatRoomState {
	mut res := CUserChatRoomState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_time_joined = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_joined = v
				i = ii
			}
			3 {
				res.has_time_last_ack = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last_ack = v
				i = ii
			}
			4 {
				res.has_desktop_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.desktop_notification_level = v
				i = ii
			}
			5 {
				res.has_mobile_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.mobile_notification_level = v
				i = ii
			}
			6 {
				res.has_time_last_mention = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last_mention = v
				i = ii
			}
			7 {
				res.has_unread_indicator_muted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.unread_indicator_muted = v
				i = ii
			}
			8 {
				res.has_time_first_unread = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_first_unread = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuserchatroomstate() CUserChatRoomState {
	return CUserChatRoomState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuserchatroomstate(o CUserChatRoomState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuserchatroomstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserChatRoomState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuserchatroomstate_unpack(v)?
	return i, unpacked
}

pub struct CUserChatRoomGroupState {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	chat_group_id                  u64
	has_chat_group_id              bool
	time_joined                    u32
	has_time_joined                bool
	user_chat_room_state           []CUserChatRoomState
	desktop_notification_level     EChatRoomNotificationLevel
	has_desktop_notification_level bool
	mobile_notification_level      EChatRoomNotificationLevel
	has_mobile_notification_level  bool
	time_last_group_ack            u32
	has_time_last_group_ack        bool
	unread_indicator_muted         bool
	has_unread_indicator_muted     bool
}

pub fn (o &CUserChatRoomGroupState) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_time_joined {
		res << vproto.pack_uint32_field(o.time_joined, 2)
	}
	// [packed=false]
	for _, x in o.user_chat_room_state {
		res << zzz_vproto_internal_pack_cuserchatroomstate(x, 3)
	}
	if o.has_desktop_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.desktop_notification_level, 4)
	}
	if o.has_mobile_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.mobile_notification_level, 5)
	}
	if o.has_time_last_group_ack {
		res << vproto.pack_uint32_field(o.time_last_group_ack, 6)
	}
	if o.has_unread_indicator_muted {
		res << vproto.pack_bool_field(o.unread_indicator_muted, 7)
	}
	return res
}

pub fn cuserchatroomgroupstate_unpack(buf []byte) ?CUserChatRoomGroupState {
	mut res := CUserChatRoomGroupState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_time_joined = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_joined = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cuserchatroomstate(cur_buf, tag_wiretype.wire_type)?
				res.user_chat_room_state << v
				i = ii
			}
			4 {
				res.has_desktop_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.desktop_notification_level = v
				i = ii
			}
			5 {
				res.has_mobile_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.mobile_notification_level = v
				i = ii
			}
			6 {
				res.has_time_last_group_ack = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last_group_ack = v
				i = ii
			}
			7 {
				res.has_unread_indicator_muted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.unread_indicator_muted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuserchatroomgroupstate() CUserChatRoomGroupState {
	return CUserChatRoomGroupState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuserchatroomgroupstate(o CUserChatRoomGroupState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuserchatroomgroupstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserChatRoomGroupState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuserchatroomgroupstate_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_CreateChatRoomGroup_Response {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	chat_group_id       u64
	has_chat_group_id   bool
	state               CChatRoomGroupState
	has_state           bool
	user_chat_state     CUserChatRoomGroupState
	has_user_chat_state bool
}

pub fn (o &CChatRoom_CreateChatRoomGroup_Response) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_state {
		res << zzz_vproto_internal_pack_cchatroomgroupstate(o.state, 2)
	}
	if o.has_user_chat_state {
		res << zzz_vproto_internal_pack_cuserchatroomgroupstate(o.user_chat_state, 3)
	}
	return res
}

pub fn cchatroom_createchatroomgroup_response_unpack(buf []byte) ?CChatRoom_CreateChatRoomGroup_Response {
	mut res := CChatRoom_CreateChatRoomGroup_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_state = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			3 {
				res.has_user_chat_state = true
				ii, v := zzz_vproto_internal_unpack_cuserchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.user_chat_state = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_createchatroomgroup_response() CChatRoom_CreateChatRoomGroup_Response {
	return CChatRoom_CreateChatRoomGroup_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_createchatroomgroup_response(o CChatRoom_CreateChatRoomGroup_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_createchatroomgroup_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_CreateChatRoomGroup_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_createchatroomgroup_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SaveChatRoomGroup_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	name              string
	has_name          bool
}

pub fn (o &CChatRoom_SaveChatRoomGroup_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	return res
}

pub fn cchatroom_savechatroomgroup_request_unpack(buf []byte) ?CChatRoom_SaveChatRoomGroup_Request {
	mut res := CChatRoom_SaveChatRoomGroup_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_savechatroomgroup_request() CChatRoom_SaveChatRoomGroup_Request {
	return CChatRoom_SaveChatRoomGroup_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_savechatroomgroup_request(o CChatRoom_SaveChatRoomGroup_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_savechatroomgroup_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SaveChatRoomGroup_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_savechatroomgroup_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SaveChatRoomGroup_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_SaveChatRoomGroup_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_savechatroomgroup_response_unpack(buf []byte) ?CChatRoom_SaveChatRoomGroup_Response {
	res := CChatRoom_SaveChatRoomGroup_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_savechatroomgroup_response() CChatRoom_SaveChatRoomGroup_Response {
	return CChatRoom_SaveChatRoomGroup_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_savechatroomgroup_response(o CChatRoom_SaveChatRoomGroup_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_savechatroomgroup_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SaveChatRoomGroup_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_savechatroomgroup_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_RenameChatRoomGroup_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	name              string
	has_name          bool
}

pub fn (o &CChatRoom_RenameChatRoomGroup_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	return res
}

pub fn cchatroom_renamechatroomgroup_request_unpack(buf []byte) ?CChatRoom_RenameChatRoomGroup_Request {
	mut res := CChatRoom_RenameChatRoomGroup_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_renamechatroomgroup_request() CChatRoom_RenameChatRoomGroup_Request {
	return CChatRoom_RenameChatRoomGroup_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_renamechatroomgroup_request(o CChatRoom_RenameChatRoomGroup_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_renamechatroomgroup_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_RenameChatRoomGroup_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_renamechatroomgroup_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_RenameChatRoomGroup_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
}

pub fn (o &CChatRoom_RenameChatRoomGroup_Response) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	return res
}

pub fn cchatroom_renamechatroomgroup_response_unpack(buf []byte) ?CChatRoom_RenameChatRoomGroup_Response {
	mut res := CChatRoom_RenameChatRoomGroup_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_renamechatroomgroup_response() CChatRoom_RenameChatRoomGroup_Response {
	return CChatRoom_RenameChatRoomGroup_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_renamechatroomgroup_response(o CChatRoom_RenameChatRoomGroup_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_renamechatroomgroup_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_RenameChatRoomGroup_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_renamechatroomgroup_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetChatRoomGroupTagline_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	tagline           string
	has_tagline       bool
}

pub fn (o &CChatRoom_SetChatRoomGroupTagline_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_tagline {
		res << vproto.pack_string_field(o.tagline, 2)
	}
	return res
}

pub fn cchatroom_setchatroomgrouptagline_request_unpack(buf []byte) ?CChatRoom_SetChatRoomGroupTagline_Request {
	mut res := CChatRoom_SetChatRoomGroupTagline_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_tagline = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tagline = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setchatroomgrouptagline_request() CChatRoom_SetChatRoomGroupTagline_Request {
	return CChatRoom_SetChatRoomGroupTagline_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setchatroomgrouptagline_request(o CChatRoom_SetChatRoomGroupTagline_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setchatroomgrouptagline_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetChatRoomGroupTagline_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setchatroomgrouptagline_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetChatRoomGroupTagline_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_SetChatRoomGroupTagline_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_setchatroomgrouptagline_response_unpack(buf []byte) ?CChatRoom_SetChatRoomGroupTagline_Response {
	res := CChatRoom_SetChatRoomGroupTagline_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setchatroomgrouptagline_response() CChatRoom_SetChatRoomGroupTagline_Response {
	return CChatRoom_SetChatRoomGroupTagline_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setchatroomgrouptagline_response(o CChatRoom_SetChatRoomGroupTagline_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setchatroomgrouptagline_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetChatRoomGroupTagline_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setchatroomgrouptagline_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetChatRoomGroupAvatar_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	avatar_sha        []byte
	has_avatar_sha    bool
}

pub fn (o &CChatRoom_SetChatRoomGroupAvatar_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_avatar_sha {
		res << vproto.pack_bytes_field(o.avatar_sha, 2)
	}
	return res
}

pub fn cchatroom_setchatroomgroupavatar_request_unpack(buf []byte) ?CChatRoom_SetChatRoomGroupAvatar_Request {
	mut res := CChatRoom_SetChatRoomGroupAvatar_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_avatar_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.avatar_sha = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setchatroomgroupavatar_request() CChatRoom_SetChatRoomGroupAvatar_Request {
	return CChatRoom_SetChatRoomGroupAvatar_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setchatroomgroupavatar_request(o CChatRoom_SetChatRoomGroupAvatar_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setchatroomgroupavatar_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetChatRoomGroupAvatar_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setchatroomgroupavatar_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetChatRoomGroupAvatar_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_SetChatRoomGroupAvatar_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_setchatroomgroupavatar_response_unpack(buf []byte) ?CChatRoom_SetChatRoomGroupAvatar_Response {
	res := CChatRoom_SetChatRoomGroupAvatar_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setchatroomgroupavatar_response() CChatRoom_SetChatRoomGroupAvatar_Response {
	return CChatRoom_SetChatRoomGroupAvatar_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setchatroomgroupavatar_response(o CChatRoom_SetChatRoomGroupAvatar_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setchatroomgroupavatar_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetChatRoomGroupAvatar_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setchatroomgroupavatar_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	chat_group_id                     u64
	has_chat_group_id                 bool
	watching_broadcast_accountid      u32
	has_watching_broadcast_accountid  bool
	watching_broadcast_channel_id     u64
	has_watching_broadcast_channel_id bool
}

pub fn (o &CChatRoom_SetChatRoomGroupWatchingBroadcast_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_watching_broadcast_accountid {
		res << vproto.pack_uint32_field(o.watching_broadcast_accountid, 2)
	}
	if o.has_watching_broadcast_channel_id {
		res << vproto.pack_uint64_field(o.watching_broadcast_channel_id, 3)
	}
	return res
}

pub fn cchatroom_setchatroomgroupwatchingbroadcast_request_unpack(buf []byte) ?CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
	mut res := CChatRoom_SetChatRoomGroupWatchingBroadcast_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_watching_broadcast_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_accountid = v
				i = ii
			}
			3 {
				res.has_watching_broadcast_channel_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_channel_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setchatroomgroupwatchingbroadcast_request() CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
	return CChatRoom_SetChatRoomGroupWatchingBroadcast_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setchatroomgroupwatchingbroadcast_request(o CChatRoom_SetChatRoomGroupWatchingBroadcast_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setchatroomgroupwatchingbroadcast_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetChatRoomGroupWatchingBroadcast_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setchatroomgroupwatchingbroadcast_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_SetChatRoomGroupWatchingBroadcast_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_setchatroomgroupwatchingbroadcast_response_unpack(buf []byte) ?CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
	res := CChatRoom_SetChatRoomGroupWatchingBroadcast_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setchatroomgroupwatchingbroadcast_response() CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
	return CChatRoom_SetChatRoomGroupWatchingBroadcast_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setchatroomgroupwatchingbroadcast_response(o CChatRoom_SetChatRoomGroupWatchingBroadcast_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setchatroomgroupwatchingbroadcast_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetChatRoomGroupWatchingBroadcast_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setchatroomgroupwatchingbroadcast_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_JoinMiniGameForChatRoomGroup_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
}

pub fn (o &CChatRoom_JoinMiniGameForChatRoomGroup_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	return res
}

pub fn cchatroom_joinminigameforchatroomgroup_request_unpack(buf []byte) ?CChatRoom_JoinMiniGameForChatRoomGroup_Request {
	mut res := CChatRoom_JoinMiniGameForChatRoomGroup_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_joinminigameforchatroomgroup_request() CChatRoom_JoinMiniGameForChatRoomGroup_Request {
	return CChatRoom_JoinMiniGameForChatRoomGroup_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_joinminigameforchatroomgroup_request(o CChatRoom_JoinMiniGameForChatRoomGroup_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_joinminigameforchatroomgroup_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_JoinMiniGameForChatRoomGroup_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_joinminigameforchatroomgroup_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_JoinMiniGameForChatRoomGroup_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	minigame_id     u64
	has_minigame_id bool
}

pub fn (o &CChatRoom_JoinMiniGameForChatRoomGroup_Response) pack() []byte {
	mut res := []byte{}
	if o.has_minigame_id {
		res << vproto.pack_uint64_field(o.minigame_id, 1)
	}
	return res
}

pub fn cchatroom_joinminigameforchatroomgroup_response_unpack(buf []byte) ?CChatRoom_JoinMiniGameForChatRoomGroup_Response {
	mut res := CChatRoom_JoinMiniGameForChatRoomGroup_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_minigame_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.minigame_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_joinminigameforchatroomgroup_response() CChatRoom_JoinMiniGameForChatRoomGroup_Response {
	return CChatRoom_JoinMiniGameForChatRoomGroup_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_joinminigameforchatroomgroup_response(o CChatRoom_JoinMiniGameForChatRoomGroup_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_joinminigameforchatroomgroup_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_JoinMiniGameForChatRoomGroup_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_joinminigameforchatroomgroup_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_EndMiniGameForChatRoomGroup_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
	minigame_id       u64
	has_minigame_id   bool
}

pub fn (o &CChatRoom_EndMiniGameForChatRoomGroup_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_minigame_id {
		res << vproto.pack_uint64_field(o.minigame_id, 3)
	}
	return res
}

pub fn cchatroom_endminigameforchatroomgroup_request_unpack(buf []byte) ?CChatRoom_EndMiniGameForChatRoomGroup_Request {
	mut res := CChatRoom_EndMiniGameForChatRoomGroup_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_minigame_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.minigame_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_endminigameforchatroomgroup_request() CChatRoom_EndMiniGameForChatRoomGroup_Request {
	return CChatRoom_EndMiniGameForChatRoomGroup_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_endminigameforchatroomgroup_request(o CChatRoom_EndMiniGameForChatRoomGroup_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_endminigameforchatroomgroup_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_EndMiniGameForChatRoomGroup_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_endminigameforchatroomgroup_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_EndMiniGameForChatRoomGroup_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_EndMiniGameForChatRoomGroup_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_endminigameforchatroomgroup_response_unpack(buf []byte) ?CChatRoom_EndMiniGameForChatRoomGroup_Response {
	res := CChatRoom_EndMiniGameForChatRoomGroup_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_endminigameforchatroomgroup_response() CChatRoom_EndMiniGameForChatRoomGroup_Response {
	return CChatRoom_EndMiniGameForChatRoomGroup_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_endminigameforchatroomgroup_response(o CChatRoom_EndMiniGameForChatRoomGroup_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_endminigameforchatroomgroup_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_EndMiniGameForChatRoomGroup_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_endminigameforchatroomgroup_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_MuteUser_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	steamid           u64
	has_steamid       bool
	expiration        int
	has_expiration    bool
}

pub fn (o &CChatRoom_MuteUser_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	if o.has_expiration {
		res << vproto.pack_int32_field(o.expiration, 3)
	}
	return res
}

pub fn cchatroom_muteuser_request_unpack(buf []byte) ?CChatRoom_MuteUser_Request {
	mut res := CChatRoom_MuteUser_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_expiration = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.expiration = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_muteuser_request() CChatRoom_MuteUser_Request {
	return CChatRoom_MuteUser_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_muteuser_request(o CChatRoom_MuteUser_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_muteuser_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_MuteUser_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_muteuser_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_MuteUser_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_MuteUser_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_muteuser_response_unpack(buf []byte) ?CChatRoom_MuteUser_Response {
	res := CChatRoom_MuteUser_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_muteuser_response() CChatRoom_MuteUser_Response {
	return CChatRoom_MuteUser_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_muteuser_response(o CChatRoom_MuteUser_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_muteuser_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_MuteUser_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_muteuser_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_KickUser_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	steamid           u64
	has_steamid       bool
	expiration        int
	has_expiration    bool
}

pub fn (o &CChatRoom_KickUser_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	if o.has_expiration {
		res << vproto.pack_int32_field(o.expiration, 3)
	}
	return res
}

pub fn cchatroom_kickuser_request_unpack(buf []byte) ?CChatRoom_KickUser_Request {
	mut res := CChatRoom_KickUser_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_expiration = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.expiration = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_kickuser_request() CChatRoom_KickUser_Request {
	return CChatRoom_KickUser_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_kickuser_request(o CChatRoom_KickUser_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_kickuser_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_KickUser_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_kickuser_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_KickUser_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_KickUser_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_kickuser_response_unpack(buf []byte) ?CChatRoom_KickUser_Response {
	res := CChatRoom_KickUser_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_kickuser_response() CChatRoom_KickUser_Response {
	return CChatRoom_KickUser_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_kickuser_response(o CChatRoom_KickUser_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_kickuser_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_KickUser_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_kickuser_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetUserBanState_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	steamid           u64
	has_steamid       bool
	ban_state         bool
	has_ban_state     bool
}

pub fn (o &CChatRoom_SetUserBanState_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	if o.has_ban_state {
		res << vproto.pack_bool_field(o.ban_state, 3)
	}
	return res
}

pub fn cchatroom_setuserbanstate_request_unpack(buf []byte) ?CChatRoom_SetUserBanState_Request {
	mut res := CChatRoom_SetUserBanState_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_ban_state = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ban_state = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setuserbanstate_request() CChatRoom_SetUserBanState_Request {
	return CChatRoom_SetUserBanState_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setuserbanstate_request(o CChatRoom_SetUserBanState_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setuserbanstate_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetUserBanState_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setuserbanstate_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetUserBanState_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_SetUserBanState_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_setuserbanstate_response_unpack(buf []byte) ?CChatRoom_SetUserBanState_Response {
	res := CChatRoom_SetUserBanState_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setuserbanstate_response() CChatRoom_SetUserBanState_Response {
	return CChatRoom_SetUserBanState_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setuserbanstate_response(o CChatRoom_SetUserBanState_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setuserbanstate_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetUserBanState_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setuserbanstate_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_RevokeInvite_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	steamid           u64
	has_steamid       bool
}

pub fn (o &CChatRoom_RevokeInvite_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	return res
}

pub fn cchatroom_revokeinvite_request_unpack(buf []byte) ?CChatRoom_RevokeInvite_Request {
	mut res := CChatRoom_RevokeInvite_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_revokeinvite_request() CChatRoom_RevokeInvite_Request {
	return CChatRoom_RevokeInvite_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_revokeinvite_request(o CChatRoom_RevokeInvite_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_revokeinvite_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_RevokeInvite_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_revokeinvite_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_RevokeInvite_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_RevokeInvite_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_revokeinvite_response_unpack(buf []byte) ?CChatRoom_RevokeInvite_Response {
	res := CChatRoom_RevokeInvite_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_revokeinvite_response() CChatRoom_RevokeInvite_Response {
	return CChatRoom_RevokeInvite_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_revokeinvite_response(o CChatRoom_RevokeInvite_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_revokeinvite_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_RevokeInvite_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_revokeinvite_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_CreateRole_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	name              string
	has_name          bool
}

pub fn (o &CChatRoom_CreateRole_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	return res
}

pub fn cchatroom_createrole_request_unpack(buf []byte) ?CChatRoom_CreateRole_Request {
	mut res := CChatRoom_CreateRole_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_createrole_request() CChatRoom_CreateRole_Request {
	return CChatRoom_CreateRole_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_createrole_request(o CChatRoom_CreateRole_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_createrole_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_CreateRole_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_createrole_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_CreateRole_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	actions        CChatRoleActions
	has_actions    bool
}

pub fn (o &CChatRoom_CreateRole_Response) pack() []byte {
	mut res := []byte{}
	if o.has_actions {
		res << zzz_vproto_internal_pack_cchatroleactions(o.actions, 2)
	}
	return res
}

pub fn cchatroom_createrole_response_unpack(buf []byte) ?CChatRoom_CreateRole_Response {
	mut res := CChatRoom_CreateRole_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				res.has_actions = true
				ii, v := zzz_vproto_internal_unpack_cchatroleactions(cur_buf, tag_wiretype.wire_type)?
				res.actions = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_createrole_response() CChatRoom_CreateRole_Response {
	return CChatRoom_CreateRole_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_createrole_response(o CChatRoom_CreateRole_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_createrole_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_CreateRole_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_createrole_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetRoles_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoom_GetRoles_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroom_getroles_request_unpack(buf []byte) ?CChatRoom_GetRoles_Request {
	mut res := CChatRoom_GetRoles_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getroles_request() CChatRoom_GetRoles_Request {
	return CChatRoom_GetRoles_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getroles_request(o CChatRoom_GetRoles_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getroles_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetRoles_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getroles_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetRoles_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	roles          []CChatRole
}

pub fn (o &CChatRoom_GetRoles_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.roles {
		res << zzz_vproto_internal_pack_cchatrole(x, 1)
	}
	return res
}

pub fn cchatroom_getroles_response_unpack(buf []byte) ?CChatRoom_GetRoles_Response {
	mut res := CChatRoom_GetRoles_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatrole(cur_buf, tag_wiretype.wire_type)?
				res.roles << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getroles_response() CChatRoom_GetRoles_Response {
	return CChatRoom_GetRoles_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getroles_response(o CChatRoom_GetRoles_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getroles_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetRoles_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getroles_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_RenameRole_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
	name              string
	has_name          bool
}

pub fn (o &CChatRoom_RenameRole_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 2)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 3)
	}
	return res
}

pub fn cchatroom_renamerole_request_unpack(buf []byte) ?CChatRoom_RenameRole_Request {
	mut res := CChatRoom_RenameRole_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			3 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_renamerole_request() CChatRoom_RenameRole_Request {
	return CChatRoom_RenameRole_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_renamerole_request(o CChatRoom_RenameRole_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_renamerole_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_RenameRole_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_renamerole_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_RenameRole_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_RenameRole_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_renamerole_response_unpack(buf []byte) ?CChatRoom_RenameRole_Response {
	res := CChatRoom_RenameRole_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_renamerole_response() CChatRoom_RenameRole_Response {
	return CChatRoom_RenameRole_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_renamerole_response(o CChatRoom_RenameRole_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_renamerole_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_RenameRole_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_renamerole_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_ReorderRole_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
	ordinal           u32
	has_ordinal       bool
}

pub fn (o &CChatRoom_ReorderRole_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 2)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 3)
	}
	return res
}

pub fn cchatroom_reorderrole_request_unpack(buf []byte) ?CChatRoom_ReorderRole_Request {
	mut res := CChatRoom_ReorderRole_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			3 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_reorderrole_request() CChatRoom_ReorderRole_Request {
	return CChatRoom_ReorderRole_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_reorderrole_request(o CChatRoom_ReorderRole_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_reorderrole_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_ReorderRole_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_reorderrole_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_ReorderRole_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_ReorderRole_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_reorderrole_response_unpack(buf []byte) ?CChatRoom_ReorderRole_Response {
	res := CChatRoom_ReorderRole_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_reorderrole_response() CChatRoom_ReorderRole_Response {
	return CChatRoom_ReorderRole_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_reorderrole_response(o CChatRoom_ReorderRole_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_reorderrole_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_ReorderRole_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_reorderrole_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_DeleteRole_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
}

pub fn (o &CChatRoom_DeleteRole_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 2)
	}
	return res
}

pub fn cchatroom_deleterole_request_unpack(buf []byte) ?CChatRoom_DeleteRole_Request {
	mut res := CChatRoom_DeleteRole_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_deleterole_request() CChatRoom_DeleteRole_Request {
	return CChatRoom_DeleteRole_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_deleterole_request(o CChatRoom_DeleteRole_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_deleterole_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_DeleteRole_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_deleterole_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_DeleteRole_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_DeleteRole_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_deleterole_response_unpack(buf []byte) ?CChatRoom_DeleteRole_Response {
	res := CChatRoom_DeleteRole_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_deleterole_response() CChatRoom_DeleteRole_Response {
	return CChatRoom_DeleteRole_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_deleterole_response(o CChatRoom_DeleteRole_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_deleterole_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_DeleteRole_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_deleterole_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetRoleActions_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
}

pub fn (o &CChatRoom_GetRoleActions_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 2)
	}
	return res
}

pub fn cchatroom_getroleactions_request_unpack(buf []byte) ?CChatRoom_GetRoleActions_Request {
	mut res := CChatRoom_GetRoleActions_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getroleactions_request() CChatRoom_GetRoleActions_Request {
	return CChatRoom_GetRoleActions_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getroleactions_request(o CChatRoom_GetRoleActions_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getroleactions_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetRoleActions_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getroleactions_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetRoleActions_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	actions        []CChatRoleActions
}

pub fn (o &CChatRoom_GetRoleActions_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.actions {
		res << zzz_vproto_internal_pack_cchatroleactions(x, 1)
	}
	return res
}

pub fn cchatroom_getroleactions_response_unpack(buf []byte) ?CChatRoom_GetRoleActions_Response {
	mut res := CChatRoom_GetRoleActions_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroleactions(cur_buf, tag_wiretype.wire_type)?
				res.actions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getroleactions_response() CChatRoom_GetRoleActions_Response {
	return CChatRoom_GetRoleActions_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getroleactions_response(o CChatRoom_GetRoleActions_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getroleactions_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetRoleActions_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getroleactions_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_ReplaceRoleActions_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
	actions           CChatRoleActions
	has_actions       bool
}

pub fn (o &CChatRoom_ReplaceRoleActions_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 2)
	}
	if o.has_actions {
		res << zzz_vproto_internal_pack_cchatroleactions(o.actions, 4)
	}
	return res
}

pub fn cchatroom_replaceroleactions_request_unpack(buf []byte) ?CChatRoom_ReplaceRoleActions_Request {
	mut res := CChatRoom_ReplaceRoleActions_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			4 {
				res.has_actions = true
				ii, v := zzz_vproto_internal_unpack_cchatroleactions(cur_buf, tag_wiretype.wire_type)?
				res.actions = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_replaceroleactions_request() CChatRoom_ReplaceRoleActions_Request {
	return CChatRoom_ReplaceRoleActions_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_replaceroleactions_request(o CChatRoom_ReplaceRoleActions_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_replaceroleactions_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_ReplaceRoleActions_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_replaceroleactions_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_ReplaceRoleActions_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_ReplaceRoleActions_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_replaceroleactions_response_unpack(buf []byte) ?CChatRoom_ReplaceRoleActions_Response {
	res := CChatRoom_ReplaceRoleActions_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_replaceroleactions_response() CChatRoom_ReplaceRoleActions_Response {
	return CChatRoom_ReplaceRoleActions_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_replaceroleactions_response(o CChatRoom_ReplaceRoleActions_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_replaceroleactions_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_ReplaceRoleActions_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_replaceroleactions_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_AddRoleToUser_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
	steamid           u64
	has_steamid       bool
}

pub fn (o &CChatRoom_AddRoleToUser_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 3)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 4)
	}
	return res
}

pub fn cchatroom_addroletouser_request_unpack(buf []byte) ?CChatRoom_AddRoleToUser_Request {
	mut res := CChatRoom_AddRoleToUser_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			3 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			4 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_addroletouser_request() CChatRoom_AddRoleToUser_Request {
	return CChatRoom_AddRoleToUser_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_addroletouser_request(o CChatRoom_AddRoleToUser_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_addroletouser_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_AddRoleToUser_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_addroletouser_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_AddRoleToUser_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_AddRoleToUser_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_addroletouser_response_unpack(buf []byte) ?CChatRoom_AddRoleToUser_Response {
	res := CChatRoom_AddRoleToUser_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_addroletouser_response() CChatRoom_AddRoleToUser_Response {
	return CChatRoom_AddRoleToUser_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_addroletouser_response(o CChatRoom_AddRoleToUser_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_addroletouser_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_AddRoleToUser_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_addroletouser_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetRolesForUser_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	steamid           u64
	has_steamid       bool
}

pub fn (o &CChatRoom_GetRolesForUser_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 3)
	}
	return res
}

pub fn cchatroom_getrolesforuser_request_unpack(buf []byte) ?CChatRoom_GetRolesForUser_Request {
	mut res := CChatRoom_GetRolesForUser_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			3 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getrolesforuser_request() CChatRoom_GetRolesForUser_Request {
	return CChatRoom_GetRolesForUser_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getrolesforuser_request(o CChatRoom_GetRolesForUser_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getrolesforuser_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetRolesForUser_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getrolesforuser_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetRolesForUser_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	role_ids       []u64
}

pub fn (o &CChatRoom_GetRolesForUser_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.role_ids {
		res << vproto.pack_uint64_field(x, 1)
	}
	return res
}

pub fn cchatroom_getrolesforuser_response_unpack(buf []byte) ?CChatRoom_GetRolesForUser_Response {
	mut res := CChatRoom_GetRolesForUser_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getrolesforuser_response() CChatRoom_GetRolesForUser_Response {
	return CChatRoom_GetRolesForUser_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getrolesforuser_response(o CChatRoom_GetRolesForUser_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getrolesforuser_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetRolesForUser_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getrolesforuser_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_DeleteRoleFromUser_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	role_id           u64
	has_role_id       bool
	steamid           u64
	has_steamid       bool
}

pub fn (o &CChatRoom_DeleteRoleFromUser_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_role_id {
		res << vproto.pack_uint64_field(o.role_id, 3)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 4)
	}
	return res
}

pub fn cchatroom_deleterolefromuser_request_unpack(buf []byte) ?CChatRoom_DeleteRoleFromUser_Request {
	mut res := CChatRoom_DeleteRoleFromUser_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			3 {
				res.has_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_id = v
				i = ii
			}
			4 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_deleterolefromuser_request() CChatRoom_DeleteRoleFromUser_Request {
	return CChatRoom_DeleteRoleFromUser_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_deleterolefromuser_request(o CChatRoom_DeleteRoleFromUser_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_deleterolefromuser_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_DeleteRoleFromUser_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_deleterolefromuser_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_DeleteRoleFromUser_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_DeleteRoleFromUser_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_deleterolefromuser_response_unpack(buf []byte) ?CChatRoom_DeleteRoleFromUser_Response {
	res := CChatRoom_DeleteRoleFromUser_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_deleterolefromuser_response() CChatRoom_DeleteRoleFromUser_Response {
	return CChatRoom_DeleteRoleFromUser_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_deleterolefromuser_response(o CChatRoom_DeleteRoleFromUser_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_deleterolefromuser_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_DeleteRoleFromUser_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_deleterolefromuser_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_JoinChatRoomGroup_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	invite_code       string
	has_invite_code   bool
	chat_id           u64
	has_chat_id       bool
}

pub fn (o &CChatRoom_JoinChatRoomGroup_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_invite_code {
		res << vproto.pack_string_field(o.invite_code, 2)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 3)
	}
	return res
}

pub fn cchatroom_joinchatroomgroup_request_unpack(buf []byte) ?CChatRoom_JoinChatRoomGroup_Request {
	mut res := CChatRoom_JoinChatRoomGroup_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_invite_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_code = v
				i = ii
			}
			3 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_joinchatroomgroup_request() CChatRoom_JoinChatRoomGroup_Request {
	return CChatRoom_JoinChatRoomGroup_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_joinchatroomgroup_request(o CChatRoom_JoinChatRoomGroup_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_joinchatroomgroup_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_JoinChatRoomGroup_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_joinchatroomgroup_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_JoinChatRoomGroup_Response {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	state               CChatRoomGroupState
	has_state           bool
	user_chat_state     CUserChatRoomGroupState
	has_user_chat_state bool
	join_chat_id        u64
	has_join_chat_id    bool
	time_expire         u32
	has_time_expire     bool
}

pub fn (o &CChatRoom_JoinChatRoomGroup_Response) pack() []byte {
	mut res := []byte{}
	if o.has_state {
		res << zzz_vproto_internal_pack_cchatroomgroupstate(o.state, 1)
	}
	if o.has_user_chat_state {
		res << zzz_vproto_internal_pack_cuserchatroomgroupstate(o.user_chat_state, 3)
	}
	if o.has_join_chat_id {
		res << vproto.pack_uint64_field(o.join_chat_id, 4)
	}
	if o.has_time_expire {
		res << vproto.pack_uint32_field(o.time_expire, 5)
	}
	return res
}

pub fn cchatroom_joinchatroomgroup_response_unpack(buf []byte) ?CChatRoom_JoinChatRoomGroup_Response {
	mut res := CChatRoom_JoinChatRoomGroup_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_state = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			3 {
				res.has_user_chat_state = true
				ii, v := zzz_vproto_internal_unpack_cuserchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.user_chat_state = v
				i = ii
			}
			4 {
				res.has_join_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.join_chat_id = v
				i = ii
			}
			5 {
				res.has_time_expire = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_expire = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_joinchatroomgroup_response() CChatRoom_JoinChatRoomGroup_Response {
	return CChatRoom_JoinChatRoomGroup_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_joinchatroomgroup_response(o CChatRoom_JoinChatRoomGroup_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_joinchatroomgroup_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_JoinChatRoomGroup_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_joinchatroomgroup_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_InviteFriendToChatRoomGroup_Request {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	chat_group_id            u64
	has_chat_group_id        bool
	steamid                  u64
	has_steamid              bool
	chat_id                  u64
	has_chat_id              bool
	skip_friendsui_check     bool
	has_skip_friendsui_check bool
}

pub fn (o &CChatRoom_InviteFriendToChatRoomGroup_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 3)
	}
	if o.has_skip_friendsui_check {
		res << vproto.pack_bool_field(o.skip_friendsui_check, 4)
	}
	return res
}

pub fn cchatroom_invitefriendtochatroomgroup_request_unpack(buf []byte) ?CChatRoom_InviteFriendToChatRoomGroup_Request {
	mut res := CChatRoom_InviteFriendToChatRoomGroup_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			4 {
				res.has_skip_friendsui_check = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.skip_friendsui_check = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_invitefriendtochatroomgroup_request() CChatRoom_InviteFriendToChatRoomGroup_Request {
	return CChatRoom_InviteFriendToChatRoomGroup_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_invitefriendtochatroomgroup_request(o CChatRoom_InviteFriendToChatRoomGroup_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_invitefriendtochatroomgroup_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_InviteFriendToChatRoomGroup_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_invitefriendtochatroomgroup_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_InviteFriendToChatRoomGroup_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_InviteFriendToChatRoomGroup_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_invitefriendtochatroomgroup_response_unpack(buf []byte) ?CChatRoom_InviteFriendToChatRoomGroup_Response {
	res := CChatRoom_InviteFriendToChatRoomGroup_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_invitefriendtochatroomgroup_response() CChatRoom_InviteFriendToChatRoomGroup_Response {
	return CChatRoom_InviteFriendToChatRoomGroup_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_invitefriendtochatroomgroup_response(o CChatRoom_InviteFriendToChatRoomGroup_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_invitefriendtochatroomgroup_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_InviteFriendToChatRoomGroup_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_invitefriendtochatroomgroup_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_LeaveChatRoomGroup_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoom_LeaveChatRoomGroup_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroom_leavechatroomgroup_request_unpack(buf []byte) ?CChatRoom_LeaveChatRoomGroup_Request {
	mut res := CChatRoom_LeaveChatRoomGroup_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_leavechatroomgroup_request() CChatRoom_LeaveChatRoomGroup_Request {
	return CChatRoom_LeaveChatRoomGroup_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_leavechatroomgroup_request(o CChatRoom_LeaveChatRoomGroup_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_leavechatroomgroup_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_LeaveChatRoomGroup_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_leavechatroomgroup_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_LeaveChatRoomGroup_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_LeaveChatRoomGroup_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_leavechatroomgroup_response_unpack(buf []byte) ?CChatRoom_LeaveChatRoomGroup_Response {
	res := CChatRoom_LeaveChatRoomGroup_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_leavechatroomgroup_response() CChatRoom_LeaveChatRoomGroup_Response {
	return CChatRoom_LeaveChatRoomGroup_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_leavechatroomgroup_response(o CChatRoom_LeaveChatRoomGroup_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_leavechatroomgroup_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_LeaveChatRoomGroup_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_leavechatroomgroup_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_CreateChatRoom_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	name              string
	has_name          bool
	allow_voice       bool
	has_allow_voice   bool
}

pub fn (o &CChatRoom_CreateChatRoom_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	if o.has_allow_voice {
		res << vproto.pack_bool_field(o.allow_voice, 3)
	}
	return res
}

pub fn cchatroom_createchatroom_request_unpack(buf []byte) ?CChatRoom_CreateChatRoom_Request {
	mut res := CChatRoom_CreateChatRoom_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				res.has_allow_voice = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.allow_voice = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_createchatroom_request() CChatRoom_CreateChatRoom_Request {
	return CChatRoom_CreateChatRoom_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_createchatroom_request(o CChatRoom_CreateChatRoom_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_createchatroom_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_CreateChatRoom_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_createchatroom_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_CreateChatRoom_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	chat_room      CChatRoomState
	has_chat_room  bool
}

pub fn (o &CChatRoom_CreateChatRoom_Response) pack() []byte {
	mut res := []byte{}
	if o.has_chat_room {
		res << zzz_vproto_internal_pack_cchatroomstate(o.chat_room, 1)
	}
	return res
}

pub fn cchatroom_createchatroom_response_unpack(buf []byte) ?CChatRoom_CreateChatRoom_Response {
	mut res := CChatRoom_CreateChatRoom_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_room = true
				ii, v := zzz_vproto_internal_unpack_cchatroomstate(cur_buf, tag_wiretype.wire_type)?
				res.chat_room = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_createchatroom_response() CChatRoom_CreateChatRoom_Response {
	return CChatRoom_CreateChatRoom_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_createchatroom_response(o CChatRoom_CreateChatRoom_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_createchatroom_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_CreateChatRoom_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_createchatroom_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_DeleteChatRoom_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
}

pub fn (o &CChatRoom_DeleteChatRoom_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	return res
}

pub fn cchatroom_deletechatroom_request_unpack(buf []byte) ?CChatRoom_DeleteChatRoom_Request {
	mut res := CChatRoom_DeleteChatRoom_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_deletechatroom_request() CChatRoom_DeleteChatRoom_Request {
	return CChatRoom_DeleteChatRoom_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_deletechatroom_request(o CChatRoom_DeleteChatRoom_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_deletechatroom_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_DeleteChatRoom_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_deletechatroom_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_DeleteChatRoom_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_DeleteChatRoom_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_deletechatroom_response_unpack(buf []byte) ?CChatRoom_DeleteChatRoom_Response {
	res := CChatRoom_DeleteChatRoom_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_deletechatroom_response() CChatRoom_DeleteChatRoom_Response {
	return CChatRoom_DeleteChatRoom_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_deletechatroom_response(o CChatRoom_DeleteChatRoom_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_deletechatroom_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_DeleteChatRoom_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_deletechatroom_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_RenameChatRoom_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
	name              string
	has_name          bool
}

pub fn (o &CChatRoom_RenameChatRoom_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 3)
	}
	return res
}

pub fn cchatroom_renamechatroom_request_unpack(buf []byte) ?CChatRoom_RenameChatRoom_Request {
	mut res := CChatRoom_RenameChatRoom_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_renamechatroom_request() CChatRoom_RenameChatRoom_Request {
	return CChatRoom_RenameChatRoom_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_renamechatroom_request(o CChatRoom_RenameChatRoom_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_renamechatroom_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_RenameChatRoom_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_renamechatroom_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_RenameChatRoom_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_RenameChatRoom_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_renamechatroom_response_unpack(buf []byte) ?CChatRoom_RenameChatRoom_Response {
	res := CChatRoom_RenameChatRoom_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_renamechatroom_response() CChatRoom_RenameChatRoom_Response {
	return CChatRoom_RenameChatRoom_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_renamechatroom_response(o CChatRoom_RenameChatRoom_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_renamechatroom_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_RenameChatRoom_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_renamechatroom_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_ReorderChatRoom_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	chat_group_id          u64
	has_chat_group_id      bool
	chat_id                u64
	has_chat_id            bool
	move_after_chat_id     u64
	has_move_after_chat_id bool
}

pub fn (o &CChatRoom_ReorderChatRoom_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_move_after_chat_id {
		res << vproto.pack_uint64_field(o.move_after_chat_id, 3)
	}
	return res
}

pub fn cchatroom_reorderchatroom_request_unpack(buf []byte) ?CChatRoom_ReorderChatRoom_Request {
	mut res := CChatRoom_ReorderChatRoom_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_move_after_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.move_after_chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_reorderchatroom_request() CChatRoom_ReorderChatRoom_Request {
	return CChatRoom_ReorderChatRoom_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_reorderchatroom_request(o CChatRoom_ReorderChatRoom_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_reorderchatroom_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_ReorderChatRoom_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_reorderchatroom_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_ReorderChatRoom_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_ReorderChatRoom_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_reorderchatroom_response_unpack(buf []byte) ?CChatRoom_ReorderChatRoom_Response {
	res := CChatRoom_ReorderChatRoom_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_reorderchatroom_response() CChatRoom_ReorderChatRoom_Response {
	return CChatRoom_ReorderChatRoom_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_reorderchatroom_response(o CChatRoom_ReorderChatRoom_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_reorderchatroom_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_ReorderChatRoom_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_reorderchatroom_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SendChatMessage_Request {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	chat_group_id      u64
	has_chat_group_id  bool
	chat_id            u64
	has_chat_id        bool
	message            string
	has_message        bool
	echo_to_sender     bool
	has_echo_to_sender bool
}

pub fn (o &CChatRoom_SendChatMessage_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 3)
	}
	if o.has_echo_to_sender {
		res << vproto.pack_bool_field(o.echo_to_sender, 4)
	}
	return res
}

pub fn cchatroom_sendchatmessage_request_unpack(buf []byte) ?CChatRoom_SendChatMessage_Request {
	mut res := CChatRoom_SendChatMessage_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			4 {
				res.has_echo_to_sender = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.echo_to_sender = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_sendchatmessage_request() CChatRoom_SendChatMessage_Request {
	return CChatRoom_SendChatMessage_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_sendchatmessage_request(o CChatRoom_SendChatMessage_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_sendchatmessage_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SendChatMessage_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_sendchatmessage_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SendChatMessage_Response {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	modified_message            string
	has_modified_message        bool
	server_timestamp            u32
	has_server_timestamp        bool
	ordinal                     u32
	has_ordinal                 bool
	message_without_bb_code     string
	has_message_without_bb_code bool
}

pub fn (o &CChatRoom_SendChatMessage_Response) pack() []byte {
	mut res := []byte{}
	if o.has_modified_message {
		res << vproto.pack_string_field(o.modified_message, 1)
	}
	if o.has_server_timestamp {
		res << vproto.pack_uint32_field(o.server_timestamp, 2)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 3)
	}
	if o.has_message_without_bb_code {
		res << vproto.pack_string_field(o.message_without_bb_code, 4)
	}
	return res
}

pub fn cchatroom_sendchatmessage_response_unpack(buf []byte) ?CChatRoom_SendChatMessage_Response {
	mut res := CChatRoom_SendChatMessage_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_modified_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.modified_message = v
				i = ii
			}
			2 {
				res.has_server_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.server_timestamp = v
				i = ii
			}
			3 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			4 {
				res.has_message_without_bb_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message_without_bb_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_sendchatmessage_response() CChatRoom_SendChatMessage_Response {
	return CChatRoom_SendChatMessage_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_sendchatmessage_response(o CChatRoom_SendChatMessage_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_sendchatmessage_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SendChatMessage_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_sendchatmessage_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_JoinVoiceChat_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
}

pub fn (o &CChatRoom_JoinVoiceChat_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	return res
}

pub fn cchatroom_joinvoicechat_request_unpack(buf []byte) ?CChatRoom_JoinVoiceChat_Request {
	mut res := CChatRoom_JoinVoiceChat_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_joinvoicechat_request() CChatRoom_JoinVoiceChat_Request {
	return CChatRoom_JoinVoiceChat_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_joinvoicechat_request(o CChatRoom_JoinVoiceChat_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_joinvoicechat_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_JoinVoiceChat_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_joinvoicechat_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_JoinVoiceChat_Response {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	voice_chatid     u64
	has_voice_chatid bool
}

pub fn (o &CChatRoom_JoinVoiceChat_Response) pack() []byte {
	mut res := []byte{}
	if o.has_voice_chatid {
		res << vproto.pack_uint64_field(o.voice_chatid, 1)
	}
	return res
}

pub fn cchatroom_joinvoicechat_response_unpack(buf []byte) ?CChatRoom_JoinVoiceChat_Response {
	mut res := CChatRoom_JoinVoiceChat_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_voice_chatid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_chatid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_joinvoicechat_response() CChatRoom_JoinVoiceChat_Response {
	return CChatRoom_JoinVoiceChat_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_joinvoicechat_response(o CChatRoom_JoinVoiceChat_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_joinvoicechat_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_JoinVoiceChat_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_joinvoicechat_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_LeaveVoiceChat_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
}

pub fn (o &CChatRoom_LeaveVoiceChat_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	return res
}

pub fn cchatroom_leavevoicechat_request_unpack(buf []byte) ?CChatRoom_LeaveVoiceChat_Request {
	mut res := CChatRoom_LeaveVoiceChat_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_leavevoicechat_request() CChatRoom_LeaveVoiceChat_Request {
	return CChatRoom_LeaveVoiceChat_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_leavevoicechat_request(o CChatRoom_LeaveVoiceChat_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_leavevoicechat_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_LeaveVoiceChat_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_leavevoicechat_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_LeaveVoiceChat_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_LeaveVoiceChat_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_leavevoicechat_response_unpack(buf []byte) ?CChatRoom_LeaveVoiceChat_Response {
	res := CChatRoom_LeaveVoiceChat_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_leavevoicechat_response() CChatRoom_LeaveVoiceChat_Response {
	return CChatRoom_LeaveVoiceChat_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_leavevoicechat_response(o CChatRoom_LeaveVoiceChat_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_leavevoicechat_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_LeaveVoiceChat_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_leavevoicechat_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetMessageHistory_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
	last_time         u32
	has_last_time     bool
	last_ordinal      u32
	has_last_ordinal  bool
	start_time        u32
	has_start_time    bool
	start_ordinal     u32
	has_start_ordinal bool
	max_count         u32
	has_max_count     bool
}

pub fn (o &CChatRoom_GetMessageHistory_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_last_time {
		res << vproto.pack_uint32_field(o.last_time, 3)
	}
	if o.has_last_ordinal {
		res << vproto.pack_uint32_field(o.last_ordinal, 4)
	}
	if o.has_start_time {
		res << vproto.pack_uint32_field(o.start_time, 5)
	}
	if o.has_start_ordinal {
		res << vproto.pack_uint32_field(o.start_ordinal, 6)
	}
	if o.has_max_count {
		res << vproto.pack_uint32_field(o.max_count, 7)
	}
	return res
}

pub fn cchatroom_getmessagehistory_request_unpack(buf []byte) ?CChatRoom_GetMessageHistory_Request {
	mut res := CChatRoom_GetMessageHistory_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_last_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_time = v
				i = ii
			}
			4 {
				res.has_last_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_ordinal = v
				i = ii
			}
			5 {
				res.has_start_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_time = v
				i = ii
			}
			6 {
				res.has_start_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_ordinal = v
				i = ii
			}
			7 {
				res.has_max_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getmessagehistory_request() CChatRoom_GetMessageHistory_Request {
	return CChatRoom_GetMessageHistory_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getmessagehistory_request(o CChatRoom_GetMessageHistory_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getmessagehistory_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetMessageHistory_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getmessagehistory_request_unpack(v)?
	return i, unpacked
}

pub struct ServerMessage {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	message             EChatRoomServerMessage
	has_message         bool
	string_param        string
	has_string_param    bool
	accountid_param     u32
	has_accountid_param bool
}

pub fn (o &ServerMessage) pack() []byte {
	mut res := []byte{}
	if o.has_message {
		res << zzz_vproto_internal_pack_echatroomservermessage(o.message, 1)
	}
	if o.has_string_param {
		res << vproto.pack_string_field(o.string_param, 2)
	}
	if o.has_accountid_param {
		res << vproto.pack_uint32_field(o.accountid_param, 3)
	}
	return res
}

pub fn servermessage_unpack(buf []byte) ?ServerMessage {
	mut res := ServerMessage{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_message = true
				ii, v := zzz_vproto_internal_unpack_echatroomservermessage(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			2 {
				res.has_string_param = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.string_param = v
				i = ii
			}
			3 {
				res.has_accountid_param = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_param = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_servermessage() ServerMessage {
	return ServerMessage{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_servermessage(o ServerMessage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_servermessage(buf []byte, tag_wiretype vproto.WireType) ?(int, ServerMessage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := servermessage_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetMessageHistory_Response_ChatMessage {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	sender               u32
	has_sender           bool
	server_timestamp     u32
	has_server_timestamp bool
	message              string
	has_message          bool
	ordinal              u32
	has_ordinal          bool
	server_message       ServerMessage
	has_server_message   bool
	deleted              bool
	has_deleted          bool
}

pub fn (o &CChatRoom_GetMessageHistory_Response_ChatMessage) pack() []byte {
	mut res := []byte{}
	if o.has_sender {
		res << vproto.pack_uint32_field(o.sender, 1)
	}
	if o.has_server_timestamp {
		res << vproto.pack_uint32_field(o.server_timestamp, 2)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 3)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 4)
	}
	if o.has_server_message {
		res << zzz_vproto_internal_pack_servermessage(o.server_message, 5)
	}
	if o.has_deleted {
		res << vproto.pack_bool_field(o.deleted, 6)
	}
	return res
}

pub fn cchatroom_getmessagehistory_response_chatmessage_unpack(buf []byte) ?CChatRoom_GetMessageHistory_Response_ChatMessage {
	mut res := CChatRoom_GetMessageHistory_Response_ChatMessage{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sender = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sender = v
				i = ii
			}
			2 {
				res.has_server_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.server_timestamp = v
				i = ii
			}
			3 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			4 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			5 {
				res.has_server_message = true
				ii, v := zzz_vproto_internal_unpack_servermessage(cur_buf, tag_wiretype.wire_type)?
				res.server_message = v
				i = ii
			}
			6 {
				res.has_deleted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.deleted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getmessagehistory_response_chatmessage() CChatRoom_GetMessageHistory_Response_ChatMessage {
	return CChatRoom_GetMessageHistory_Response_ChatMessage{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getmessagehistory_response_chatmessage(o CChatRoom_GetMessageHistory_Response_ChatMessage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getmessagehistory_response_chatmessage(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetMessageHistory_Response_ChatMessage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getmessagehistory_response_chatmessage_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetMessageHistory_Response {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	messages           []CChatRoom_GetMessageHistory_Response_ChatMessage
	more_available     bool
	has_more_available bool
}

pub fn (o &CChatRoom_GetMessageHistory_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.messages {
		res << zzz_vproto_internal_pack_cchatroom_getmessagehistory_response_chatmessage(x, 1)
	}
	if o.has_more_available {
		res << vproto.pack_bool_field(o.more_available, 4)
	}
	return res
}

pub fn cchatroom_getmessagehistory_response_unpack(buf []byte) ?CChatRoom_GetMessageHistory_Response {
	mut res := CChatRoom_GetMessageHistory_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroom_getmessagehistory_response_chatmessage(cur_buf,
					tag_wiretype.wire_type)?
				res.messages << v
				i = ii
			}
			4 {
				res.has_more_available = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.more_available = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getmessagehistory_response() CChatRoom_GetMessageHistory_Response {
	return CChatRoom_GetMessageHistory_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getmessagehistory_response(o CChatRoom_GetMessageHistory_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getmessagehistory_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetMessageHistory_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getmessagehistory_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetMyChatRoomGroups_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_GetMyChatRoomGroups_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_getmychatroomgroups_request_unpack(buf []byte) ?CChatRoom_GetMyChatRoomGroups_Request {
	res := CChatRoom_GetMyChatRoomGroups_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getmychatroomgroups_request() CChatRoom_GetMyChatRoomGroups_Request {
	return CChatRoom_GetMyChatRoomGroups_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getmychatroomgroups_request(o CChatRoom_GetMyChatRoomGroups_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getmychatroomgroups_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetMyChatRoomGroups_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getmychatroomgroups_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetChatRoomGroupSummary_Response {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	chat_group_id                     u64
	has_chat_group_id                 bool
	chat_group_name                   string
	has_chat_group_name               bool
	active_member_count               u32
	has_active_member_count           bool
	active_voice_member_count         u32
	has_active_voice_member_count     bool
	default_chat_id                   u64
	has_default_chat_id               bool
	chat_rooms                        []CChatRoomState
	clanid                            u32
	has_clanid                        bool
	chat_group_tagline                string
	has_chat_group_tagline            bool
	accountid_owner                   u32
	has_accountid_owner               bool
	top_members                       []u32
	chat_group_avatar_sha             []byte
	has_chat_group_avatar_sha         bool
	rank                              EChatRoomGroupRank
	has_rank                          bool
	default_role_id                   u64
	has_default_role_id               bool
	role_ids                          []u64
	role_actions                      []CChatRoleActions
	watching_broadcast_accountid      u32
	has_watching_broadcast_accountid  bool
	appid                             u32
	has_appid                         bool
	party_beacons                     []CChatPartyBeacon
	watching_broadcast_channel_id     u64
	has_watching_broadcast_channel_id bool
	active_minigame_id                u64
	has_active_minigame_id            bool
	avatar_ugc_url                    string
	has_avatar_ugc_url                bool
}

pub fn (o &CChatRoom_GetChatRoomGroupSummary_Response) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_group_name {
		res << vproto.pack_string_field(o.chat_group_name, 2)
	}
	if o.has_active_member_count {
		res << vproto.pack_uint32_field(o.active_member_count, 3)
	}
	if o.has_active_voice_member_count {
		res << vproto.pack_uint32_field(o.active_voice_member_count, 4)
	}
	if o.has_default_chat_id {
		res << vproto.pack_uint64_field(o.default_chat_id, 5)
	}
	// [packed=false]
	for _, x in o.chat_rooms {
		res << zzz_vproto_internal_pack_cchatroomstate(x, 6)
	}
	if o.has_clanid {
		res << vproto.pack_uint32_field(o.clanid, 7)
	}
	if o.has_chat_group_tagline {
		res << vproto.pack_string_field(o.chat_group_tagline, 8)
	}
	if o.has_accountid_owner {
		res << vproto.pack_uint32_field(o.accountid_owner, 9)
	}
	// [packed=false]
	for _, x in o.top_members {
		res << vproto.pack_uint32_field(x, 10)
	}
	if o.has_chat_group_avatar_sha {
		res << vproto.pack_bytes_field(o.chat_group_avatar_sha, 11)
	}
	if o.has_rank {
		res << zzz_vproto_internal_pack_echatroomgrouprank(o.rank, 12)
	}
	if o.has_default_role_id {
		res << vproto.pack_uint64_field(o.default_role_id, 13)
	}
	// [packed=false]
	for _, x in o.role_ids {
		res << vproto.pack_uint64_field(x, 14)
	}
	// [packed=false]
	for _, x in o.role_actions {
		res << zzz_vproto_internal_pack_cchatroleactions(x, 15)
	}
	if o.has_watching_broadcast_accountid {
		res << vproto.pack_uint32_field(o.watching_broadcast_accountid, 16)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 17)
	}
	// [packed=false]
	for _, x in o.party_beacons {
		res << zzz_vproto_internal_pack_cchatpartybeacon(x, 18)
	}
	if o.has_watching_broadcast_channel_id {
		res << vproto.pack_uint64_field(o.watching_broadcast_channel_id, 19)
	}
	if o.has_active_minigame_id {
		res << vproto.pack_uint64_field(o.active_minigame_id, 20)
	}
	if o.has_avatar_ugc_url {
		res << vproto.pack_string_field(o.avatar_ugc_url, 21)
	}
	return res
}

pub fn cchatroom_getchatroomgroupsummary_response_unpack(buf []byte) ?CChatRoom_GetChatRoomGroupSummary_Response {
	mut res := CChatRoom_GetChatRoomGroupSummary_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_group_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_name = v
				i = ii
			}
			3 {
				res.has_active_member_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.active_member_count = v
				i = ii
			}
			4 {
				res.has_active_voice_member_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.active_voice_member_count = v
				i = ii
			}
			5 {
				res.has_default_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.default_chat_id = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomstate(cur_buf, tag_wiretype.wire_type)?
				res.chat_rooms << v
				i = ii
			}
			7 {
				res.has_clanid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.clanid = v
				i = ii
			}
			8 {
				res.has_chat_group_tagline = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_tagline = v
				i = ii
			}
			9 {
				res.has_accountid_owner = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_owner = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.top_members << v
				i = ii
			}
			11 {
				res.has_chat_group_avatar_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_avatar_sha = v
				i = ii
			}
			12 {
				res.has_rank = true
				ii, v := zzz_vproto_internal_unpack_echatroomgrouprank(cur_buf, tag_wiretype.wire_type)?
				res.rank = v
				i = ii
			}
			13 {
				res.has_default_role_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.default_role_id = v
				i = ii
			}
			14 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.role_ids << v
				i = ii
			}
			15 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroleactions(cur_buf, tag_wiretype.wire_type)?
				res.role_actions << v
				i = ii
			}
			16 {
				res.has_watching_broadcast_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_accountid = v
				i = ii
			}
			17 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			18 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatpartybeacon(cur_buf, tag_wiretype.wire_type)?
				res.party_beacons << v
				i = ii
			}
			19 {
				res.has_watching_broadcast_channel_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_channel_id = v
				i = ii
			}
			20 {
				res.has_active_minigame_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.active_minigame_id = v
				i = ii
			}
			21 {
				res.has_avatar_ugc_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.avatar_ugc_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getchatroomgroupsummary_response() CChatRoom_GetChatRoomGroupSummary_Response {
	return CChatRoom_GetChatRoomGroupSummary_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getchatroomgroupsummary_response(o CChatRoom_GetChatRoomGroupSummary_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getchatroomgroupsummary_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetChatRoomGroupSummary_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getchatroomgroupsummary_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomSummaryPair {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	user_chat_group_state     CUserChatRoomGroupState
	has_user_chat_group_state bool
	group_summary             CChatRoom_GetChatRoomGroupSummary_Response
	has_group_summary         bool
}

pub fn (o &CChatRoomSummaryPair) pack() []byte {
	mut res := []byte{}
	if o.has_user_chat_group_state {
		res << zzz_vproto_internal_pack_cuserchatroomgroupstate(o.user_chat_group_state, 1)
	}
	if o.has_group_summary {
		res <<
			zzz_vproto_internal_pack_cchatroom_getchatroomgroupsummary_response(o.group_summary, 2)
	}
	return res
}

pub fn cchatroomsummarypair_unpack(buf []byte) ?CChatRoomSummaryPair {
	mut res := CChatRoomSummaryPair{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_user_chat_group_state = true
				ii, v := zzz_vproto_internal_unpack_cuserchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.user_chat_group_state = v
				i = ii
			}
			2 {
				res.has_group_summary = true
				ii, v := zzz_vproto_internal_unpack_cchatroom_getchatroomgroupsummary_response(cur_buf,
					tag_wiretype.wire_type)?
				res.group_summary = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomsummarypair() CChatRoomSummaryPair {
	return CChatRoomSummaryPair{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomsummarypair(o CChatRoomSummaryPair, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomsummarypair(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomSummaryPair) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomsummarypair_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetMyChatRoomGroups_Response {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	chat_room_groups []CChatRoomSummaryPair
}

pub fn (o &CChatRoom_GetMyChatRoomGroups_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.chat_room_groups {
		res << zzz_vproto_internal_pack_cchatroomsummarypair(x, 1)
	}
	return res
}

pub fn cchatroom_getmychatroomgroups_response_unpack(buf []byte) ?CChatRoom_GetMyChatRoomGroups_Response {
	mut res := CChatRoom_GetMyChatRoomGroups_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomsummarypair(cur_buf, tag_wiretype.wire_type)?
				res.chat_room_groups << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getmychatroomgroups_response() CChatRoom_GetMyChatRoomGroups_Response {
	return CChatRoom_GetMyChatRoomGroups_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getmychatroomgroups_response(o CChatRoom_GetMyChatRoomGroups_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getmychatroomgroups_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetMyChatRoomGroups_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getmychatroomgroups_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetChatRoomGroupState_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoom_GetChatRoomGroupState_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroom_getchatroomgroupstate_request_unpack(buf []byte) ?CChatRoom_GetChatRoomGroupState_Request {
	mut res := CChatRoom_GetChatRoomGroupState_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getchatroomgroupstate_request() CChatRoom_GetChatRoomGroupState_Request {
	return CChatRoom_GetChatRoomGroupState_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getchatroomgroupstate_request(o CChatRoom_GetChatRoomGroupState_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getchatroomgroupstate_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetChatRoomGroupState_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getchatroomgroupstate_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetChatRoomGroupState_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	state          CChatRoomGroupState
	has_state      bool
}

pub fn (o &CChatRoom_GetChatRoomGroupState_Response) pack() []byte {
	mut res := []byte{}
	if o.has_state {
		res << zzz_vproto_internal_pack_cchatroomgroupstate(o.state, 1)
	}
	return res
}

pub fn cchatroom_getchatroomgroupstate_response_unpack(buf []byte) ?CChatRoom_GetChatRoomGroupState_Response {
	mut res := CChatRoom_GetChatRoomGroupState_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_state = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getchatroomgroupstate_response() CChatRoom_GetChatRoomGroupState_Response {
	return CChatRoom_GetChatRoomGroupState_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getchatroomgroupstate_response(o CChatRoom_GetChatRoomGroupState_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getchatroomgroupstate_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetChatRoomGroupState_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getchatroomgroupstate_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetChatRoomGroupSummary_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoom_GetChatRoomGroupSummary_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroom_getchatroomgroupsummary_request_unpack(buf []byte) ?CChatRoom_GetChatRoomGroupSummary_Request {
	mut res := CChatRoom_GetChatRoomGroupSummary_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getchatroomgroupsummary_request() CChatRoom_GetChatRoomGroupSummary_Request {
	return CChatRoom_GetChatRoomGroupSummary_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getchatroomgroupsummary_request(o CChatRoom_GetChatRoomGroupSummary_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getchatroomgroupsummary_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetChatRoomGroupSummary_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getchatroomgroupsummary_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetAppChatRoomGroupForceActive_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	chat_group_id         u64
	has_chat_group_id     bool
	requesting_app_id     u32
	has_requesting_app_id bool
}

pub fn (o &CChatRoom_SetAppChatRoomGroupForceActive_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_requesting_app_id {
		res << vproto.pack_uint32_field(o.requesting_app_id, 2)
	}
	return res
}

pub fn cchatroom_setappchatroomgroupforceactive_request_unpack(buf []byte) ?CChatRoom_SetAppChatRoomGroupForceActive_Request {
	mut res := CChatRoom_SetAppChatRoomGroupForceActive_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_requesting_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.requesting_app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setappchatroomgroupforceactive_request() CChatRoom_SetAppChatRoomGroupForceActive_Request {
	return CChatRoom_SetAppChatRoomGroupForceActive_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setappchatroomgroupforceactive_request(o CChatRoom_SetAppChatRoomGroupForceActive_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setappchatroomgroupforceactive_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetAppChatRoomGroupForceActive_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setappchatroomgroupforceactive_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetAppChatRoomGroupForceActive_Response {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	result              u32
	has_result          bool
	accounts_in_channel []u32
}

pub fn (o &CChatRoom_SetAppChatRoomGroupForceActive_Response) pack() []byte {
	mut res := []byte{}
	if o.has_result {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	// [packed=false]
	for _, x in o.accounts_in_channel {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cchatroom_setappchatroomgroupforceactive_response_unpack(buf []byte) ?CChatRoom_SetAppChatRoomGroupForceActive_Response {
	mut res := CChatRoom_SetAppChatRoomGroupForceActive_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accounts_in_channel << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setappchatroomgroupforceactive_response() CChatRoom_SetAppChatRoomGroupForceActive_Response {
	return CChatRoom_SetAppChatRoomGroupForceActive_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setappchatroomgroupforceactive_response(o CChatRoom_SetAppChatRoomGroupForceActive_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setappchatroomgroupforceactive_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetAppChatRoomGroupForceActive_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setappchatroomgroupforceactive_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	chat_group_id         u64
	has_chat_group_id     bool
	requesting_app_id     u32
	has_requesting_app_id bool
}

pub fn (o &CChatRoom_SetAppChatRoomGroupStopForceActive_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_requesting_app_id {
		res << vproto.pack_uint32_field(o.requesting_app_id, 2)
	}
	return res
}

pub fn cchatroom_setappchatroomgroupstopforceactive_notification_unpack(buf []byte) ?CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
	mut res := CChatRoom_SetAppChatRoomGroupStopForceActive_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_requesting_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.requesting_app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setappchatroomgroupstopforceactive_notification() CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
	return CChatRoom_SetAppChatRoomGroupStopForceActive_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setappchatroomgroupstopforceactive_notification(o CChatRoom_SetAppChatRoomGroupStopForceActive_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setappchatroomgroupstopforceactive_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetAppChatRoomGroupStopForceActive_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setappchatroomgroupstopforceactive_notification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_AckChatMessage_Notification {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
	timestamp         u32
	has_timestamp     bool
}

pub fn (o &CChatRoom_AckChatMessage_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 3)
	}
	return res
}

pub fn cchatroom_ackchatmessage_notification_unpack(buf []byte) ?CChatRoom_AckChatMessage_Notification {
	mut res := CChatRoom_AckChatMessage_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_ackchatmessage_notification() CChatRoom_AckChatMessage_Notification {
	return CChatRoom_AckChatMessage_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_ackchatmessage_notification(o CChatRoom_AckChatMessage_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_ackchatmessage_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_AckChatMessage_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_ackchatmessage_notification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_CreateInviteLink_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	seconds_valid     u32
	has_seconds_valid bool
	chat_id           u64
	has_chat_id       bool
}

pub fn (o &CChatRoom_CreateInviteLink_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_seconds_valid {
		res << vproto.pack_uint32_field(o.seconds_valid, 2)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 3)
	}
	return res
}

pub fn cchatroom_createinvitelink_request_unpack(buf []byte) ?CChatRoom_CreateInviteLink_Request {
	mut res := CChatRoom_CreateInviteLink_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_seconds_valid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_valid = v
				i = ii
			}
			3 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_createinvitelink_request() CChatRoom_CreateInviteLink_Request {
	return CChatRoom_CreateInviteLink_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_createinvitelink_request(o CChatRoom_CreateInviteLink_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_createinvitelink_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_CreateInviteLink_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_createinvitelink_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_CreateInviteLink_Response {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	invite_code       string
	has_invite_code   bool
	seconds_valid     u32
	has_seconds_valid bool
}

pub fn (o &CChatRoom_CreateInviteLink_Response) pack() []byte {
	mut res := []byte{}
	if o.has_invite_code {
		res << vproto.pack_string_field(o.invite_code, 1)
	}
	if o.has_seconds_valid {
		res << vproto.pack_uint32_field(o.seconds_valid, 2)
	}
	return res
}

pub fn cchatroom_createinvitelink_response_unpack(buf []byte) ?CChatRoom_CreateInviteLink_Response {
	mut res := CChatRoom_CreateInviteLink_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_invite_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_code = v
				i = ii
			}
			2 {
				res.has_seconds_valid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_valid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_createinvitelink_response() CChatRoom_CreateInviteLink_Response {
	return CChatRoom_CreateInviteLink_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_createinvitelink_response(o CChatRoom_CreateInviteLink_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_createinvitelink_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_CreateInviteLink_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_createinvitelink_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetInviteLinkInfo_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	invite_code     string
	has_invite_code bool
}

pub fn (o &CChatRoom_GetInviteLinkInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.has_invite_code {
		res << vproto.pack_string_field(o.invite_code, 1)
	}
	return res
}

pub fn cchatroom_getinvitelinkinfo_request_unpack(buf []byte) ?CChatRoom_GetInviteLinkInfo_Request {
	mut res := CChatRoom_GetInviteLinkInfo_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_invite_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getinvitelinkinfo_request() CChatRoom_GetInviteLinkInfo_Request {
	return CChatRoom_GetInviteLinkInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getinvitelinkinfo_request(o CChatRoom_GetInviteLinkInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getinvitelinkinfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetInviteLinkInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getinvitelinkinfo_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetInviteLinkInfo_Response {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	steamid_sender            u64
	has_steamid_sender        bool
	time_expires              u32
	has_time_expires          bool
	chat_id                   u64
	has_chat_id               bool
	group_summary             CChatRoom_GetChatRoomGroupSummary_Response
	has_group_summary         bool
	user_chat_group_state     CUserChatRoomGroupState
	has_user_chat_group_state bool
	time_kick_expire          u32
	has_time_kick_expire      bool
	banned                    bool
	has_banned                bool
}

pub fn (o &CChatRoom_GetInviteLinkInfo_Response) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_sender {
		res << vproto.pack_64bit_field(o.steamid_sender, 3)
	}
	if o.has_time_expires {
		res << vproto.pack_uint32_field(o.time_expires, 4)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 6)
	}
	if o.has_group_summary {
		res <<
			zzz_vproto_internal_pack_cchatroom_getchatroomgroupsummary_response(o.group_summary, 8)
	}
	if o.has_user_chat_group_state {
		res << zzz_vproto_internal_pack_cuserchatroomgroupstate(o.user_chat_group_state, 9)
	}
	if o.has_time_kick_expire {
		res << vproto.pack_uint32_field(o.time_kick_expire, 10)
	}
	if o.has_banned {
		res << vproto.pack_bool_field(o.banned, 11)
	}
	return res
}

pub fn cchatroom_getinvitelinkinfo_response_unpack(buf []byte) ?CChatRoom_GetInviteLinkInfo_Response {
	mut res := CChatRoom_GetInviteLinkInfo_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			3 {
				res.has_steamid_sender = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_sender = v
				i = ii
			}
			4 {
				res.has_time_expires = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_expires = v
				i = ii
			}
			6 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			8 {
				res.has_group_summary = true
				ii, v := zzz_vproto_internal_unpack_cchatroom_getchatroomgroupsummary_response(cur_buf,
					tag_wiretype.wire_type)?
				res.group_summary = v
				i = ii
			}
			9 {
				res.has_user_chat_group_state = true
				ii, v := zzz_vproto_internal_unpack_cuserchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.user_chat_group_state = v
				i = ii
			}
			10 {
				res.has_time_kick_expire = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_kick_expire = v
				i = ii
			}
			11 {
				res.has_banned = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.banned = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getinvitelinkinfo_response() CChatRoom_GetInviteLinkInfo_Response {
	return CChatRoom_GetInviteLinkInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getinvitelinkinfo_response(o CChatRoom_GetInviteLinkInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getinvitelinkinfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetInviteLinkInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getinvitelinkinfo_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetInviteInfo_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	steamid_invitee     u64
	has_steamid_invitee bool
	chat_group_id       u64
	has_chat_group_id   bool
	chat_id             u64
	has_chat_id         bool
	invite_code         string
	has_invite_code     bool
}

pub fn (o &CChatRoom_GetInviteInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_invitee {
		res << vproto.pack_64bit_field(o.steamid_invitee, 1)
	}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 2)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 3)
	}
	if o.has_invite_code {
		res << vproto.pack_string_field(o.invite_code, 4)
	}
	return res
}

pub fn cchatroom_getinviteinfo_request_unpack(buf []byte) ?CChatRoom_GetInviteInfo_Request {
	mut res := CChatRoom_GetInviteInfo_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_invitee = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_invitee = v
				i = ii
			}
			2 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			3 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			4 {
				res.has_invite_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getinviteinfo_request() CChatRoom_GetInviteInfo_Request {
	return CChatRoom_GetInviteInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getinviteinfo_request(o CChatRoom_GetInviteInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getinviteinfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetInviteInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getinviteinfo_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetInviteInfo_Response {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	group_summary        CChatRoom_GetChatRoomGroupSummary_Response
	has_group_summary    bool
	time_kick_expire     u32
	has_time_kick_expire bool
	banned               bool
	has_banned           bool
}

pub fn (o &CChatRoom_GetInviteInfo_Response) pack() []byte {
	mut res := []byte{}
	if o.has_group_summary {
		res <<
			zzz_vproto_internal_pack_cchatroom_getchatroomgroupsummary_response(o.group_summary, 1)
	}
	if o.has_time_kick_expire {
		res << vproto.pack_uint32_field(o.time_kick_expire, 2)
	}
	if o.has_banned {
		res << vproto.pack_bool_field(o.banned, 3)
	}
	return res
}

pub fn cchatroom_getinviteinfo_response_unpack(buf []byte) ?CChatRoom_GetInviteInfo_Response {
	mut res := CChatRoom_GetInviteInfo_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_group_summary = true
				ii, v := zzz_vproto_internal_unpack_cchatroom_getchatroomgroupsummary_response(cur_buf,
					tag_wiretype.wire_type)?
				res.group_summary = v
				i = ii
			}
			2 {
				res.has_time_kick_expire = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_kick_expire = v
				i = ii
			}
			3 {
				res.has_banned = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.banned = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getinviteinfo_response() CChatRoom_GetInviteInfo_Response {
	return CChatRoom_GetInviteInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getinviteinfo_response(o CChatRoom_GetInviteInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getinviteinfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetInviteInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getinviteinfo_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetInviteLinksForGroup_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoom_GetInviteLinksForGroup_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroom_getinvitelinksforgroup_request_unpack(buf []byte) ?CChatRoom_GetInviteLinksForGroup_Request {
	mut res := CChatRoom_GetInviteLinksForGroup_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getinvitelinksforgroup_request() CChatRoom_GetInviteLinksForGroup_Request {
	return CChatRoom_GetInviteLinksForGroup_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getinvitelinksforgroup_request(o CChatRoom_GetInviteLinksForGroup_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getinvitelinksforgroup_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetInviteLinksForGroup_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getinvitelinksforgroup_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	invite_code         string
	has_invite_code     bool
	steamid_creator     u64
	has_steamid_creator bool
	time_expires        u32
	has_time_expires    bool
	chat_id             u64
	has_chat_id         bool
}

pub fn (o &CChatRoom_GetInviteLinksForGroup_Response_LinkInfo) pack() []byte {
	mut res := []byte{}
	if o.has_invite_code {
		res << vproto.pack_string_field(o.invite_code, 1)
	}
	if o.has_steamid_creator {
		res << vproto.pack_64bit_field(o.steamid_creator, 2)
	}
	if o.has_time_expires {
		res << vproto.pack_uint32_field(o.time_expires, 3)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 4)
	}
	return res
}

pub fn cchatroom_getinvitelinksforgroup_response_linkinfo_unpack(buf []byte) ?CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
	mut res := CChatRoom_GetInviteLinksForGroup_Response_LinkInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_invite_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_code = v
				i = ii
			}
			2 {
				res.has_steamid_creator = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_creator = v
				i = ii
			}
			3 {
				res.has_time_expires = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_expires = v
				i = ii
			}
			4 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getinvitelinksforgroup_response_linkinfo() CChatRoom_GetInviteLinksForGroup_Response_LinkInfo {
	return CChatRoom_GetInviteLinksForGroup_Response_LinkInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getinvitelinksforgroup_response_linkinfo(o CChatRoom_GetInviteLinksForGroup_Response_LinkInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getinvitelinksforgroup_response_linkinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetInviteLinksForGroup_Response_LinkInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getinvitelinksforgroup_response_linkinfo_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetInviteLinksForGroup_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	invite_links   []CChatRoom_GetInviteLinksForGroup_Response_LinkInfo
}

pub fn (o &CChatRoom_GetInviteLinksForGroup_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.invite_links {
		res << zzz_vproto_internal_pack_cchatroom_getinvitelinksforgroup_response_linkinfo(x, 1)
	}
	return res
}

pub fn cchatroom_getinvitelinksforgroup_response_unpack(buf []byte) ?CChatRoom_GetInviteLinksForGroup_Response {
	mut res := CChatRoom_GetInviteLinksForGroup_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroom_getinvitelinksforgroup_response_linkinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.invite_links << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getinvitelinksforgroup_response() CChatRoom_GetInviteLinksForGroup_Response {
	return CChatRoom_GetInviteLinksForGroup_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getinvitelinksforgroup_response(o CChatRoom_GetInviteLinksForGroup_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getinvitelinksforgroup_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetInviteLinksForGroup_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getinvitelinksforgroup_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetBanList_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoom_GetBanList_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroom_getbanlist_request_unpack(buf []byte) ?CChatRoom_GetBanList_Request {
	mut res := CChatRoom_GetBanList_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getbanlist_request() CChatRoom_GetBanList_Request {
	return CChatRoom_GetBanList_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getbanlist_request(o CChatRoom_GetBanList_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getbanlist_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetBanList_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getbanlist_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetBanList_Response_BanInfo {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	accountid           u32
	has_accountid       bool
	accountid_actor     u32
	has_accountid_actor bool
	time_banned         u32
	has_time_banned     bool
	ban_reason          string
	has_ban_reason      bool
}

pub fn (o &CChatRoom_GetBanList_Response_BanInfo) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 1)
	}
	if o.has_accountid_actor {
		res << vproto.pack_uint32_field(o.accountid_actor, 2)
	}
	if o.has_time_banned {
		res << vproto.pack_uint32_field(o.time_banned, 3)
	}
	if o.has_ban_reason {
		res << vproto.pack_string_field(o.ban_reason, 4)
	}
	return res
}

pub fn cchatroom_getbanlist_response_baninfo_unpack(buf []byte) ?CChatRoom_GetBanList_Response_BanInfo {
	mut res := CChatRoom_GetBanList_Response_BanInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_accountid_actor = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_actor = v
				i = ii
			}
			3 {
				res.has_time_banned = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_banned = v
				i = ii
			}
			4 {
				res.has_ban_reason = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.ban_reason = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getbanlist_response_baninfo() CChatRoom_GetBanList_Response_BanInfo {
	return CChatRoom_GetBanList_Response_BanInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getbanlist_response_baninfo(o CChatRoom_GetBanList_Response_BanInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getbanlist_response_baninfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetBanList_Response_BanInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getbanlist_response_baninfo_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetBanList_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bans           []CChatRoom_GetBanList_Response_BanInfo
}

pub fn (o &CChatRoom_GetBanList_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.bans {
		res << zzz_vproto_internal_pack_cchatroom_getbanlist_response_baninfo(x, 1)
	}
	return res
}

pub fn cchatroom_getbanlist_response_unpack(buf []byte) ?CChatRoom_GetBanList_Response {
	mut res := CChatRoom_GetBanList_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroom_getbanlist_response_baninfo(cur_buf,
					tag_wiretype.wire_type)?
				res.bans << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getbanlist_response() CChatRoom_GetBanList_Response {
	return CChatRoom_GetBanList_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getbanlist_response(o CChatRoom_GetBanList_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getbanlist_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetBanList_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getbanlist_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetInviteList_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoom_GetInviteList_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	return res
}

pub fn cchatroom_getinvitelist_request_unpack(buf []byte) ?CChatRoom_GetInviteList_Request {
	mut res := CChatRoom_GetInviteList_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getinvitelist_request() CChatRoom_GetInviteList_Request {
	return CChatRoom_GetInviteList_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getinvitelist_request(o CChatRoom_GetInviteList_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getinvitelist_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetInviteList_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getinvitelist_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomGroupInvite {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	accountid           u32
	has_accountid       bool
	accountid_actor     u32
	has_accountid_actor bool
	time_invited        u32
	has_time_invited    bool
}

pub fn (o &CChatRoomGroupInvite) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 1)
	}
	if o.has_accountid_actor {
		res << vproto.pack_uint32_field(o.accountid_actor, 2)
	}
	if o.has_time_invited {
		res << vproto.pack_uint32_field(o.time_invited, 3)
	}
	return res
}

pub fn cchatroomgroupinvite_unpack(buf []byte) ?CChatRoomGroupInvite {
	mut res := CChatRoomGroupInvite{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_accountid_actor = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_actor = v
				i = ii
			}
			3 {
				res.has_time_invited = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_invited = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomgroupinvite() CChatRoomGroupInvite {
	return CChatRoomGroupInvite{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomgroupinvite(o CChatRoomGroupInvite, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomgroupinvite(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomGroupInvite) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomgroupinvite_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_GetInviteList_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	invites        []CChatRoomGroupInvite
}

pub fn (o &CChatRoom_GetInviteList_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.invites {
		res << zzz_vproto_internal_pack_cchatroomgroupinvite(x, 1)
	}
	return res
}

pub fn cchatroom_getinvitelist_response_unpack(buf []byte) ?CChatRoom_GetInviteList_Response {
	mut res := CChatRoom_GetInviteList_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupinvite(cur_buf, tag_wiretype.wire_type)?
				res.invites << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_getinvitelist_response() CChatRoom_GetInviteList_Response {
	return CChatRoom_GetInviteList_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_getinvitelist_response(o CChatRoom_GetInviteList_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_getinvitelist_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_GetInviteList_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_getinvitelist_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_DeleteInviteLink_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	invite_code       string
	has_invite_code   bool
}

pub fn (o &CChatRoom_DeleteInviteLink_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_invite_code {
		res << vproto.pack_string_field(o.invite_code, 2)
	}
	return res
}

pub fn cchatroom_deleteinvitelink_request_unpack(buf []byte) ?CChatRoom_DeleteInviteLink_Request {
	mut res := CChatRoom_DeleteInviteLink_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_invite_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_deleteinvitelink_request() CChatRoom_DeleteInviteLink_Request {
	return CChatRoom_DeleteInviteLink_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_deleteinvitelink_request(o CChatRoom_DeleteInviteLink_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_deleteinvitelink_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_DeleteInviteLink_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_deleteinvitelink_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_DeleteInviteLink_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_DeleteInviteLink_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_deleteinvitelink_response_unpack(buf []byte) ?CChatRoom_DeleteInviteLink_Response {
	res := CChatRoom_DeleteInviteLink_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_deleteinvitelink_response() CChatRoom_DeleteInviteLink_Response {
	return CChatRoom_DeleteInviteLink_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_deleteinvitelink_response(o CChatRoom_DeleteInviteLink_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_deleteinvitelink_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_DeleteInviteLink_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_deleteinvitelink_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetSessionActiveChatRoomGroups_Request {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	chat_group_ids                   []u64
	chat_groups_data_requested       []u64
	virtualize_members_threshold     int
	has_virtualize_members_threshold bool
}

pub fn (o &CChatRoom_SetSessionActiveChatRoomGroups_Request) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.chat_group_ids {
		res << vproto.pack_uint64_field(x, 1)
	}
	// [packed=false]
	for _, x in o.chat_groups_data_requested {
		res << vproto.pack_uint64_field(x, 2)
	}
	if o.has_virtualize_members_threshold {
		res << vproto.pack_int32_field(o.virtualize_members_threshold, 3)
	}
	return res
}

pub fn cchatroom_setsessionactivechatroomgroups_request_unpack(buf []byte) ?CChatRoom_SetSessionActiveChatRoomGroups_Request {
	mut res := CChatRoom_SetSessionActiveChatRoomGroups_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_ids << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_groups_data_requested << v
				i = ii
			}
			3 {
				res.has_virtualize_members_threshold = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.virtualize_members_threshold = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setsessionactivechatroomgroups_request() CChatRoom_SetSessionActiveChatRoomGroups_Request {
	return CChatRoom_SetSessionActiveChatRoomGroups_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setsessionactivechatroomgroups_request(o CChatRoom_SetSessionActiveChatRoomGroups_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setsessionactivechatroomgroups_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetSessionActiveChatRoomGroups_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setsessionactivechatroomgroups_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetSessionActiveChatRoomGroups_Response {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	chat_states                       []CChatRoomGroupState
	virtualize_members_chat_group_ids []u64
}

pub fn (o &CChatRoom_SetSessionActiveChatRoomGroups_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.chat_states {
		res << zzz_vproto_internal_pack_cchatroomgroupstate(x, 1)
	}
	// [packed=false]
	for _, x in o.virtualize_members_chat_group_ids {
		res << vproto.pack_uint64_field(x, 2)
	}
	return res
}

pub fn cchatroom_setsessionactivechatroomgroups_response_unpack(buf []byte) ?CChatRoom_SetSessionActiveChatRoomGroups_Response {
	mut res := CChatRoom_SetSessionActiveChatRoomGroups_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.chat_states << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.virtualize_members_chat_group_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setsessionactivechatroomgroups_response() CChatRoom_SetSessionActiveChatRoomGroups_Response {
	return CChatRoom_SetSessionActiveChatRoomGroups_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setsessionactivechatroomgroups_response(o CChatRoom_SetSessionActiveChatRoomGroups_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setsessionactivechatroomgroups_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetSessionActiveChatRoomGroups_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setsessionactivechatroomgroups_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	desktop_notification_level     EChatRoomNotificationLevel
	has_desktop_notification_level bool
	mobile_notification_level      EChatRoomNotificationLevel
	has_mobile_notification_level  bool
	unread_indicator_muted         bool
	has_unread_indicator_muted     bool
}

pub fn (o &CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences) pack() []byte {
	mut res := []byte{}
	if o.has_desktop_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.desktop_notification_level, 1)
	}
	if o.has_mobile_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.mobile_notification_level, 2)
	}
	if o.has_unread_indicator_muted {
		res << vproto.pack_bool_field(o.unread_indicator_muted, 3)
	}
	return res
}

pub fn cchatroom_setuserchatgrouppreferences_request_chatgrouppreferences_unpack(buf []byte) ?CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
	mut res := CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_desktop_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.desktop_notification_level = v
				i = ii
			}
			2 {
				res.has_mobile_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.mobile_notification_level = v
				i = ii
			}
			3 {
				res.has_unread_indicator_muted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.unread_indicator_muted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setuserchatgrouppreferences_request_chatgrouppreferences() CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences {
	return CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setuserchatgrouppreferences_request_chatgrouppreferences(o CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setuserchatgrouppreferences_request_chatgrouppreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setuserchatgrouppreferences_request_chatgrouppreferences_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	chat_id                        u64
	has_chat_id                    bool
	desktop_notification_level     EChatRoomNotificationLevel
	has_desktop_notification_level bool
	mobile_notification_level      EChatRoomNotificationLevel
	has_mobile_notification_level  bool
	unread_indicator_muted         bool
	has_unread_indicator_muted     bool
}

pub fn (o &CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 1)
	}
	if o.has_desktop_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.desktop_notification_level, 2)
	}
	if o.has_mobile_notification_level {
		res << zzz_vproto_internal_pack_echatroomnotificationlevel(o.mobile_notification_level, 3)
	}
	if o.has_unread_indicator_muted {
		res << vproto.pack_bool_field(o.unread_indicator_muted, 4)
	}
	return res
}

pub fn cchatroom_setuserchatgrouppreferences_request_chatroompreferences_unpack(buf []byte) ?CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
	mut res := CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_desktop_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.desktop_notification_level = v
				i = ii
			}
			3 {
				res.has_mobile_notification_level = true
				ii, v := zzz_vproto_internal_unpack_echatroomnotificationlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.mobile_notification_level = v
				i = ii
			}
			4 {
				res.has_unread_indicator_muted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.unread_indicator_muted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setuserchatgrouppreferences_request_chatroompreferences() CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences {
	return CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setuserchatgrouppreferences_request_chatroompreferences(o CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setuserchatgrouppreferences_request_chatroompreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setuserchatgrouppreferences_request_chatroompreferences_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetUserChatGroupPreferences_Request {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	chat_group_id              u64
	has_chat_group_id          bool
	chat_group_preferences     CChatRoom_SetUserChatGroupPreferences_Request_ChatGroupPreferences
	has_chat_group_preferences bool
	chat_room_preferences      []CChatRoom_SetUserChatGroupPreferences_Request_ChatRoomPreferences
}

pub fn (o &CChatRoom_SetUserChatGroupPreferences_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_group_preferences {
		res <<
			zzz_vproto_internal_pack_cchatroom_setuserchatgrouppreferences_request_chatgrouppreferences(o.chat_group_preferences, 2)
	}
	// [packed=false]
	for _, x in o.chat_room_preferences {
		res <<
			zzz_vproto_internal_pack_cchatroom_setuserchatgrouppreferences_request_chatroompreferences(x, 3)
	}
	return res
}

pub fn cchatroom_setuserchatgrouppreferences_request_unpack(buf []byte) ?CChatRoom_SetUserChatGroupPreferences_Request {
	mut res := CChatRoom_SetUserChatGroupPreferences_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_group_preferences = true
				ii, v := zzz_vproto_internal_unpack_cchatroom_setuserchatgrouppreferences_request_chatgrouppreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.chat_group_preferences = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroom_setuserchatgrouppreferences_request_chatroompreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.chat_room_preferences << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setuserchatgrouppreferences_request() CChatRoom_SetUserChatGroupPreferences_Request {
	return CChatRoom_SetUserChatGroupPreferences_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setuserchatgrouppreferences_request(o CChatRoom_SetUserChatGroupPreferences_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setuserchatgrouppreferences_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetUserChatGroupPreferences_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setuserchatgrouppreferences_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SetUserChatGroupPreferences_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_SetUserChatGroupPreferences_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_setuserchatgrouppreferences_response_unpack(buf []byte) ?CChatRoom_SetUserChatGroupPreferences_Response {
	res := CChatRoom_SetUserChatGroupPreferences_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_setuserchatgrouppreferences_response() CChatRoom_SetUserChatGroupPreferences_Response {
	return CChatRoom_SetUserChatGroupPreferences_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_setuserchatgrouppreferences_response(o CChatRoom_SetUserChatGroupPreferences_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_setuserchatgrouppreferences_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SetUserChatGroupPreferences_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_setuserchatgrouppreferences_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_DeleteChatMessages_Request_Message {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	server_timestamp     u32
	has_server_timestamp bool
	ordinal              u32
	has_ordinal          bool
}

pub fn (o &CChatRoom_DeleteChatMessages_Request_Message) pack() []byte {
	mut res := []byte{}
	if o.has_server_timestamp {
		res << vproto.pack_uint32_field(o.server_timestamp, 1)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 2)
	}
	return res
}

pub fn cchatroom_deletechatmessages_request_message_unpack(buf []byte) ?CChatRoom_DeleteChatMessages_Request_Message {
	mut res := CChatRoom_DeleteChatMessages_Request_Message{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_server_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.server_timestamp = v
				i = ii
			}
			2 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_deletechatmessages_request_message() CChatRoom_DeleteChatMessages_Request_Message {
	return CChatRoom_DeleteChatMessages_Request_Message{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_deletechatmessages_request_message(o CChatRoom_DeleteChatMessages_Request_Message, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_deletechatmessages_request_message(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_DeleteChatMessages_Request_Message) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_deletechatmessages_request_message_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_DeleteChatMessages_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
	messages          []CChatRoom_DeleteChatMessages_Request_Message
}

pub fn (o &CChatRoom_DeleteChatMessages_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	// [packed=false]
	for _, x in o.messages {
		res << zzz_vproto_internal_pack_cchatroom_deletechatmessages_request_message(x, 3)
	}
	return res
}

pub fn cchatroom_deletechatmessages_request_unpack(buf []byte) ?CChatRoom_DeleteChatMessages_Request {
	mut res := CChatRoom_DeleteChatMessages_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroom_deletechatmessages_request_message(cur_buf,
					tag_wiretype.wire_type)?
				res.messages << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_deletechatmessages_request() CChatRoom_DeleteChatMessages_Request {
	return CChatRoom_DeleteChatMessages_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_deletechatmessages_request(o CChatRoom_DeleteChatMessages_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_deletechatmessages_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_DeleteChatMessages_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_deletechatmessages_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_DeleteChatMessages_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CChatRoom_DeleteChatMessages_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cchatroom_deletechatmessages_response_unpack(buf []byte) ?CChatRoom_DeleteChatMessages_Response {
	res := CChatRoom_DeleteChatMessages_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_deletechatmessages_response() CChatRoom_DeleteChatMessages_Response {
	return CChatRoom_DeleteChatMessages_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_deletechatmessages_response(o CChatRoom_DeleteChatMessages_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_deletechatmessages_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_DeleteChatMessages_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_deletechatmessages_response_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_UpdateMemberListView_Notification {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	chat_group_id                  u64
	has_chat_group_id              bool
	view_id                        u64
	has_view_id                    bool
	start                          int
	has_start                      bool
	end                            int
	has_end                        bool
	client_changenumber            int
	has_client_changenumber        bool
	delete_view                    bool
	has_delete_view                bool
	persona_subscribe_accountids   []int
	persona_unsubscribe_accountids []int
}

pub fn (o &CChatRoom_UpdateMemberListView_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_view_id {
		res << vproto.pack_uint64_field(o.view_id, 2)
	}
	if o.has_start {
		res << vproto.pack_int32_field(o.start, 3)
	}
	if o.has_end {
		res << vproto.pack_int32_field(o.end, 4)
	}
	if o.has_client_changenumber {
		res << vproto.pack_int32_field(o.client_changenumber, 5)
	}
	if o.has_delete_view {
		res << vproto.pack_bool_field(o.delete_view, 6)
	}
	// [packed=false]
	for _, x in o.persona_subscribe_accountids {
		res << vproto.pack_int32_field(x, 7)
	}
	// [packed=false]
	for _, x in o.persona_unsubscribe_accountids {
		res << vproto.pack_int32_field(x, 8)
	}
	return res
}

pub fn cchatroom_updatememberlistview_notification_unpack(buf []byte) ?CChatRoom_UpdateMemberListView_Notification {
	mut res := CChatRoom_UpdateMemberListView_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_view_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.view_id = v
				i = ii
			}
			3 {
				res.has_start = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.start = v
				i = ii
			}
			4 {
				res.has_end = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.end = v
				i = ii
			}
			5 {
				res.has_client_changenumber = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_changenumber = v
				i = ii
			}
			6 {
				res.has_delete_view = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.delete_view = v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_subscribe_accountids << v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_unsubscribe_accountids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_updatememberlistview_notification() CChatRoom_UpdateMemberListView_Notification {
	return CChatRoom_UpdateMemberListView_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_updatememberlistview_notification(o CChatRoom_UpdateMemberListView_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_updatememberlistview_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_UpdateMemberListView_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_updatememberlistview_notification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SearchMembers_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	search_id         u64
	has_search_id     bool
	search_text       string
	has_search_text   bool
	max_results       int
	has_max_results   bool
}

pub fn (o &CChatRoom_SearchMembers_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_search_id {
		res << vproto.pack_uint64_field(o.search_id, 2)
	}
	if o.has_search_text {
		res << vproto.pack_string_field(o.search_text, 3)
	}
	if o.has_max_results {
		res << vproto.pack_int32_field(o.max_results, 4)
	}
	return res
}

pub fn cchatroom_searchmembers_request_unpack(buf []byte) ?CChatRoom_SearchMembers_Request {
	mut res := CChatRoom_SearchMembers_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_search_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.search_id = v
				i = ii
			}
			3 {
				res.has_search_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.search_text = v
				i = ii
			}
			4 {
				res.has_max_results = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_results = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_searchmembers_request() CChatRoom_SearchMembers_Request {
	return CChatRoom_SearchMembers_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_searchmembers_request(o CChatRoom_SearchMembers_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_searchmembers_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SearchMembers_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_searchmembers_request_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SearchMembers_Response_MemberMatch {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	accountid      int
	has_accountid  bool
	persona        CMsgClientPersonaState_Friend
	has_persona    bool
}

pub fn (o &CChatRoom_SearchMembers_Response_MemberMatch) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_int32_field(o.accountid, 1)
	}
	if o.has_persona {
		res << zzz_vproto_internal_pack_cmsgclientpersonastate_friend(o.persona, 2)
	}
	return res
}

pub fn cchatroom_searchmembers_response_membermatch_unpack(buf []byte) ?CChatRoom_SearchMembers_Response_MemberMatch {
	mut res := CChatRoom_SearchMembers_Response_MemberMatch{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_persona = true
				ii, v := zzz_vproto_internal_unpack_cmsgclientpersonastate_friend(cur_buf,
					tag_wiretype.wire_type)?
				res.persona = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_searchmembers_response_membermatch() CChatRoom_SearchMembers_Response_MemberMatch {
	return CChatRoom_SearchMembers_Response_MemberMatch{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_searchmembers_response_membermatch(o CChatRoom_SearchMembers_Response_MemberMatch, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_searchmembers_response_membermatch(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SearchMembers_Response_MemberMatch) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_searchmembers_response_membermatch_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_SearchMembers_Response {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	matching_members []CChatRoom_SearchMembers_Response_MemberMatch
	status_flags     u32
	has_status_flags bool
}

pub fn (o &CChatRoom_SearchMembers_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.matching_members {
		res << zzz_vproto_internal_pack_cchatroom_searchmembers_response_membermatch(x, 1)
	}
	if o.has_status_flags {
		res << vproto.pack_uint32_field(o.status_flags, 2)
	}
	return res
}

pub fn cchatroom_searchmembers_response_unpack(buf []byte) ?CChatRoom_SearchMembers_Response {
	mut res := CChatRoom_SearchMembers_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroom_searchmembers_response_membermatch(cur_buf,
					tag_wiretype.wire_type)?
				res.matching_members << v
				i = ii
			}
			2 {
				res.has_status_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.status_flags = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_searchmembers_response() CChatRoom_SearchMembers_Response {
	return CChatRoom_SearchMembers_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_searchmembers_response(o CChatRoom_SearchMembers_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_searchmembers_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_SearchMembers_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_searchmembers_response_unpack(v)?
	return i, unpacked
}

pub struct CClanChatRooms_GetClanChatRoomInfo_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	autocreate     bool
	has_autocreate bool
}

pub fn (o &CClanChatRooms_GetClanChatRoomInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_autocreate {
		res << vproto.pack_bool_field(o.autocreate, 2)
	}
	return res
}

pub fn cclanchatrooms_getclanchatroominfo_request_unpack(buf []byte) ?CClanChatRooms_GetClanChatRoomInfo_Request {
	mut res := CClanChatRooms_GetClanChatRoomInfo_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_autocreate = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.autocreate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclanchatrooms_getclanchatroominfo_request() CClanChatRooms_GetClanChatRoomInfo_Request {
	return CClanChatRooms_GetClanChatRoomInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclanchatrooms_getclanchatroominfo_request(o CClanChatRooms_GetClanChatRoomInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclanchatrooms_getclanchatroominfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanChatRooms_GetClanChatRoomInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclanchatrooms_getclanchatroominfo_request_unpack(v)?
	return i, unpacked
}

pub struct CClanChatRooms_GetClanChatRoomInfo_Response {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	chat_group_summary     CChatRoom_GetChatRoomGroupSummary_Response
	has_chat_group_summary bool
}

pub fn (o &CClanChatRooms_GetClanChatRoomInfo_Response) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_summary {
		res <<
			zzz_vproto_internal_pack_cchatroom_getchatroomgroupsummary_response(o.chat_group_summary, 1)
	}
	return res
}

pub fn cclanchatrooms_getclanchatroominfo_response_unpack(buf []byte) ?CClanChatRooms_GetClanChatRoomInfo_Response {
	mut res := CClanChatRooms_GetClanChatRoomInfo_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_summary = true
				ii, v := zzz_vproto_internal_unpack_cchatroom_getchatroomgroupsummary_response(cur_buf,
					tag_wiretype.wire_type)?
				res.chat_group_summary = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclanchatrooms_getclanchatroominfo_response() CClanChatRooms_GetClanChatRoomInfo_Response {
	return CClanChatRooms_GetClanChatRoomInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclanchatrooms_getclanchatroominfo_response(o CClanChatRooms_GetClanChatRoomInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclanchatrooms_getclanchatroominfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanChatRooms_GetClanChatRoomInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclanchatrooms_getclanchatroominfo_response_unpack(v)?
	return i, unpacked
}

pub struct CClanChatRooms_SetClanChatRoomPrivate_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steamid               u64
	has_steamid           bool
	chat_room_private     bool
	has_chat_room_private bool
}

pub fn (o &CClanChatRooms_SetClanChatRoomPrivate_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_chat_room_private {
		res << vproto.pack_bool_field(o.chat_room_private, 2)
	}
	return res
}

pub fn cclanchatrooms_setclanchatroomprivate_request_unpack(buf []byte) ?CClanChatRooms_SetClanChatRoomPrivate_Request {
	mut res := CClanChatRooms_SetClanChatRoomPrivate_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_chat_room_private = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_room_private = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclanchatrooms_setclanchatroomprivate_request() CClanChatRooms_SetClanChatRoomPrivate_Request {
	return CClanChatRooms_SetClanChatRoomPrivate_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclanchatrooms_setclanchatroomprivate_request(o CClanChatRooms_SetClanChatRoomPrivate_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclanchatrooms_setclanchatroomprivate_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanChatRooms_SetClanChatRoomPrivate_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclanchatrooms_setclanchatroomprivate_request_unpack(v)?
	return i, unpacked
}

pub struct CClanChatRooms_SetClanChatRoomPrivate_Response {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	chat_room_private     bool
	has_chat_room_private bool
}

pub fn (o &CClanChatRooms_SetClanChatRoomPrivate_Response) pack() []byte {
	mut res := []byte{}
	if o.has_chat_room_private {
		res << vproto.pack_bool_field(o.chat_room_private, 1)
	}
	return res
}

pub fn cclanchatrooms_setclanchatroomprivate_response_unpack(buf []byte) ?CClanChatRooms_SetClanChatRoomPrivate_Response {
	mut res := CClanChatRooms_SetClanChatRoomPrivate_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_room_private = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_room_private = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclanchatrooms_setclanchatroomprivate_response() CClanChatRooms_SetClanChatRoomPrivate_Response {
	return CClanChatRooms_SetClanChatRoomPrivate_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclanchatrooms_setclanchatroomprivate_response(o CClanChatRooms_SetClanChatRoomPrivate_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclanchatrooms_setclanchatroomprivate_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanChatRooms_SetClanChatRoomPrivate_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclanchatrooms_setclanchatroomprivate_response_unpack(v)?
	return i, unpacked
}

pub struct CChatMentions {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	mention_all        bool
	has_mention_all    bool
	mention_here       bool
	has_mention_here   bool
	mention_accountids []u32
}

pub fn (o &CChatMentions) pack() []byte {
	mut res := []byte{}
	if o.has_mention_all {
		res << vproto.pack_bool_field(o.mention_all, 1)
	}
	if o.has_mention_here {
		res << vproto.pack_bool_field(o.mention_here, 2)
	}
	// [packed=false]
	for _, x in o.mention_accountids {
		res << vproto.pack_uint32_field(x, 3)
	}
	return res
}

pub fn cchatmentions_unpack(buf []byte) ?CChatMentions {
	mut res := CChatMentions{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_mention_all = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.mention_all = v
				i = ii
			}
			2 {
				res.has_mention_here = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.mention_here = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.mention_accountids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatmentions() CChatMentions {
	return CChatMentions{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatmentions(o CChatMentions, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatmentions(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatMentions) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatmentions_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_IncomingChatMessage_Notification {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	chat_group_id         u64
	has_chat_group_id     bool
	chat_id               u64
	has_chat_id           bool
	steamid_sender        u64
	has_steamid_sender    bool
	message               string
	has_message           bool
	timestamp             u32
	has_timestamp         bool
	mentions              CChatMentions
	has_mentions          bool
	ordinal               u32
	has_ordinal           bool
	server_message        ServerMessage
	has_server_message    bool
	message_no_bbcode     string
	has_message_no_bbcode bool
	chat_name             string
	has_chat_name         bool
}

pub fn (o &CChatRoom_IncomingChatMessage_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	if o.has_steamid_sender {
		res << vproto.pack_64bit_field(o.steamid_sender, 3)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 4)
	}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 5)
	}
	if o.has_mentions {
		res << zzz_vproto_internal_pack_cchatmentions(o.mentions, 6)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 7)
	}
	if o.has_server_message {
		res << zzz_vproto_internal_pack_servermessage(o.server_message, 8)
	}
	if o.has_message_no_bbcode {
		res << vproto.pack_string_field(o.message_no_bbcode, 9)
	}
	if o.has_chat_name {
		res << vproto.pack_string_field(o.chat_name, 10)
	}
	return res
}

pub fn cchatroom_incomingchatmessage_notification_unpack(buf []byte) ?CChatRoom_IncomingChatMessage_Notification {
	mut res := CChatRoom_IncomingChatMessage_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_steamid_sender = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_sender = v
				i = ii
			}
			4 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			5 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			6 {
				res.has_mentions = true
				ii, v := zzz_vproto_internal_unpack_cchatmentions(cur_buf, tag_wiretype.wire_type)?
				res.mentions = v
				i = ii
			}
			7 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			8 {
				res.has_server_message = true
				ii, v := zzz_vproto_internal_unpack_servermessage(cur_buf, tag_wiretype.wire_type)?
				res.server_message = v
				i = ii
			}
			9 {
				res.has_message_no_bbcode = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message_no_bbcode = v
				i = ii
			}
			10 {
				res.has_chat_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_incomingchatmessage_notification() CChatRoom_IncomingChatMessage_Notification {
	return CChatRoom_IncomingChatMessage_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_incomingchatmessage_notification(o CChatRoom_IncomingChatMessage_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_incomingchatmessage_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_IncomingChatMessage_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_incomingchatmessage_notification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_ChatMessageModified_Notification_ChatMessage {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	server_timestamp     u32
	has_server_timestamp bool
	ordinal              u32
	has_ordinal          bool
	deleted              bool
	has_deleted          bool
}

pub fn (o &CChatRoom_ChatMessageModified_Notification_ChatMessage) pack() []byte {
	mut res := []byte{}
	if o.has_server_timestamp {
		res << vproto.pack_uint32_field(o.server_timestamp, 1)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 2)
	}
	if o.has_deleted {
		res << vproto.pack_bool_field(o.deleted, 3)
	}
	return res
}

pub fn cchatroom_chatmessagemodified_notification_chatmessage_unpack(buf []byte) ?CChatRoom_ChatMessageModified_Notification_ChatMessage {
	mut res := CChatRoom_ChatMessageModified_Notification_ChatMessage{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_server_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.server_timestamp = v
				i = ii
			}
			2 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			3 {
				res.has_deleted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.deleted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_chatmessagemodified_notification_chatmessage() CChatRoom_ChatMessageModified_Notification_ChatMessage {
	return CChatRoom_ChatMessageModified_Notification_ChatMessage{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_chatmessagemodified_notification_chatmessage(o CChatRoom_ChatMessageModified_Notification_ChatMessage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_chatmessagemodified_notification_chatmessage(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_ChatMessageModified_Notification_ChatMessage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_chatmessagemodified_notification_chatmessage_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_ChatMessageModified_Notification {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	chat_id           u64
	has_chat_id       bool
	messages          []CChatRoom_ChatMessageModified_Notification_ChatMessage
}

pub fn (o &CChatRoom_ChatMessageModified_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 2)
	}
	// [packed=false]
	for _, x in o.messages {
		res <<
			zzz_vproto_internal_pack_cchatroom_chatmessagemodified_notification_chatmessage(x, 3)
	}
	return res
}

pub fn cchatroom_chatmessagemodified_notification_unpack(buf []byte) ?CChatRoom_ChatMessageModified_Notification {
	mut res := CChatRoom_ChatMessageModified_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroom_chatmessagemodified_notification_chatmessage(cur_buf,
					tag_wiretype.wire_type)?
				res.messages << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_chatmessagemodified_notification() CChatRoom_ChatMessageModified_Notification {
	return CChatRoom_ChatMessageModified_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_chatmessagemodified_notification(o CChatRoom_ChatMessageModified_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_chatmessagemodified_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_ChatMessageModified_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_chatmessagemodified_notification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_MemberStateChange_Notification {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_group_id     u64
	has_chat_group_id bool
	member            CChatRoomMember
	has_member        bool
	change            EChatRoomMemberStateChange
	has_change        bool
}

pub fn (o &CChatRoom_MemberStateChange_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_member {
		res << zzz_vproto_internal_pack_cchatroommember(o.member, 2)
	}
	if o.has_change {
		res << zzz_vproto_internal_pack_echatroommemberstatechange(o.change, 3)
	}
	return res
}

pub fn cchatroom_memberstatechange_notification_unpack(buf []byte) ?CChatRoom_MemberStateChange_Notification {
	mut res := CChatRoom_MemberStateChange_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_member = true
				ii, v := zzz_vproto_internal_unpack_cchatroommember(cur_buf, tag_wiretype.wire_type)?
				res.member = v
				i = ii
			}
			3 {
				res.has_change = true
				ii, v := zzz_vproto_internal_unpack_echatroommemberstatechange(cur_buf,
					tag_wiretype.wire_type)?
				res.change = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_memberstatechange_notification() CChatRoom_MemberStateChange_Notification {
	return CChatRoom_MemberStateChange_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_memberstatechange_notification(o CChatRoom_MemberStateChange_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_memberstatechange_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_MemberStateChange_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_memberstatechange_notification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_ChatRoomHeaderState_Notification {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	header_state     CChatRoomGroupHeaderState
	has_header_state bool
}

pub fn (o &CChatRoom_ChatRoomHeaderState_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_header_state {
		res << zzz_vproto_internal_pack_cchatroomgroupheaderstate(o.header_state, 1)
	}
	return res
}

pub fn cchatroom_chatroomheaderstate_notification_unpack(buf []byte) ?CChatRoom_ChatRoomHeaderState_Notification {
	mut res := CChatRoom_ChatRoomHeaderState_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_header_state = true
				ii, v := zzz_vproto_internal_unpack_cchatroomgroupheaderstate(cur_buf,
					tag_wiretype.wire_type)?
				res.header_state = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_chatroomheaderstate_notification() CChatRoom_ChatRoomHeaderState_Notification {
	return CChatRoom_ChatRoomHeaderState_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_chatroomheaderstate_notification(o CChatRoom_ChatRoomHeaderState_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_chatroomheaderstate_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_ChatRoomHeaderState_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_chatroomheaderstate_notification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_ChatRoomGroupRoomsChange_Notification {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	chat_group_id       u64
	has_chat_group_id   bool
	default_chat_id     u64
	has_default_chat_id bool
	chat_rooms          []CChatRoomState
}

pub fn (o &CChatRoom_ChatRoomGroupRoomsChange_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_default_chat_id {
		res << vproto.pack_uint64_field(o.default_chat_id, 2)
	}
	// [packed=false]
	for _, x in o.chat_rooms {
		res << zzz_vproto_internal_pack_cchatroomstate(x, 3)
	}
	return res
}

pub fn cchatroom_chatroomgrouproomschange_notification_unpack(buf []byte) ?CChatRoom_ChatRoomGroupRoomsChange_Notification {
	mut res := CChatRoom_ChatRoomGroupRoomsChange_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_default_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.default_chat_id = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomstate(cur_buf, tag_wiretype.wire_type)?
				res.chat_rooms << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_chatroomgrouproomschange_notification() CChatRoom_ChatRoomGroupRoomsChange_Notification {
	return CChatRoom_ChatRoomGroupRoomsChange_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_chatroomgrouproomschange_notification(o CChatRoom_ChatRoomGroupRoomsChange_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_chatroomgrouproomschange_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_ChatRoomGroupRoomsChange_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_chatroomgrouproomschange_notification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	chat_id           u64
	has_chat_id       bool
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_uint64_field(o.chat_id, 1)
	}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 2)
	}
	return res
}

pub fn cchatroom_notifyshouldrejoinchatroomvoicechat_notification_unpack(buf []byte) ?CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
	mut res := CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroom_notifyshouldrejoinchatroomvoicechat_notification() CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
	return CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroom_notifyshouldrejoinchatroomvoicechat_notification(o CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroom_notifyshouldrejoinchatroomvoicechat_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroom_notifyshouldrejoinchatroomvoicechat_notification_unpack(v)?
	return i, unpacked
}

pub struct ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	chat_group_id             u64
	has_chat_group_id         bool
	user_chat_group_state     CUserChatRoomGroupState
	has_user_chat_group_state bool
	group_summary             CChatRoom_GetChatRoomGroupSummary_Response
	has_group_summary         bool
	user_action               EChatRoomMemberStateChange
	has_user_action           bool
}

pub fn (o &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_user_chat_group_state {
		res << zzz_vproto_internal_pack_cuserchatroomgroupstate(o.user_chat_group_state, 2)
	}
	if o.has_group_summary {
		res <<
			zzz_vproto_internal_pack_cchatroom_getchatroomgroupsummary_response(o.group_summary, 3)
	}
	if o.has_user_action {
		res << zzz_vproto_internal_pack_echatroommemberstatechange(o.user_action, 4)
	}
	return res
}

pub fn chatroomclient_notifychatgroupuserstatechanged_notification_unpack(buf []byte) ?ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
	mut res := ChatRoomClient_NotifyChatGroupUserStateChanged_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_user_chat_group_state = true
				ii, v := zzz_vproto_internal_unpack_cuserchatroomgroupstate(cur_buf, tag_wiretype.wire_type)?
				res.user_chat_group_state = v
				i = ii
			}
			3 {
				res.has_group_summary = true
				ii, v := zzz_vproto_internal_unpack_cchatroom_getchatroomgroupsummary_response(cur_buf,
					tag_wiretype.wire_type)?
				res.group_summary = v
				i = ii
			}
			4 {
				res.has_user_action = true
				ii, v := zzz_vproto_internal_unpack_echatroommemberstatechange(cur_buf,
					tag_wiretype.wire_type)?
				res.user_action = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chatroomclient_notifychatgroupuserstatechanged_notification() ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
	return ChatRoomClient_NotifyChatGroupUserStateChanged_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chatroomclient_notifychatgroupuserstatechanged_notification(o ChatRoomClient_NotifyChatGroupUserStateChanged_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chatroomclient_notifychatgroupuserstatechanged_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, ChatRoomClient_NotifyChatGroupUserStateChanged_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chatroomclient_notifychatgroupuserstatechanged_notification_unpack(v)?
	return i, unpacked
}

pub struct ChatRoomClient_NotifyChatRoomDisconnect_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	chat_group_ids []u64
}

pub fn (o &ChatRoomClient_NotifyChatRoomDisconnect_Notification) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.chat_group_ids {
		res << vproto.pack_uint64_field(x, 1)
	}
	return res
}

pub fn chatroomclient_notifychatroomdisconnect_notification_unpack(buf []byte) ?ChatRoomClient_NotifyChatRoomDisconnect_Notification {
	mut res := ChatRoomClient_NotifyChatRoomDisconnect_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chatroomclient_notifychatroomdisconnect_notification() ChatRoomClient_NotifyChatRoomDisconnect_Notification {
	return ChatRoomClient_NotifyChatRoomDisconnect_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chatroomclient_notifychatroomdisconnect_notification(o ChatRoomClient_NotifyChatRoomDisconnect_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chatroomclient_notifychatroomdisconnect_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, ChatRoomClient_NotifyChatRoomDisconnect_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chatroomclient_notifychatroomdisconnect_notification_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomMemberListView {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	start                   int
	has_start               bool
	end                     int
	has_end                 bool
	total_count             int
	has_total_count         bool
	client_changenumber     int
	has_client_changenumber bool
	server_changenumber     int
	has_server_changenumber bool
}

pub fn (o &CChatRoomMemberListView) pack() []byte {
	mut res := []byte{}
	if o.has_start {
		res << vproto.pack_int32_field(o.start, 3)
	}
	if o.has_end {
		res << vproto.pack_int32_field(o.end, 4)
	}
	if o.has_total_count {
		res << vproto.pack_int32_field(o.total_count, 5)
	}
	if o.has_client_changenumber {
		res << vproto.pack_int32_field(o.client_changenumber, 6)
	}
	if o.has_server_changenumber {
		res << vproto.pack_int32_field(o.server_changenumber, 7)
	}
	return res
}

pub fn cchatroommemberlistview_unpack(buf []byte) ?CChatRoomMemberListView {
	mut res := CChatRoomMemberListView{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			3 {
				res.has_start = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.start = v
				i = ii
			}
			4 {
				res.has_end = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.end = v
				i = ii
			}
			5 {
				res.has_total_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_count = v
				i = ii
			}
			6 {
				res.has_client_changenumber = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_changenumber = v
				i = ii
			}
			7 {
				res.has_server_changenumber = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.server_changenumber = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroommemberlistview() CChatRoomMemberListView {
	return CChatRoomMemberListView{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroommemberlistview(o CChatRoomMemberListView, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroommemberlistview(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomMemberListView) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroommemberlistview_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomMemberSummaryCounts {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ingame         int
	has_ingame     bool
	online         int
	has_online     bool
	offline        int
	has_offline    bool
}

pub fn (o &CChatRoomMemberSummaryCounts) pack() []byte {
	mut res := []byte{}
	if o.has_ingame {
		res << vproto.pack_int32_field(o.ingame, 1)
	}
	if o.has_online {
		res << vproto.pack_int32_field(o.online, 2)
	}
	if o.has_offline {
		res << vproto.pack_int32_field(o.offline, 3)
	}
	return res
}

pub fn cchatroommembersummarycounts_unpack(buf []byte) ?CChatRoomMemberSummaryCounts {
	mut res := CChatRoomMemberSummaryCounts{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ingame = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ingame = v
				i = ii
			}
			2 {
				res.has_online = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.online = v
				i = ii
			}
			3 {
				res.has_offline = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.offline = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroommembersummarycounts() CChatRoomMemberSummaryCounts {
	return CChatRoomMemberSummaryCounts{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroommembersummarycounts(o CChatRoomMemberSummaryCounts, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroommembersummarycounts(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomMemberSummaryCounts) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroommembersummarycounts_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	rank           int
	has_rank       bool
	accountid      u32
	has_accountid  bool
	persona        CMsgClientPersonaState_Friend
	has_persona    bool
}

pub fn (o &CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry) pack() []byte {
	mut res := []byte{}
	if o.has_rank {
		res << vproto.pack_int32_field(o.rank, 1)
	}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 2)
	}
	if o.has_persona {
		res << zzz_vproto_internal_pack_cmsgclientpersonastate_friend(o.persona, 3)
	}
	return res
}

pub fn cchatroomclient_memberlistviewupdated_notification_memberlistviewentry_unpack(buf []byte) ?CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
	mut res := CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_rank = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.rank = v
				i = ii
			}
			2 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			3 {
				res.has_persona = true
				ii, v := zzz_vproto_internal_unpack_cmsgclientpersonastate_friend(cur_buf,
					tag_wiretype.wire_type)?
				res.persona = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomclient_memberlistviewupdated_notification_memberlistviewentry() CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry {
	return CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomclient_memberlistviewupdated_notification_memberlistviewentry(o CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomclient_memberlistviewupdated_notification_memberlistviewentry(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomclient_memberlistviewupdated_notification_memberlistviewentry_unpack(v)?
	return i, unpacked
}

pub struct CChatRoomClient_MemberListViewUpdated_Notification {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	chat_group_id       u64
	has_chat_group_id   bool
	view_id             u64
	has_view_id         bool
	view                CChatRoomMemberListView
	has_view            bool
	members             []CChatRoomClient_MemberListViewUpdated_Notification_MemberListViewEntry
	status_flags        u32
	has_status_flags    bool
	member_summary      CChatRoomMemberSummaryCounts
	has_member_summary  bool
	subscribed_personas []CMsgClientPersonaState_Friend
}

pub fn (o &CChatRoomClient_MemberListViewUpdated_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 1)
	}
	if o.has_view_id {
		res << vproto.pack_uint64_field(o.view_id, 2)
	}
	if o.has_view {
		res << zzz_vproto_internal_pack_cchatroommemberlistview(o.view, 3)
	}
	// [packed=false]
	for _, x in o.members {
		res <<
			zzz_vproto_internal_pack_cchatroomclient_memberlistviewupdated_notification_memberlistviewentry(x, 4)
	}
	if o.has_status_flags {
		res << vproto.pack_uint32_field(o.status_flags, 5)
	}
	if o.has_member_summary {
		res << zzz_vproto_internal_pack_cchatroommembersummarycounts(o.member_summary, 6)
	}
	// [packed=false]
	for _, x in o.subscribed_personas {
		res << zzz_vproto_internal_pack_cmsgclientpersonastate_friend(x, 7)
	}
	return res
}

pub fn cchatroomclient_memberlistviewupdated_notification_unpack(buf []byte) ?CChatRoomClient_MemberListViewUpdated_Notification {
	mut res := CChatRoomClient_MemberListViewUpdated_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			2 {
				res.has_view_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.view_id = v
				i = ii
			}
			3 {
				res.has_view = true
				ii, v := zzz_vproto_internal_unpack_cchatroommemberlistview(cur_buf, tag_wiretype.wire_type)?
				res.view = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cchatroomclient_memberlistviewupdated_notification_memberlistviewentry(cur_buf,
					tag_wiretype.wire_type)?
				res.members << v
				i = ii
			}
			5 {
				res.has_status_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.status_flags = v
				i = ii
			}
			6 {
				res.has_member_summary = true
				ii, v := zzz_vproto_internal_unpack_cchatroommembersummarycounts(cur_buf,
					tag_wiretype.wire_type)?
				res.member_summary = v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpersonastate_friend(cur_buf,
					tag_wiretype.wire_type)?
				res.subscribed_personas << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatroomclient_memberlistviewupdated_notification() CChatRoomClient_MemberListViewUpdated_Notification {
	return CChatRoomClient_MemberListViewUpdated_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatroomclient_memberlistviewupdated_notification(o CChatRoomClient_MemberListViewUpdated_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatroomclient_memberlistviewupdated_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatRoomClient_MemberListViewUpdated_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatroomclient_memberlistviewupdated_notification_unpack(v)?
	return i, unpacked
}

pub struct CChatUsability_ClientUsabilityMetrics_Notification_Settings {
mut:
	unknown_fields                                []vproto.UnknownField
pub mut:
	notifications_show_ingame                     bool
	has_notifications_show_ingame                 bool
	notifications_show_online                     bool
	has_notifications_show_online                 bool
	notifications_show_message                    bool
	has_notifications_show_message                bool
	notifications_events_and_announcements        bool
	has_notifications_events_and_announcements    bool
	sounds_play_ingame                            bool
	has_sounds_play_ingame                        bool
	sounds_play_online                            bool
	has_sounds_play_online                        bool
	sounds_play_message                           bool
	has_sounds_play_message                       bool
	sounds_events_and_announcements               bool
	has_sounds_events_and_announcements           bool
	always_new_chat_window                        bool
	has_always_new_chat_window                    bool
	force_alphabetic_friend_sorting               bool
	has_force_alphabetic_friend_sorting           bool
	chat_flash_mode                               int
	has_chat_flash_mode                           bool
	remember_open_chats                           bool
	has_remember_open_chats                       bool
	compact_quick_access                          bool
	has_compact_quick_access                      bool
	compact_friends_list                          bool
	has_compact_friends_list                      bool
	notifications_show_chat_room_notification     bool
	has_notifications_show_chat_room_notification bool
	sounds_play_chat_room_notification            bool
	has_sounds_play_chat_room_notification        bool
	hide_offline_friends_in_tag_groups            bool
	has_hide_offline_friends_in_tag_groups        bool
	hide_categorized_friends                      bool
	has_hide_categorized_friends                  bool
	categorize_in_game_friends_by_game            bool
	has_categorize_in_game_friends_by_game        bool
	chat_font_size                                int
	has_chat_font_size                            bool
	use24hour_clock                               bool
	has_use24hour_clock                           bool
	do_not_disturb_mode                           bool
	has_do_not_disturb_mode                       bool
	disable_embed_inlining                        bool
	has_disable_embed_inlining                    bool
	sign_into_friends                             bool
	has_sign_into_friends                         bool
	animated_avatars                              bool
	has_animated_avatars                          bool
}

pub fn (o &CChatUsability_ClientUsabilityMetrics_Notification_Settings) pack() []byte {
	mut res := []byte{}
	if o.has_notifications_show_ingame {
		res << vproto.pack_bool_field(o.notifications_show_ingame, 1)
	}
	if o.has_notifications_show_online {
		res << vproto.pack_bool_field(o.notifications_show_online, 2)
	}
	if o.has_notifications_show_message {
		res << vproto.pack_bool_field(o.notifications_show_message, 3)
	}
	if o.has_notifications_events_and_announcements {
		res << vproto.pack_bool_field(o.notifications_events_and_announcements, 4)
	}
	if o.has_sounds_play_ingame {
		res << vproto.pack_bool_field(o.sounds_play_ingame, 5)
	}
	if o.has_sounds_play_online {
		res << vproto.pack_bool_field(o.sounds_play_online, 6)
	}
	if o.has_sounds_play_message {
		res << vproto.pack_bool_field(o.sounds_play_message, 7)
	}
	if o.has_sounds_events_and_announcements {
		res << vproto.pack_bool_field(o.sounds_events_and_announcements, 8)
	}
	if o.has_always_new_chat_window {
		res << vproto.pack_bool_field(o.always_new_chat_window, 9)
	}
	if o.has_force_alphabetic_friend_sorting {
		res << vproto.pack_bool_field(o.force_alphabetic_friend_sorting, 10)
	}
	if o.has_chat_flash_mode {
		res << vproto.pack_int32_field(o.chat_flash_mode, 11)
	}
	if o.has_remember_open_chats {
		res << vproto.pack_bool_field(o.remember_open_chats, 12)
	}
	if o.has_compact_quick_access {
		res << vproto.pack_bool_field(o.compact_quick_access, 13)
	}
	if o.has_compact_friends_list {
		res << vproto.pack_bool_field(o.compact_friends_list, 14)
	}
	if o.has_notifications_show_chat_room_notification {
		res << vproto.pack_bool_field(o.notifications_show_chat_room_notification, 15)
	}
	if o.has_sounds_play_chat_room_notification {
		res << vproto.pack_bool_field(o.sounds_play_chat_room_notification, 16)
	}
	if o.has_hide_offline_friends_in_tag_groups {
		res << vproto.pack_bool_field(o.hide_offline_friends_in_tag_groups, 17)
	}
	if o.has_hide_categorized_friends {
		res << vproto.pack_bool_field(o.hide_categorized_friends, 18)
	}
	if o.has_categorize_in_game_friends_by_game {
		res << vproto.pack_bool_field(o.categorize_in_game_friends_by_game, 19)
	}
	if o.has_chat_font_size {
		res << vproto.pack_int32_field(o.chat_font_size, 20)
	}
	if o.has_use24hour_clock {
		res << vproto.pack_bool_field(o.use24hour_clock, 21)
	}
	if o.has_do_not_disturb_mode {
		res << vproto.pack_bool_field(o.do_not_disturb_mode, 22)
	}
	if o.has_disable_embed_inlining {
		res << vproto.pack_bool_field(o.disable_embed_inlining, 23)
	}
	if o.has_sign_into_friends {
		res << vproto.pack_bool_field(o.sign_into_friends, 24)
	}
	if o.has_animated_avatars {
		res << vproto.pack_bool_field(o.animated_avatars, 25)
	}
	return res
}

pub fn cchatusability_clientusabilitymetrics_notification_settings_unpack(buf []byte) ?CChatUsability_ClientUsabilityMetrics_Notification_Settings {
	mut res := CChatUsability_ClientUsabilityMetrics_Notification_Settings{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_notifications_show_ingame = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notifications_show_ingame = v
				i = ii
			}
			2 {
				res.has_notifications_show_online = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notifications_show_online = v
				i = ii
			}
			3 {
				res.has_notifications_show_message = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notifications_show_message = v
				i = ii
			}
			4 {
				res.has_notifications_events_and_announcements = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notifications_events_and_announcements = v
				i = ii
			}
			5 {
				res.has_sounds_play_ingame = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.sounds_play_ingame = v
				i = ii
			}
			6 {
				res.has_sounds_play_online = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.sounds_play_online = v
				i = ii
			}
			7 {
				res.has_sounds_play_message = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.sounds_play_message = v
				i = ii
			}
			8 {
				res.has_sounds_events_and_announcements = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.sounds_events_and_announcements = v
				i = ii
			}
			9 {
				res.has_always_new_chat_window = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.always_new_chat_window = v
				i = ii
			}
			10 {
				res.has_force_alphabetic_friend_sorting = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.force_alphabetic_friend_sorting = v
				i = ii
			}
			11 {
				res.has_chat_flash_mode = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_flash_mode = v
				i = ii
			}
			12 {
				res.has_remember_open_chats = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.remember_open_chats = v
				i = ii
			}
			13 {
				res.has_compact_quick_access = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.compact_quick_access = v
				i = ii
			}
			14 {
				res.has_compact_friends_list = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.compact_friends_list = v
				i = ii
			}
			15 {
				res.has_notifications_show_chat_room_notification = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notifications_show_chat_room_notification = v
				i = ii
			}
			16 {
				res.has_sounds_play_chat_room_notification = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.sounds_play_chat_room_notification = v
				i = ii
			}
			17 {
				res.has_hide_offline_friends_in_tag_groups = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_offline_friends_in_tag_groups = v
				i = ii
			}
			18 {
				res.has_hide_categorized_friends = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_categorized_friends = v
				i = ii
			}
			19 {
				res.has_categorize_in_game_friends_by_game = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.categorize_in_game_friends_by_game = v
				i = ii
			}
			20 {
				res.has_chat_font_size = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_font_size = v
				i = ii
			}
			21 {
				res.has_use24hour_clock = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use24hour_clock = v
				i = ii
			}
			22 {
				res.has_do_not_disturb_mode = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.do_not_disturb_mode = v
				i = ii
			}
			23 {
				res.has_disable_embed_inlining = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.disable_embed_inlining = v
				i = ii
			}
			24 {
				res.has_sign_into_friends = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.sign_into_friends = v
				i = ii
			}
			25 {
				res.has_animated_avatars = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.animated_avatars = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusability_clientusabilitymetrics_notification_settings() CChatUsability_ClientUsabilityMetrics_Notification_Settings {
	return CChatUsability_ClientUsabilityMetrics_Notification_Settings{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusability_clientusabilitymetrics_notification_settings(o CChatUsability_ClientUsabilityMetrics_Notification_Settings, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusability_clientusabilitymetrics_notification_settings(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsability_ClientUsabilityMetrics_Notification_Settings) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusability_clientusabilitymetrics_notification_settings_unpack(v)?
	return i, unpacked
}

pub struct CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	voice_input_gain                 f32
	has_voice_input_gain             bool
	voice_output_gain                f32
	has_voice_output_gain            bool
	noise_gate_level                 int
	has_noise_gate_level             bool
	voice_use_echo_cancellation      bool
	has_voice_use_echo_cancellation  bool
	voice_use_noise_cancellation     bool
	has_voice_use_noise_cancellation bool
	voice_use_auto_gain_control      bool
	has_voice_use_auto_gain_control  bool
	selected_non_default_mic         bool
	has_selected_non_default_mic     bool
	selected_non_default_output      bool
	has_selected_non_default_output  bool
	push_to_talk_enabled             bool
	has_push_to_talk_enabled         bool
	push_to_mute_enabled             bool
	has_push_to_mute_enabled         bool
	play_ptt_sounds                  bool
	has_play_ptt_sounds              bool
}

pub fn (o &CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings) pack() []byte {
	mut res := []byte{}
	if o.has_voice_input_gain {
		res << vproto.pack_float_field(o.voice_input_gain, 1)
	}
	if o.has_voice_output_gain {
		res << vproto.pack_float_field(o.voice_output_gain, 2)
	}
	if o.has_noise_gate_level {
		res << vproto.pack_int32_field(o.noise_gate_level, 3)
	}
	if o.has_voice_use_echo_cancellation {
		res << vproto.pack_bool_field(o.voice_use_echo_cancellation, 4)
	}
	if o.has_voice_use_noise_cancellation {
		res << vproto.pack_bool_field(o.voice_use_noise_cancellation, 5)
	}
	if o.has_voice_use_auto_gain_control {
		res << vproto.pack_bool_field(o.voice_use_auto_gain_control, 6)
	}
	if o.has_selected_non_default_mic {
		res << vproto.pack_bool_field(o.selected_non_default_mic, 7)
	}
	if o.has_selected_non_default_output {
		res << vproto.pack_bool_field(o.selected_non_default_output, 8)
	}
	if o.has_push_to_talk_enabled {
		res << vproto.pack_bool_field(o.push_to_talk_enabled, 9)
	}
	if o.has_push_to_mute_enabled {
		res << vproto.pack_bool_field(o.push_to_mute_enabled, 10)
	}
	if o.has_play_ptt_sounds {
		res << vproto.pack_bool_field(o.play_ptt_sounds, 11)
	}
	return res
}

pub fn cchatusability_clientusabilitymetrics_notification_voicesettings_unpack(buf []byte) ?CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
	mut res := CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_voice_input_gain = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_input_gain = v
				i = ii
			}
			2 {
				res.has_voice_output_gain = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_output_gain = v
				i = ii
			}
			3 {
				res.has_noise_gate_level = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.noise_gate_level = v
				i = ii
			}
			4 {
				res.has_voice_use_echo_cancellation = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_use_echo_cancellation = v
				i = ii
			}
			5 {
				res.has_voice_use_noise_cancellation = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_use_noise_cancellation = v
				i = ii
			}
			6 {
				res.has_voice_use_auto_gain_control = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.voice_use_auto_gain_control = v
				i = ii
			}
			7 {
				res.has_selected_non_default_mic = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.selected_non_default_mic = v
				i = ii
			}
			8 {
				res.has_selected_non_default_output = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.selected_non_default_output = v
				i = ii
			}
			9 {
				res.has_push_to_talk_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.push_to_talk_enabled = v
				i = ii
			}
			10 {
				res.has_push_to_mute_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.push_to_mute_enabled = v
				i = ii
			}
			11 {
				res.has_play_ptt_sounds = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.play_ptt_sounds = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusability_clientusabilitymetrics_notification_voicesettings() CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings {
	return CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusability_clientusabilitymetrics_notification_voicesettings(o CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusability_clientusabilitymetrics_notification_voicesettings(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusability_clientusabilitymetrics_notification_voicesettings_unpack(v)?
	return i, unpacked
}

pub struct CChatUsability_ClientUsabilityMetrics_NotificationUIState_CategoryCollapseState {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	in_game_collapsed         bool
	has_in_game_collapsed     bool
	online_collapsed          bool
	has_online_collapsed      bool
	offline_collapsed         bool
	has_offline_collapsed     bool
	game_groups_collapsed     int
	has_game_groups_collapsed bool
	categories_collapsed      int
	has_categories_collapsed  bool
}

pub fn (o &CChatUsability_ClientUsabilityMetrics_NotificationUIState_CategoryCollapseState) pack() []byte {
	mut res := []byte{}
	if o.has_in_game_collapsed {
		res << vproto.pack_bool_field(o.in_game_collapsed, 1)
	}
	if o.has_online_collapsed {
		res << vproto.pack_bool_field(o.online_collapsed, 2)
	}
	if o.has_offline_collapsed {
		res << vproto.pack_bool_field(o.offline_collapsed, 3)
	}
	if o.has_game_groups_collapsed {
		res << vproto.pack_int32_field(o.game_groups_collapsed, 4)
	}
	if o.has_categories_collapsed {
		res << vproto.pack_int32_field(o.categories_collapsed, 5)
	}
	return res
}

pub fn cchatusability_clientusabilitymetrics_notificationuistate_categorycollapsestate_unpack(buf []byte) ?CChatUsability_ClientUsabilityMetrics_NotificationUIState_CategoryCollapseState {
	mut res := CChatUsability_ClientUsabilityMetrics_NotificationUIState_CategoryCollapseState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_in_game_collapsed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.in_game_collapsed = v
				i = ii
			}
			2 {
				res.has_online_collapsed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.online_collapsed = v
				i = ii
			}
			3 {
				res.has_offline_collapsed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.offline_collapsed = v
				i = ii
			}
			4 {
				res.has_game_groups_collapsed = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_groups_collapsed = v
				i = ii
			}
			5 {
				res.has_categories_collapsed = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.categories_collapsed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusability_clientusabilitymetrics_notificationuistate_categorycollapsestate() CChatUsability_ClientUsabilityMetrics_NotificationUIState_CategoryCollapseState {
	return CChatUsability_ClientUsabilityMetrics_NotificationUIState_CategoryCollapseState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusability_clientusabilitymetrics_notificationuistate_categorycollapsestate(o CChatUsability_ClientUsabilityMetrics_NotificationUIState_CategoryCollapseState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusability_clientusabilitymetrics_notificationuistate_categorycollapsestate(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsability_ClientUsabilityMetrics_NotificationUIState_CategoryCollapseState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusability_clientusabilitymetrics_notificationuistate_categorycollapsestate_unpack(v)?
	return i, unpacked
}

pub struct CChatUsability_ClientUsabilityMetrics_Notification_UIState {
mut:
	unknown_fields                      []vproto.UnknownField
pub mut:
	friends_list_height                 int
	has_friends_list_height             bool
	friends_list_width                  int
	has_friends_list_width              bool
	friends_list_docked                 bool
	has_friends_list_docked             bool
	friends_list_collapsed              bool
	has_friends_list_collapsed          bool
	friends_list_group_chats_height     int
	has_friends_list_group_chats_height bool
	friends_list_visible                bool
	has_friends_list_visible            bool
	chat_popups_opened                  int
	has_chat_popups_opened              bool
	group_chat_tabs_opened              int
	has_group_chat_tabs_opened          bool
	friend_chat_tabs_opened             int
	has_friend_chat_tabs_opened         bool
	chat_window_width                   int
	has_chat_window_width               bool
	chat_window_height                  int
	has_chat_window_height              bool
	category_collapse                   CChatUsability_ClientUsabilityMetrics_NotificationUIState_CategoryCollapseState
	has_category_collapse               bool
	group_chat_left_col_collapsed       int
	has_group_chat_left_col_collapsed   bool
	group_chat_right_col_collapsed      int
	has_group_chat_right_col_collapsed  bool
	in_one_on_one_voice_chat            bool
	has_in_one_on_one_voice_chat        bool
	in_group_voice_chat                 bool
	has_in_group_voice_chat             bool
}

pub fn (o &CChatUsability_ClientUsabilityMetrics_Notification_UIState) pack() []byte {
	mut res := []byte{}
	if o.has_friends_list_height {
		res << vproto.pack_int32_field(o.friends_list_height, 1)
	}
	if o.has_friends_list_width {
		res << vproto.pack_int32_field(o.friends_list_width, 2)
	}
	if o.has_friends_list_docked {
		res << vproto.pack_bool_field(o.friends_list_docked, 3)
	}
	if o.has_friends_list_collapsed {
		res << vproto.pack_bool_field(o.friends_list_collapsed, 4)
	}
	if o.has_friends_list_group_chats_height {
		res << vproto.pack_int32_field(o.friends_list_group_chats_height, 5)
	}
	if o.has_friends_list_visible {
		res << vproto.pack_bool_field(o.friends_list_visible, 6)
	}
	if o.has_chat_popups_opened {
		res << vproto.pack_int32_field(o.chat_popups_opened, 7)
	}
	if o.has_group_chat_tabs_opened {
		res << vproto.pack_int32_field(o.group_chat_tabs_opened, 8)
	}
	if o.has_friend_chat_tabs_opened {
		res << vproto.pack_int32_field(o.friend_chat_tabs_opened, 9)
	}
	if o.has_chat_window_width {
		res << vproto.pack_int32_field(o.chat_window_width, 10)
	}
	if o.has_chat_window_height {
		res << vproto.pack_int32_field(o.chat_window_height, 11)
	}
	if o.has_category_collapse {
		res <<
			zzz_vproto_internal_pack_cchatusability_clientusabilitymetrics_notificationuistate_categorycollapsestate(o.category_collapse, 12)
	}
	if o.has_group_chat_left_col_collapsed {
		res << vproto.pack_int32_field(o.group_chat_left_col_collapsed, 13)
	}
	if o.has_group_chat_right_col_collapsed {
		res << vproto.pack_int32_field(o.group_chat_right_col_collapsed, 14)
	}
	if o.has_in_one_on_one_voice_chat {
		res << vproto.pack_bool_field(o.in_one_on_one_voice_chat, 15)
	}
	if o.has_in_group_voice_chat {
		res << vproto.pack_bool_field(o.in_group_voice_chat, 16)
	}
	return res
}

pub fn cchatusability_clientusabilitymetrics_notification_uistate_unpack(buf []byte) ?CChatUsability_ClientUsabilityMetrics_Notification_UIState {
	mut res := CChatUsability_ClientUsabilityMetrics_Notification_UIState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_friends_list_height = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_list_height = v
				i = ii
			}
			2 {
				res.has_friends_list_width = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_list_width = v
				i = ii
			}
			3 {
				res.has_friends_list_docked = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_list_docked = v
				i = ii
			}
			4 {
				res.has_friends_list_collapsed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_list_collapsed = v
				i = ii
			}
			5 {
				res.has_friends_list_group_chats_height = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_list_group_chats_height = v
				i = ii
			}
			6 {
				res.has_friends_list_visible = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_list_visible = v
				i = ii
			}
			7 {
				res.has_chat_popups_opened = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_popups_opened = v
				i = ii
			}
			8 {
				res.has_group_chat_tabs_opened = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.group_chat_tabs_opened = v
				i = ii
			}
			9 {
				res.has_friend_chat_tabs_opened = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friend_chat_tabs_opened = v
				i = ii
			}
			10 {
				res.has_chat_window_width = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_window_width = v
				i = ii
			}
			11 {
				res.has_chat_window_height = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_window_height = v
				i = ii
			}
			12 {
				res.has_category_collapse = true
				ii, v := zzz_vproto_internal_unpack_cchatusability_clientusabilitymetrics_notificationuistate_categorycollapsestate(cur_buf,
					tag_wiretype.wire_type)?
				res.category_collapse = v
				i = ii
			}
			13 {
				res.has_group_chat_left_col_collapsed = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.group_chat_left_col_collapsed = v
				i = ii
			}
			14 {
				res.has_group_chat_right_col_collapsed = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.group_chat_right_col_collapsed = v
				i = ii
			}
			15 {
				res.has_in_one_on_one_voice_chat = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.in_one_on_one_voice_chat = v
				i = ii
			}
			16 {
				res.has_in_group_voice_chat = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.in_group_voice_chat = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusability_clientusabilitymetrics_notification_uistate() CChatUsability_ClientUsabilityMetrics_Notification_UIState {
	return CChatUsability_ClientUsabilityMetrics_Notification_UIState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusability_clientusabilitymetrics_notification_uistate(o CChatUsability_ClientUsabilityMetrics_Notification_UIState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusability_clientusabilitymetrics_notification_uistate(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsability_ClientUsabilityMetrics_Notification_UIState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusability_clientusabilitymetrics_notification_uistate_unpack(v)?
	return i, unpacked
}

pub struct CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
mut:
	unknown_fields                      []vproto.UnknownField
pub mut:
	friends_count                       int
	has_friends_count                   bool
	friends_category_count              int
	has_friends_category_count          bool
	friends_categorized_count           int
	has_friends_categorized_count       bool
	friends_online_count                int
	has_friends_online_count            bool
	friends_in_game_count               int
	has_friends_in_game_count           bool
	friends_in_game_singleton_count     int
	has_friends_in_game_singleton_count bool
	game_group_count                    int
	has_game_group_count                bool
	friends_favorite_count              int
	has_friends_favorite_count          bool
	group_chat_count                    int
	has_group_chat_count                bool
	group_chat_favorite_count           int
	has_group_chat_favorite_count       bool
}

pub fn (o &CChatUsability_ClientUsabilityMetrics_Notification_Metrics) pack() []byte {
	mut res := []byte{}
	if o.has_friends_count {
		res << vproto.pack_int32_field(o.friends_count, 1)
	}
	if o.has_friends_category_count {
		res << vproto.pack_int32_field(o.friends_category_count, 2)
	}
	if o.has_friends_categorized_count {
		res << vproto.pack_int32_field(o.friends_categorized_count, 3)
	}
	if o.has_friends_online_count {
		res << vproto.pack_int32_field(o.friends_online_count, 4)
	}
	if o.has_friends_in_game_count {
		res << vproto.pack_int32_field(o.friends_in_game_count, 5)
	}
	if o.has_friends_in_game_singleton_count {
		res << vproto.pack_int32_field(o.friends_in_game_singleton_count, 6)
	}
	if o.has_game_group_count {
		res << vproto.pack_int32_field(o.game_group_count, 7)
	}
	if o.has_friends_favorite_count {
		res << vproto.pack_int32_field(o.friends_favorite_count, 8)
	}
	if o.has_group_chat_count {
		res << vproto.pack_int32_field(o.group_chat_count, 9)
	}
	if o.has_group_chat_favorite_count {
		res << vproto.pack_int32_field(o.group_chat_favorite_count, 10)
	}
	return res
}

pub fn cchatusability_clientusabilitymetrics_notification_metrics_unpack(buf []byte) ?CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
	mut res := CChatUsability_ClientUsabilityMetrics_Notification_Metrics{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_friends_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_count = v
				i = ii
			}
			2 {
				res.has_friends_category_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_category_count = v
				i = ii
			}
			3 {
				res.has_friends_categorized_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_categorized_count = v
				i = ii
			}
			4 {
				res.has_friends_online_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_online_count = v
				i = ii
			}
			5 {
				res.has_friends_in_game_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_in_game_count = v
				i = ii
			}
			6 {
				res.has_friends_in_game_singleton_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_in_game_singleton_count = v
				i = ii
			}
			7 {
				res.has_game_group_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_group_count = v
				i = ii
			}
			8 {
				res.has_friends_favorite_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_favorite_count = v
				i = ii
			}
			9 {
				res.has_group_chat_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.group_chat_count = v
				i = ii
			}
			10 {
				res.has_group_chat_favorite_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.group_chat_favorite_count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusability_clientusabilitymetrics_notification_metrics() CChatUsability_ClientUsabilityMetrics_Notification_Metrics {
	return CChatUsability_ClientUsabilityMetrics_Notification_Metrics{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusability_clientusabilitymetrics_notification_metrics(o CChatUsability_ClientUsabilityMetrics_Notification_Metrics, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusability_clientusabilitymetrics_notification_metrics(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsability_ClientUsabilityMetrics_Notification_Metrics) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusability_clientusabilitymetrics_notification_metrics_unpack(v)?
	return i, unpacked
}

pub struct CChatUsability_ClientUsabilityMetrics_Notification {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	metrics_run_id      u32
	has_metrics_run_id  bool
	client_build        u32
	has_client_build    bool
	metrics_version     u32
	has_metrics_version bool
	in_web              bool
	has_in_web          bool
	settings            CChatUsability_ClientUsabilityMetrics_Notification_Settings
	has_settings        bool
	voice_settings      CChatUsability_ClientUsabilityMetrics_Notification_VoiceSettings
	has_voice_settings  bool
	ui_state            CChatUsability_ClientUsabilityMetrics_Notification_UIState
	has_ui_state        bool
	metrics             CChatUsability_ClientUsabilityMetrics_Notification_Metrics
	has_metrics         bool
}

pub fn (o &CChatUsability_ClientUsabilityMetrics_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_metrics_run_id {
		res << vproto.pack_uint32_field(o.metrics_run_id, 1)
	}
	if o.has_client_build {
		res << vproto.pack_uint32_field(o.client_build, 2)
	}
	if o.has_metrics_version {
		res << vproto.pack_uint32_field(o.metrics_version, 3)
	}
	if o.has_in_web {
		res << vproto.pack_bool_field(o.in_web, 4)
	}
	if o.has_settings {
		res <<
			zzz_vproto_internal_pack_cchatusability_clientusabilitymetrics_notification_settings(o.settings, 10)
	}
	if o.has_voice_settings {
		res <<
			zzz_vproto_internal_pack_cchatusability_clientusabilitymetrics_notification_voicesettings(o.voice_settings, 11)
	}
	if o.has_ui_state {
		res <<
			zzz_vproto_internal_pack_cchatusability_clientusabilitymetrics_notification_uistate(o.ui_state, 12)
	}
	if o.has_metrics {
		res <<
			zzz_vproto_internal_pack_cchatusability_clientusabilitymetrics_notification_metrics(o.metrics, 13)
	}
	return res
}

pub fn cchatusability_clientusabilitymetrics_notification_unpack(buf []byte) ?CChatUsability_ClientUsabilityMetrics_Notification {
	mut res := CChatUsability_ClientUsabilityMetrics_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_metrics_run_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.metrics_run_id = v
				i = ii
			}
			2 {
				res.has_client_build = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_build = v
				i = ii
			}
			3 {
				res.has_metrics_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.metrics_version = v
				i = ii
			}
			4 {
				res.has_in_web = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.in_web = v
				i = ii
			}
			10 {
				res.has_settings = true
				ii, v := zzz_vproto_internal_unpack_cchatusability_clientusabilitymetrics_notification_settings(cur_buf,
					tag_wiretype.wire_type)?
				res.settings = v
				i = ii
			}
			11 {
				res.has_voice_settings = true
				ii, v := zzz_vproto_internal_unpack_cchatusability_clientusabilitymetrics_notification_voicesettings(cur_buf,
					tag_wiretype.wire_type)?
				res.voice_settings = v
				i = ii
			}
			12 {
				res.has_ui_state = true
				ii, v := zzz_vproto_internal_unpack_cchatusability_clientusabilitymetrics_notification_uistate(cur_buf,
					tag_wiretype.wire_type)?
				res.ui_state = v
				i = ii
			}
			13 {
				res.has_metrics = true
				ii, v := zzz_vproto_internal_unpack_cchatusability_clientusabilitymetrics_notification_metrics(cur_buf,
					tag_wiretype.wire_type)?
				res.metrics = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusability_clientusabilitymetrics_notification() CChatUsability_ClientUsabilityMetrics_Notification {
	return CChatUsability_ClientUsabilityMetrics_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusability_clientusabilitymetrics_notification(o CChatUsability_ClientUsabilityMetrics_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusability_clientusabilitymetrics_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsability_ClientUsabilityMetrics_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusability_clientusabilitymetrics_notification_unpack(v)?
	return i, unpacked
}

pub struct CChatUsability_RequestClientUsabilityMetrics_Notification {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	metrics_run_id     u32
	has_metrics_run_id bool
}

pub fn (o &CChatUsability_RequestClientUsabilityMetrics_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_metrics_run_id {
		res << vproto.pack_uint32_field(o.metrics_run_id, 1)
	}
	return res
}

pub fn cchatusability_requestclientusabilitymetrics_notification_unpack(buf []byte) ?CChatUsability_RequestClientUsabilityMetrics_Notification {
	mut res := CChatUsability_RequestClientUsabilityMetrics_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_metrics_run_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.metrics_run_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cchatusability_requestclientusabilitymetrics_notification() CChatUsability_RequestClientUsabilityMetrics_Notification {
	return CChatUsability_RequestClientUsabilityMetrics_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cchatusability_requestclientusabilitymetrics_notification(o CChatUsability_RequestClientUsabilityMetrics_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cchatusability_requestclientusabilitymetrics_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CChatUsability_RequestClientUsabilityMetrics_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cchatusability_requestclientusabilitymetrics_notification_unpack(v)?
	return i, unpacked
}
