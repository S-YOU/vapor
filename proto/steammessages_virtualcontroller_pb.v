
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


[_allow_multiple_values]
enum EInputMode {
k_einputmodeunknown = 0
k_einputmodemouse = 1
k_einputmodecontroller = 2
k_einputmodemouseandcontroller = 3
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_einputmode(e EInputMode, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_einputmode(buf []byte, tag_wiretype vproto.WireType) ?(int, EInputMode) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, EInputMode(v)
}
[_allow_multiple_values]
enum EMouseMode {
k_emousemodeunknown = 0
k_emousemoderelativecursor = 1
k_emousemodeabsolutecursor = 2
k_emousemodetouch = 3
k_emousemoderelative = 4
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_emousemode(e EMouseMode, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_emousemode(buf []byte, tag_wiretype vproto.WireType) ?(int, EMouseMode) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, EMouseMode(v)
}
[_allow_multiple_values]
enum EControllerElementType {
k_econtrollerelementtypenone = -1
k_econtrollerelementtypethumb = 0
k_econtrollerelementtypebuttonsteam = 1
k_econtrollerelementtypejoystickleft = 2
k_econtrollerelementtypebuttonjoystickleft = 3
k_econtrollerelementtypejoystickright = 4
k_econtrollerelementtypebuttonjoystickright = 5
k_econtrollerelementtypedpad = 6
k_econtrollerelementtypebuttona = 7
k_econtrollerelementtypebuttonb = 8
k_econtrollerelementtypebuttonx = 9
k_econtrollerelementtypebuttony = 10
k_econtrollerelementtypebuttonselect = 11
k_econtrollerelementtypebuttonstart = 12
k_econtrollerelementtypebuttontriggerleft = 13
k_econtrollerelementtypebuttontriggerright = 14
k_econtrollerelementtypebuttonbumperleft = 15
k_econtrollerelementtypebuttonbumperright = 16
k_econtrollerelementtypebuttonmacro0 = 17
k_econtrollerelementtypebuttonmacro1 = 18
k_econtrollerelementtypebuttonmacro2 = 19
k_econtrollerelementtypebuttonmacro3 = 20
k_econtrollerelementtypebuttonmacro4 = 21
k_econtrollerelementtypebuttonmacro5 = 22
k_econtrollerelementtypebuttonmacro6 = 23
k_econtrollerelementtypebuttonmacro7 = 24
k_econtrollerelementtypetrackpadcenter = 25
k_econtrollerelementtypetrackpadleft = 26
k_econtrollerelementtypetrackpadright = 27
k_econtrollerelementtypekeyboard = 28
k_econtrollerelementtypemagnifyingglass = 29
k_econtrollerelementtypebuttonmacro1finger = 30
k_econtrollerelementtypebuttonmacro2finger = 31
k_econtrollerelementtyperecordinput = 32
k_econtrollerelementtypeplaybackinput = 33
k_econtrollerelementtypepaste = 34
k_econtrollerelementtypemax = 35
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_econtrollerelementtype(e EControllerElementType, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_econtrollerelementtype(buf []byte, tag_wiretype vproto.WireType) ?(int, EControllerElementType) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, EControllerElementType(v)
}
pub struct CVirtualControllerElement {
mut:
unknown_fields []vproto.UnknownField
pub mut:
@type EControllerElementType
has_type bool
visible bool
has_visible bool
x_position f32
has_x_position bool
y_position f32
has_y_position bool
x_scale f32
has_x_scale bool
y_scale f32
has_y_scale bool
}
pub fn (o &CVirtualControllerElement) pack() []byte {
mut res := []byte{}
if o.has_type {
res << zzz_vproto_internal_pack_econtrollerelementtype(o.@type, 1)
}

if o.has_visible {
res << vproto.pack_bool_field(o.visible, 2)
}

if o.has_x_position {
res << vproto.pack_float_field(o.x_position, 3)
}

if o.has_y_position {
res << vproto.pack_float_field(o.y_position, 4)
}

if o.has_x_scale {
res << vproto.pack_float_field(o.x_scale, 5)
}

if o.has_y_scale {
res << vproto.pack_float_field(o.y_scale, 6)
}

return res
}

pub fn cvirtualcontrollerelement_unpack(buf []byte) ?CVirtualControllerElement {
mut res := CVirtualControllerElement{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_type = true
ii, v := zzz_vproto_internal_unpack_econtrollerelementtype(cur_buf, tag_wiretype.wire_type)?
res.@type = v
i = ii
}

2 {
res.has_visible = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.visible = v
i = ii
}

3 {
res.has_x_position = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.x_position = v
i = ii
}

4 {
res.has_y_position = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.y_position = v
i = ii
}

5 {
res.has_x_scale = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.x_scale = v
i = ii
}

6 {
res.has_y_scale = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.y_scale = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvirtualcontrollerelement() CVirtualControllerElement {
return CVirtualControllerElement{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvirtualcontrollerelement(o CVirtualControllerElement, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerelement(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerElement) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cvirtualcontrollerelement_unpack(v)?
return i, unpacked
}
pub struct CVirtualControllerColor {
mut:
unknown_fields []vproto.UnknownField
pub mut:
r f32
has_r bool
g f32
has_g bool
b f32
has_b bool
a f32
has_a bool
}
pub fn (o &CVirtualControllerColor) pack() []byte {
mut res := []byte{}
if o.has_r {
res << vproto.pack_float_field(o.r, 1)
}

if o.has_g {
res << vproto.pack_float_field(o.g, 2)
}

if o.has_b {
res << vproto.pack_float_field(o.b, 3)
}

if o.has_a {
res << vproto.pack_float_field(o.a, 4)
}

return res
}

pub fn cvirtualcontrollercolor_unpack(buf []byte) ?CVirtualControllerColor {
mut res := CVirtualControllerColor{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_r = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.r = v
i = ii
}

2 {
res.has_g = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.g = v
i = ii
}

3 {
res.has_b = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.b = v
i = ii
}

4 {
res.has_a = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.a = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvirtualcontrollercolor() CVirtualControllerColor {
return CVirtualControllerColor{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvirtualcontrollercolor(o CVirtualControllerColor, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvirtualcontrollercolor(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerColor) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cvirtualcontrollercolor_unpack(v)?
return i, unpacked
}
pub struct CVirtualControllerLayout {
mut:
unknown_fields []vproto.UnknownField
pub mut:
layout_version int
has_layout_version bool
actionset_id int
has_actionset_id bool
elements []CVirtualControllerElement
color CVirtualControllerColor
has_color bool
}
pub fn (o &CVirtualControllerLayout) pack() []byte {
mut res := []byte{}
if o.has_layout_version {
res << vproto.pack_int32_field(o.layout_version, 1)
}

if o.has_actionset_id {
res << vproto.pack_int32_field(o.actionset_id, 2)
}

// [packed=false]
for _, x in o.elements {
res << zzz_vproto_internal_pack_cvirtualcontrollerelement(x, 4)
}

if o.has_color {
res << zzz_vproto_internal_pack_cvirtualcontrollercolor(o.color, 5)
}

return res
}

pub fn cvirtualcontrollerlayout_unpack(buf []byte) ?CVirtualControllerLayout {
mut res := CVirtualControllerLayout{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_layout_version = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.layout_version = v
i = ii
}

2 {
res.has_actionset_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.actionset_id = v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cvirtualcontrollerelement(cur_buf, tag_wiretype.wire_type)?
res.elements << v
i = ii
}

5 {
res.has_color = true
ii, v := zzz_vproto_internal_unpack_cvirtualcontrollercolor(cur_buf, tag_wiretype.wire_type)?
res.color = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvirtualcontrollerlayout() CVirtualControllerLayout {
return CVirtualControllerLayout{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvirtualcontrollerlayout(o CVirtualControllerLayout, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerlayout(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerLayout) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cvirtualcontrollerlayout_unpack(v)?
return i, unpacked
}
pub struct CVirtualControllerLayouts {
mut:
unknown_fields []vproto.UnknownField
pub mut:
layouts []CVirtualControllerLayout
input_mode EInputMode
has_input_mode bool
mouse_mode EMouseMode
has_mouse_mode bool
trackpad_sensitivity f32
has_trackpad_sensitivity bool
pinch_zoom_enabled bool
has_pinch_zoom_enabled bool
pinch_zoom_x f32
has_pinch_zoom_x bool
pinch_zoom_y f32
has_pinch_zoom_y bool
pinch_zoom_scale f32
has_pinch_zoom_scale bool
shaken bool
has_shaken bool
mouse_offscreen bool
has_mouse_offscreen bool
}
pub fn (o &CVirtualControllerLayouts) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.layouts {
res << zzz_vproto_internal_pack_cvirtualcontrollerlayout(x, 1)
}

if o.has_input_mode {
res << zzz_vproto_internal_pack_einputmode(o.input_mode, 2)
}

if o.has_mouse_mode {
res << zzz_vproto_internal_pack_emousemode(o.mouse_mode, 3)
}

if o.has_trackpad_sensitivity {
res << vproto.pack_float_field(o.trackpad_sensitivity, 4)
}

if o.has_pinch_zoom_enabled {
res << vproto.pack_bool_field(o.pinch_zoom_enabled, 5)
}

if o.has_pinch_zoom_x {
res << vproto.pack_float_field(o.pinch_zoom_x, 6)
}

if o.has_pinch_zoom_y {
res << vproto.pack_float_field(o.pinch_zoom_y, 7)
}

if o.has_pinch_zoom_scale {
res << vproto.pack_float_field(o.pinch_zoom_scale, 8)
}

if o.has_shaken {
res << vproto.pack_bool_field(o.shaken, 9)
}

if o.has_mouse_offscreen {
res << vproto.pack_bool_field(o.mouse_offscreen, 10)
}

return res
}

pub fn cvirtualcontrollerlayouts_unpack(buf []byte) ?CVirtualControllerLayouts {
mut res := CVirtualControllerLayouts{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cvirtualcontrollerlayout(cur_buf, tag_wiretype.wire_type)?
res.layouts << v
i = ii
}

2 {
res.has_input_mode = true
ii, v := zzz_vproto_internal_unpack_einputmode(cur_buf, tag_wiretype.wire_type)?
res.input_mode = v
i = ii
}

3 {
res.has_mouse_mode = true
ii, v := zzz_vproto_internal_unpack_emousemode(cur_buf, tag_wiretype.wire_type)?
res.mouse_mode = v
i = ii
}

4 {
res.has_trackpad_sensitivity = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.trackpad_sensitivity = v
i = ii
}

5 {
res.has_pinch_zoom_enabled = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.pinch_zoom_enabled = v
i = ii
}

6 {
res.has_pinch_zoom_x = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.pinch_zoom_x = v
i = ii
}

7 {
res.has_pinch_zoom_y = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.pinch_zoom_y = v
i = ii
}

8 {
res.has_pinch_zoom_scale = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.pinch_zoom_scale = v
i = ii
}

9 {
res.has_shaken = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.shaken = v
i = ii
}

10 {
res.has_mouse_offscreen = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.mouse_offscreen = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvirtualcontrollerlayouts() CVirtualControllerLayouts {
return CVirtualControllerLayouts{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvirtualcontrollerlayouts(o CVirtualControllerLayouts, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerlayouts(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerLayouts) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cvirtualcontrollerlayouts_unpack(v)?
return i, unpacked
}
pub struct CVirtualControllerConfigControl {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
has_name bool
icon string
has_icon bool
input_source int
has_input_source bool
input_mode int
has_input_mode bool
input_element int
has_input_element bool
output_gamepad int
has_output_gamepad bool
output_keyboard int
has_output_keyboard bool
output_mouse int
has_output_mouse bool
icon_foreground string
has_icon_foreground bool
icon_background string
has_icon_background bool
input_toggle bool
has_input_toggle bool
input_activate_stick_or_trackpad int
has_input_activate_stick_or_trackpad bool
activation_type int
has_activation_type bool
long_press_ms int
has_long_press_ms bool
double_press_ms int
has_double_press_ms bool
}
pub fn (o &CVirtualControllerConfigControl) pack() []byte {
mut res := []byte{}
if o.has_name {
res << vproto.pack_string_field(o.name, 1)
}

if o.has_icon {
res << vproto.pack_string_field(o.icon, 2)
}

if o.has_input_source {
res << vproto.pack_int32_field(o.input_source, 3)
}

if o.has_input_mode {
res << vproto.pack_int32_field(o.input_mode, 4)
}

if o.has_input_element {
res << vproto.pack_int32_field(o.input_element, 5)
}

if o.has_output_gamepad {
res << vproto.pack_int32_field(o.output_gamepad, 6)
}

if o.has_output_keyboard {
res << vproto.pack_int32_field(o.output_keyboard, 7)
}

if o.has_output_mouse {
res << vproto.pack_int32_field(o.output_mouse, 8)
}

if o.has_icon_foreground {
res << vproto.pack_string_field(o.icon_foreground, 9)
}

if o.has_icon_background {
res << vproto.pack_string_field(o.icon_background, 10)
}

if o.has_input_toggle {
res << vproto.pack_bool_field(o.input_toggle, 11)
}

if o.has_input_activate_stick_or_trackpad {
res << vproto.pack_int32_field(o.input_activate_stick_or_trackpad, 12)
}

if o.has_activation_type {
res << vproto.pack_int32_field(o.activation_type, 13)
}

if o.has_long_press_ms {
res << vproto.pack_int32_field(o.long_press_ms, 14)
}

if o.has_double_press_ms {
res << vproto.pack_int32_field(o.double_press_ms, 15)
}

return res
}

pub fn cvirtualcontrollerconfigcontrol_unpack(buf []byte) ?CVirtualControllerConfigControl {
mut res := CVirtualControllerConfigControl{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

2 {
res.has_icon = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.icon = v
i = ii
}

3 {
res.has_input_source = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.input_source = v
i = ii
}

4 {
res.has_input_mode = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.input_mode = v
i = ii
}

5 {
res.has_input_element = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.input_element = v
i = ii
}

6 {
res.has_output_gamepad = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.output_gamepad = v
i = ii
}

7 {
res.has_output_keyboard = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.output_keyboard = v
i = ii
}

8 {
res.has_output_mouse = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.output_mouse = v
i = ii
}

9 {
res.has_icon_foreground = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.icon_foreground = v
i = ii
}

10 {
res.has_icon_background = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.icon_background = v
i = ii
}

11 {
res.has_input_toggle = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.input_toggle = v
i = ii
}

12 {
res.has_input_activate_stick_or_trackpad = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.input_activate_stick_or_trackpad = v
i = ii
}

13 {
res.has_activation_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.activation_type = v
i = ii
}

14 {
res.has_long_press_ms = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.long_press_ms = v
i = ii
}

15 {
res.has_double_press_ms = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.double_press_ms = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvirtualcontrollerconfigcontrol() CVirtualControllerConfigControl {
return CVirtualControllerConfigControl{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvirtualcontrollerconfigcontrol(o CVirtualControllerConfigControl, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerconfigcontrol(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerConfigControl) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cvirtualcontrollerconfigcontrol_unpack(v)?
return i, unpacked
}
pub struct CVirtualControllerConfigActionSet {
mut:
unknown_fields []vproto.UnknownField
pub mut:
id int
has_id bool
parent_id int
has_parent_id bool
name string
has_name bool
controls []CVirtualControllerConfigControl
}
pub fn (o &CVirtualControllerConfigActionSet) pack() []byte {
mut res := []byte{}
if o.has_id {
res << vproto.pack_int32_field(o.id, 1)
}

if o.has_parent_id {
res << vproto.pack_int32_field(o.parent_id, 2)
}

if o.has_name {
res << vproto.pack_string_field(o.name, 3)
}

// [packed=false]
for _, x in o.controls {
res << zzz_vproto_internal_pack_cvirtualcontrollerconfigcontrol(x, 4)
}

return res
}

pub fn cvirtualcontrollerconfigactionset_unpack(buf []byte) ?CVirtualControllerConfigActionSet {
mut res := CVirtualControllerConfigActionSet{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.id = v
i = ii
}

2 {
res.has_parent_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.parent_id = v
i = ii
}

3 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cvirtualcontrollerconfigcontrol(cur_buf, tag_wiretype.wire_type)?
res.controls << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvirtualcontrollerconfigactionset() CVirtualControllerConfigActionSet {
return CVirtualControllerConfigActionSet{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvirtualcontrollerconfigactionset(o CVirtualControllerConfigActionSet, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerconfigactionset(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerConfigActionSet) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cvirtualcontrollerconfigactionset_unpack(v)?
return i, unpacked
}
pub struct CVirtualControllerConfig {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
has_name bool
actionsets []CVirtualControllerConfigActionSet
default_mouse_mode EMouseMode
has_default_mouse_mode bool
}
pub fn (o &CVirtualControllerConfig) pack() []byte {
mut res := []byte{}
if o.has_name {
res << vproto.pack_string_field(o.name, 1)
}

// [packed=false]
for _, x in o.actionsets {
res << zzz_vproto_internal_pack_cvirtualcontrollerconfigactionset(x, 2)
}

if o.has_default_mouse_mode {
res << zzz_vproto_internal_pack_emousemode(o.default_mouse_mode, 3)
}

return res
}

pub fn cvirtualcontrollerconfig_unpack(buf []byte) ?CVirtualControllerConfig {
mut res := CVirtualControllerConfig{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cvirtualcontrollerconfigactionset(cur_buf, tag_wiretype.wire_type)?
res.actionsets << v
i = ii
}

3 {
res.has_default_mouse_mode = true
ii, v := zzz_vproto_internal_unpack_emousemode(cur_buf, tag_wiretype.wire_type)?
res.default_mouse_mode = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvirtualcontrollerconfig() CVirtualControllerConfig {
return CVirtualControllerConfig{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvirtualcontrollerconfig(o CVirtualControllerConfig, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerconfig(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerConfig) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cvirtualcontrollerconfig_unpack(v)?
return i, unpacked
}
pub struct CVirtualControllerLayoutPackage {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
creator u64
has_creator bool
initial_revision u32
has_initial_revision bool
saved_revision u32
has_saved_revision bool
config CVirtualControllerConfig
has_config bool
layouts CVirtualControllerLayouts
has_layouts bool
}
pub fn (o &CVirtualControllerLayoutPackage) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_creator {
res << vproto.pack_uint64_field(o.creator, 2)
}

if o.has_initial_revision {
res << vproto.pack_uint32_field(o.initial_revision, 3)
}

if o.has_saved_revision {
res << vproto.pack_uint32_field(o.saved_revision, 4)
}

if o.has_config {
res << zzz_vproto_internal_pack_cvirtualcontrollerconfig(o.config, 5)
}

if o.has_layouts {
res << zzz_vproto_internal_pack_cvirtualcontrollerlayouts(o.layouts, 6)
}

return res
}

pub fn cvirtualcontrollerlayoutpackage_unpack(buf []byte) ?CVirtualControllerLayoutPackage {
mut res := CVirtualControllerLayoutPackage{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_creator = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.creator = v
i = ii
}

3 {
res.has_initial_revision = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.initial_revision = v
i = ii
}

4 {
res.has_saved_revision = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.saved_revision = v
i = ii
}

5 {
res.has_config = true
ii, v := zzz_vproto_internal_unpack_cvirtualcontrollerconfig(cur_buf, tag_wiretype.wire_type)?
res.config = v
i = ii
}

6 {
res.has_layouts = true
ii, v := zzz_vproto_internal_unpack_cvirtualcontrollerlayouts(cur_buf, tag_wiretype.wire_type)?
res.layouts = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvirtualcontrollerlayoutpackage() CVirtualControllerLayoutPackage {
return CVirtualControllerLayoutPackage{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvirtualcontrollerlayoutpackage(o CVirtualControllerLayoutPackage, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerlayoutpackage(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerLayoutPackage) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cvirtualcontrollerlayoutpackage_unpack(v)?
return i, unpacked
}
pub struct CVirtualControllerGlobalConfig {
mut:
unknown_fields []vproto.UnknownField
pub mut:
feedback_enabled bool
has_feedback_enabled bool
gyroscope_enabled bool
has_gyroscope_enabled bool
auto_fade_enabled bool
has_auto_fade_enabled bool
rumble_enabled bool
has_rumble_enabled bool
shake_fade_enabled bool
has_shake_fade_enabled bool
}
pub fn (o &CVirtualControllerGlobalConfig) pack() []byte {
mut res := []byte{}
if o.has_feedback_enabled {
res << vproto.pack_bool_field(o.feedback_enabled, 1)
}

if o.has_gyroscope_enabled {
res << vproto.pack_bool_field(o.gyroscope_enabled, 2)
}

if o.has_auto_fade_enabled {
res << vproto.pack_bool_field(o.auto_fade_enabled, 3)
}

if o.has_rumble_enabled {
res << vproto.pack_bool_field(o.rumble_enabled, 4)
}

if o.has_shake_fade_enabled {
res << vproto.pack_bool_field(o.shake_fade_enabled, 5)
}

return res
}

pub fn cvirtualcontrollerglobalconfig_unpack(buf []byte) ?CVirtualControllerGlobalConfig {
mut res := CVirtualControllerGlobalConfig{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_feedback_enabled = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.feedback_enabled = v
i = ii
}

2 {
res.has_gyroscope_enabled = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.gyroscope_enabled = v
i = ii
}

3 {
res.has_auto_fade_enabled = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.auto_fade_enabled = v
i = ii
}

4 {
res.has_rumble_enabled = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.rumble_enabled = v
i = ii
}

5 {
res.has_shake_fade_enabled = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.shake_fade_enabled = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvirtualcontrollerglobalconfig() CVirtualControllerGlobalConfig {
return CVirtualControllerGlobalConfig{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvirtualcontrollerglobalconfig(o CVirtualControllerGlobalConfig, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvirtualcontrollerglobalconfig(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualControllerGlobalConfig) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cvirtualcontrollerglobalconfig_unpack(v)?
return i, unpacked
}
