// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CCloudGamingCreateNonceRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	platform       string
	has_platform   bool
	appid          u32
	has_appid      bool
}

pub fn (o &CCloudGamingCreateNonceRequest) pack() []byte {
	mut res := []byte{}
	if o.has_platform {
		res << vproto.pack_string_field(o.platform, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	return res
}

pub fn ccloudgamingcreatenoncerequest_unpack(buf []byte) ?CCloudGamingCreateNonceRequest {
	mut res := CCloudGamingCreateNonceRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_platform = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.platform = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudgamingcreatenoncerequest() CCloudGamingCreateNonceRequest {
	return CCloudGamingCreateNonceRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudgamingcreatenoncerequest(o CCloudGamingCreateNonceRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudgamingcreatenoncerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudGamingCreateNonceRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudgamingcreatenoncerequest_unpack(v)?
	return i, unpacked
}

pub struct CCloudGamingCreateNonceResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	nonce          string
	has_nonce      bool
	expiry         u32
	has_expiry     bool
}

pub fn (o &CCloudGamingCreateNonceResponse) pack() []byte {
	mut res := []byte{}
	if o.has_nonce {
		res << vproto.pack_string_field(o.nonce, 1)
	}
	if o.has_expiry {
		res << vproto.pack_uint32_field(o.expiry, 2)
	}
	return res
}

pub fn ccloudgamingcreatenonceresponse_unpack(buf []byte) ?CCloudGamingCreateNonceResponse {
	mut res := CCloudGamingCreateNonceResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_nonce = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.nonce = v
				i = ii
			}
			2 {
				res.has_expiry = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.expiry = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudgamingcreatenonceresponse() CCloudGamingCreateNonceResponse {
	return CCloudGamingCreateNonceResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudgamingcreatenonceresponse(o CCloudGamingCreateNonceResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudgamingcreatenonceresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudGamingCreateNonceResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudgamingcreatenonceresponse_unpack(v)?
	return i, unpacked
}

pub struct CCloudGamingGetTimeRemainingRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	platform       string
	has_platform   bool
	appid_list     []u32
}

pub fn (o &CCloudGamingGetTimeRemainingRequest) pack() []byte {
	mut res := []byte{}
	if o.has_platform {
		res << vproto.pack_string_field(o.platform, 1)
	}
	// [packed=false]
	for _, x in o.appid_list {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn ccloudgaminggettimeremainingrequest_unpack(buf []byte) ?CCloudGamingGetTimeRemainingRequest {
	mut res := CCloudGamingGetTimeRemainingRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_platform = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.platform = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid_list << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudgaminggettimeremainingrequest() CCloudGamingGetTimeRemainingRequest {
	return CCloudGamingGetTimeRemainingRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudgaminggettimeremainingrequest(o CCloudGamingGetTimeRemainingRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudgaminggettimeremainingrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudGamingGetTimeRemainingRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudgaminggettimeremainingrequest_unpack(v)?
	return i, unpacked
}

pub struct CCloudGamingTimeRemaining {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	appid                 u32
	has_appid             bool
	minutes_remaining     u32
	has_minutes_remaining bool
}

pub fn (o &CCloudGamingTimeRemaining) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_minutes_remaining {
		res << vproto.pack_uint32_field(o.minutes_remaining, 2)
	}
	return res
}

pub fn ccloudgamingtimeremaining_unpack(buf []byte) ?CCloudGamingTimeRemaining {
	mut res := CCloudGamingTimeRemaining{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_minutes_remaining = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.minutes_remaining = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudgamingtimeremaining() CCloudGamingTimeRemaining {
	return CCloudGamingTimeRemaining{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudgamingtimeremaining(o CCloudGamingTimeRemaining, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudgamingtimeremaining(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudGamingTimeRemaining) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudgamingtimeremaining_unpack(v)?
	return i, unpacked
}

pub struct CCloudGamingGetTimeRemainingResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	entries        []CCloudGamingTimeRemaining
}

pub fn (o &CCloudGamingGetTimeRemainingResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.entries {
		res << zzz_vproto_internal_pack_ccloudgamingtimeremaining(x, 2)
	}
	return res
}

pub fn ccloudgaminggettimeremainingresponse_unpack(buf []byte) ?CCloudGamingGetTimeRemainingResponse {
	mut res := CCloudGamingGetTimeRemainingResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccloudgamingtimeremaining(cur_buf,
					tag_wiretype.wire_type)?
				res.entries << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudgaminggettimeremainingresponse() CCloudGamingGetTimeRemainingResponse {
	return CCloudGamingGetTimeRemainingResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudgaminggettimeremainingresponse(o CCloudGamingGetTimeRemainingResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudgaminggettimeremainingresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudGamingGetTimeRemainingResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudgaminggettimeremainingresponse_unpack(v)?
	return i, unpacked
}
