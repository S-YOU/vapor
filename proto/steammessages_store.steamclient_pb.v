// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EUserReviewScorePreference {
	k_euserreviewscorepreference_unset = 0
	k_euserreviewscorepreference_includeall = 1
	k_euserreviewscorepreference_excludebombs = 2
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_euserreviewscorepreference(e EUserReviewScorePreference, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_euserreviewscorepreference(buf []byte, tag_wiretype vproto.WireType) ?(int, EUserReviewScorePreference) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EUserReviewScorePreference(v)
}

pub struct CStoreGetLocalizedNameForTagsRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	language       string
	has_language   bool
	tagids         []u32
}

pub fn (o &CStoreGetLocalizedNameForTagsRequest) pack() []byte {
	mut res := []byte{}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 1)
	}
	// [packed=false]
	for _, x in o.tagids {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cstoregetlocalizednamefortagsrequest_unpack(buf []byte) ?CStoreGetLocalizedNameForTagsRequest {
	mut res := CStoreGetLocalizedNameForTagsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tagids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstoregetlocalizednamefortagsrequest() CStoreGetLocalizedNameForTagsRequest {
	return CStoreGetLocalizedNameForTagsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstoregetlocalizednamefortagsrequest(o CStoreGetLocalizedNameForTagsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstoregetlocalizednamefortagsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CStoreGetLocalizedNameForTagsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstoregetlocalizednamefortagsrequest_unpack(v)?
	return i, unpacked
}

pub struct CStoreGetLocalizedNameForTagsResponseTag {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	tagid            u32
	has_tagid        bool
	english_name     string
	has_english_name bool
	name             string
	has_name         bool
}

pub fn (o &CStoreGetLocalizedNameForTagsResponseTag) pack() []byte {
	mut res := []byte{}
	if o.has_tagid {
		res << vproto.pack_uint32_field(o.tagid, 1)
	}
	if o.has_english_name {
		res << vproto.pack_string_field(o.english_name, 2)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 3)
	}
	return res
}

pub fn cstoregetlocalizednamefortagsresponsetag_unpack(buf []byte) ?CStoreGetLocalizedNameForTagsResponseTag {
	mut res := CStoreGetLocalizedNameForTagsResponseTag{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_tagid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tagid = v
				i = ii
			}
			2 {
				res.has_english_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.english_name = v
				i = ii
			}
			3 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstoregetlocalizednamefortagsresponsetag() CStoreGetLocalizedNameForTagsResponseTag {
	return CStoreGetLocalizedNameForTagsResponseTag{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstoregetlocalizednamefortagsresponsetag(o CStoreGetLocalizedNameForTagsResponseTag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstoregetlocalizednamefortagsresponsetag(buf []byte, tag_wiretype vproto.WireType) ?(int, CStoreGetLocalizedNameForTagsResponseTag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstoregetlocalizednamefortagsresponsetag_unpack(v)?
	return i, unpacked
}

pub struct CStoreGetLocalizedNameForTagsResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	tags           []CStoreGetLocalizedNameForTagsResponseTag
}

pub fn (o &CStoreGetLocalizedNameForTagsResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.tags {
		res << zzz_vproto_internal_pack_cstoregetlocalizednamefortagsresponsetag(x, 1)
	}
	return res
}

pub fn cstoregetlocalizednamefortagsresponse_unpack(buf []byte) ?CStoreGetLocalizedNameForTagsResponse {
	mut res := CStoreGetLocalizedNameForTagsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstoregetlocalizednamefortagsresponsetag(cur_buf,
					tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstoregetlocalizednamefortagsresponse() CStoreGetLocalizedNameForTagsResponse {
	return CStoreGetLocalizedNameForTagsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstoregetlocalizednamefortagsresponse(o CStoreGetLocalizedNameForTagsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstoregetlocalizednamefortagsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CStoreGetLocalizedNameForTagsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstoregetlocalizednamefortagsresponse_unpack(v)?
	return i, unpacked
}

pub struct CStoreGetStorePreferencesRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CStoreGetStorePreferencesRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn cstoregetstorepreferencesrequest_unpack(buf []byte) ?CStoreGetStorePreferencesRequest {
	res := CStoreGetStorePreferencesRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstoregetstorepreferencesrequest() CStoreGetStorePreferencesRequest {
	return CStoreGetStorePreferencesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstoregetstorepreferencesrequest(o CStoreGetStorePreferencesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstoregetstorepreferencesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CStoreGetStorePreferencesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstoregetstorepreferencesrequest_unpack(v)?
	return i, unpacked
}

pub struct CStoreUserPreferences {
mut:
	unknown_fields                                       []vproto.UnknownField
pub mut:
	primary_language                                     u32
	has_primary_language                                 bool
	secondary_languages                                  u32
	has_secondary_languages                              bool
	platform_windows                                     bool
	has_platform_windows                                 bool
	platform_mac                                         bool
	has_platform_mac                                     bool
	platform_linux                                       bool
	has_platform_linux                                   bool
	hide_adult_content_violence                          bool
	has_hide_adult_content_violence                      bool
	hide_adult_content_sex                               bool
	has_hide_adult_content_sex                           bool
	timestamp_updated                                    u32
	has_timestamp_updated                                bool
	hide_store_broadcast                                 bool
	has_hide_store_broadcast                             bool
	review_score_preference                              EUserReviewScorePreference
	has_review_score_preference                          bool
	timestamp_content_descriptor_preferences_updated     int
	has_timestamp_content_descriptor_preferences_updated bool
}

pub fn (o &CStoreUserPreferences) pack() []byte {
	mut res := []byte{}
	if o.has_primary_language {
		res << vproto.pack_uint32_field(o.primary_language, 1)
	}
	if o.has_secondary_languages {
		res << vproto.pack_uint32_field(o.secondary_languages, 2)
	}
	if o.has_platform_windows {
		res << vproto.pack_bool_field(o.platform_windows, 3)
	}
	if o.has_platform_mac {
		res << vproto.pack_bool_field(o.platform_mac, 4)
	}
	if o.has_platform_linux {
		res << vproto.pack_bool_field(o.platform_linux, 5)
	}
	if o.has_hide_adult_content_violence {
		res << vproto.pack_bool_field(o.hide_adult_content_violence, 6)
	}
	if o.has_hide_adult_content_sex {
		res << vproto.pack_bool_field(o.hide_adult_content_sex, 7)
	}
	if o.has_timestamp_updated {
		res << vproto.pack_uint32_field(o.timestamp_updated, 8)
	}
	if o.has_hide_store_broadcast {
		res << vproto.pack_bool_field(o.hide_store_broadcast, 9)
	}
	if o.has_review_score_preference {
		res << zzz_vproto_internal_pack_euserreviewscorepreference(o.review_score_preference, 10)
	}
	if o.has_timestamp_content_descriptor_preferences_updated {
		res << vproto.pack_int32_field(o.timestamp_content_descriptor_preferences_updated, 11)
	}
	return res
}

pub fn cstoreuserpreferences_unpack(buf []byte) ?CStoreUserPreferences {
	mut res := CStoreUserPreferences{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_primary_language = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.primary_language = v
				i = ii
			}
			2 {
				res.has_secondary_languages = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.secondary_languages = v
				i = ii
			}
			3 {
				res.has_platform_windows = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.platform_windows = v
				i = ii
			}
			4 {
				res.has_platform_mac = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.platform_mac = v
				i = ii
			}
			5 {
				res.has_platform_linux = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.platform_linux = v
				i = ii
			}
			6 {
				res.has_hide_adult_content_violence = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_adult_content_violence = v
				i = ii
			}
			7 {
				res.has_hide_adult_content_sex = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_adult_content_sex = v
				i = ii
			}
			8 {
				res.has_timestamp_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_updated = v
				i = ii
			}
			9 {
				res.has_hide_store_broadcast = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_store_broadcast = v
				i = ii
			}
			10 {
				res.has_review_score_preference = true
				ii, v := zzz_vproto_internal_unpack_euserreviewscorepreference(cur_buf,
					tag_wiretype.wire_type)?
				res.review_score_preference = v
				i = ii
			}
			11 {
				res.has_timestamp_content_descriptor_preferences_updated = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_content_descriptor_preferences_updated = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstoreuserpreferences() CStoreUserPreferences {
	return CStoreUserPreferences{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstoreuserpreferences(o CStoreUserPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstoreuserpreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CStoreUserPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstoreuserpreferences_unpack(v)?
	return i, unpacked
}

pub struct CStoreUserTagPreferencesTag {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	tagid               u32
	has_tagid           bool
	name                string
	has_name            bool
	timestamp_added     u32
	has_timestamp_added bool
}

pub fn (o &CStoreUserTagPreferencesTag) pack() []byte {
	mut res := []byte{}
	if o.has_tagid {
		res << vproto.pack_uint32_field(o.tagid, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	if o.has_timestamp_added {
		res << vproto.pack_uint32_field(o.timestamp_added, 3)
	}
	return res
}

pub fn cstoreusertagpreferencestag_unpack(buf []byte) ?CStoreUserTagPreferencesTag {
	mut res := CStoreUserTagPreferencesTag{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_tagid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tagid = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				res.has_timestamp_added = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_added = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstoreusertagpreferencestag() CStoreUserTagPreferencesTag {
	return CStoreUserTagPreferencesTag{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstoreusertagpreferencestag(o CStoreUserTagPreferencesTag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstoreusertagpreferencestag(buf []byte, tag_wiretype vproto.WireType) ?(int, CStoreUserTagPreferencesTag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstoreusertagpreferencestag_unpack(v)?
	return i, unpacked
}

pub struct CStoreUserTagPreferences {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	tags_to_exclude []CStoreUserTagPreferencesTag
}

pub fn (o &CStoreUserTagPreferences) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.tags_to_exclude {
		res << zzz_vproto_internal_pack_cstoreusertagpreferencestag(x, 1)
	}
	return res
}

pub fn cstoreusertagpreferences_unpack(buf []byte) ?CStoreUserTagPreferences {
	mut res := CStoreUserTagPreferences{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstoreusertagpreferencestag(cur_buf,
					tag_wiretype.wire_type)?
				res.tags_to_exclude << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstoreusertagpreferences() CStoreUserTagPreferences {
	return CStoreUserTagPreferences{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstoreusertagpreferences(o CStoreUserTagPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstoreusertagpreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CStoreUserTagPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstoreusertagpreferences_unpack(v)?
	return i, unpacked
}

pub struct CStoreUserContentDescriptorPreferencesContentDescriptor {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	content_descriptorid     u32
	has_content_descriptorid bool
	timestamp_added          u32
	has_timestamp_added      bool
}

pub fn (o &CStoreUserContentDescriptorPreferencesContentDescriptor) pack() []byte {
	mut res := []byte{}
	if o.has_content_descriptorid {
		res << vproto.pack_uint32_field(o.content_descriptorid, 1)
	}
	if o.has_timestamp_added {
		res << vproto.pack_uint32_field(o.timestamp_added, 2)
	}
	return res
}

pub fn cstoreusercontentdescriptorpreferencescontentdescriptor_unpack(buf []byte) ?CStoreUserContentDescriptorPreferencesContentDescriptor {
	mut res := CStoreUserContentDescriptorPreferencesContentDescriptor{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_content_descriptorid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.content_descriptorid = v
				i = ii
			}
			2 {
				res.has_timestamp_added = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_added = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstoreusercontentdescriptorpreferencescontentdescriptor() CStoreUserContentDescriptorPreferencesContentDescriptor {
	return CStoreUserContentDescriptorPreferencesContentDescriptor{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstoreusercontentdescriptorpreferencescontentdescriptor(o CStoreUserContentDescriptorPreferencesContentDescriptor, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstoreusercontentdescriptorpreferencescontentdescriptor(buf []byte, tag_wiretype vproto.WireType) ?(int, CStoreUserContentDescriptorPreferencesContentDescriptor) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstoreusercontentdescriptorpreferencescontentdescriptor_unpack(v)?
	return i, unpacked
}

pub struct CStoreUserContentDescriptorPreferences {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	content_descriptors_to_exclude []CStoreUserContentDescriptorPreferencesContentDescriptor
}

pub fn (o &CStoreUserContentDescriptorPreferences) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.content_descriptors_to_exclude {
		res <<
			zzz_vproto_internal_pack_cstoreusercontentdescriptorpreferencescontentdescriptor(x, 1)
	}
	return res
}

pub fn cstoreusercontentdescriptorpreferences_unpack(buf []byte) ?CStoreUserContentDescriptorPreferences {
	mut res := CStoreUserContentDescriptorPreferences{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstoreusercontentdescriptorpreferencescontentdescriptor(cur_buf,
					tag_wiretype.wire_type)?
				res.content_descriptors_to_exclude << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstoreusercontentdescriptorpreferences() CStoreUserContentDescriptorPreferences {
	return CStoreUserContentDescriptorPreferences{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstoreusercontentdescriptorpreferences(o CStoreUserContentDescriptorPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstoreusercontentdescriptorpreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CStoreUserContentDescriptorPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstoreusercontentdescriptorpreferences_unpack(v)?
	return i, unpacked
}

pub struct CStoreGetStorePreferencesResponse {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	preferences                        CStoreUserPreferences
	has_preferences                    bool
	tag_preferences                    CStoreUserTagPreferences
	has_tag_preferences                bool
	content_descriptor_preferences     CStoreUserContentDescriptorPreferences
	has_content_descriptor_preferences bool
}

pub fn (o &CStoreGetStorePreferencesResponse) pack() []byte {
	mut res := []byte{}
	if o.has_preferences {
		res << zzz_vproto_internal_pack_cstoreuserpreferences(o.preferences, 1)
	}
	if o.has_tag_preferences {
		res << zzz_vproto_internal_pack_cstoreusertagpreferences(o.tag_preferences, 2)
	}
	if o.has_content_descriptor_preferences {
		res <<
			zzz_vproto_internal_pack_cstoreusercontentdescriptorpreferences(o.content_descriptor_preferences, 3)
	}
	return res
}

pub fn cstoregetstorepreferencesresponse_unpack(buf []byte) ?CStoreGetStorePreferencesResponse {
	mut res := CStoreGetStorePreferencesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_preferences = true
				ii, v := zzz_vproto_internal_unpack_cstoreuserpreferences(cur_buf, tag_wiretype.wire_type)?
				res.preferences = v
				i = ii
			}
			2 {
				res.has_tag_preferences = true
				ii, v := zzz_vproto_internal_unpack_cstoreusertagpreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.tag_preferences = v
				i = ii
			}
			3 {
				res.has_content_descriptor_preferences = true
				ii, v := zzz_vproto_internal_unpack_cstoreusercontentdescriptorpreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.content_descriptor_preferences = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstoregetstorepreferencesresponse() CStoreGetStorePreferencesResponse {
	return CStoreGetStorePreferencesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstoregetstorepreferencesresponse(o CStoreGetStorePreferencesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstoregetstorepreferencesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CStoreGetStorePreferencesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstoregetstorepreferencesresponse_unpack(v)?
	return i, unpacked
}

pub struct CStoreStorePreferencesChangedNotification {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	preferences                        CStoreUserPreferences
	has_preferences                    bool
	tag_preferences                    CStoreUserTagPreferences
	has_tag_preferences                bool
	content_descriptor_preferences     CStoreUserContentDescriptorPreferences
	has_content_descriptor_preferences bool
}

pub fn (o &CStoreStorePreferencesChangedNotification) pack() []byte {
	mut res := []byte{}
	if o.has_preferences {
		res << zzz_vproto_internal_pack_cstoreuserpreferences(o.preferences, 1)
	}
	if o.has_tag_preferences {
		res << zzz_vproto_internal_pack_cstoreusertagpreferences(o.tag_preferences, 2)
	}
	if o.has_content_descriptor_preferences {
		res <<
			zzz_vproto_internal_pack_cstoreusercontentdescriptorpreferences(o.content_descriptor_preferences, 3)
	}
	return res
}

pub fn cstorestorepreferenceschangednotification_unpack(buf []byte) ?CStoreStorePreferencesChangedNotification {
	mut res := CStoreStorePreferencesChangedNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_preferences = true
				ii, v := zzz_vproto_internal_unpack_cstoreuserpreferences(cur_buf, tag_wiretype.wire_type)?
				res.preferences = v
				i = ii
			}
			2 {
				res.has_tag_preferences = true
				ii, v := zzz_vproto_internal_unpack_cstoreusertagpreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.tag_preferences = v
				i = ii
			}
			3 {
				res.has_content_descriptor_preferences = true
				ii, v := zzz_vproto_internal_unpack_cstoreusercontentdescriptorpreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.content_descriptor_preferences = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstorestorepreferenceschangednotification() CStoreStorePreferencesChangedNotification {
	return CStoreStorePreferencesChangedNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstorestorepreferenceschangednotification(o CStoreStorePreferencesChangedNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstorestorepreferenceschangednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CStoreStorePreferencesChangedNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstorestorepreferenceschangednotification_unpack(v)?
	return i, unpacked
}
