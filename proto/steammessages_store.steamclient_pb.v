// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EUserReviewScorePreference {
	k_euserreviewscorepreference_unset = 0
	k_euserreviewscorepreference_includeall = 1
	k_euserreviewscorepreference_excludebombs = 2
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_euserreviewscorepreference(e EUserReviewScorePreference, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_euserreviewscorepreference_packed(e []EUserReviewScorePreference, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_euserreviewscorepreference(buf []byte, tag_wiretype vproto.WireType) ?(int, EUserReviewScorePreference) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EUserReviewScorePreference(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_euserreviewscorepreference_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EUserReviewScorePreference) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CStore_GetLocalizedNameForTags_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	language       string
	has_language   bool
	tagids         []u32
}

pub fn (o &CStore_GetLocalizedNameForTags_Request) pack() []byte {
	mut res := []byte{}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 1)
	}
	// [packed=false]
	for _, x in o.tagids {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cstore_getlocalizednamefortags_request_unpack(buf []byte) ?CStore_GetLocalizedNameForTags_Request {
	mut res := CStore_GetLocalizedNameForTags_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tagids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstore_getlocalizednamefortags_request() CStore_GetLocalizedNameForTags_Request {
	return CStore_GetLocalizedNameForTags_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstore_getlocalizednamefortags_request(o CStore_GetLocalizedNameForTags_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstore_getlocalizednamefortags_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CStore_GetLocalizedNameForTags_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstore_getlocalizednamefortags_request_unpack(v)?
	return i, unpacked
}

pub struct CStore_GetLocalizedNameForTags_Response_Tag {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	tagid            u32
	has_tagid        bool
	english_name     string
	has_english_name bool
	name             string
	has_name         bool
}

pub fn (o &CStore_GetLocalizedNameForTags_Response_Tag) pack() []byte {
	mut res := []byte{}
	if o.has_tagid {
		res << vproto.pack_uint32_field(o.tagid, 1)
	}
	if o.has_english_name {
		res << vproto.pack_string_field(o.english_name, 2)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 3)
	}
	return res
}

pub fn cstore_getlocalizednamefortags_response_tag_unpack(buf []byte) ?CStore_GetLocalizedNameForTags_Response_Tag {
	mut res := CStore_GetLocalizedNameForTags_Response_Tag{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_tagid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tagid = v
				i = ii
			}
			2 {
				res.has_english_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.english_name = v
				i = ii
			}
			3 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstore_getlocalizednamefortags_response_tag() CStore_GetLocalizedNameForTags_Response_Tag {
	return CStore_GetLocalizedNameForTags_Response_Tag{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstore_getlocalizednamefortags_response_tag(o CStore_GetLocalizedNameForTags_Response_Tag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstore_getlocalizednamefortags_response_tag(buf []byte, tag_wiretype vproto.WireType) ?(int, CStore_GetLocalizedNameForTags_Response_Tag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstore_getlocalizednamefortags_response_tag_unpack(v)?
	return i, unpacked
}

pub struct CStore_GetLocalizedNameForTags_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	tags           []CStore_GetLocalizedNameForTags_Response_Tag
}

pub fn (o &CStore_GetLocalizedNameForTags_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.tags {
		res << zzz_vproto_internal_pack_cstore_getlocalizednamefortags_response_tag(x, 1)
	}
	return res
}

pub fn cstore_getlocalizednamefortags_response_unpack(buf []byte) ?CStore_GetLocalizedNameForTags_Response {
	mut res := CStore_GetLocalizedNameForTags_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstore_getlocalizednamefortags_response_tag(cur_buf,
					tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstore_getlocalizednamefortags_response() CStore_GetLocalizedNameForTags_Response {
	return CStore_GetLocalizedNameForTags_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstore_getlocalizednamefortags_response(o CStore_GetLocalizedNameForTags_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstore_getlocalizednamefortags_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CStore_GetLocalizedNameForTags_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstore_getlocalizednamefortags_response_unpack(v)?
	return i, unpacked
}

pub struct CStore_GetStorePreferences_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CStore_GetStorePreferences_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cstore_getstorepreferences_request_unpack(buf []byte) ?CStore_GetStorePreferences_Request {
	res := CStore_GetStorePreferences_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstore_getstorepreferences_request() CStore_GetStorePreferences_Request {
	return CStore_GetStorePreferences_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstore_getstorepreferences_request(o CStore_GetStorePreferences_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstore_getstorepreferences_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CStore_GetStorePreferences_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstore_getstorepreferences_request_unpack(v)?
	return i, unpacked
}

pub struct CStore_UserPreferences {
mut:
	unknown_fields                                       []vproto.UnknownField
pub mut:
	primary_language                                     u32
	has_primary_language                                 bool
	secondary_languages                                  u32
	has_secondary_languages                              bool
	platform_windows                                     bool
	has_platform_windows                                 bool
	platform_mac                                         bool
	has_platform_mac                                     bool
	platform_linux                                       bool
	has_platform_linux                                   bool
	hide_adult_content_violence                          bool
	has_hide_adult_content_violence                      bool
	hide_adult_content_sex                               bool
	has_hide_adult_content_sex                           bool
	timestamp_updated                                    u32
	has_timestamp_updated                                bool
	hide_store_broadcast                                 bool
	has_hide_store_broadcast                             bool
	review_score_preference                              EUserReviewScorePreference
	has_review_score_preference                          bool
	timestamp_content_descriptor_preferences_updated     int
	has_timestamp_content_descriptor_preferences_updated bool
}

pub fn (o &CStore_UserPreferences) pack() []byte {
	mut res := []byte{}
	if o.has_primary_language {
		res << vproto.pack_uint32_field(o.primary_language, 1)
	}
	if o.has_secondary_languages {
		res << vproto.pack_uint32_field(o.secondary_languages, 2)
	}
	if o.has_platform_windows {
		res << vproto.pack_bool_field(o.platform_windows, 3)
	}
	if o.has_platform_mac {
		res << vproto.pack_bool_field(o.platform_mac, 4)
	}
	if o.has_platform_linux {
		res << vproto.pack_bool_field(o.platform_linux, 5)
	}
	if o.has_hide_adult_content_violence {
		res << vproto.pack_bool_field(o.hide_adult_content_violence, 6)
	}
	if o.has_hide_adult_content_sex {
		res << vproto.pack_bool_field(o.hide_adult_content_sex, 7)
	}
	if o.has_timestamp_updated {
		res << vproto.pack_uint32_field(o.timestamp_updated, 8)
	}
	if o.has_hide_store_broadcast {
		res << vproto.pack_bool_field(o.hide_store_broadcast, 9)
	}
	if o.has_review_score_preference {
		res << zzz_vproto_internal_pack_euserreviewscorepreference(o.review_score_preference, 10)
	}
	if o.has_timestamp_content_descriptor_preferences_updated {
		res << vproto.pack_int32_field(o.timestamp_content_descriptor_preferences_updated, 11)
	}
	return res
}

pub fn cstore_userpreferences_unpack(buf []byte) ?CStore_UserPreferences {
	mut res := CStore_UserPreferences{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_primary_language = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.primary_language = v
				i = ii
			}
			2 {
				res.has_secondary_languages = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.secondary_languages = v
				i = ii
			}
			3 {
				res.has_platform_windows = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.platform_windows = v
				i = ii
			}
			4 {
				res.has_platform_mac = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.platform_mac = v
				i = ii
			}
			5 {
				res.has_platform_linux = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.platform_linux = v
				i = ii
			}
			6 {
				res.has_hide_adult_content_violence = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_adult_content_violence = v
				i = ii
			}
			7 {
				res.has_hide_adult_content_sex = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_adult_content_sex = v
				i = ii
			}
			8 {
				res.has_timestamp_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_updated = v
				i = ii
			}
			9 {
				res.has_hide_store_broadcast = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_store_broadcast = v
				i = ii
			}
			10 {
				res.has_review_score_preference = true
				ii, v := zzz_vproto_internal_unpack_euserreviewscorepreference(cur_buf,
					tag_wiretype.wire_type)?
				res.review_score_preference = v
				i = ii
			}
			11 {
				res.has_timestamp_content_descriptor_preferences_updated = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_content_descriptor_preferences_updated = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstore_userpreferences() CStore_UserPreferences {
	return CStore_UserPreferences{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstore_userpreferences(o CStore_UserPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstore_userpreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CStore_UserPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstore_userpreferences_unpack(v)?
	return i, unpacked
}

pub struct CStore_UserTagPreferences_Tag {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	tagid               u32
	has_tagid           bool
	name                string
	has_name            bool
	timestamp_added     u32
	has_timestamp_added bool
}

pub fn (o &CStore_UserTagPreferences_Tag) pack() []byte {
	mut res := []byte{}
	if o.has_tagid {
		res << vproto.pack_uint32_field(o.tagid, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	if o.has_timestamp_added {
		res << vproto.pack_uint32_field(o.timestamp_added, 3)
	}
	return res
}

pub fn cstore_usertagpreferences_tag_unpack(buf []byte) ?CStore_UserTagPreferences_Tag {
	mut res := CStore_UserTagPreferences_Tag{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_tagid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tagid = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				res.has_timestamp_added = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_added = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstore_usertagpreferences_tag() CStore_UserTagPreferences_Tag {
	return CStore_UserTagPreferences_Tag{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstore_usertagpreferences_tag(o CStore_UserTagPreferences_Tag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstore_usertagpreferences_tag(buf []byte, tag_wiretype vproto.WireType) ?(int, CStore_UserTagPreferences_Tag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstore_usertagpreferences_tag_unpack(v)?
	return i, unpacked
}

pub struct CStore_UserTagPreferences {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	tags_to_exclude []CStore_UserTagPreferences_Tag
}

pub fn (o &CStore_UserTagPreferences) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.tags_to_exclude {
		res << zzz_vproto_internal_pack_cstore_usertagpreferences_tag(x, 1)
	}
	return res
}

pub fn cstore_usertagpreferences_unpack(buf []byte) ?CStore_UserTagPreferences {
	mut res := CStore_UserTagPreferences{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstore_usertagpreferences_tag(cur_buf,
					tag_wiretype.wire_type)?
				res.tags_to_exclude << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstore_usertagpreferences() CStore_UserTagPreferences {
	return CStore_UserTagPreferences{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstore_usertagpreferences(o CStore_UserTagPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstore_usertagpreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CStore_UserTagPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstore_usertagpreferences_unpack(v)?
	return i, unpacked
}

pub struct CStore_UserContentDescriptorPreferences_ContentDescriptor {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	content_descriptorid     u32
	has_content_descriptorid bool
	timestamp_added          u32
	has_timestamp_added      bool
}

pub fn (o &CStore_UserContentDescriptorPreferences_ContentDescriptor) pack() []byte {
	mut res := []byte{}
	if o.has_content_descriptorid {
		res << vproto.pack_uint32_field(o.content_descriptorid, 1)
	}
	if o.has_timestamp_added {
		res << vproto.pack_uint32_field(o.timestamp_added, 2)
	}
	return res
}

pub fn cstore_usercontentdescriptorpreferences_contentdescriptor_unpack(buf []byte) ?CStore_UserContentDescriptorPreferences_ContentDescriptor {
	mut res := CStore_UserContentDescriptorPreferences_ContentDescriptor{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_content_descriptorid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.content_descriptorid = v
				i = ii
			}
			2 {
				res.has_timestamp_added = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_added = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstore_usercontentdescriptorpreferences_contentdescriptor() CStore_UserContentDescriptorPreferences_ContentDescriptor {
	return CStore_UserContentDescriptorPreferences_ContentDescriptor{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstore_usercontentdescriptorpreferences_contentdescriptor(o CStore_UserContentDescriptorPreferences_ContentDescriptor, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstore_usercontentdescriptorpreferences_contentdescriptor(buf []byte, tag_wiretype vproto.WireType) ?(int, CStore_UserContentDescriptorPreferences_ContentDescriptor) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstore_usercontentdescriptorpreferences_contentdescriptor_unpack(v)?
	return i, unpacked
}

pub struct CStore_UserContentDescriptorPreferences {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	content_descriptors_to_exclude []CStore_UserContentDescriptorPreferences_ContentDescriptor
}

pub fn (o &CStore_UserContentDescriptorPreferences) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.content_descriptors_to_exclude {
		res <<
			zzz_vproto_internal_pack_cstore_usercontentdescriptorpreferences_contentdescriptor(x, 1)
	}
	return res
}

pub fn cstore_usercontentdescriptorpreferences_unpack(buf []byte) ?CStore_UserContentDescriptorPreferences {
	mut res := CStore_UserContentDescriptorPreferences{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstore_usercontentdescriptorpreferences_contentdescriptor(cur_buf,
					tag_wiretype.wire_type)?
				res.content_descriptors_to_exclude << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstore_usercontentdescriptorpreferences() CStore_UserContentDescriptorPreferences {
	return CStore_UserContentDescriptorPreferences{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstore_usercontentdescriptorpreferences(o CStore_UserContentDescriptorPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstore_usercontentdescriptorpreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CStore_UserContentDescriptorPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstore_usercontentdescriptorpreferences_unpack(v)?
	return i, unpacked
}

pub struct CStore_GetStorePreferences_Response {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	preferences                        CStore_UserPreferences
	has_preferences                    bool
	tag_preferences                    CStore_UserTagPreferences
	has_tag_preferences                bool
	content_descriptor_preferences     CStore_UserContentDescriptorPreferences
	has_content_descriptor_preferences bool
}

pub fn (o &CStore_GetStorePreferences_Response) pack() []byte {
	mut res := []byte{}
	if o.has_preferences {
		res << zzz_vproto_internal_pack_cstore_userpreferences(o.preferences, 1)
	}
	if o.has_tag_preferences {
		res << zzz_vproto_internal_pack_cstore_usertagpreferences(o.tag_preferences, 2)
	}
	if o.has_content_descriptor_preferences {
		res <<
			zzz_vproto_internal_pack_cstore_usercontentdescriptorpreferences(o.content_descriptor_preferences, 3)
	}
	return res
}

pub fn cstore_getstorepreferences_response_unpack(buf []byte) ?CStore_GetStorePreferences_Response {
	mut res := CStore_GetStorePreferences_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_preferences = true
				ii, v := zzz_vproto_internal_unpack_cstore_userpreferences(cur_buf, tag_wiretype.wire_type)?
				res.preferences = v
				i = ii
			}
			2 {
				res.has_tag_preferences = true
				ii, v := zzz_vproto_internal_unpack_cstore_usertagpreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.tag_preferences = v
				i = ii
			}
			3 {
				res.has_content_descriptor_preferences = true
				ii, v := zzz_vproto_internal_unpack_cstore_usercontentdescriptorpreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.content_descriptor_preferences = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstore_getstorepreferences_response() CStore_GetStorePreferences_Response {
	return CStore_GetStorePreferences_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstore_getstorepreferences_response(o CStore_GetStorePreferences_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstore_getstorepreferences_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CStore_GetStorePreferences_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstore_getstorepreferences_response_unpack(v)?
	return i, unpacked
}

pub struct CStore_StorePreferencesChanged_Notification {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	preferences                        CStore_UserPreferences
	has_preferences                    bool
	tag_preferences                    CStore_UserTagPreferences
	has_tag_preferences                bool
	content_descriptor_preferences     CStore_UserContentDescriptorPreferences
	has_content_descriptor_preferences bool
}

pub fn (o &CStore_StorePreferencesChanged_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_preferences {
		res << zzz_vproto_internal_pack_cstore_userpreferences(o.preferences, 1)
	}
	if o.has_tag_preferences {
		res << zzz_vproto_internal_pack_cstore_usertagpreferences(o.tag_preferences, 2)
	}
	if o.has_content_descriptor_preferences {
		res <<
			zzz_vproto_internal_pack_cstore_usercontentdescriptorpreferences(o.content_descriptor_preferences, 3)
	}
	return res
}

pub fn cstore_storepreferenceschanged_notification_unpack(buf []byte) ?CStore_StorePreferencesChanged_Notification {
	mut res := CStore_StorePreferencesChanged_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_preferences = true
				ii, v := zzz_vproto_internal_unpack_cstore_userpreferences(cur_buf, tag_wiretype.wire_type)?
				res.preferences = v
				i = ii
			}
			2 {
				res.has_tag_preferences = true
				ii, v := zzz_vproto_internal_unpack_cstore_usertagpreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.tag_preferences = v
				i = ii
			}
			3 {
				res.has_content_descriptor_preferences = true
				ii, v := zzz_vproto_internal_unpack_cstore_usercontentdescriptorpreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.content_descriptor_preferences = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstore_storepreferenceschanged_notification() CStore_StorePreferencesChanged_Notification {
	return CStore_StorePreferencesChanged_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstore_storepreferenceschanged_notification(o CStore_StorePreferencesChanged_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstore_storepreferenceschanged_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CStore_StorePreferencesChanged_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstore_storepreferenceschanged_notification_unpack(v)?
	return i, unpacked
}
