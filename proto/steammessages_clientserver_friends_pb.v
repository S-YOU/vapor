// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CMsgClientFriendMsg {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	steamid                      u64
	has_steamid                  bool
	chat_entry_type              int
	has_chat_entry_type          bool
	message                      []byte
	has_message                  bool
	rtime32_server_timestamp     u32
	has_rtime32_server_timestamp bool
	echo_to_sender               bool
	has_echo_to_sender           bool
}

pub fn (o &CMsgClientFriendMsg) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_chat_entry_type {
		res << vproto.pack_int32_field(o.chat_entry_type, 2)
	}
	if o.has_message {
		res << vproto.pack_bytes_field(o.message, 3)
	}
	if o.has_rtime32_server_timestamp {
		res << vproto.pack_32bit_field(o.rtime32_server_timestamp, 4)
	}
	if o.has_echo_to_sender {
		res << vproto.pack_bool_field(o.echo_to_sender, 5)
	}
	return res
}

pub fn cmsgclientfriendmsg_unpack(buf []byte) ?CMsgClientFriendMsg {
	mut res := CMsgClientFriendMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_chat_entry_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_entry_type = v
				i = ii
			}
			3 {
				res.has_message = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			4 {
				res.has_rtime32_server_timestamp = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_server_timestamp = v
				i = ii
			}
			5 {
				res.has_echo_to_sender = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.echo_to_sender = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfriendmsg() CMsgClientFriendMsg {
	return CMsgClientFriendMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfriendmsg(o CMsgClientFriendMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfriendmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientfriendmsg_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientFriendMsgIncoming {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	steamid_from                 u64
	has_steamid_from             bool
	chat_entry_type              int
	has_chat_entry_type          bool
	from_limited_account         bool
	has_from_limited_account     bool
	message                      []byte
	has_message                  bool
	rtime32_server_timestamp     u32
	has_rtime32_server_timestamp bool
}

pub fn (o &CMsgClientFriendMsgIncoming) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_from {
		res << vproto.pack_64bit_field(o.steamid_from, 1)
	}
	if o.has_chat_entry_type {
		res << vproto.pack_int32_field(o.chat_entry_type, 2)
	}
	if o.has_from_limited_account {
		res << vproto.pack_bool_field(o.from_limited_account, 3)
	}
	if o.has_message {
		res << vproto.pack_bytes_field(o.message, 4)
	}
	if o.has_rtime32_server_timestamp {
		res << vproto.pack_32bit_field(o.rtime32_server_timestamp, 5)
	}
	return res
}

pub fn cmsgclientfriendmsgincoming_unpack(buf []byte) ?CMsgClientFriendMsgIncoming {
	mut res := CMsgClientFriendMsgIncoming{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_from = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_from = v
				i = ii
			}
			2 {
				res.has_chat_entry_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_entry_type = v
				i = ii
			}
			3 {
				res.has_from_limited_account = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.from_limited_account = v
				i = ii
			}
			4 {
				res.has_message = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			5 {
				res.has_rtime32_server_timestamp = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_server_timestamp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfriendmsgincoming() CMsgClientFriendMsgIncoming {
	return CMsgClientFriendMsgIncoming{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfriendmsgincoming(o CMsgClientFriendMsgIncoming, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfriendmsgincoming(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendMsgIncoming) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientfriendmsgincoming_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAddFriend {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	steamid_to_add                  u64
	has_steamid_to_add              bool
	accountname_or_email_to_add     string
	has_accountname_or_email_to_add bool
}

pub fn (o &CMsgClientAddFriend) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_to_add {
		res << vproto.pack_64bit_field(o.steamid_to_add, 1)
	}
	if o.has_accountname_or_email_to_add {
		res << vproto.pack_string_field(o.accountname_or_email_to_add, 2)
	}
	return res
}

pub fn cmsgclientaddfriend_unpack(buf []byte) ?CMsgClientAddFriend {
	mut res := CMsgClientAddFriend{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_to_add = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_to_add = v
				i = ii
			}
			2 {
				res.has_accountname_or_email_to_add = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.accountname_or_email_to_add = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientaddfriend() CMsgClientAddFriend {
	return CMsgClientAddFriend{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientaddfriend(o CMsgClientAddFriend, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientaddfriend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAddFriend) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientaddfriend_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAddFriendResponse {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	eresult                int
	has_eresult            bool
	steam_id_added         u64
	has_steam_id_added     bool
	persona_name_added     string
	has_persona_name_added bool
}

pub fn (o &CMsgClientAddFriendResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_steam_id_added {
		res << vproto.pack_64bit_field(o.steam_id_added, 2)
	}
	if o.has_persona_name_added {
		res << vproto.pack_string_field(o.persona_name_added, 3)
	}
	return res
}

pub fn cmsgclientaddfriendresponse_unpack(buf []byte) ?CMsgClientAddFriendResponse {
	mut res := CMsgClientAddFriendResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_steam_id_added = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_added = v
				i = ii
			}
			3 {
				res.has_persona_name_added = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_name_added = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientaddfriendresponse() CMsgClientAddFriendResponse {
	return CMsgClientAddFriendResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientaddfriendresponse(o CMsgClientAddFriendResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientaddfriendresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAddFriendResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientaddfriendresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRemoveFriend {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	friendid       u64
	has_friendid   bool
}

pub fn (o &CMsgClientRemoveFriend) pack() []byte {
	mut res := []byte{}
	if o.has_friendid {
		res << vproto.pack_64bit_field(o.friendid, 1)
	}
	return res
}

pub fn cmsgclientremovefriend_unpack(buf []byte) ?CMsgClientRemoveFriend {
	mut res := CMsgClientRemoveFriend{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_friendid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.friendid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientremovefriend() CMsgClientRemoveFriend {
	return CMsgClientRemoveFriend{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientremovefriend(o CMsgClientRemoveFriend, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientremovefriend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRemoveFriend) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientremovefriend_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientHideFriend {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	friendid       u64
	has_friendid   bool
	hide           bool
	has_hide       bool
}

pub fn (o &CMsgClientHideFriend) pack() []byte {
	mut res := []byte{}
	if o.has_friendid {
		res << vproto.pack_64bit_field(o.friendid, 1)
	}
	if o.has_hide {
		res << vproto.pack_bool_field(o.hide, 2)
	}
	return res
}

pub fn cmsgclienthidefriend_unpack(buf []byte) ?CMsgClientHideFriend {
	mut res := CMsgClientHideFriend{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_friendid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.friendid = v
				i = ii
			}
			2 {
				res.has_hide = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclienthidefriend() CMsgClientHideFriend {
	return CMsgClientHideFriend{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclienthidefriend(o CMsgClientHideFriend, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclienthidefriend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientHideFriend) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclienthidefriend_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientFriendsListFriend {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	ulfriendid              u64
	has_ulfriendid          bool
	efriendrelationship     u32
	has_efriendrelationship bool
}

pub fn (o &CMsgClientFriendsListFriend) pack() []byte {
	mut res := []byte{}
	if o.has_ulfriendid {
		res << vproto.pack_64bit_field(o.ulfriendid, 1)
	}
	if o.has_efriendrelationship {
		res << vproto.pack_uint32_field(o.efriendrelationship, 2)
	}
	return res
}

pub fn cmsgclientfriendslistfriend_unpack(buf []byte) ?CMsgClientFriendsListFriend {
	mut res := CMsgClientFriendsListFriend{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ulfriendid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ulfriendid = v
				i = ii
			}
			2 {
				res.has_efriendrelationship = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.efriendrelationship = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfriendslistfriend() CMsgClientFriendsListFriend {
	return CMsgClientFriendsListFriend{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfriendslistfriend(o CMsgClientFriendsListFriend, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfriendslistfriend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendsListFriend) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientfriendslistfriend_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientFriendsList {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	bincremental            bool
	has_bincremental        bool
	friends                 []CMsgClientFriendsListFriend
	max_friend_count        u32
	has_max_friend_count    bool
	active_friend_count     u32
	has_active_friend_count bool
	friends_limit_hit       bool
	has_friends_limit_hit   bool
}

pub fn (o &CMsgClientFriendsList) pack() []byte {
	mut res := []byte{}
	if o.has_bincremental {
		res << vproto.pack_bool_field(o.bincremental, 1)
	}
	// [packed=false]
	for _, x in o.friends {
		res << zzz_vproto_internal_pack_cmsgclientfriendslistfriend(x, 2)
	}
	if o.has_max_friend_count {
		res << vproto.pack_uint32_field(o.max_friend_count, 3)
	}
	if o.has_active_friend_count {
		res << vproto.pack_uint32_field(o.active_friend_count, 4)
	}
	if o.has_friends_limit_hit {
		res << vproto.pack_bool_field(o.friends_limit_hit, 5)
	}
	return res
}

pub fn cmsgclientfriendslist_unpack(buf []byte) ?CMsgClientFriendsList {
	mut res := CMsgClientFriendsList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_bincremental = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bincremental = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientfriendslistfriend(cur_buf,
					tag_wiretype.wire_type)?
				res.friends << v
				i = ii
			}
			3 {
				res.has_max_friend_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_friend_count = v
				i = ii
			}
			4 {
				res.has_active_friend_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.active_friend_count = v
				i = ii
			}
			5 {
				res.has_friends_limit_hit = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_limit_hit = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfriendslist() CMsgClientFriendsList {
	return CMsgClientFriendsList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfriendslist(o CMsgClientFriendsList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfriendslist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendsList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientfriendslist_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientFriendsGroupsListFriendGroup {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	ngroupid         int
	has_ngroupid     bool
	strgroupname     string
	has_strgroupname bool
}

pub fn (o &CMsgClientFriendsGroupsListFriendGroup) pack() []byte {
	mut res := []byte{}
	if o.has_ngroupid {
		res << vproto.pack_int32_field(o.ngroupid, 1)
	}
	if o.has_strgroupname {
		res << vproto.pack_string_field(o.strgroupname, 2)
	}
	return res
}

pub fn cmsgclientfriendsgroupslistfriendgroup_unpack(buf []byte) ?CMsgClientFriendsGroupsListFriendGroup {
	mut res := CMsgClientFriendsGroupsListFriendGroup{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ngroupid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ngroupid = v
				i = ii
			}
			2 {
				res.has_strgroupname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.strgroupname = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfriendsgroupslistfriendgroup() CMsgClientFriendsGroupsListFriendGroup {
	return CMsgClientFriendsGroupsListFriendGroup{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfriendsgroupslistfriendgroup(o CMsgClientFriendsGroupsListFriendGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfriendsgroupslistfriendgroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendsGroupsListFriendGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientfriendsgroupslistfriendgroup_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientFriendsGroupsListFriendGroupsMembership {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ulsteamid      u64
	has_ulsteamid  bool
	ngroupid       int
	has_ngroupid   bool
}

pub fn (o &CMsgClientFriendsGroupsListFriendGroupsMembership) pack() []byte {
	mut res := []byte{}
	if o.has_ulsteamid {
		res << vproto.pack_64bit_field(o.ulsteamid, 1)
	}
	if o.has_ngroupid {
		res << vproto.pack_int32_field(o.ngroupid, 2)
	}
	return res
}

pub fn cmsgclientfriendsgroupslistfriendgroupsmembership_unpack(buf []byte) ?CMsgClientFriendsGroupsListFriendGroupsMembership {
	mut res := CMsgClientFriendsGroupsListFriendGroupsMembership{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ulsteamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ulsteamid = v
				i = ii
			}
			2 {
				res.has_ngroupid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ngroupid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfriendsgroupslistfriendgroupsmembership() CMsgClientFriendsGroupsListFriendGroupsMembership {
	return CMsgClientFriendsGroupsListFriendGroupsMembership{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfriendsgroupslistfriendgroupsmembership(o CMsgClientFriendsGroupsListFriendGroupsMembership, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfriendsgroupslistfriendgroupsmembership(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendsGroupsListFriendGroupsMembership) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientfriendsgroupslistfriendgroupsmembership_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientFriendsGroupsList {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	bremoval         bool
	has_bremoval     bool
	bincremental     bool
	has_bincremental bool
	friendgroups     []CMsgClientFriendsGroupsListFriendGroup
	memberships      []CMsgClientFriendsGroupsListFriendGroupsMembership
}

pub fn (o &CMsgClientFriendsGroupsList) pack() []byte {
	mut res := []byte{}
	if o.has_bremoval {
		res << vproto.pack_bool_field(o.bremoval, 1)
	}
	if o.has_bincremental {
		res << vproto.pack_bool_field(o.bincremental, 2)
	}
	// [packed=false]
	for _, x in o.friendgroups {
		res << zzz_vproto_internal_pack_cmsgclientfriendsgroupslistfriendgroup(x, 3)
	}
	// [packed=false]
	for _, x in o.memberships {
		res << zzz_vproto_internal_pack_cmsgclientfriendsgroupslistfriendgroupsmembership(x, 4)
	}
	return res
}

pub fn cmsgclientfriendsgroupslist_unpack(buf []byte) ?CMsgClientFriendsGroupsList {
	mut res := CMsgClientFriendsGroupsList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_bremoval = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bremoval = v
				i = ii
			}
			2 {
				res.has_bincremental = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bincremental = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientfriendsgroupslistfriendgroup(cur_buf,
					tag_wiretype.wire_type)?
				res.friendgroups << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientfriendsgroupslistfriendgroupsmembership(cur_buf,
					tag_wiretype.wire_type)?
				res.memberships << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfriendsgroupslist() CMsgClientFriendsGroupsList {
	return CMsgClientFriendsGroupsList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfriendsgroupslist(o CMsgClientFriendsGroupsList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfriendsgroupslist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendsGroupsList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientfriendsgroupslist_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPlayerNicknameListPlayerNickname {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	nickname       string
	has_nickname   bool
}

pub fn (o &CMsgClientPlayerNicknameListPlayerNickname) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_nickname {
		res << vproto.pack_string_field(o.nickname, 3)
	}
	return res
}

pub fn cmsgclientplayernicknamelistplayernickname_unpack(buf []byte) ?CMsgClientPlayerNicknameListPlayerNickname {
	mut res := CMsgClientPlayerNicknameListPlayerNickname{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_nickname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.nickname = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientplayernicknamelistplayernickname() CMsgClientPlayerNicknameListPlayerNickname {
	return CMsgClientPlayerNicknameListPlayerNickname{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientplayernicknamelistplayernickname(o CMsgClientPlayerNicknameListPlayerNickname, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientplayernicknamelistplayernickname(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPlayerNicknameListPlayerNickname) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientplayernicknamelistplayernickname_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPlayerNicknameList {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	removal         bool
	has_removal     bool
	incremental     bool
	has_incremental bool
	nicknames       []CMsgClientPlayerNicknameListPlayerNickname
}

pub fn (o &CMsgClientPlayerNicknameList) pack() []byte {
	mut res := []byte{}
	if o.has_removal {
		res << vproto.pack_bool_field(o.removal, 1)
	}
	if o.has_incremental {
		res << vproto.pack_bool_field(o.incremental, 2)
	}
	// [packed=false]
	for _, x in o.nicknames {
		res << zzz_vproto_internal_pack_cmsgclientplayernicknamelistplayernickname(x, 3)
	}
	return res
}

pub fn cmsgclientplayernicknamelist_unpack(buf []byte) ?CMsgClientPlayerNicknameList {
	mut res := CMsgClientPlayerNicknameList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_removal = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.removal = v
				i = ii
			}
			2 {
				res.has_incremental = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.incremental = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientplayernicknamelistplayernickname(cur_buf,
					tag_wiretype.wire_type)?
				res.nicknames << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientplayernicknamelist() CMsgClientPlayerNicknameList {
	return CMsgClientPlayerNicknameList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientplayernicknamelist(o CMsgClientPlayerNicknameList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientplayernicknamelist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPlayerNicknameList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientplayernicknamelist_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientSetPlayerNickname {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	nickname       string
	has_nickname   bool
}

pub fn (o &CMsgClientSetPlayerNickname) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_nickname {
		res << vproto.pack_string_field(o.nickname, 2)
	}
	return res
}

pub fn cmsgclientsetplayernickname_unpack(buf []byte) ?CMsgClientSetPlayerNickname {
	mut res := CMsgClientSetPlayerNickname{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_nickname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.nickname = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsetplayernickname() CMsgClientSetPlayerNickname {
	return CMsgClientSetPlayerNickname{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsetplayernickname(o CMsgClientSetPlayerNickname, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsetplayernickname(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSetPlayerNickname) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientsetplayernickname_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientSetPlayerNicknameResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
	has_eresult    bool
}

pub fn (o &CMsgClientSetPlayerNicknameResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientsetplayernicknameresponse_unpack(buf []byte) ?CMsgClientSetPlayerNicknameResponse {
	mut res := CMsgClientSetPlayerNicknameResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsetplayernicknameresponse() CMsgClientSetPlayerNicknameResponse {
	return CMsgClientSetPlayerNicknameResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsetplayernicknameresponse(o CMsgClientSetPlayerNicknameResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsetplayernicknameresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSetPlayerNicknameResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientsetplayernicknameresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestFriendData {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	persona_state_requested     u32
	has_persona_state_requested bool
	friends                     []u64
}

pub fn (o &CMsgClientRequestFriendData) pack() []byte {
	mut res := []byte{}
	if o.has_persona_state_requested {
		res << vproto.pack_uint32_field(o.persona_state_requested, 1)
	}
	// [packed=false]
	for _, x in o.friends {
		res << vproto.pack_64bit_field(x, 2)
	}
	return res
}

pub fn cmsgclientrequestfrienddata_unpack(buf []byte) ?CMsgClientRequestFriendData {
	mut res := CMsgClientRequestFriendData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_persona_state_requested = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_state_requested = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.friends << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestfrienddata() CMsgClientRequestFriendData {
	return CMsgClientRequestFriendData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestfrienddata(o CMsgClientRequestFriendData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestfrienddata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestFriendData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestfrienddata_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientChangeStatus {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	persona_state              u32
	has_persona_state          bool
	player_name                string
	has_player_name            bool
	is_auto_generated_name     bool
	has_is_auto_generated_name bool
	high_priority              bool
	has_high_priority          bool
	persona_set_by_user        bool
	has_persona_set_by_user    bool
	persona_state_flags        u32
	has_persona_state_flags    bool
	need_persona_response      bool
	has_need_persona_response  bool
	is_client_idle             bool
	has_is_client_idle         bool
}

pub fn (o &CMsgClientChangeStatus) pack() []byte {
	mut res := []byte{}
	if o.has_persona_state {
		res << vproto.pack_uint32_field(o.persona_state, 1)
	}
	if o.has_player_name {
		res << vproto.pack_string_field(o.player_name, 2)
	}
	if o.has_is_auto_generated_name {
		res << vproto.pack_bool_field(o.is_auto_generated_name, 3)
	}
	if o.has_high_priority {
		res << vproto.pack_bool_field(o.high_priority, 4)
	}
	if o.has_persona_set_by_user {
		res << vproto.pack_bool_field(o.persona_set_by_user, 5)
	}
	if o.has_persona_state_flags {
		res << vproto.pack_uint32_field(o.persona_state_flags, 6)
	}
	if o.has_need_persona_response {
		res << vproto.pack_bool_field(o.need_persona_response, 7)
	}
	if o.has_is_client_idle {
		res << vproto.pack_bool_field(o.is_client_idle, 8)
	}
	return res
}

pub fn cmsgclientchangestatus_unpack(buf []byte) ?CMsgClientChangeStatus {
	mut res := CMsgClientChangeStatus{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_persona_state = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_state = v
				i = ii
			}
			2 {
				res.has_player_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.player_name = v
				i = ii
			}
			3 {
				res.has_is_auto_generated_name = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_auto_generated_name = v
				i = ii
			}
			4 {
				res.has_high_priority = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.high_priority = v
				i = ii
			}
			5 {
				res.has_persona_set_by_user = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_set_by_user = v
				i = ii
			}
			6 {
				res.has_persona_state_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_state_flags = v
				i = ii
			}
			7 {
				res.has_need_persona_response = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.need_persona_response = v
				i = ii
			}
			8 {
				res.has_is_client_idle = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_client_idle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientchangestatus() CMsgClientChangeStatus {
	return CMsgClientChangeStatus{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientchangestatus(o CMsgClientChangeStatus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientchangestatus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChangeStatus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientchangestatus_unpack(v)?
	return i, unpacked
}

pub struct CMsgPersonaChangeResponse {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	result          u32
	has_result      bool
	player_name     string
	has_player_name bool
}

pub fn (o &CMsgPersonaChangeResponse) pack() []byte {
	mut res := []byte{}
	if o.has_result {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	if o.has_player_name {
		res << vproto.pack_string_field(o.player_name, 2)
	}
	return res
}

pub fn cmsgpersonachangeresponse_unpack(buf []byte) ?CMsgPersonaChangeResponse {
	mut res := CMsgPersonaChangeResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			2 {
				res.has_player_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.player_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgpersonachangeresponse() CMsgPersonaChangeResponse {
	return CMsgPersonaChangeResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgpersonachangeresponse(o CMsgPersonaChangeResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgpersonachangeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPersonaChangeResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgpersonachangeresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPersonaStateFriendClanData {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	ogg_app_id        u32
	has_ogg_app_id    bool
	chat_group_id     u64
	has_chat_group_id bool
}

pub fn (o &CMsgClientPersonaStateFriendClanData) pack() []byte {
	mut res := []byte{}
	if o.has_ogg_app_id {
		res << vproto.pack_uint32_field(o.ogg_app_id, 1)
	}
	if o.has_chat_group_id {
		res << vproto.pack_uint64_field(o.chat_group_id, 2)
	}
	return res
}

pub fn cmsgclientpersonastatefriendclandata_unpack(buf []byte) ?CMsgClientPersonaStateFriendClanData {
	mut res := CMsgClientPersonaStateFriendClanData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ogg_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ogg_app_id = v
				i = ii
			}
			2 {
				res.has_chat_group_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_group_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpersonastatefriendclandata() CMsgClientPersonaStateFriendClanData {
	return CMsgClientPersonaStateFriendClanData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpersonastatefriendclandata(o CMsgClientPersonaStateFriendClanData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpersonastatefriendclandata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPersonaStateFriendClanData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpersonastatefriendclandata_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPersonaStateFriendKV {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &CMsgClientPersonaStateFriendKV) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn cmsgclientpersonastatefriendkv_unpack(buf []byte) ?CMsgClientPersonaStateFriendKV {
	mut res := CMsgClientPersonaStateFriendKV{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpersonastatefriendkv() CMsgClientPersonaStateFriendKV {
	return CMsgClientPersonaStateFriendKV{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpersonastatefriendkv(o CMsgClientPersonaStateFriendKV, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpersonastatefriendkv(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPersonaStateFriendKV) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpersonastatefriendkv_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPersonaStateFriend {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	friendid                         u64
	has_friendid                     bool
	persona_state                    u32
	has_persona_state                bool
	game_played_app_id               u32
	has_game_played_app_id           bool
	game_server_ip                   u32
	has_game_server_ip               bool
	game_server_port                 u32
	has_game_server_port             bool
	persona_state_flags              u32
	has_persona_state_flags          bool
	online_session_instances         u32
	has_online_session_instances     bool
	persona_set_by_user              bool
	has_persona_set_by_user          bool
	player_name                      string
	has_player_name                  bool
	query_port                       u32
	has_query_port                   bool
	steamid_source                   u64
	has_steamid_source               bool
	avatar_hash                      []byte
	has_avatar_hash                  bool
	last_logoff                      u32
	has_last_logoff                  bool
	last_logon                       u32
	has_last_logon                   bool
	last_seen_online                 u32
	has_last_seen_online             bool
	clan_rank                        u32
	has_clan_rank                    bool
	game_name                        string
	has_game_name                    bool
	gameid                           u64
	has_gameid                       bool
	game_data_blob                   []byte
	has_game_data_blob               bool
	clan_data                        CMsgClientPersonaStateFriendClanData
	has_clan_data                    bool
	clan_tag                         string
	has_clan_tag                     bool
	rich_presence                    []CMsgClientPersonaStateFriendKV
	broadcast_id                     u64
	has_broadcast_id                 bool
	game_lobby_id                    u64
	has_game_lobby_id                bool
	watching_broadcast_accountid     u32
	has_watching_broadcast_accountid bool
	watching_broadcast_appid         u32
	has_watching_broadcast_appid     bool
	watching_broadcast_viewers       u32
	has_watching_broadcast_viewers   bool
	watching_broadcast_title         string
	has_watching_broadcast_title     bool
}

pub fn (o &CMsgClientPersonaStateFriend) pack() []byte {
	mut res := []byte{}
	if o.has_friendid {
		res << vproto.pack_64bit_field(o.friendid, 1)
	}
	if o.has_persona_state {
		res << vproto.pack_uint32_field(o.persona_state, 2)
	}
	if o.has_game_played_app_id {
		res << vproto.pack_uint32_field(o.game_played_app_id, 3)
	}
	if o.has_game_server_ip {
		res << vproto.pack_uint32_field(o.game_server_ip, 4)
	}
	if o.has_game_server_port {
		res << vproto.pack_uint32_field(o.game_server_port, 5)
	}
	if o.has_persona_state_flags {
		res << vproto.pack_uint32_field(o.persona_state_flags, 6)
	}
	if o.has_online_session_instances {
		res << vproto.pack_uint32_field(o.online_session_instances, 7)
	}
	if o.has_persona_set_by_user {
		res << vproto.pack_bool_field(o.persona_set_by_user, 10)
	}
	if o.has_player_name {
		res << vproto.pack_string_field(o.player_name, 15)
	}
	if o.has_query_port {
		res << vproto.pack_uint32_field(o.query_port, 20)
	}
	if o.has_steamid_source {
		res << vproto.pack_64bit_field(o.steamid_source, 25)
	}
	if o.has_avatar_hash {
		res << vproto.pack_bytes_field(o.avatar_hash, 31)
	}
	if o.has_last_logoff {
		res << vproto.pack_uint32_field(o.last_logoff, 45)
	}
	if o.has_last_logon {
		res << vproto.pack_uint32_field(o.last_logon, 46)
	}
	if o.has_last_seen_online {
		res << vproto.pack_uint32_field(o.last_seen_online, 47)
	}
	if o.has_clan_rank {
		res << vproto.pack_uint32_field(o.clan_rank, 50)
	}
	if o.has_game_name {
		res << vproto.pack_string_field(o.game_name, 55)
	}
	if o.has_gameid {
		res << vproto.pack_64bit_field(o.gameid, 56)
	}
	if o.has_game_data_blob {
		res << vproto.pack_bytes_field(o.game_data_blob, 60)
	}
	if o.has_clan_data {
		res << zzz_vproto_internal_pack_cmsgclientpersonastatefriendclandata(o.clan_data, 64)
	}
	if o.has_clan_tag {
		res << vproto.pack_string_field(o.clan_tag, 65)
	}
	// [packed=false]
	for _, x in o.rich_presence {
		res << zzz_vproto_internal_pack_cmsgclientpersonastatefriendkv(x, 71)
	}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 72)
	}
	if o.has_game_lobby_id {
		res << vproto.pack_64bit_field(o.game_lobby_id, 73)
	}
	if o.has_watching_broadcast_accountid {
		res << vproto.pack_uint32_field(o.watching_broadcast_accountid, 74)
	}
	if o.has_watching_broadcast_appid {
		res << vproto.pack_uint32_field(o.watching_broadcast_appid, 75)
	}
	if o.has_watching_broadcast_viewers {
		res << vproto.pack_uint32_field(o.watching_broadcast_viewers, 76)
	}
	if o.has_watching_broadcast_title {
		res << vproto.pack_string_field(o.watching_broadcast_title, 77)
	}
	return res
}

pub fn cmsgclientpersonastatefriend_unpack(buf []byte) ?CMsgClientPersonaStateFriend {
	mut res := CMsgClientPersonaStateFriend{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_friendid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.friendid = v
				i = ii
			}
			2 {
				res.has_persona_state = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_state = v
				i = ii
			}
			3 {
				res.has_game_played_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_played_app_id = v
				i = ii
			}
			4 {
				res.has_game_server_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_server_ip = v
				i = ii
			}
			5 {
				res.has_game_server_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_server_port = v
				i = ii
			}
			6 {
				res.has_persona_state_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_state_flags = v
				i = ii
			}
			7 {
				res.has_online_session_instances = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.online_session_instances = v
				i = ii
			}
			10 {
				res.has_persona_set_by_user = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_set_by_user = v
				i = ii
			}
			15 {
				res.has_player_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.player_name = v
				i = ii
			}
			20 {
				res.has_query_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.query_port = v
				i = ii
			}
			25 {
				res.has_steamid_source = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_source = v
				i = ii
			}
			31 {
				res.has_avatar_hash = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.avatar_hash = v
				i = ii
			}
			45 {
				res.has_last_logoff = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_logoff = v
				i = ii
			}
			46 {
				res.has_last_logon = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_logon = v
				i = ii
			}
			47 {
				res.has_last_seen_online = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_seen_online = v
				i = ii
			}
			50 {
				res.has_clan_rank = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.clan_rank = v
				i = ii
			}
			55 {
				res.has_game_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_name = v
				i = ii
			}
			56 {
				res.has_gameid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			60 {
				res.has_game_data_blob = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.game_data_blob = v
				i = ii
			}
			64 {
				res.has_clan_data = true
				ii, v := zzz_vproto_internal_unpack_cmsgclientpersonastatefriendclandata(cur_buf,
					tag_wiretype.wire_type)?
				res.clan_data = v
				i = ii
			}
			65 {
				res.has_clan_tag = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.clan_tag = v
				i = ii
			}
			71 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpersonastatefriendkv(cur_buf,
					tag_wiretype.wire_type)?
				res.rich_presence << v
				i = ii
			}
			72 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			73 {
				res.has_game_lobby_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.game_lobby_id = v
				i = ii
			}
			74 {
				res.has_watching_broadcast_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_accountid = v
				i = ii
			}
			75 {
				res.has_watching_broadcast_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_appid = v
				i = ii
			}
			76 {
				res.has_watching_broadcast_viewers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_viewers = v
				i = ii
			}
			77 {
				res.has_watching_broadcast_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.watching_broadcast_title = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpersonastatefriend() CMsgClientPersonaStateFriend {
	return CMsgClientPersonaStateFriend{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpersonastatefriend(o CMsgClientPersonaStateFriend, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpersonastatefriend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPersonaStateFriend) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpersonastatefriend_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPersonaState {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	status_flags     u32
	has_status_flags bool
	friends          []CMsgClientPersonaStateFriend
}

pub fn (o &CMsgClientPersonaState) pack() []byte {
	mut res := []byte{}
	if o.has_status_flags {
		res << vproto.pack_uint32_field(o.status_flags, 1)
	}
	// [packed=false]
	for _, x in o.friends {
		res << zzz_vproto_internal_pack_cmsgclientpersonastatefriend(x, 2)
	}
	return res
}

pub fn cmsgclientpersonastate_unpack(buf []byte) ?CMsgClientPersonaState {
	mut res := CMsgClientPersonaState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_status_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.status_flags = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientpersonastatefriend(cur_buf,
					tag_wiretype.wire_type)?
				res.friends << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpersonastate() CMsgClientPersonaState {
	return CMsgClientPersonaState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpersonastate(o CMsgClientPersonaState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpersonastate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPersonaState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpersonastate_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientFriendProfileInfo {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	steamid_friend     u64
	has_steamid_friend bool
}

pub fn (o &CMsgClientFriendProfileInfo) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_friend {
		res << vproto.pack_64bit_field(o.steamid_friend, 1)
	}
	return res
}

pub fn cmsgclientfriendprofileinfo_unpack(buf []byte) ?CMsgClientFriendProfileInfo {
	mut res := CMsgClientFriendProfileInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_friend = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_friend = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfriendprofileinfo() CMsgClientFriendProfileInfo {
	return CMsgClientFriendProfileInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfriendprofileinfo(o CMsgClientFriendProfileInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfriendprofileinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendProfileInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientfriendprofileinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientFriendProfileInfoResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	eresult            int
	has_eresult        bool
	steamid_friend     u64
	has_steamid_friend bool
	time_created       u32
	has_time_created   bool
	real_name          string
	has_real_name      bool
	city_name          string
	has_city_name      bool
	state_name         string
	has_state_name     bool
	country_name       string
	has_country_name   bool
	headline           string
	has_headline       bool
	summary            string
	has_summary        bool
}

pub fn (o &CMsgClientFriendProfileInfoResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_steamid_friend {
		res << vproto.pack_64bit_field(o.steamid_friend, 2)
	}
	if o.has_time_created {
		res << vproto.pack_uint32_field(o.time_created, 3)
	}
	if o.has_real_name {
		res << vproto.pack_string_field(o.real_name, 4)
	}
	if o.has_city_name {
		res << vproto.pack_string_field(o.city_name, 5)
	}
	if o.has_state_name {
		res << vproto.pack_string_field(o.state_name, 6)
	}
	if o.has_country_name {
		res << vproto.pack_string_field(o.country_name, 7)
	}
	if o.has_headline {
		res << vproto.pack_string_field(o.headline, 8)
	}
	if o.has_summary {
		res << vproto.pack_string_field(o.summary, 9)
	}
	return res
}

pub fn cmsgclientfriendprofileinforesponse_unpack(buf []byte) ?CMsgClientFriendProfileInfoResponse {
	mut res := CMsgClientFriendProfileInfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_steamid_friend = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_friend = v
				i = ii
			}
			3 {
				res.has_time_created = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			4 {
				res.has_real_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.real_name = v
				i = ii
			}
			5 {
				res.has_city_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.city_name = v
				i = ii
			}
			6 {
				res.has_state_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.state_name = v
				i = ii
			}
			7 {
				res.has_country_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.country_name = v
				i = ii
			}
			8 {
				res.has_headline = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.headline = v
				i = ii
			}
			9 {
				res.has_summary = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.summary = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfriendprofileinforesponse() CMsgClientFriendProfileInfoResponse {
	return CMsgClientFriendProfileInfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfriendprofileinforesponse(o CMsgClientFriendProfileInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfriendprofileinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendProfileInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientfriendprofileinforesponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientCreateFriendsGroup {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	steamid         u64
	has_steamid     bool
	groupname       string
	has_groupname   bool
	steamid_friends []u64
}

pub fn (o &CMsgClientCreateFriendsGroup) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_groupname {
		res << vproto.pack_string_field(o.groupname, 2)
	}
	// [packed=false]
	for _, x in o.steamid_friends {
		res << vproto.pack_64bit_field(x, 3)
	}
	return res
}

pub fn cmsgclientcreatefriendsgroup_unpack(buf []byte) ?CMsgClientCreateFriendsGroup {
	mut res := CMsgClientCreateFriendsGroup{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_groupname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.groupname = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_friends << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcreatefriendsgroup() CMsgClientCreateFriendsGroup {
	return CMsgClientCreateFriendsGroup{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcreatefriendsgroup(o CMsgClientCreateFriendsGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcreatefriendsgroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCreateFriendsGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientcreatefriendsgroup_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientCreateFriendsGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
	has_eresult    bool
	groupid        int
	has_groupid    bool
}

pub fn (o &CMsgClientCreateFriendsGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	if o.has_groupid {
		res << vproto.pack_int32_field(o.groupid, 2)
	}
	return res
}

pub fn cmsgclientcreatefriendsgroupresponse_unpack(buf []byte) ?CMsgClientCreateFriendsGroupResponse {
	mut res := CMsgClientCreateFriendsGroupResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_groupid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.groupid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcreatefriendsgroupresponse() CMsgClientCreateFriendsGroupResponse {
	return CMsgClientCreateFriendsGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcreatefriendsgroupresponse(o CMsgClientCreateFriendsGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcreatefriendsgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCreateFriendsGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientcreatefriendsgroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientDeleteFriendsGroup {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	groupid        int
	has_groupid    bool
}

pub fn (o &CMsgClientDeleteFriendsGroup) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_groupid {
		res << vproto.pack_int32_field(o.groupid, 2)
	}
	return res
}

pub fn cmsgclientdeletefriendsgroup_unpack(buf []byte) ?CMsgClientDeleteFriendsGroup {
	mut res := CMsgClientDeleteFriendsGroup{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_groupid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.groupid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdeletefriendsgroup() CMsgClientDeleteFriendsGroup {
	return CMsgClientDeleteFriendsGroup{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdeletefriendsgroup(o CMsgClientDeleteFriendsGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdeletefriendsgroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDeleteFriendsGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientdeletefriendsgroup_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientDeleteFriendsGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
	has_eresult    bool
}

pub fn (o &CMsgClientDeleteFriendsGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientdeletefriendsgroupresponse_unpack(buf []byte) ?CMsgClientDeleteFriendsGroupResponse {
	mut res := CMsgClientDeleteFriendsGroupResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdeletefriendsgroupresponse() CMsgClientDeleteFriendsGroupResponse {
	return CMsgClientDeleteFriendsGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdeletefriendsgroupresponse(o CMsgClientDeleteFriendsGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdeletefriendsgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDeleteFriendsGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientdeletefriendsgroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientManageFriendsGroup {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	groupid                 int
	has_groupid             bool
	groupname               string
	has_groupname           bool
	steamid_friends_added   []u64
	steamid_friends_removed []u64
}

pub fn (o &CMsgClientManageFriendsGroup) pack() []byte {
	mut res := []byte{}
	if o.has_groupid {
		res << vproto.pack_int32_field(o.groupid, 1)
	}
	if o.has_groupname {
		res << vproto.pack_string_field(o.groupname, 2)
	}
	// [packed=false]
	for _, x in o.steamid_friends_added {
		res << vproto.pack_64bit_field(x, 3)
	}
	// [packed=false]
	for _, x in o.steamid_friends_removed {
		res << vproto.pack_64bit_field(x, 4)
	}
	return res
}

pub fn cmsgclientmanagefriendsgroup_unpack(buf []byte) ?CMsgClientManageFriendsGroup {
	mut res := CMsgClientManageFriendsGroup{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_groupid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.groupid = v
				i = ii
			}
			2 {
				res.has_groupname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.groupname = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_friends_added << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_friends_removed << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmanagefriendsgroup() CMsgClientManageFriendsGroup {
	return CMsgClientManageFriendsGroup{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmanagefriendsgroup(o CMsgClientManageFriendsGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmanagefriendsgroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientManageFriendsGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmanagefriendsgroup_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientManageFriendsGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
	has_eresult    bool
}

pub fn (o &CMsgClientManageFriendsGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientmanagefriendsgroupresponse_unpack(buf []byte) ?CMsgClientManageFriendsGroupResponse {
	mut res := CMsgClientManageFriendsGroupResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientmanagefriendsgroupresponse() CMsgClientManageFriendsGroupResponse {
	return CMsgClientManageFriendsGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientmanagefriendsgroupresponse(o CMsgClientManageFriendsGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientmanagefriendsgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientManageFriendsGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientmanagefriendsgroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAddFriendToGroup {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	groupid         int
	has_groupid     bool
	steamiduser     u64
	has_steamiduser bool
}

pub fn (o &CMsgClientAddFriendToGroup) pack() []byte {
	mut res := []byte{}
	if o.has_groupid {
		res << vproto.pack_int32_field(o.groupid, 1)
	}
	if o.has_steamiduser {
		res << vproto.pack_64bit_field(o.steamiduser, 2)
	}
	return res
}

pub fn cmsgclientaddfriendtogroup_unpack(buf []byte) ?CMsgClientAddFriendToGroup {
	mut res := CMsgClientAddFriendToGroup{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_groupid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.groupid = v
				i = ii
			}
			2 {
				res.has_steamiduser = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamiduser = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientaddfriendtogroup() CMsgClientAddFriendToGroup {
	return CMsgClientAddFriendToGroup{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientaddfriendtogroup(o CMsgClientAddFriendToGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientaddfriendtogroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAddFriendToGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientaddfriendtogroup_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAddFriendToGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
	has_eresult    bool
}

pub fn (o &CMsgClientAddFriendToGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientaddfriendtogroupresponse_unpack(buf []byte) ?CMsgClientAddFriendToGroupResponse {
	mut res := CMsgClientAddFriendToGroupResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientaddfriendtogroupresponse() CMsgClientAddFriendToGroupResponse {
	return CMsgClientAddFriendToGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientaddfriendtogroupresponse(o CMsgClientAddFriendToGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientaddfriendtogroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAddFriendToGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientaddfriendtogroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRemoveFriendFromGroup {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	groupid         int
	has_groupid     bool
	steamiduser     u64
	has_steamiduser bool
}

pub fn (o &CMsgClientRemoveFriendFromGroup) pack() []byte {
	mut res := []byte{}
	if o.has_groupid {
		res << vproto.pack_int32_field(o.groupid, 1)
	}
	if o.has_steamiduser {
		res << vproto.pack_64bit_field(o.steamiduser, 2)
	}
	return res
}

pub fn cmsgclientremovefriendfromgroup_unpack(buf []byte) ?CMsgClientRemoveFriendFromGroup {
	mut res := CMsgClientRemoveFriendFromGroup{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_groupid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.groupid = v
				i = ii
			}
			2 {
				res.has_steamiduser = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamiduser = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientremovefriendfromgroup() CMsgClientRemoveFriendFromGroup {
	return CMsgClientRemoveFriendFromGroup{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientremovefriendfromgroup(o CMsgClientRemoveFriendFromGroup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientremovefriendfromgroup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRemoveFriendFromGroup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientremovefriendfromgroup_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRemoveFriendFromGroupResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
	has_eresult    bool
}

pub fn (o &CMsgClientRemoveFriendFromGroupResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientremovefriendfromgroupresponse_unpack(buf []byte) ?CMsgClientRemoveFriendFromGroupResponse {
	mut res := CMsgClientRemoveFriendFromGroupResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientremovefriendfromgroupresponse() CMsgClientRemoveFriendFromGroupResponse {
	return CMsgClientRemoveFriendFromGroupResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientremovefriendfromgroupresponse(o CMsgClientRemoveFriendFromGroupResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientremovefriendfromgroupresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRemoveFriendFromGroupResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientremovefriendfromgroupresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetEmoticonList {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientGetEmoticonList) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientgetemoticonlist_unpack(buf []byte) ?CMsgClientGetEmoticonList {
	res := CMsgClientGetEmoticonList{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetemoticonlist() CMsgClientGetEmoticonList {
	return CMsgClientGetEmoticonList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetemoticonlist(o CMsgClientGetEmoticonList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetemoticonlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetEmoticonList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetemoticonlist_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientEmoticonListEmoticon {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	name               string
	has_name           bool
	count              int
	has_count          bool
	time_last_used     u32
	has_time_last_used bool
	use_count          u32
	has_use_count      bool
	time_received      u32
	has_time_received  bool
}

pub fn (o &CMsgClientEmoticonListEmoticon) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_count {
		res << vproto.pack_int32_field(o.count, 2)
	}
	if o.has_time_last_used {
		res << vproto.pack_uint32_field(o.time_last_used, 3)
	}
	if o.has_use_count {
		res << vproto.pack_uint32_field(o.use_count, 4)
	}
	if o.has_time_received {
		res << vproto.pack_uint32_field(o.time_received, 5)
	}
	return res
}

pub fn cmsgclientemoticonlistemoticon_unpack(buf []byte) ?CMsgClientEmoticonListEmoticon {
	mut res := CMsgClientEmoticonListEmoticon{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			3 {
				res.has_time_last_used = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last_used = v
				i = ii
			}
			4 {
				res.has_use_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.use_count = v
				i = ii
			}
			5 {
				res.has_time_received = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_received = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientemoticonlistemoticon() CMsgClientEmoticonListEmoticon {
	return CMsgClientEmoticonListEmoticon{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientemoticonlistemoticon(o CMsgClientEmoticonListEmoticon, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientemoticonlistemoticon(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientEmoticonListEmoticon) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientemoticonlistemoticon_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientEmoticonListSticker {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	name              string
	has_name          bool
	count             int
	has_count         bool
	time_received     u32
	has_time_received bool
	appid             u32
	has_appid         bool
}

pub fn (o &CMsgClientEmoticonListSticker) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_count {
		res << vproto.pack_int32_field(o.count, 2)
	}
	if o.has_time_received {
		res << vproto.pack_uint32_field(o.time_received, 3)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 4)
	}
	return res
}

pub fn cmsgclientemoticonliststicker_unpack(buf []byte) ?CMsgClientEmoticonListSticker {
	mut res := CMsgClientEmoticonListSticker{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			3 {
				res.has_time_received = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_received = v
				i = ii
			}
			4 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientemoticonliststicker() CMsgClientEmoticonListSticker {
	return CMsgClientEmoticonListSticker{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientemoticonliststicker(o CMsgClientEmoticonListSticker, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientemoticonliststicker(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientEmoticonListSticker) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientemoticonliststicker_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientEmoticonListEffect {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	name              string
	has_name          bool
	count             int
	has_count         bool
	time_received     u32
	has_time_received bool
	infinite_use      bool
	has_infinite_use  bool
	appid             u32
	has_appid         bool
}

pub fn (o &CMsgClientEmoticonListEffect) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_count {
		res << vproto.pack_int32_field(o.count, 2)
	}
	if o.has_time_received {
		res << vproto.pack_uint32_field(o.time_received, 3)
	}
	if o.has_infinite_use {
		res << vproto.pack_bool_field(o.infinite_use, 4)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 5)
	}
	return res
}

pub fn cmsgclientemoticonlisteffect_unpack(buf []byte) ?CMsgClientEmoticonListEffect {
	mut res := CMsgClientEmoticonListEffect{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			3 {
				res.has_time_received = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_received = v
				i = ii
			}
			4 {
				res.has_infinite_use = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.infinite_use = v
				i = ii
			}
			5 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientemoticonlisteffect() CMsgClientEmoticonListEffect {
	return CMsgClientEmoticonListEffect{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientemoticonlisteffect(o CMsgClientEmoticonListEffect, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientemoticonlisteffect(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientEmoticonListEffect) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientemoticonlisteffect_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientEmoticonList {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	emoticons      []CMsgClientEmoticonListEmoticon
	stickers       []CMsgClientEmoticonListSticker
	effects        []CMsgClientEmoticonListEffect
}

pub fn (o &CMsgClientEmoticonList) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.emoticons {
		res << zzz_vproto_internal_pack_cmsgclientemoticonlistemoticon(x, 1)
	}
	// [packed=false]
	for _, x in o.stickers {
		res << zzz_vproto_internal_pack_cmsgclientemoticonliststicker(x, 2)
	}
	// [packed=false]
	for _, x in o.effects {
		res << zzz_vproto_internal_pack_cmsgclientemoticonlisteffect(x, 3)
	}
	return res
}

pub fn cmsgclientemoticonlist_unpack(buf []byte) ?CMsgClientEmoticonList {
	mut res := CMsgClientEmoticonList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientemoticonlistemoticon(cur_buf,
					tag_wiretype.wire_type)?
				res.emoticons << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientemoticonliststicker(cur_buf,
					tag_wiretype.wire_type)?
				res.stickers << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientemoticonlisteffect(cur_buf,
					tag_wiretype.wire_type)?
				res.effects << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientemoticonlist() CMsgClientEmoticonList {
	return CMsgClientEmoticonList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientemoticonlist(o CMsgClientEmoticonList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientemoticonlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientEmoticonList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientemoticonlist_unpack(v)?
	return i, unpacked
}
