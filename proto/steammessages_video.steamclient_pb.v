// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CVideo_ClientGetVideoURL_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	video_id          u64
	has_video_id      bool
	client_cellid     u32
	has_client_cellid bool
}

pub fn (o &CVideo_ClientGetVideoURL_Request) pack() []byte {
	mut res := []byte{}
	if o.has_video_id {
		res << vproto.pack_uint64_field(o.video_id, 1)
	}
	if o.has_client_cellid {
		res << vproto.pack_uint32_field(o.client_cellid, 2)
	}
	return res
}

pub fn cvideo_clientgetvideourl_request_unpack(buf []byte) ?CVideo_ClientGetVideoURL_Request {
	mut res := CVideo_ClientGetVideoURL_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_video_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.video_id = v
				i = ii
			}
			2 {
				res.has_client_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_cellid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideo_clientgetvideourl_request() CVideo_ClientGetVideoURL_Request {
	return CVideo_ClientGetVideoURL_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideo_clientgetvideourl_request(o CVideo_ClientGetVideoURL_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideo_clientgetvideourl_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideo_ClientGetVideoURL_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideo_clientgetvideourl_request_unpack(v)?
	return i, unpacked
}

pub struct CVideo_ClientGetVideoURL_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	video_id       u64
	has_video_id   bool
	video_url      string
	has_video_url  bool
}

pub fn (o &CVideo_ClientGetVideoURL_Response) pack() []byte {
	mut res := []byte{}
	if o.has_video_id {
		res << vproto.pack_uint64_field(o.video_id, 1)
	}
	if o.has_video_url {
		res << vproto.pack_string_field(o.video_url, 2)
	}
	return res
}

pub fn cvideo_clientgetvideourl_response_unpack(buf []byte) ?CVideo_ClientGetVideoURL_Response {
	mut res := CVideo_ClientGetVideoURL_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_video_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.video_id = v
				i = ii
			}
			2 {
				res.has_video_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.video_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideo_clientgetvideourl_response() CVideo_ClientGetVideoURL_Response {
	return CVideo_ClientGetVideoURL_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideo_clientgetvideourl_response(o CVideo_ClientGetVideoURL_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideo_clientgetvideourl_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideo_ClientGetVideoURL_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideo_clientgetvideourl_response_unpack(v)?
	return i, unpacked
}

pub struct VideoBookmark {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	app_id                           u32
	has_app_id                       bool
	playback_position_in_seconds     u32
	has_playback_position_in_seconds bool
	video_track_id                   u64
	has_video_track_id               bool
	audio_track_id                   u64
	has_audio_track_id               bool
	timedtext_track_id               u64
	has_timedtext_track_id           bool
	last_modified                    u32
	has_last_modified                bool
	hide_from_watch_history          bool
	has_hide_from_watch_history      bool
	hide_from_library                bool
	has_hide_from_library            bool
}

pub fn (o &VideoBookmark) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_playback_position_in_seconds {
		res << vproto.pack_uint32_field(o.playback_position_in_seconds, 2)
	}
	if o.has_video_track_id {
		res << vproto.pack_uint64_field(o.video_track_id, 3)
	}
	if o.has_audio_track_id {
		res << vproto.pack_uint64_field(o.audio_track_id, 4)
	}
	if o.has_timedtext_track_id {
		res << vproto.pack_uint64_field(o.timedtext_track_id, 5)
	}
	if o.has_last_modified {
		res << vproto.pack_uint32_field(o.last_modified, 6)
	}
	if o.has_hide_from_watch_history {
		res << vproto.pack_bool_field(o.hide_from_watch_history, 7)
	}
	if o.has_hide_from_library {
		res << vproto.pack_bool_field(o.hide_from_library, 8)
	}
	return res
}

pub fn videobookmark_unpack(buf []byte) ?VideoBookmark {
	mut res := VideoBookmark{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_playback_position_in_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.playback_position_in_seconds = v
				i = ii
			}
			3 {
				res.has_video_track_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.video_track_id = v
				i = ii
			}
			4 {
				res.has_audio_track_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.audio_track_id = v
				i = ii
			}
			5 {
				res.has_timedtext_track_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.timedtext_track_id = v
				i = ii
			}
			6 {
				res.has_last_modified = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_modified = v
				i = ii
			}
			7 {
				res.has_hide_from_watch_history = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_from_watch_history = v
				i = ii
			}
			8 {
				res.has_hide_from_library = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_from_library = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_videobookmark() VideoBookmark {
	return VideoBookmark{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_videobookmark(o VideoBookmark, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_videobookmark(buf []byte, tag_wiretype vproto.WireType) ?(int, VideoBookmark) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := videobookmark_unpack(v)?
	return i, unpacked
}

pub struct CVideo_SetVideoBookmark_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bookmarks      []VideoBookmark
}

pub fn (o &CVideo_SetVideoBookmark_Notification) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.bookmarks {
		res << zzz_vproto_internal_pack_videobookmark(x, 1)
	}
	return res
}

pub fn cvideo_setvideobookmark_notification_unpack(buf []byte) ?CVideo_SetVideoBookmark_Notification {
	mut res := CVideo_SetVideoBookmark_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_videobookmark(cur_buf, tag_wiretype.wire_type)?
				res.bookmarks << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideo_setvideobookmark_notification() CVideo_SetVideoBookmark_Notification {
	return CVideo_SetVideoBookmark_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideo_setvideobookmark_notification(o CVideo_SetVideoBookmark_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideo_setvideobookmark_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideo_SetVideoBookmark_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideo_setvideobookmark_notification_unpack(v)?
	return i, unpacked
}

pub struct CVideo_GetVideoBookmarks_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	appids            []u32
	updated_since     u32
	has_updated_since bool
}

pub fn (o &CVideo_GetVideoBookmarks_Request) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.appids {
		res << vproto.pack_uint32_field(x, 1)
	}
	if o.has_updated_since {
		res << vproto.pack_uint32_field(o.updated_since, 2)
	}
	return res
}

pub fn cvideo_getvideobookmarks_request_unpack(buf []byte) ?CVideo_GetVideoBookmarks_Request {
	mut res := CVideo_GetVideoBookmarks_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appids << v
				i = ii
			}
			2 {
				res.has_updated_since = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.updated_since = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideo_getvideobookmarks_request() CVideo_GetVideoBookmarks_Request {
	return CVideo_GetVideoBookmarks_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideo_getvideobookmarks_request(o CVideo_GetVideoBookmarks_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideo_getvideobookmarks_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideo_GetVideoBookmarks_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideo_getvideobookmarks_request_unpack(v)?
	return i, unpacked
}

pub struct CVideo_GetVideoBookmarks_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bookmarks      []VideoBookmark
}

pub fn (o &CVideo_GetVideoBookmarks_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.bookmarks {
		res << zzz_vproto_internal_pack_videobookmark(x, 1)
	}
	return res
}

pub fn cvideo_getvideobookmarks_response_unpack(buf []byte) ?CVideo_GetVideoBookmarks_Response {
	mut res := CVideo_GetVideoBookmarks_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_videobookmark(cur_buf, tag_wiretype.wire_type)?
				res.bookmarks << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideo_getvideobookmarks_response() CVideo_GetVideoBookmarks_Response {
	return CVideo_GetVideoBookmarks_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideo_getvideobookmarks_response(o CVideo_GetVideoBookmarks_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideo_getvideobookmarks_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideo_GetVideoBookmarks_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideo_getvideobookmarks_response_unpack(v)?
	return i, unpacked
}

pub struct CVideo_UnlockedH264_Notification {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	encryption_key     []byte
	has_encryption_key bool
}

pub fn (o &CVideo_UnlockedH264_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_encryption_key {
		res << vproto.pack_bytes_field(o.encryption_key, 1)
	}
	return res
}

pub fn cvideo_unlockedh264_notification_unpack(buf []byte) ?CVideo_UnlockedH264_Notification {
	mut res := CVideo_UnlockedH264_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_encryption_key = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.encryption_key = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideo_unlockedh264_notification() CVideo_UnlockedH264_Notification {
	return CVideo_UnlockedH264_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideo_unlockedh264_notification(o CVideo_UnlockedH264_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideo_unlockedh264_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideo_UnlockedH264_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideo_unlockedh264_notification_unpack(v)?
	return i, unpacked
}

pub struct CFovasVideo_ClientGetOPFSettings_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	app_id            u32
	has_app_id        bool
	client_cellid     u32
	has_client_cellid bool
}

pub fn (o &CFovasVideo_ClientGetOPFSettings_Request) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_client_cellid {
		res << vproto.pack_uint32_field(o.client_cellid, 2)
	}
	return res
}

pub fn cfovasvideo_clientgetopfsettings_request_unpack(buf []byte) ?CFovasVideo_ClientGetOPFSettings_Request {
	mut res := CFovasVideo_ClientGetOPFSettings_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_client_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_cellid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfovasvideo_clientgetopfsettings_request() CFovasVideo_ClientGetOPFSettings_Request {
	return CFovasVideo_ClientGetOPFSettings_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfovasvideo_clientgetopfsettings_request(o CFovasVideo_ClientGetOPFSettings_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfovasvideo_clientgetopfsettings_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CFovasVideo_ClientGetOPFSettings_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfovasvideo_clientgetopfsettings_request_unpack(v)?
	return i, unpacked
}

pub struct CFovasVideo_ClientGetOPFSettings_Response {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	app_id           u32
	has_app_id       bool
	opf_settings     string
	has_opf_settings bool
}

pub fn (o &CFovasVideo_ClientGetOPFSettings_Response) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_opf_settings {
		res << vproto.pack_string_field(o.opf_settings, 2)
	}
	return res
}

pub fn cfovasvideo_clientgetopfsettings_response_unpack(buf []byte) ?CFovasVideo_ClientGetOPFSettings_Response {
	mut res := CFovasVideo_ClientGetOPFSettings_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_opf_settings = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.opf_settings = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfovasvideo_clientgetopfsettings_response() CFovasVideo_ClientGetOPFSettings_Response {
	return CFovasVideo_ClientGetOPFSettings_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfovasvideo_clientgetopfsettings_response(o CFovasVideo_ClientGetOPFSettings_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfovasvideo_clientgetopfsettings_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CFovasVideo_ClientGetOPFSettings_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfovasvideo_clientgetopfsettings_response_unpack(v)?
	return i, unpacked
}
