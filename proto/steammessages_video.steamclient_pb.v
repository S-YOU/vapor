// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CVideoClientGetVideoURlrequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	video_id          u64
	has_video_id      bool
	client_cellid     u32
	has_client_cellid bool
}

pub fn (o &CVideoClientGetVideoURlrequest) pack() []byte {
	mut res := []byte{}
	if o.has_video_id {
		res << vproto.pack_uint64_field(o.video_id, 1)
	}
	if o.has_client_cellid {
		res << vproto.pack_uint32_field(o.client_cellid, 2)
	}
	return res
}

pub fn cvideoclientgetvideourlrequest_unpack(buf []byte) ?CVideoClientGetVideoURlrequest {
	mut res := CVideoClientGetVideoURlrequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_video_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.video_id = v
				i = ii
			}
			2 {
				res.has_client_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_cellid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideoclientgetvideourlrequest() CVideoClientGetVideoURlrequest {
	return CVideoClientGetVideoURlrequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideoclientgetvideourlrequest(o CVideoClientGetVideoURlrequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideoclientgetvideourlrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideoClientGetVideoURlrequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideoclientgetvideourlrequest_unpack(v)?
	return i, unpacked
}

pub struct CVideoClientGetVideoURlresponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	video_id       u64
	has_video_id   bool
	video_url      string
	has_video_url  bool
}

pub fn (o &CVideoClientGetVideoURlresponse) pack() []byte {
	mut res := []byte{}
	if o.has_video_id {
		res << vproto.pack_uint64_field(o.video_id, 1)
	}
	if o.has_video_url {
		res << vproto.pack_string_field(o.video_url, 2)
	}
	return res
}

pub fn cvideoclientgetvideourlresponse_unpack(buf []byte) ?CVideoClientGetVideoURlresponse {
	mut res := CVideoClientGetVideoURlresponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_video_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.video_id = v
				i = ii
			}
			2 {
				res.has_video_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.video_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideoclientgetvideourlresponse() CVideoClientGetVideoURlresponse {
	return CVideoClientGetVideoURlresponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideoclientgetvideourlresponse(o CVideoClientGetVideoURlresponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideoclientgetvideourlresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideoClientGetVideoURlresponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideoclientgetvideourlresponse_unpack(v)?
	return i, unpacked
}

pub struct VideoBookmark {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	app_id                           u32
	has_app_id                       bool
	playback_position_in_seconds     u32
	has_playback_position_in_seconds bool
	video_track_id                   u64
	has_video_track_id               bool
	audio_track_id                   u64
	has_audio_track_id               bool
	timedtext_track_id               u64
	has_timedtext_track_id           bool
	last_modified                    u32
	has_last_modified                bool
	hide_from_watch_history          bool
	has_hide_from_watch_history      bool
	hide_from_library                bool
	has_hide_from_library            bool
}

pub fn (o &VideoBookmark) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_playback_position_in_seconds {
		res << vproto.pack_uint32_field(o.playback_position_in_seconds, 2)
	}
	if o.has_video_track_id {
		res << vproto.pack_uint64_field(o.video_track_id, 3)
	}
	if o.has_audio_track_id {
		res << vproto.pack_uint64_field(o.audio_track_id, 4)
	}
	if o.has_timedtext_track_id {
		res << vproto.pack_uint64_field(o.timedtext_track_id, 5)
	}
	if o.has_last_modified {
		res << vproto.pack_uint32_field(o.last_modified, 6)
	}
	if o.has_hide_from_watch_history {
		res << vproto.pack_bool_field(o.hide_from_watch_history, 7)
	}
	if o.has_hide_from_library {
		res << vproto.pack_bool_field(o.hide_from_library, 8)
	}
	return res
}

pub fn videobookmark_unpack(buf []byte) ?VideoBookmark {
	mut res := VideoBookmark{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_playback_position_in_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.playback_position_in_seconds = v
				i = ii
			}
			3 {
				res.has_video_track_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.video_track_id = v
				i = ii
			}
			4 {
				res.has_audio_track_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.audio_track_id = v
				i = ii
			}
			5 {
				res.has_timedtext_track_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.timedtext_track_id = v
				i = ii
			}
			6 {
				res.has_last_modified = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_modified = v
				i = ii
			}
			7 {
				res.has_hide_from_watch_history = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_from_watch_history = v
				i = ii
			}
			8 {
				res.has_hide_from_library = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_from_library = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_videobookmark() VideoBookmark {
	return VideoBookmark{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_videobookmark(o VideoBookmark, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_videobookmark(buf []byte, tag_wiretype vproto.WireType) ?(int, VideoBookmark) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := videobookmark_unpack(v)?
	return i, unpacked
}

pub struct CVideoSetVideoBookmarkNotification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bookmarks      []VideoBookmark
}

pub fn (o &CVideoSetVideoBookmarkNotification) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.bookmarks {
		res << zzz_vproto_internal_pack_videobookmark(x, 1)
	}
	return res
}

pub fn cvideosetvideobookmarknotification_unpack(buf []byte) ?CVideoSetVideoBookmarkNotification {
	mut res := CVideoSetVideoBookmarkNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_videobookmark(cur_buf, tag_wiretype.wire_type)?
				res.bookmarks << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideosetvideobookmarknotification() CVideoSetVideoBookmarkNotification {
	return CVideoSetVideoBookmarkNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideosetvideobookmarknotification(o CVideoSetVideoBookmarkNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideosetvideobookmarknotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideoSetVideoBookmarkNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideosetvideobookmarknotification_unpack(v)?
	return i, unpacked
}

pub struct CVideoGetVideoBookmarksRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	appids            []u32
	updated_since     u32
	has_updated_since bool
}

pub fn (o &CVideoGetVideoBookmarksRequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.appids {
		res << vproto.pack_uint32_field(x, 1)
	}
	if o.has_updated_since {
		res << vproto.pack_uint32_field(o.updated_since, 2)
	}
	return res
}

pub fn cvideogetvideobookmarksrequest_unpack(buf []byte) ?CVideoGetVideoBookmarksRequest {
	mut res := CVideoGetVideoBookmarksRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appids << v
				i = ii
			}
			2 {
				res.has_updated_since = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.updated_since = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideogetvideobookmarksrequest() CVideoGetVideoBookmarksRequest {
	return CVideoGetVideoBookmarksRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideogetvideobookmarksrequest(o CVideoGetVideoBookmarksRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideogetvideobookmarksrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideoGetVideoBookmarksRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideogetvideobookmarksrequest_unpack(v)?
	return i, unpacked
}

pub struct CVideoGetVideoBookmarksResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bookmarks      []VideoBookmark
}

pub fn (o &CVideoGetVideoBookmarksResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.bookmarks {
		res << zzz_vproto_internal_pack_videobookmark(x, 1)
	}
	return res
}

pub fn cvideogetvideobookmarksresponse_unpack(buf []byte) ?CVideoGetVideoBookmarksResponse {
	mut res := CVideoGetVideoBookmarksResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_videobookmark(cur_buf, tag_wiretype.wire_type)?
				res.bookmarks << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideogetvideobookmarksresponse() CVideoGetVideoBookmarksResponse {
	return CVideoGetVideoBookmarksResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideogetvideobookmarksresponse(o CVideoGetVideoBookmarksResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideogetvideobookmarksresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideoGetVideoBookmarksResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideogetvideobookmarksresponse_unpack(v)?
	return i, unpacked
}

pub struct CVideoUnlockedH264Notification {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	encryption_key     []byte
	has_encryption_key bool
}

pub fn (o &CVideoUnlockedH264Notification) pack() []byte {
	mut res := []byte{}
	if o.has_encryption_key {
		res << vproto.pack_bytes_field(o.encryption_key, 1)
	}
	return res
}

pub fn cvideounlockedh264notification_unpack(buf []byte) ?CVideoUnlockedH264Notification {
	mut res := CVideoUnlockedH264Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_encryption_key = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.encryption_key = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideounlockedh264notification() CVideoUnlockedH264Notification {
	return CVideoUnlockedH264Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideounlockedh264notification(o CVideoUnlockedH264Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideounlockedh264notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideoUnlockedH264Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideounlockedh264notification_unpack(v)?
	return i, unpacked
}

pub struct CFovasVideoClientGetOPfsettingsRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	app_id            u32
	has_app_id        bool
	client_cellid     u32
	has_client_cellid bool
}

pub fn (o &CFovasVideoClientGetOPfsettingsRequest) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_client_cellid {
		res << vproto.pack_uint32_field(o.client_cellid, 2)
	}
	return res
}

pub fn cfovasvideoclientgetopfsettingsrequest_unpack(buf []byte) ?CFovasVideoClientGetOPfsettingsRequest {
	mut res := CFovasVideoClientGetOPfsettingsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_client_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_cellid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfovasvideoclientgetopfsettingsrequest() CFovasVideoClientGetOPfsettingsRequest {
	return CFovasVideoClientGetOPfsettingsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfovasvideoclientgetopfsettingsrequest(o CFovasVideoClientGetOPfsettingsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfovasvideoclientgetopfsettingsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CFovasVideoClientGetOPfsettingsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfovasvideoclientgetopfsettingsrequest_unpack(v)?
	return i, unpacked
}

pub struct CFovasVideoClientGetOPfsettingsResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	app_id           u32
	has_app_id       bool
	opf_settings     string
	has_opf_settings bool
}

pub fn (o &CFovasVideoClientGetOPfsettingsResponse) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_opf_settings {
		res << vproto.pack_string_field(o.opf_settings, 2)
	}
	return res
}

pub fn cfovasvideoclientgetopfsettingsresponse_unpack(buf []byte) ?CFovasVideoClientGetOPfsettingsResponse {
	mut res := CFovasVideoClientGetOPfsettingsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_opf_settings = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.opf_settings = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfovasvideoclientgetopfsettingsresponse() CFovasVideoClientGetOPfsettingsResponse {
	return CFovasVideoClientGetOPfsettingsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfovasvideoclientgetopfsettingsresponse(o CFovasVideoClientGetOPfsettingsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfovasvideoclientgetopfsettingsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CFovasVideoClientGetOPfsettingsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfovasvideoclientgetopfsettingsresponse_unpack(v)?
	return i, unpacked
}
