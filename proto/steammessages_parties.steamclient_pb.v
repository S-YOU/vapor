// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CPartiesJoinPartyRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	beacon_id      u64
	has_beacon_id  bool
}

pub fn (o &CPartiesJoinPartyRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_beacon_id {
		res << vproto.pack_uint64_field(o.beacon_id, 2)
	}
	return res
}

pub fn cpartiesjoinpartyrequest_unpack(buf []byte) ?CPartiesJoinPartyRequest {
	mut res := CPartiesJoinPartyRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_beacon_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.beacon_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartiesjoinpartyrequest() CPartiesJoinPartyRequest {
	return CPartiesJoinPartyRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartiesjoinpartyrequest(o CPartiesJoinPartyRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartiesjoinpartyrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartiesJoinPartyRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpartiesjoinpartyrequest_unpack(v)?
	return i, unpacked
}

pub struct CPartiesJoinPartyResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	beacon_id          u64
	has_beacon_id      bool
	connect_string     string
	has_connect_string bool
}

pub fn (o &CPartiesJoinPartyResponse) pack() []byte {
	mut res := []byte{}
	if o.has_beacon_id {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	if o.has_connect_string {
		res << vproto.pack_string_field(o.connect_string, 2)
	}
	return res
}

pub fn cpartiesjoinpartyresponse_unpack(buf []byte) ?CPartiesJoinPartyResponse {
	mut res := CPartiesJoinPartyResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_beacon_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.beacon_id = v
				i = ii
			}
			2 {
				res.has_connect_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.connect_string = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartiesjoinpartyresponse() CPartiesJoinPartyResponse {
	return CPartiesJoinPartyResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartiesjoinpartyresponse(o CPartiesJoinPartyResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartiesjoinpartyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartiesJoinPartyResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpartiesjoinpartyresponse_unpack(v)?
	return i, unpacked
}

pub struct CPartiesBeaconLocation {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	location_type     u32
	has_location_type bool
	location_id       u64
	has_location_id   bool
}

pub fn (o &CPartiesBeaconLocation) pack() []byte {
	mut res := []byte{}
	if o.has_location_type {
		res << vproto.pack_uint32_field(o.location_type, 1)
	}
	if o.has_location_id {
		res << vproto.pack_uint64_field(o.location_id, 2)
	}
	return res
}

pub fn cpartiesbeaconlocation_unpack(buf []byte) ?CPartiesBeaconLocation {
	mut res := CPartiesBeaconLocation{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_location_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.location_type = v
				i = ii
			}
			2 {
				res.has_location_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.location_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartiesbeaconlocation() CPartiesBeaconLocation {
	return CPartiesBeaconLocation{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartiesbeaconlocation(o CPartiesBeaconLocation, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartiesbeaconlocation(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartiesBeaconLocation) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpartiesbeaconlocation_unpack(v)?
	return i, unpacked
}

pub struct CPartiesCreateBeaconRequest {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	appid              u32
	has_appid          bool
	num_open_slots     u32
	has_num_open_slots bool
	locations          []CPartiesBeaconLocation
	connect_string     string
	has_connect_string bool
	metadata           string
	has_metadata       bool
}

pub fn (o &CPartiesCreateBeaconRequest) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_num_open_slots {
		res << vproto.pack_uint32_field(o.num_open_slots, 2)
	}
	// [packed=false]
	for _, x in o.locations {
		res << zzz_vproto_internal_pack_cpartiesbeaconlocation(x, 3)
	}
	if o.has_connect_string {
		res << vproto.pack_string_field(o.connect_string, 4)
	}
	if o.has_metadata {
		res << vproto.pack_string_field(o.metadata, 5)
	}
	return res
}

pub fn cpartiescreatebeaconrequest_unpack(buf []byte) ?CPartiesCreateBeaconRequest {
	mut res := CPartiesCreateBeaconRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_num_open_slots = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_open_slots = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cpartiesbeaconlocation(cur_buf, tag_wiretype.wire_type)?
				res.locations << v
				i = ii
			}
			4 {
				res.has_connect_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.connect_string = v
				i = ii
			}
			5 {
				res.has_metadata = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.metadata = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartiescreatebeaconrequest() CPartiesCreateBeaconRequest {
	return CPartiesCreateBeaconRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartiescreatebeaconrequest(o CPartiesCreateBeaconRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartiescreatebeaconrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartiesCreateBeaconRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpartiescreatebeaconrequest_unpack(v)?
	return i, unpacked
}

pub struct CPartiesCreateBeaconResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
	has_beacon_id  bool
}

pub fn (o &CPartiesCreateBeaconResponse) pack() []byte {
	mut res := []byte{}
	if o.has_beacon_id {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	return res
}

pub fn cpartiescreatebeaconresponse_unpack(buf []byte) ?CPartiesCreateBeaconResponse {
	mut res := CPartiesCreateBeaconResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_beacon_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.beacon_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartiescreatebeaconresponse() CPartiesCreateBeaconResponse {
	return CPartiesCreateBeaconResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartiescreatebeaconresponse(o CPartiesCreateBeaconResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartiescreatebeaconresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartiesCreateBeaconResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpartiescreatebeaconresponse_unpack(v)?
	return i, unpacked
}

pub struct CPartiesOnReservationCompletedRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	beacon_id        u64
	has_beacon_id    bool
	user_steamid     u64
	has_user_steamid bool
}

pub fn (o &CPartiesOnReservationCompletedRequest) pack() []byte {
	mut res := []byte{}
	if o.has_beacon_id {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	if o.has_user_steamid {
		res << vproto.pack_64bit_field(o.user_steamid, 2)
	}
	return res
}

pub fn cpartiesonreservationcompletedrequest_unpack(buf []byte) ?CPartiesOnReservationCompletedRequest {
	mut res := CPartiesOnReservationCompletedRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_beacon_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.beacon_id = v
				i = ii
			}
			2 {
				res.has_user_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.user_steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartiesonreservationcompletedrequest() CPartiesOnReservationCompletedRequest {
	return CPartiesOnReservationCompletedRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartiesonreservationcompletedrequest(o CPartiesOnReservationCompletedRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartiesonreservationcompletedrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartiesOnReservationCompletedRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpartiesonreservationcompletedrequest_unpack(v)?
	return i, unpacked
}

pub struct CPartiesOnReservationCompletedResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
	has_beacon_id  bool
}

pub fn (o &CPartiesOnReservationCompletedResponse) pack() []byte {
	mut res := []byte{}
	if o.has_beacon_id {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	return res
}

pub fn cpartiesonreservationcompletedresponse_unpack(buf []byte) ?CPartiesOnReservationCompletedResponse {
	mut res := CPartiesOnReservationCompletedResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_beacon_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.beacon_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartiesonreservationcompletedresponse() CPartiesOnReservationCompletedResponse {
	return CPartiesOnReservationCompletedResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartiesonreservationcompletedresponse(o CPartiesOnReservationCompletedResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartiesonreservationcompletedresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartiesOnReservationCompletedResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpartiesonreservationcompletedresponse_unpack(v)?
	return i, unpacked
}

pub struct CPartiesCancelReservationRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	beacon_id        u64
	has_beacon_id    bool
	user_steamid     u64
	has_user_steamid bool
}

pub fn (o &CPartiesCancelReservationRequest) pack() []byte {
	mut res := []byte{}
	if o.has_beacon_id {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	if o.has_user_steamid {
		res << vproto.pack_64bit_field(o.user_steamid, 2)
	}
	return res
}

pub fn cpartiescancelreservationrequest_unpack(buf []byte) ?CPartiesCancelReservationRequest {
	mut res := CPartiesCancelReservationRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_beacon_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.beacon_id = v
				i = ii
			}
			2 {
				res.has_user_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.user_steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartiescancelreservationrequest() CPartiesCancelReservationRequest {
	return CPartiesCancelReservationRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartiescancelreservationrequest(o CPartiesCancelReservationRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartiescancelreservationrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartiesCancelReservationRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpartiescancelreservationrequest_unpack(v)?
	return i, unpacked
}

pub struct CPartiesCancelReservationResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
	has_beacon_id  bool
}

pub fn (o &CPartiesCancelReservationResponse) pack() []byte {
	mut res := []byte{}
	if o.has_beacon_id {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	return res
}

pub fn cpartiescancelreservationresponse_unpack(buf []byte) ?CPartiesCancelReservationResponse {
	mut res := CPartiesCancelReservationResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_beacon_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.beacon_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartiescancelreservationresponse() CPartiesCancelReservationResponse {
	return CPartiesCancelReservationResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartiescancelreservationresponse(o CPartiesCancelReservationResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartiescancelreservationresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartiesCancelReservationResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpartiescancelreservationresponse_unpack(v)?
	return i, unpacked
}

pub struct CPartiesChangeNumOpenSlotsRequest {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	beacon_id          u64
	has_beacon_id      bool
	num_open_slots     u32
	has_num_open_slots bool
}

pub fn (o &CPartiesChangeNumOpenSlotsRequest) pack() []byte {
	mut res := []byte{}
	if o.has_beacon_id {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	if o.has_num_open_slots {
		res << vproto.pack_uint32_field(o.num_open_slots, 2)
	}
	return res
}

pub fn cpartieschangenumopenslotsrequest_unpack(buf []byte) ?CPartiesChangeNumOpenSlotsRequest {
	mut res := CPartiesChangeNumOpenSlotsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_beacon_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.beacon_id = v
				i = ii
			}
			2 {
				res.has_num_open_slots = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_open_slots = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartieschangenumopenslotsrequest() CPartiesChangeNumOpenSlotsRequest {
	return CPartiesChangeNumOpenSlotsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartieschangenumopenslotsrequest(o CPartiesChangeNumOpenSlotsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartieschangenumopenslotsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartiesChangeNumOpenSlotsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpartieschangenumopenslotsrequest_unpack(v)?
	return i, unpacked
}

pub struct CPartiesChangeNumOpenSlotsResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
	has_beacon_id  bool
}

pub fn (o &CPartiesChangeNumOpenSlotsResponse) pack() []byte {
	mut res := []byte{}
	if o.has_beacon_id {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	return res
}

pub fn cpartieschangenumopenslotsresponse_unpack(buf []byte) ?CPartiesChangeNumOpenSlotsResponse {
	mut res := CPartiesChangeNumOpenSlotsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_beacon_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.beacon_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartieschangenumopenslotsresponse() CPartiesChangeNumOpenSlotsResponse {
	return CPartiesChangeNumOpenSlotsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartieschangenumopenslotsresponse(o CPartiesChangeNumOpenSlotsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartieschangenumopenslotsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartiesChangeNumOpenSlotsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpartieschangenumopenslotsresponse_unpack(v)?
	return i, unpacked
}

pub struct CPartiesDestroyBeaconRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
	has_beacon_id  bool
}

pub fn (o &CPartiesDestroyBeaconRequest) pack() []byte {
	mut res := []byte{}
	if o.has_beacon_id {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	return res
}

pub fn cpartiesdestroybeaconrequest_unpack(buf []byte) ?CPartiesDestroyBeaconRequest {
	mut res := CPartiesDestroyBeaconRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_beacon_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.beacon_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartiesdestroybeaconrequest() CPartiesDestroyBeaconRequest {
	return CPartiesDestroyBeaconRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartiesdestroybeaconrequest(o CPartiesDestroyBeaconRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartiesdestroybeaconrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartiesDestroyBeaconRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpartiesdestroybeaconrequest_unpack(v)?
	return i, unpacked
}

pub struct CPartiesDestroyBeaconResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	beacon_id      u64
	has_beacon_id  bool
}

pub fn (o &CPartiesDestroyBeaconResponse) pack() []byte {
	mut res := []byte{}
	if o.has_beacon_id {
		res << vproto.pack_uint64_field(o.beacon_id, 1)
	}
	return res
}

pub fn cpartiesdestroybeaconresponse_unpack(buf []byte) ?CPartiesDestroyBeaconResponse {
	mut res := CPartiesDestroyBeaconResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_beacon_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.beacon_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartiesdestroybeaconresponse() CPartiesDestroyBeaconResponse {
	return CPartiesDestroyBeaconResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartiesdestroybeaconresponse(o CPartiesDestroyBeaconResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartiesdestroybeaconresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartiesDestroyBeaconResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpartiesdestroybeaconresponse_unpack(v)?
	return i, unpacked
}
