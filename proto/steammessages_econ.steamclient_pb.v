// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CEcon_GetTradeOfferAccessToken_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	generate_new_token     bool
	has_generate_new_token bool
}

pub fn (o &CEcon_GetTradeOfferAccessToken_Request) pack() []byte {
	mut res := []byte{}
	if o.has_generate_new_token {
		res << vproto.pack_bool_field(o.generate_new_token, 1)
	}
	return res
}

pub fn cecon_gettradeofferaccesstoken_request_unpack(buf []byte) ?CEcon_GetTradeOfferAccessToken_Request {
	mut res := CEcon_GetTradeOfferAccessToken_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_generate_new_token = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.generate_new_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cecon_gettradeofferaccesstoken_request() CEcon_GetTradeOfferAccessToken_Request {
	return CEcon_GetTradeOfferAccessToken_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cecon_gettradeofferaccesstoken_request(o CEcon_GetTradeOfferAccessToken_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cecon_gettradeofferaccesstoken_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CEcon_GetTradeOfferAccessToken_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cecon_gettradeofferaccesstoken_request_unpack(v)?
	return i, unpacked
}

pub struct CEcon_GetTradeOfferAccessToken_Response {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	trade_offer_access_token     string
	has_trade_offer_access_token bool
}

pub fn (o &CEcon_GetTradeOfferAccessToken_Response) pack() []byte {
	mut res := []byte{}
	if o.has_trade_offer_access_token {
		res << vproto.pack_string_field(o.trade_offer_access_token, 1)
	}
	return res
}

pub fn cecon_gettradeofferaccesstoken_response_unpack(buf []byte) ?CEcon_GetTradeOfferAccessToken_Response {
	mut res := CEcon_GetTradeOfferAccessToken_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_trade_offer_access_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.trade_offer_access_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cecon_gettradeofferaccesstoken_response() CEcon_GetTradeOfferAccessToken_Response {
	return CEcon_GetTradeOfferAccessToken_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cecon_gettradeofferaccesstoken_response(o CEcon_GetTradeOfferAccessToken_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cecon_gettradeofferaccesstoken_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CEcon_GetTradeOfferAccessToken_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cecon_gettradeofferaccesstoken_response_unpack(v)?
	return i, unpacked
}

pub struct CEcon_ClientGetItemShopOverlayAuthURL_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	return_url     string
	has_return_url bool
}

pub fn (o &CEcon_ClientGetItemShopOverlayAuthURL_Request) pack() []byte {
	mut res := []byte{}
	if o.has_return_url {
		res << vproto.pack_string_field(o.return_url, 1)
	}
	return res
}

pub fn cecon_clientgetitemshopoverlayauthurl_request_unpack(buf []byte) ?CEcon_ClientGetItemShopOverlayAuthURL_Request {
	mut res := CEcon_ClientGetItemShopOverlayAuthURL_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_return_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.return_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cecon_clientgetitemshopoverlayauthurl_request() CEcon_ClientGetItemShopOverlayAuthURL_Request {
	return CEcon_ClientGetItemShopOverlayAuthURL_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cecon_clientgetitemshopoverlayauthurl_request(o CEcon_ClientGetItemShopOverlayAuthURL_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cecon_clientgetitemshopoverlayauthurl_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CEcon_ClientGetItemShopOverlayAuthURL_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cecon_clientgetitemshopoverlayauthurl_request_unpack(v)?
	return i, unpacked
}

pub struct CEcon_ClientGetItemShopOverlayAuthURL_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	url            string
	has_url        bool
}

pub fn (o &CEcon_ClientGetItemShopOverlayAuthURL_Response) pack() []byte {
	mut res := []byte{}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 1)
	}
	return res
}

pub fn cecon_clientgetitemshopoverlayauthurl_response_unpack(buf []byte) ?CEcon_ClientGetItemShopOverlayAuthURL_Response {
	mut res := CEcon_ClientGetItemShopOverlayAuthURL_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cecon_clientgetitemshopoverlayauthurl_response() CEcon_ClientGetItemShopOverlayAuthURL_Response {
	return CEcon_ClientGetItemShopOverlayAuthURL_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cecon_clientgetitemshopoverlayauthurl_response(o CEcon_ClientGetItemShopOverlayAuthURL_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cecon_clientgetitemshopoverlayauthurl_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CEcon_ClientGetItemShopOverlayAuthURL_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cecon_clientgetitemshopoverlayauthurl_response_unpack(v)?
	return i, unpacked
}

pub struct CEcon_GetAssetClassInfo_Request_Class {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	classid        u64
	has_classid    bool
	instanceid     u64
	has_instanceid bool
}

pub fn (o &CEcon_GetAssetClassInfo_Request_Class) pack() []byte {
	mut res := []byte{}
	if o.has_classid {
		res << vproto.pack_uint64_field(o.classid, 1)
	}
	if o.has_instanceid {
		res << vproto.pack_uint64_field(o.instanceid, 2)
	}
	return res
}

pub fn cecon_getassetclassinfo_request_class_unpack(buf []byte) ?CEcon_GetAssetClassInfo_Request_Class {
	mut res := CEcon_GetAssetClassInfo_Request_Class{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_classid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.classid = v
				i = ii
			}
			2 {
				res.has_instanceid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.instanceid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cecon_getassetclassinfo_request_class() CEcon_GetAssetClassInfo_Request_Class {
	return CEcon_GetAssetClassInfo_Request_Class{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cecon_getassetclassinfo_request_class(o CEcon_GetAssetClassInfo_Request_Class, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cecon_getassetclassinfo_request_class(buf []byte, tag_wiretype vproto.WireType) ?(int, CEcon_GetAssetClassInfo_Request_Class) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cecon_getassetclassinfo_request_class_unpack(v)?
	return i, unpacked
}

pub struct CEcon_GetAssetClassInfo_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	language       string
	has_language   bool
	appid          u32
	has_appid      bool
	classes        []CEcon_GetAssetClassInfo_Request_Class
}

pub fn (o &CEcon_GetAssetClassInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	// [packed=false]
	for _, x in o.classes {
		res << zzz_vproto_internal_pack_cecon_getassetclassinfo_request_class(x, 3)
	}
	return res
}

pub fn cecon_getassetclassinfo_request_unpack(buf []byte) ?CEcon_GetAssetClassInfo_Request {
	mut res := CEcon_GetAssetClassInfo_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cecon_getassetclassinfo_request_class(cur_buf,
					tag_wiretype.wire_type)?
				res.classes << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cecon_getassetclassinfo_request() CEcon_GetAssetClassInfo_Request {
	return CEcon_GetAssetClassInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cecon_getassetclassinfo_request(o CEcon_GetAssetClassInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cecon_getassetclassinfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CEcon_GetAssetClassInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cecon_getassetclassinfo_request_unpack(v)?
	return i, unpacked
}

pub struct CEconItem_DescriptionLine {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	@type          string
	has_type       bool
	value          string
	has_value      bool
	color          string
	has_color      bool
	label          string
	has_label      bool
}

pub fn (o &CEconItem_DescriptionLine) pack() []byte {
	mut res := []byte{}
	if o.has_type {
		res << vproto.pack_string_field(o.@type, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	if o.has_color {
		res << vproto.pack_string_field(o.color, 3)
	}
	if o.has_label {
		res << vproto.pack_string_field(o.label, 4)
	}
	return res
}

pub fn ceconitem_descriptionline_unpack(buf []byte) ?CEconItem_DescriptionLine {
	mut res := CEconItem_DescriptionLine{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			3 {
				res.has_color = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.color = v
				i = ii
			}
			4 {
				res.has_label = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.label = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ceconitem_descriptionline() CEconItem_DescriptionLine {
	return CEconItem_DescriptionLine{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ceconitem_descriptionline(o CEconItem_DescriptionLine, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ceconitem_descriptionline(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconItem_DescriptionLine) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ceconitem_descriptionline_unpack(v)?
	return i, unpacked
}

pub struct CEconItem_Action {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	link           string
	has_link       bool
	name           string
	has_name       bool
}

pub fn (o &CEconItem_Action) pack() []byte {
	mut res := []byte{}
	if o.has_link {
		res << vproto.pack_string_field(o.link, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	return res
}

pub fn ceconitem_action_unpack(buf []byte) ?CEconItem_Action {
	mut res := CEconItem_Action{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_link = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.link = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ceconitem_action() CEconItem_Action {
	return CEconItem_Action{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ceconitem_action(o CEconItem_Action, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ceconitem_action(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconItem_Action) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ceconitem_action_unpack(v)?
	return i, unpacked
}

pub struct CEconItem_Description {
mut:
	unknown_fields                      []vproto.UnknownField
pub mut:
	appid                               int
	has_appid                           bool
	classid                             u64
	has_classid                         bool
	instanceid                          u64
	has_instanceid                      bool
	currency                            bool
	has_currency                        bool
	background_color                    string
	has_background_color                bool
	icon_url                            string
	has_icon_url                        bool
	icon_url_large                      string
	has_icon_url_large                  bool
	descriptions                        []CEconItem_DescriptionLine
	tradable                            bool
	has_tradable                        bool
	actions                             []CEconItem_Action
	owner_descriptions                  []CEconItem_DescriptionLine
	owner_actions                       []CEconItem_Action
	fraudwarnings                       []string
	name                                string
	has_name                            bool
	name_color                          string
	has_name_color                      bool
	@type                               string
	has_type                            bool
	market_name                         string
	has_market_name                     bool
	market_hash_name                    string
	has_market_hash_name                bool
	market_fee                          string
	has_market_fee                      bool
	market_fee_app                      int
	has_market_fee_app                  bool
	contained_item                      &CEconItem_Description
	has_contained_item                  bool
	market_actions                      []CEconItem_Action
	commodity                           bool
	has_commodity                       bool
	market_tradable_restriction         int
	has_market_tradable_restriction     bool
	market_marketable_restriction       int
	has_market_marketable_restriction   bool
	marketable                          bool
	has_marketable                      bool
	tags                                []CEconItem_Tag
	item_expiration                     string
	has_item_expiration                 bool
	market_buy_country_restriction      string
	has_market_buy_country_restriction  bool
	market_sell_country_restriction     string
	has_market_sell_country_restriction bool
}

pub fn (o &CEconItem_Description) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_int32_field(o.appid, 1)
	}
	if o.has_classid {
		res << vproto.pack_uint64_field(o.classid, 2)
	}
	if o.has_instanceid {
		res << vproto.pack_uint64_field(o.instanceid, 3)
	}
	if o.has_currency {
		res << vproto.pack_bool_field(o.currency, 4)
	}
	if o.has_background_color {
		res << vproto.pack_string_field(o.background_color, 5)
	}
	if o.has_icon_url {
		res << vproto.pack_string_field(o.icon_url, 6)
	}
	if o.has_icon_url_large {
		res << vproto.pack_string_field(o.icon_url_large, 7)
	}
	// [packed=false]
	for _, x in o.descriptions {
		res << zzz_vproto_internal_pack_ceconitem_descriptionline(x, 8)
	}
	if o.has_tradable {
		res << vproto.pack_bool_field(o.tradable, 9)
	}
	// [packed=false]
	for _, x in o.actions {
		res << zzz_vproto_internal_pack_ceconitem_action(x, 10)
	}
	// [packed=false]
	for _, x in o.owner_descriptions {
		res << zzz_vproto_internal_pack_ceconitem_descriptionline(x, 11)
	}
	// [packed=false]
	for _, x in o.owner_actions {
		res << zzz_vproto_internal_pack_ceconitem_action(x, 12)
	}
	// [packed=false]
	for _, x in o.fraudwarnings {
		res << vproto.pack_string_field(x, 13)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 14)
	}
	if o.has_name_color {
		res << vproto.pack_string_field(o.name_color, 15)
	}
	if o.has_type {
		res << vproto.pack_string_field(o.@type, 16)
	}
	if o.has_market_name {
		res << vproto.pack_string_field(o.market_name, 17)
	}
	if o.has_market_hash_name {
		res << vproto.pack_string_field(o.market_hash_name, 18)
	}
	if o.has_market_fee {
		res << vproto.pack_string_field(o.market_fee, 19)
	}
	if o.has_market_fee_app {
		res << vproto.pack_int32_field(o.market_fee_app, 28)
	}
	if o.has_contained_item {
		res << zzz_vproto_internal_pack_ceconitem_description(o.contained_item, 20)
	}
	// [packed=false]
	for _, x in o.market_actions {
		res << zzz_vproto_internal_pack_ceconitem_action(x, 21)
	}
	if o.has_commodity {
		res << vproto.pack_bool_field(o.commodity, 22)
	}
	if o.has_market_tradable_restriction {
		res << vproto.pack_int32_field(o.market_tradable_restriction, 23)
	}
	if o.has_market_marketable_restriction {
		res << vproto.pack_int32_field(o.market_marketable_restriction, 24)
	}
	if o.has_marketable {
		res << vproto.pack_bool_field(o.marketable, 25)
	}
	// [packed=false]
	for _, x in o.tags {
		res << zzz_vproto_internal_pack_ceconitem_tag(x, 26)
	}
	if o.has_item_expiration {
		res << vproto.pack_string_field(o.item_expiration, 27)
	}
	if o.has_market_buy_country_restriction {
		res << vproto.pack_string_field(o.market_buy_country_restriction, 30)
	}
	if o.has_market_sell_country_restriction {
		res << vproto.pack_string_field(o.market_sell_country_restriction, 31)
	}
	return res
}

pub fn ceconitem_description_unpack(buf []byte) ?CEconItem_Description {
	mut res := CEconItem_Description{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_classid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.classid = v
				i = ii
			}
			3 {
				res.has_instanceid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.instanceid = v
				i = ii
			}
			4 {
				res.has_currency = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.currency = v
				i = ii
			}
			5 {
				res.has_background_color = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.background_color = v
				i = ii
			}
			6 {
				res.has_icon_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon_url = v
				i = ii
			}
			7 {
				res.has_icon_url_large = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon_url_large = v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitem_descriptionline(cur_buf,
					tag_wiretype.wire_type)?
				res.descriptions << v
				i = ii
			}
			9 {
				res.has_tradable = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.tradable = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitem_action(cur_buf, tag_wiretype.wire_type)?
				res.actions << v
				i = ii
			}
			11 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitem_descriptionline(cur_buf,
					tag_wiretype.wire_type)?
				res.owner_descriptions << v
				i = ii
			}
			12 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitem_action(cur_buf, tag_wiretype.wire_type)?
				res.owner_actions << v
				i = ii
			}
			13 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.fraudwarnings << v
				i = ii
			}
			14 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			15 {
				res.has_name_color = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name_color = v
				i = ii
			}
			16 {
				res.has_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			17 {
				res.has_market_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.market_name = v
				i = ii
			}
			18 {
				res.has_market_hash_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.market_hash_name = v
				i = ii
			}
			19 {
				res.has_market_fee = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.market_fee = v
				i = ii
			}
			28 {
				res.has_market_fee_app = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.market_fee_app = v
				i = ii
			}
			20 {
				res.has_contained_item = true
				ii, v := zzz_vproto_internal_unpack_ceconitem_description(cur_buf, tag_wiretype.wire_type)?
				res.contained_item = memdup(&v, int(sizeof(ceconitem_description)))
				i = ii
			}
			21 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitem_action(cur_buf, tag_wiretype.wire_type)?
				res.market_actions << v
				i = ii
			}
			22 {
				res.has_commodity = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.commodity = v
				i = ii
			}
			23 {
				res.has_market_tradable_restriction = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.market_tradable_restriction = v
				i = ii
			}
			24 {
				res.has_market_marketable_restriction = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.market_marketable_restriction = v
				i = ii
			}
			25 {
				res.has_marketable = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.marketable = v
				i = ii
			}
			26 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitem_tag(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			27 {
				res.has_item_expiration = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.item_expiration = v
				i = ii
			}
			30 {
				res.has_market_buy_country_restriction = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.market_buy_country_restriction = v
				i = ii
			}
			31 {
				res.has_market_sell_country_restriction = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.market_sell_country_restriction = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ceconitem_description() CEconItem_Description {
	return CEconItem_Description{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ceconitem_description(o CEconItem_Description, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ceconitem_description(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconItem_Description) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ceconitem_description_unpack(v)?
	return i, unpacked
}

pub struct CEconItem_Tag {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	appid                       u32
	has_appid                   bool
	category                    string
	has_category                bool
	internal_name               string
	has_internal_name           bool
	localized_category_name     string
	has_localized_category_name bool
	localized_tag_name          string
	has_localized_tag_name      bool
	color                       string
	has_color                   bool
}

pub fn (o &CEconItem_Tag) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_category {
		res << vproto.pack_string_field(o.category, 2)
	}
	if o.has_internal_name {
		res << vproto.pack_string_field(o.internal_name, 3)
	}
	if o.has_localized_category_name {
		res << vproto.pack_string_field(o.localized_category_name, 4)
	}
	if o.has_localized_tag_name {
		res << vproto.pack_string_field(o.localized_tag_name, 5)
	}
	if o.has_color {
		res << vproto.pack_string_field(o.color, 6)
	}
	return res
}

pub fn ceconitem_tag_unpack(buf []byte) ?CEconItem_Tag {
	mut res := CEconItem_Tag{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_category = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.category = v
				i = ii
			}
			3 {
				res.has_internal_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.internal_name = v
				i = ii
			}
			4 {
				res.has_localized_category_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.localized_category_name = v
				i = ii
			}
			5 {
				res.has_localized_tag_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.localized_tag_name = v
				i = ii
			}
			6 {
				res.has_color = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.color = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ceconitem_tag() CEconItem_Tag {
	return CEconItem_Tag{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ceconitem_tag(o CEconItem_Tag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ceconitem_tag(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconItem_Tag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ceconitem_tag_unpack(v)?
	return i, unpacked
}

pub struct CEcon_GetAssetClassInfo_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	descriptions   []CEconItem_Description
}

pub fn (o &CEcon_GetAssetClassInfo_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.descriptions {
		res << zzz_vproto_internal_pack_ceconitem_description(x, 1)
	}
	return res
}

pub fn cecon_getassetclassinfo_response_unpack(buf []byte) ?CEcon_GetAssetClassInfo_Response {
	mut res := CEcon_GetAssetClassInfo_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitem_description(cur_buf, tag_wiretype.wire_type)?
				res.descriptions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cecon_getassetclassinfo_response() CEcon_GetAssetClassInfo_Response {
	return CEcon_GetAssetClassInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cecon_getassetclassinfo_response(o CEcon_GetAssetClassInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cecon_getassetclassinfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CEcon_GetAssetClassInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cecon_getassetclassinfo_response_unpack(v)?
	return i, unpacked
}
