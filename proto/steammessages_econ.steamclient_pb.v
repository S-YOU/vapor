// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CEconGetTradeOfferAccessTokenRequest {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	generate_new_token     bool
	has_generate_new_token bool
}

pub fn (o &CEconGetTradeOfferAccessTokenRequest) pack() []byte {
	mut res := []byte{}
	if o.has_generate_new_token {
		res << vproto.pack_bool_field(o.generate_new_token, 1)
	}
	return res
}

pub fn cecongettradeofferaccesstokenrequest_unpack(buf []byte) ?CEconGetTradeOfferAccessTokenRequest {
	mut res := CEconGetTradeOfferAccessTokenRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_generate_new_token = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.generate_new_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cecongettradeofferaccesstokenrequest() CEconGetTradeOfferAccessTokenRequest {
	return CEconGetTradeOfferAccessTokenRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cecongettradeofferaccesstokenrequest(o CEconGetTradeOfferAccessTokenRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cecongettradeofferaccesstokenrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconGetTradeOfferAccessTokenRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cecongettradeofferaccesstokenrequest_unpack(v)?
	return i, unpacked
}

pub struct CEconGetTradeOfferAccessTokenResponse {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	trade_offer_access_token     string
	has_trade_offer_access_token bool
}

pub fn (o &CEconGetTradeOfferAccessTokenResponse) pack() []byte {
	mut res := []byte{}
	if o.has_trade_offer_access_token {
		res << vproto.pack_string_field(o.trade_offer_access_token, 1)
	}
	return res
}

pub fn cecongettradeofferaccesstokenresponse_unpack(buf []byte) ?CEconGetTradeOfferAccessTokenResponse {
	mut res := CEconGetTradeOfferAccessTokenResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_trade_offer_access_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.trade_offer_access_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cecongettradeofferaccesstokenresponse() CEconGetTradeOfferAccessTokenResponse {
	return CEconGetTradeOfferAccessTokenResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cecongettradeofferaccesstokenresponse(o CEconGetTradeOfferAccessTokenResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cecongettradeofferaccesstokenresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconGetTradeOfferAccessTokenResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cecongettradeofferaccesstokenresponse_unpack(v)?
	return i, unpacked
}

pub struct CEconClientGetItemShopOverlayAuthURlrequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	return_url     string
	has_return_url bool
}

pub fn (o &CEconClientGetItemShopOverlayAuthURlrequest) pack() []byte {
	mut res := []byte{}
	if o.has_return_url {
		res << vproto.pack_string_field(o.return_url, 1)
	}
	return res
}

pub fn ceconclientgetitemshopoverlayauthurlrequest_unpack(buf []byte) ?CEconClientGetItemShopOverlayAuthURlrequest {
	mut res := CEconClientGetItemShopOverlayAuthURlrequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_return_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.return_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ceconclientgetitemshopoverlayauthurlrequest() CEconClientGetItemShopOverlayAuthURlrequest {
	return CEconClientGetItemShopOverlayAuthURlrequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ceconclientgetitemshopoverlayauthurlrequest(o CEconClientGetItemShopOverlayAuthURlrequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ceconclientgetitemshopoverlayauthurlrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconClientGetItemShopOverlayAuthURlrequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ceconclientgetitemshopoverlayauthurlrequest_unpack(v)?
	return i, unpacked
}

pub struct CEconClientGetItemShopOverlayAuthURlresponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	url            string
	has_url        bool
}

pub fn (o &CEconClientGetItemShopOverlayAuthURlresponse) pack() []byte {
	mut res := []byte{}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 1)
	}
	return res
}

pub fn ceconclientgetitemshopoverlayauthurlresponse_unpack(buf []byte) ?CEconClientGetItemShopOverlayAuthURlresponse {
	mut res := CEconClientGetItemShopOverlayAuthURlresponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ceconclientgetitemshopoverlayauthurlresponse() CEconClientGetItemShopOverlayAuthURlresponse {
	return CEconClientGetItemShopOverlayAuthURlresponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ceconclientgetitemshopoverlayauthurlresponse(o CEconClientGetItemShopOverlayAuthURlresponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ceconclientgetitemshopoverlayauthurlresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconClientGetItemShopOverlayAuthURlresponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ceconclientgetitemshopoverlayauthurlresponse_unpack(v)?
	return i, unpacked
}

pub struct CEconGetAssetClassInfoRequestClass {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	classid        u64
	has_classid    bool
	instanceid     u64
	has_instanceid bool
}

pub fn (o &CEconGetAssetClassInfoRequestClass) pack() []byte {
	mut res := []byte{}
	if o.has_classid {
		res << vproto.pack_uint64_field(o.classid, 1)
	}
	if o.has_instanceid {
		res << vproto.pack_uint64_field(o.instanceid, 2)
	}
	return res
}

pub fn cecongetassetclassinforequestclass_unpack(buf []byte) ?CEconGetAssetClassInfoRequestClass {
	mut res := CEconGetAssetClassInfoRequestClass{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_classid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.classid = v
				i = ii
			}
			2 {
				res.has_instanceid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.instanceid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cecongetassetclassinforequestclass() CEconGetAssetClassInfoRequestClass {
	return CEconGetAssetClassInfoRequestClass{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cecongetassetclassinforequestclass(o CEconGetAssetClassInfoRequestClass, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cecongetassetclassinforequestclass(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconGetAssetClassInfoRequestClass) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cecongetassetclassinforequestclass_unpack(v)?
	return i, unpacked
}

pub struct CEconGetAssetClassInfoRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	language       string
	has_language   bool
	appid          u32
	has_appid      bool
	classes        []CEconGetAssetClassInfoRequestClass
}

pub fn (o &CEconGetAssetClassInfoRequest) pack() []byte {
	mut res := []byte{}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	// [packed=false]
	for _, x in o.classes {
		res << zzz_vproto_internal_pack_cecongetassetclassinforequestclass(x, 3)
	}
	return res
}

pub fn cecongetassetclassinforequest_unpack(buf []byte) ?CEconGetAssetClassInfoRequest {
	mut res := CEconGetAssetClassInfoRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cecongetassetclassinforequestclass(cur_buf,
					tag_wiretype.wire_type)?
				res.classes << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cecongetassetclassinforequest() CEconGetAssetClassInfoRequest {
	return CEconGetAssetClassInfoRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cecongetassetclassinforequest(o CEconGetAssetClassInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cecongetassetclassinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconGetAssetClassInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cecongetassetclassinforequest_unpack(v)?
	return i, unpacked
}

pub struct CEconItemDescriptionLine {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	@type          string
	has_type       bool
	value          string
	has_value      bool
	color          string
	has_color      bool
	label          string
	has_label      bool
}

pub fn (o &CEconItemDescriptionLine) pack() []byte {
	mut res := []byte{}
	if o.has_type {
		res << vproto.pack_string_field(o.@type, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	if o.has_color {
		res << vproto.pack_string_field(o.color, 3)
	}
	if o.has_label {
		res << vproto.pack_string_field(o.label, 4)
	}
	return res
}

pub fn ceconitemdescriptionline_unpack(buf []byte) ?CEconItemDescriptionLine {
	mut res := CEconItemDescriptionLine{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			3 {
				res.has_color = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.color = v
				i = ii
			}
			4 {
				res.has_label = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.label = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ceconitemdescriptionline() CEconItemDescriptionLine {
	return CEconItemDescriptionLine{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ceconitemdescriptionline(o CEconItemDescriptionLine, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ceconitemdescriptionline(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconItemDescriptionLine) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ceconitemdescriptionline_unpack(v)?
	return i, unpacked
}

pub struct CEconItemAction {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	link           string
	has_link       bool
	name           string
	has_name       bool
}

pub fn (o &CEconItemAction) pack() []byte {
	mut res := []byte{}
	if o.has_link {
		res << vproto.pack_string_field(o.link, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	return res
}

pub fn ceconitemaction_unpack(buf []byte) ?CEconItemAction {
	mut res := CEconItemAction{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_link = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.link = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ceconitemaction() CEconItemAction {
	return CEconItemAction{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ceconitemaction(o CEconItemAction, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ceconitemaction(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconItemAction) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ceconitemaction_unpack(v)?
	return i, unpacked
}

pub struct CEconItemDescription {
mut:
	unknown_fields                      []vproto.UnknownField
pub mut:
	appid                               int
	has_appid                           bool
	classid                             u64
	has_classid                         bool
	instanceid                          u64
	has_instanceid                      bool
	currency                            bool
	has_currency                        bool
	background_color                    string
	has_background_color                bool
	icon_url                            string
	has_icon_url                        bool
	icon_url_large                      string
	has_icon_url_large                  bool
	descriptions                        []CEconItemDescriptionLine
	tradable                            bool
	has_tradable                        bool
	actions                             []CEconItemAction
	owner_descriptions                  []CEconItemDescriptionLine
	owner_actions                       []CEconItemAction
	fraudwarnings                       []string
	name                                string
	has_name                            bool
	name_color                          string
	has_name_color                      bool
	@type                               string
	has_type                            bool
	market_name                         string
	has_market_name                     bool
	market_hash_name                    string
	has_market_hash_name                bool
	market_fee                          string
	has_market_fee                      bool
	market_fee_app                      int
	has_market_fee_app                  bool
	contained_item                      CEconItemDescription
	has_contained_item                  bool
	market_actions                      []CEconItemAction
	commodity                           bool
	has_commodity                       bool
	market_tradable_restriction         int
	has_market_tradable_restriction     bool
	market_marketable_restriction       int
	has_market_marketable_restriction   bool
	marketable                          bool
	has_marketable                      bool
	tags                                []CEconItemTag
	item_expiration                     string
	has_item_expiration                 bool
	market_buy_country_restriction      string
	has_market_buy_country_restriction  bool
	market_sell_country_restriction     string
	has_market_sell_country_restriction bool
}

pub fn (o &CEconItemDescription) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_int32_field(o.appid, 1)
	}
	if o.has_classid {
		res << vproto.pack_uint64_field(o.classid, 2)
	}
	if o.has_instanceid {
		res << vproto.pack_uint64_field(o.instanceid, 3)
	}
	if o.has_currency {
		res << vproto.pack_bool_field(o.currency, 4)
	}
	if o.has_background_color {
		res << vproto.pack_string_field(o.background_color, 5)
	}
	if o.has_icon_url {
		res << vproto.pack_string_field(o.icon_url, 6)
	}
	if o.has_icon_url_large {
		res << vproto.pack_string_field(o.icon_url_large, 7)
	}
	// [packed=false]
	for _, x in o.descriptions {
		res << zzz_vproto_internal_pack_ceconitemdescriptionline(x, 8)
	}
	if o.has_tradable {
		res << vproto.pack_bool_field(o.tradable, 9)
	}
	// [packed=false]
	for _, x in o.actions {
		res << zzz_vproto_internal_pack_ceconitemaction(x, 10)
	}
	// [packed=false]
	for _, x in o.owner_descriptions {
		res << zzz_vproto_internal_pack_ceconitemdescriptionline(x, 11)
	}
	// [packed=false]
	for _, x in o.owner_actions {
		res << zzz_vproto_internal_pack_ceconitemaction(x, 12)
	}
	// [packed=false]
	for _, x in o.fraudwarnings {
		res << vproto.pack_string_field(x, 13)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 14)
	}
	if o.has_name_color {
		res << vproto.pack_string_field(o.name_color, 15)
	}
	if o.has_type {
		res << vproto.pack_string_field(o.@type, 16)
	}
	if o.has_market_name {
		res << vproto.pack_string_field(o.market_name, 17)
	}
	if o.has_market_hash_name {
		res << vproto.pack_string_field(o.market_hash_name, 18)
	}
	if o.has_market_fee {
		res << vproto.pack_string_field(o.market_fee, 19)
	}
	if o.has_market_fee_app {
		res << vproto.pack_int32_field(o.market_fee_app, 28)
	}
	if o.has_contained_item {
		res << zzz_vproto_internal_pack_ceconitemdescription(o.contained_item, 20)
	}
	// [packed=false]
	for _, x in o.market_actions {
		res << zzz_vproto_internal_pack_ceconitemaction(x, 21)
	}
	if o.has_commodity {
		res << vproto.pack_bool_field(o.commodity, 22)
	}
	if o.has_market_tradable_restriction {
		res << vproto.pack_int32_field(o.market_tradable_restriction, 23)
	}
	if o.has_market_marketable_restriction {
		res << vproto.pack_int32_field(o.market_marketable_restriction, 24)
	}
	if o.has_marketable {
		res << vproto.pack_bool_field(o.marketable, 25)
	}
	// [packed=false]
	for _, x in o.tags {
		res << zzz_vproto_internal_pack_ceconitemtag(x, 26)
	}
	if o.has_item_expiration {
		res << vproto.pack_string_field(o.item_expiration, 27)
	}
	if o.has_market_buy_country_restriction {
		res << vproto.pack_string_field(o.market_buy_country_restriction, 30)
	}
	if o.has_market_sell_country_restriction {
		res << vproto.pack_string_field(o.market_sell_country_restriction, 31)
	}
	return res
}

pub fn ceconitemdescription_unpack(buf []byte) ?CEconItemDescription {
	mut res := CEconItemDescription{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_classid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.classid = v
				i = ii
			}
			3 {
				res.has_instanceid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.instanceid = v
				i = ii
			}
			4 {
				res.has_currency = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.currency = v
				i = ii
			}
			5 {
				res.has_background_color = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.background_color = v
				i = ii
			}
			6 {
				res.has_icon_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon_url = v
				i = ii
			}
			7 {
				res.has_icon_url_large = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon_url_large = v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitemdescriptionline(cur_buf,
					tag_wiretype.wire_type)?
				res.descriptions << v
				i = ii
			}
			9 {
				res.has_tradable = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.tradable = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitemaction(cur_buf, tag_wiretype.wire_type)?
				res.actions << v
				i = ii
			}
			11 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitemdescriptionline(cur_buf,
					tag_wiretype.wire_type)?
				res.owner_descriptions << v
				i = ii
			}
			12 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitemaction(cur_buf, tag_wiretype.wire_type)?
				res.owner_actions << v
				i = ii
			}
			13 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.fraudwarnings << v
				i = ii
			}
			14 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			15 {
				res.has_name_color = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name_color = v
				i = ii
			}
			16 {
				res.has_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			17 {
				res.has_market_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.market_name = v
				i = ii
			}
			18 {
				res.has_market_hash_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.market_hash_name = v
				i = ii
			}
			19 {
				res.has_market_fee = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.market_fee = v
				i = ii
			}
			28 {
				res.has_market_fee_app = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.market_fee_app = v
				i = ii
			}
			20 {
				res.has_contained_item = true
				ii, v := zzz_vproto_internal_unpack_ceconitemdescription(cur_buf, tag_wiretype.wire_type)?
				res.contained_item = v
				i = ii
			}
			21 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitemaction(cur_buf, tag_wiretype.wire_type)?
				res.market_actions << v
				i = ii
			}
			22 {
				res.has_commodity = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.commodity = v
				i = ii
			}
			23 {
				res.has_market_tradable_restriction = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.market_tradable_restriction = v
				i = ii
			}
			24 {
				res.has_market_marketable_restriction = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.market_marketable_restriction = v
				i = ii
			}
			25 {
				res.has_marketable = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.marketable = v
				i = ii
			}
			26 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitemtag(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			27 {
				res.has_item_expiration = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.item_expiration = v
				i = ii
			}
			30 {
				res.has_market_buy_country_restriction = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.market_buy_country_restriction = v
				i = ii
			}
			31 {
				res.has_market_sell_country_restriction = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.market_sell_country_restriction = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ceconitemdescription() CEconItemDescription {
	return CEconItemDescription{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ceconitemdescription(o CEconItemDescription, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ceconitemdescription(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconItemDescription) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ceconitemdescription_unpack(v)?
	return i, unpacked
}

pub struct CEconItemTag {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	appid                       u32
	has_appid                   bool
	category                    string
	has_category                bool
	internal_name               string
	has_internal_name           bool
	localized_category_name     string
	has_localized_category_name bool
	localized_tag_name          string
	has_localized_tag_name      bool
	color                       string
	has_color                   bool
}

pub fn (o &CEconItemTag) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_category {
		res << vproto.pack_string_field(o.category, 2)
	}
	if o.has_internal_name {
		res << vproto.pack_string_field(o.internal_name, 3)
	}
	if o.has_localized_category_name {
		res << vproto.pack_string_field(o.localized_category_name, 4)
	}
	if o.has_localized_tag_name {
		res << vproto.pack_string_field(o.localized_tag_name, 5)
	}
	if o.has_color {
		res << vproto.pack_string_field(o.color, 6)
	}
	return res
}

pub fn ceconitemtag_unpack(buf []byte) ?CEconItemTag {
	mut res := CEconItemTag{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_category = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.category = v
				i = ii
			}
			3 {
				res.has_internal_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.internal_name = v
				i = ii
			}
			4 {
				res.has_localized_category_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.localized_category_name = v
				i = ii
			}
			5 {
				res.has_localized_tag_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.localized_tag_name = v
				i = ii
			}
			6 {
				res.has_color = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.color = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ceconitemtag() CEconItemTag {
	return CEconItemTag{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ceconitemtag(o CEconItemTag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ceconitemtag(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconItemTag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ceconitemtag_unpack(v)?
	return i, unpacked
}

pub struct CEconGetAssetClassInfoResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	descriptions   []CEconItemDescription
}

pub fn (o &CEconGetAssetClassInfoResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.descriptions {
		res << zzz_vproto_internal_pack_ceconitemdescription(x, 1)
	}
	return res
}

pub fn cecongetassetclassinforesponse_unpack(buf []byte) ?CEconGetAssetClassInfoResponse {
	mut res := CEconGetAssetClassInfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ceconitemdescription(cur_buf, tag_wiretype.wire_type)?
				res.descriptions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cecongetassetclassinforesponse() CEconGetAssetClassInfoResponse {
	return CEconGetAssetClassInfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cecongetassetclassinforesponse(o CEconGetAssetClassInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cecongetassetclassinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CEconGetAssetClassInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cecongetassetclassinforesponse_unpack(v)?
	return i, unpacked
}
