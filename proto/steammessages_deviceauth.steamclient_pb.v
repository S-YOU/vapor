// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CDeviceAuth_GetOwnAuthorizedDevices_Request {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	steamid              u64
	has_steamid          bool
	include_canceled     bool
	has_include_canceled bool
}

pub fn (o &CDeviceAuth_GetOwnAuthorizedDevices_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_include_canceled {
		res << vproto.pack_bool_field(o.include_canceled, 2)
	}
	return res
}

pub fn cdeviceauth_getownauthorizeddevices_request_unpack(buf []byte) ?CDeviceAuth_GetOwnAuthorizedDevices_Request {
	mut res := CDeviceAuth_GetOwnAuthorizedDevices_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_include_canceled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_canceled = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getownauthorizeddevices_request() CDeviceAuth_GetOwnAuthorizedDevices_Request {
	return CDeviceAuth_GetOwnAuthorizedDevices_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getownauthorizeddevices_request(o CDeviceAuth_GetOwnAuthorizedDevices_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getownauthorizeddevices_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetOwnAuthorizedDevices_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getownauthorizeddevices_request_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetOwnAuthorizedDevices_Response_Device {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	auth_device_token     u64
	has_auth_device_token bool
	device_name           string
	has_device_name       bool
	is_pending            bool
	has_is_pending        bool
	is_canceled           bool
	has_is_canceled       bool
	last_time_used        u32
	has_last_time_used    bool
	last_borrower_id      u64
	has_last_borrower_id  bool
	last_app_played       u32
	has_last_app_played   bool
	is_limited            bool
	has_is_limited        bool
}

pub fn (o &CDeviceAuth_GetOwnAuthorizedDevices_Response_Device) pack() []byte {
	mut res := []byte{}
	if o.has_auth_device_token {
		res << vproto.pack_64bit_field(o.auth_device_token, 1)
	}
	if o.has_device_name {
		res << vproto.pack_string_field(o.device_name, 2)
	}
	if o.has_is_pending {
		res << vproto.pack_bool_field(o.is_pending, 3)
	}
	if o.has_is_canceled {
		res << vproto.pack_bool_field(o.is_canceled, 4)
	}
	if o.has_last_time_used {
		res << vproto.pack_uint32_field(o.last_time_used, 5)
	}
	if o.has_last_borrower_id {
		res << vproto.pack_64bit_field(o.last_borrower_id, 6)
	}
	if o.has_last_app_played {
		res << vproto.pack_uint32_field(o.last_app_played, 7)
	}
	if o.has_is_limited {
		res << vproto.pack_bool_field(o.is_limited, 8)
	}
	return res
}

pub fn cdeviceauth_getownauthorizeddevices_response_device_unpack(buf []byte) ?CDeviceAuth_GetOwnAuthorizedDevices_Response_Device {
	mut res := CDeviceAuth_GetOwnAuthorizedDevices_Response_Device{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_auth_device_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_device_token = v
				i = ii
			}
			2 {
				res.has_device_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_name = v
				i = ii
			}
			3 {
				res.has_is_pending = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_pending = v
				i = ii
			}
			4 {
				res.has_is_canceled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_canceled = v
				i = ii
			}
			5 {
				res.has_last_time_used = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_time_used = v
				i = ii
			}
			6 {
				res.has_last_borrower_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.last_borrower_id = v
				i = ii
			}
			7 {
				res.has_last_app_played = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_app_played = v
				i = ii
			}
			8 {
				res.has_is_limited = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_limited = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getownauthorizeddevices_response_device() CDeviceAuth_GetOwnAuthorizedDevices_Response_Device {
	return CDeviceAuth_GetOwnAuthorizedDevices_Response_Device{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getownauthorizeddevices_response_device(o CDeviceAuth_GetOwnAuthorizedDevices_Response_Device, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getownauthorizeddevices_response_device(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetOwnAuthorizedDevices_Response_Device) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getownauthorizeddevices_response_device_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetOwnAuthorizedDevices_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	devices        []CDeviceAuth_GetOwnAuthorizedDevices_Response_Device
}

pub fn (o &CDeviceAuth_GetOwnAuthorizedDevices_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.devices {
		res << zzz_vproto_internal_pack_cdeviceauth_getownauthorizeddevices_response_device(x, 1)
	}
	return res
}

pub fn cdeviceauth_getownauthorizeddevices_response_unpack(buf []byte) ?CDeviceAuth_GetOwnAuthorizedDevices_Response {
	mut res := CDeviceAuth_GetOwnAuthorizedDevices_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getownauthorizeddevices_response_device(cur_buf,
					tag_wiretype.wire_type)?
				res.devices << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getownauthorizeddevices_response() CDeviceAuth_GetOwnAuthorizedDevices_Response {
	return CDeviceAuth_GetOwnAuthorizedDevices_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getownauthorizeddevices_response(o CDeviceAuth_GetOwnAuthorizedDevices_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getownauthorizeddevices_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetOwnAuthorizedDevices_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getownauthorizeddevices_response_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_AcceptAuthorizationRequest_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steamid               u64
	has_steamid           bool
	auth_device_token     u64
	has_auth_device_token bool
	auth_code             u64
	has_auth_code         bool
	from_steamid          u64
	has_from_steamid      bool
}

pub fn (o &CDeviceAuth_AcceptAuthorizationRequest_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_auth_device_token {
		res << vproto.pack_64bit_field(o.auth_device_token, 2)
	}
	if o.has_auth_code {
		res << vproto.pack_64bit_field(o.auth_code, 3)
	}
	if o.has_from_steamid {
		res << vproto.pack_64bit_field(o.from_steamid, 4)
	}
	return res
}

pub fn cdeviceauth_acceptauthorizationrequest_request_unpack(buf []byte) ?CDeviceAuth_AcceptAuthorizationRequest_Request {
	mut res := CDeviceAuth_AcceptAuthorizationRequest_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_auth_device_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_device_token = v
				i = ii
			}
			3 {
				res.has_auth_code = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_code = v
				i = ii
			}
			4 {
				res.has_from_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.from_steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_acceptauthorizationrequest_request() CDeviceAuth_AcceptAuthorizationRequest_Request {
	return CDeviceAuth_AcceptAuthorizationRequest_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_acceptauthorizationrequest_request(o CDeviceAuth_AcceptAuthorizationRequest_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_acceptauthorizationrequest_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_AcceptAuthorizationRequest_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_acceptauthorizationrequest_request_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_AcceptAuthorizationRequest_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CDeviceAuth_AcceptAuthorizationRequest_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cdeviceauth_acceptauthorizationrequest_response_unpack(buf []byte) ?CDeviceAuth_AcceptAuthorizationRequest_Response {
	res := CDeviceAuth_AcceptAuthorizationRequest_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_acceptauthorizationrequest_response() CDeviceAuth_AcceptAuthorizationRequest_Response {
	return CDeviceAuth_AcceptAuthorizationRequest_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_acceptauthorizationrequest_response(o CDeviceAuth_AcceptAuthorizationRequest_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_acceptauthorizationrequest_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_AcceptAuthorizationRequest_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_acceptauthorizationrequest_response_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_AuthorizeRemoteDevice_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steamid               u64
	has_steamid           bool
	auth_device_token     u64
	has_auth_device_token bool
}

pub fn (o &CDeviceAuth_AuthorizeRemoteDevice_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_auth_device_token {
		res << vproto.pack_64bit_field(o.auth_device_token, 2)
	}
	return res
}

pub fn cdeviceauth_authorizeremotedevice_request_unpack(buf []byte) ?CDeviceAuth_AuthorizeRemoteDevice_Request {
	mut res := CDeviceAuth_AuthorizeRemoteDevice_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_auth_device_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_device_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_authorizeremotedevice_request() CDeviceAuth_AuthorizeRemoteDevice_Request {
	return CDeviceAuth_AuthorizeRemoteDevice_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_authorizeremotedevice_request(o CDeviceAuth_AuthorizeRemoteDevice_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_authorizeremotedevice_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_AuthorizeRemoteDevice_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_authorizeremotedevice_request_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_AuthorizeRemoteDevice_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CDeviceAuth_AuthorizeRemoteDevice_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cdeviceauth_authorizeremotedevice_response_unpack(buf []byte) ?CDeviceAuth_AuthorizeRemoteDevice_Response {
	res := CDeviceAuth_AuthorizeRemoteDevice_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_authorizeremotedevice_response() CDeviceAuth_AuthorizeRemoteDevice_Response {
	return CDeviceAuth_AuthorizeRemoteDevice_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_authorizeremotedevice_response(o CDeviceAuth_AuthorizeRemoteDevice_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_authorizeremotedevice_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_AuthorizeRemoteDevice_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_authorizeremotedevice_response_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_DeauthorizeRemoteDevice_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steamid               u64
	has_steamid           bool
	auth_device_token     u64
	has_auth_device_token bool
}

pub fn (o &CDeviceAuth_DeauthorizeRemoteDevice_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_auth_device_token {
		res << vproto.pack_64bit_field(o.auth_device_token, 2)
	}
	return res
}

pub fn cdeviceauth_deauthorizeremotedevice_request_unpack(buf []byte) ?CDeviceAuth_DeauthorizeRemoteDevice_Request {
	mut res := CDeviceAuth_DeauthorizeRemoteDevice_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_auth_device_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_device_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_deauthorizeremotedevice_request() CDeviceAuth_DeauthorizeRemoteDevice_Request {
	return CDeviceAuth_DeauthorizeRemoteDevice_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_deauthorizeremotedevice_request(o CDeviceAuth_DeauthorizeRemoteDevice_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_deauthorizeremotedevice_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_DeauthorizeRemoteDevice_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_deauthorizeremotedevice_request_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_DeauthorizeRemoteDevice_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CDeviceAuth_DeauthorizeRemoteDevice_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cdeviceauth_deauthorizeremotedevice_response_unpack(buf []byte) ?CDeviceAuth_DeauthorizeRemoteDevice_Response {
	res := CDeviceAuth_DeauthorizeRemoteDevice_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_deauthorizeremotedevice_response() CDeviceAuth_DeauthorizeRemoteDevice_Response {
	return CDeviceAuth_DeauthorizeRemoteDevice_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_deauthorizeremotedevice_response(o CDeviceAuth_DeauthorizeRemoteDevice_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_deauthorizeremotedevice_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_DeauthorizeRemoteDevice_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_deauthorizeremotedevice_response_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetUsedAuthorizedDevices_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CDeviceAuth_GetUsedAuthorizedDevices_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cdeviceauth_getusedauthorizeddevices_request_unpack(buf []byte) ?CDeviceAuth_GetUsedAuthorizedDevices_Request {
	mut res := CDeviceAuth_GetUsedAuthorizedDevices_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getusedauthorizeddevices_request() CDeviceAuth_GetUsedAuthorizedDevices_Request {
	return CDeviceAuth_GetUsedAuthorizedDevices_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getusedauthorizeddevices_request(o CDeviceAuth_GetUsedAuthorizedDevices_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getusedauthorizeddevices_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetUsedAuthorizedDevices_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getusedauthorizeddevices_request_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetUsedAuthorizedDevices_Response_Device {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	auth_device_token     u64
	has_auth_device_token bool
	device_name           string
	has_device_name       bool
	owner_steamid         u64
	has_owner_steamid     bool
	last_time_used        u32
	has_last_time_used    bool
	last_app_played       u32
	has_last_app_played   bool
}

pub fn (o &CDeviceAuth_GetUsedAuthorizedDevices_Response_Device) pack() []byte {
	mut res := []byte{}
	if o.has_auth_device_token {
		res << vproto.pack_64bit_field(o.auth_device_token, 1)
	}
	if o.has_device_name {
		res << vproto.pack_string_field(o.device_name, 2)
	}
	if o.has_owner_steamid {
		res << vproto.pack_64bit_field(o.owner_steamid, 3)
	}
	if o.has_last_time_used {
		res << vproto.pack_uint32_field(o.last_time_used, 4)
	}
	if o.has_last_app_played {
		res << vproto.pack_uint32_field(o.last_app_played, 5)
	}
	return res
}

pub fn cdeviceauth_getusedauthorizeddevices_response_device_unpack(buf []byte) ?CDeviceAuth_GetUsedAuthorizedDevices_Response_Device {
	mut res := CDeviceAuth_GetUsedAuthorizedDevices_Response_Device{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_auth_device_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_device_token = v
				i = ii
			}
			2 {
				res.has_device_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_name = v
				i = ii
			}
			3 {
				res.has_owner_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_steamid = v
				i = ii
			}
			4 {
				res.has_last_time_used = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_time_used = v
				i = ii
			}
			5 {
				res.has_last_app_played = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_app_played = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getusedauthorizeddevices_response_device() CDeviceAuth_GetUsedAuthorizedDevices_Response_Device {
	return CDeviceAuth_GetUsedAuthorizedDevices_Response_Device{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getusedauthorizeddevices_response_device(o CDeviceAuth_GetUsedAuthorizedDevices_Response_Device, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getusedauthorizeddevices_response_device(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetUsedAuthorizedDevices_Response_Device) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getusedauthorizeddevices_response_device_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetUsedAuthorizedDevices_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	devices        []CDeviceAuth_GetUsedAuthorizedDevices_Response_Device
}

pub fn (o &CDeviceAuth_GetUsedAuthorizedDevices_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.devices {
		res << zzz_vproto_internal_pack_cdeviceauth_getusedauthorizeddevices_response_device(x, 1)
	}
	return res
}

pub fn cdeviceauth_getusedauthorizeddevices_response_unpack(buf []byte) ?CDeviceAuth_GetUsedAuthorizedDevices_Response {
	mut res := CDeviceAuth_GetUsedAuthorizedDevices_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getusedauthorizeddevices_response_device(cur_buf,
					tag_wiretype.wire_type)?
				res.devices << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getusedauthorizeddevices_response() CDeviceAuth_GetUsedAuthorizedDevices_Response {
	return CDeviceAuth_GetUsedAuthorizedDevices_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getusedauthorizeddevices_response(o CDeviceAuth_GetUsedAuthorizedDevices_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getusedauthorizeddevices_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetUsedAuthorizedDevices_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getusedauthorizeddevices_response_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetAuthorizedBorrowers_Request {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	steamid              u64
	has_steamid          bool
	include_canceled     bool
	has_include_canceled bool
	include_pending      bool
	has_include_pending  bool
}

pub fn (o &CDeviceAuth_GetAuthorizedBorrowers_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_include_canceled {
		res << vproto.pack_bool_field(o.include_canceled, 2)
	}
	if o.has_include_pending {
		res << vproto.pack_bool_field(o.include_pending, 3)
	}
	return res
}

pub fn cdeviceauth_getauthorizedborrowers_request_unpack(buf []byte) ?CDeviceAuth_GetAuthorizedBorrowers_Request {
	mut res := CDeviceAuth_GetAuthorizedBorrowers_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_include_canceled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_canceled = v
				i = ii
			}
			3 {
				res.has_include_pending = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_pending = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getauthorizedborrowers_request() CDeviceAuth_GetAuthorizedBorrowers_Request {
	return CDeviceAuth_GetAuthorizedBorrowers_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getauthorizedborrowers_request(o CDeviceAuth_GetAuthorizedBorrowers_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getauthorizedborrowers_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetAuthorizedBorrowers_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getauthorizedborrowers_request_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	is_pending       bool
	has_is_pending   bool
	is_canceled      bool
	has_is_canceled  bool
	time_created     u32
	has_time_created bool
}

pub fn (o &CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_is_pending {
		res << vproto.pack_bool_field(o.is_pending, 2)
	}
	if o.has_is_canceled {
		res << vproto.pack_bool_field(o.is_canceled, 3)
	}
	if o.has_time_created {
		res << vproto.pack_uint32_field(o.time_created, 4)
	}
	return res
}

pub fn cdeviceauth_getauthorizedborrowers_response_borrower_unpack(buf []byte) ?CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower {
	mut res := CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_is_pending = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_pending = v
				i = ii
			}
			3 {
				res.has_is_canceled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_canceled = v
				i = ii
			}
			4 {
				res.has_time_created = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getauthorizedborrowers_response_borrower() CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower {
	return CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getauthorizedborrowers_response_borrower(o CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getauthorizedborrowers_response_borrower(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getauthorizedborrowers_response_borrower_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetAuthorizedBorrowers_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	borrowers      []CDeviceAuth_GetAuthorizedBorrowers_Response_Borrower
}

pub fn (o &CDeviceAuth_GetAuthorizedBorrowers_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.borrowers {
		res << zzz_vproto_internal_pack_cdeviceauth_getauthorizedborrowers_response_borrower(x, 1)
	}
	return res
}

pub fn cdeviceauth_getauthorizedborrowers_response_unpack(buf []byte) ?CDeviceAuth_GetAuthorizedBorrowers_Response {
	mut res := CDeviceAuth_GetAuthorizedBorrowers_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getauthorizedborrowers_response_borrower(cur_buf,
					tag_wiretype.wire_type)?
				res.borrowers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getauthorizedborrowers_response() CDeviceAuth_GetAuthorizedBorrowers_Response {
	return CDeviceAuth_GetAuthorizedBorrowers_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getauthorizedborrowers_response(o CDeviceAuth_GetAuthorizedBorrowers_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getauthorizedborrowers_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetAuthorizedBorrowers_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getauthorizedborrowers_response_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_AddAuthorizedBorrowers_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	steamid_borrower []u64
}

pub fn (o &CDeviceAuth_AddAuthorizedBorrowers_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	// [packed=false]
	for _, x in o.steamid_borrower {
		res << vproto.pack_64bit_field(x, 2)
	}
	return res
}

pub fn cdeviceauth_addauthorizedborrowers_request_unpack(buf []byte) ?CDeviceAuth_AddAuthorizedBorrowers_Request {
	mut res := CDeviceAuth_AddAuthorizedBorrowers_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_borrower << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_addauthorizedborrowers_request() CDeviceAuth_AddAuthorizedBorrowers_Request {
	return CDeviceAuth_AddAuthorizedBorrowers_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_addauthorizedborrowers_request(o CDeviceAuth_AddAuthorizedBorrowers_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_addauthorizedborrowers_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_AddAuthorizedBorrowers_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_addauthorizedborrowers_request_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_AddAuthorizedBorrowers_Response {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	seconds_to_wait     int
	has_seconds_to_wait bool
}

pub fn (o &CDeviceAuth_AddAuthorizedBorrowers_Response) pack() []byte {
	mut res := []byte{}
	if o.has_seconds_to_wait {
		res << vproto.pack_int32_field(o.seconds_to_wait, 1)
	}
	return res
}

pub fn cdeviceauth_addauthorizedborrowers_response_unpack(buf []byte) ?CDeviceAuth_AddAuthorizedBorrowers_Response {
	mut res := CDeviceAuth_AddAuthorizedBorrowers_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_seconds_to_wait = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_to_wait = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_addauthorizedborrowers_response() CDeviceAuth_AddAuthorizedBorrowers_Response {
	return CDeviceAuth_AddAuthorizedBorrowers_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_addauthorizedborrowers_response(o CDeviceAuth_AddAuthorizedBorrowers_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_addauthorizedborrowers_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_AddAuthorizedBorrowers_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_addauthorizedborrowers_response_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_RemoveAuthorizedBorrowers_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	steamid_borrower []u64
}

pub fn (o &CDeviceAuth_RemoveAuthorizedBorrowers_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	// [packed=false]
	for _, x in o.steamid_borrower {
		res << vproto.pack_64bit_field(x, 2)
	}
	return res
}

pub fn cdeviceauth_removeauthorizedborrowers_request_unpack(buf []byte) ?CDeviceAuth_RemoveAuthorizedBorrowers_Request {
	mut res := CDeviceAuth_RemoveAuthorizedBorrowers_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_borrower << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_removeauthorizedborrowers_request() CDeviceAuth_RemoveAuthorizedBorrowers_Request {
	return CDeviceAuth_RemoveAuthorizedBorrowers_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_removeauthorizedborrowers_request(o CDeviceAuth_RemoveAuthorizedBorrowers_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_removeauthorizedborrowers_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_RemoveAuthorizedBorrowers_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_removeauthorizedborrowers_request_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_RemoveAuthorizedBorrowers_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CDeviceAuth_RemoveAuthorizedBorrowers_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cdeviceauth_removeauthorizedborrowers_response_unpack(buf []byte) ?CDeviceAuth_RemoveAuthorizedBorrowers_Response {
	res := CDeviceAuth_RemoveAuthorizedBorrowers_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_removeauthorizedborrowers_response() CDeviceAuth_RemoveAuthorizedBorrowers_Response {
	return CDeviceAuth_RemoveAuthorizedBorrowers_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_removeauthorizedborrowers_response(o CDeviceAuth_RemoveAuthorizedBorrowers_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_removeauthorizedborrowers_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_RemoveAuthorizedBorrowers_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_removeauthorizedborrowers_response_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetAuthorizedAsBorrower_Request {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	steamid              u64
	has_steamid          bool
	include_canceled     bool
	has_include_canceled bool
	include_pending      bool
	has_include_pending  bool
}

pub fn (o &CDeviceAuth_GetAuthorizedAsBorrower_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_include_canceled {
		res << vproto.pack_bool_field(o.include_canceled, 2)
	}
	if o.has_include_pending {
		res << vproto.pack_bool_field(o.include_pending, 3)
	}
	return res
}

pub fn cdeviceauth_getauthorizedasborrower_request_unpack(buf []byte) ?CDeviceAuth_GetAuthorizedAsBorrower_Request {
	mut res := CDeviceAuth_GetAuthorizedAsBorrower_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_include_canceled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_canceled = v
				i = ii
			}
			3 {
				res.has_include_pending = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_pending = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getauthorizedasborrower_request() CDeviceAuth_GetAuthorizedAsBorrower_Request {
	return CDeviceAuth_GetAuthorizedAsBorrower_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getauthorizedasborrower_request(o CDeviceAuth_GetAuthorizedAsBorrower_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getauthorizedasborrower_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetAuthorizedAsBorrower_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getauthorizedasborrower_request_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	time_created     u32
	has_time_created bool
	is_pending       bool
	has_is_pending   bool
	is_canceled      bool
	has_is_canceled  bool
	is_used          bool
	has_is_used      bool
}

pub fn (o &CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_time_created {
		res << vproto.pack_uint32_field(o.time_created, 2)
	}
	if o.has_is_pending {
		res << vproto.pack_bool_field(o.is_pending, 3)
	}
	if o.has_is_canceled {
		res << vproto.pack_bool_field(o.is_canceled, 4)
	}
	if o.has_is_used {
		res << vproto.pack_bool_field(o.is_used, 5)
	}
	return res
}

pub fn cdeviceauth_getauthorizedasborrower_response_lender_unpack(buf []byte) ?CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender {
	mut res := CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_time_created = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			3 {
				res.has_is_pending = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_pending = v
				i = ii
			}
			4 {
				res.has_is_canceled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_canceled = v
				i = ii
			}
			5 {
				res.has_is_used = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_used = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getauthorizedasborrower_response_lender() CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender {
	return CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getauthorizedasborrower_response_lender(o CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getauthorizedasborrower_response_lender(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getauthorizedasborrower_response_lender_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetAuthorizedAsBorrower_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	lenders        []CDeviceAuth_GetAuthorizedAsBorrower_Response_Lender
}

pub fn (o &CDeviceAuth_GetAuthorizedAsBorrower_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.lenders {
		res << zzz_vproto_internal_pack_cdeviceauth_getauthorizedasborrower_response_lender(x, 1)
	}
	return res
}

pub fn cdeviceauth_getauthorizedasborrower_response_unpack(buf []byte) ?CDeviceAuth_GetAuthorizedAsBorrower_Response {
	mut res := CDeviceAuth_GetAuthorizedAsBorrower_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getauthorizedasborrower_response_lender(cur_buf,
					tag_wiretype.wire_type)?
				res.lenders << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getauthorizedasborrower_response() CDeviceAuth_GetAuthorizedAsBorrower_Response {
	return CDeviceAuth_GetAuthorizedAsBorrower_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getauthorizedasborrower_response(o CDeviceAuth_GetAuthorizedAsBorrower_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getauthorizedasborrower_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetAuthorizedAsBorrower_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getauthorizedasborrower_response_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetExcludedGamesInLibrary_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CDeviceAuth_GetExcludedGamesInLibrary_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cdeviceauth_getexcludedgamesinlibrary_request_unpack(buf []byte) ?CDeviceAuth_GetExcludedGamesInLibrary_Request {
	mut res := CDeviceAuth_GetExcludedGamesInLibrary_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getexcludedgamesinlibrary_request() CDeviceAuth_GetExcludedGamesInLibrary_Request {
	return CDeviceAuth_GetExcludedGamesInLibrary_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getexcludedgamesinlibrary_request(o CDeviceAuth_GetExcludedGamesInLibrary_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getexcludedgamesinlibrary_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetExcludedGamesInLibrary_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getexcludedgamesinlibrary_request_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	appid                u32
	has_appid            bool
	game_name            string
	has_game_name        bool
	vac_banned           bool
	has_vac_banned       bool
	package_excluded     bool
	has_package_excluded bool
}

pub fn (o &CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_game_name {
		res << vproto.pack_string_field(o.game_name, 2)
	}
	if o.has_vac_banned {
		res << vproto.pack_bool_field(o.vac_banned, 3)
	}
	if o.has_package_excluded {
		res << vproto.pack_bool_field(o.package_excluded, 4)
	}
	return res
}

pub fn cdeviceauth_getexcludedgamesinlibrary_response_excludedgame_unpack(buf []byte) ?CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame {
	mut res := CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_game_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_name = v
				i = ii
			}
			3 {
				res.has_vac_banned = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.vac_banned = v
				i = ii
			}
			4 {
				res.has_package_excluded = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.package_excluded = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getexcludedgamesinlibrary_response_excludedgame() CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame {
	return CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getexcludedgamesinlibrary_response_excludedgame(o CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getexcludedgamesinlibrary_response_excludedgame(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getexcludedgamesinlibrary_response_excludedgame_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetExcludedGamesInLibrary_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	excluded_games []CDeviceAuth_GetExcludedGamesInLibrary_Response_ExcludedGame
}

pub fn (o &CDeviceAuth_GetExcludedGamesInLibrary_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.excluded_games {
		res <<
			zzz_vproto_internal_pack_cdeviceauth_getexcludedgamesinlibrary_response_excludedgame(x, 1)
	}
	return res
}

pub fn cdeviceauth_getexcludedgamesinlibrary_response_unpack(buf []byte) ?CDeviceAuth_GetExcludedGamesInLibrary_Response {
	mut res := CDeviceAuth_GetExcludedGamesInLibrary_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getexcludedgamesinlibrary_response_excludedgame(cur_buf,
					tag_wiretype.wire_type)?
				res.excluded_games << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getexcludedgamesinlibrary_response() CDeviceAuth_GetExcludedGamesInLibrary_Response {
	return CDeviceAuth_GetExcludedGamesInLibrary_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getexcludedgamesinlibrary_response(o CDeviceAuth_GetExcludedGamesInLibrary_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getexcludedgamesinlibrary_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetExcludedGamesInLibrary_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getexcludedgamesinlibrary_response_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetBorrowerPlayHistory_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CDeviceAuth_GetBorrowerPlayHistory_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cdeviceauth_getborrowerplayhistory_request_unpack(buf []byte) ?CDeviceAuth_GetBorrowerPlayHistory_Request {
	mut res := CDeviceAuth_GetBorrowerPlayHistory_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getborrowerplayhistory_request() CDeviceAuth_GetBorrowerPlayHistory_Request {
	return CDeviceAuth_GetBorrowerPlayHistory_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getborrowerplayhistory_request(o CDeviceAuth_GetBorrowerPlayHistory_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getborrowerplayhistory_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetBorrowerPlayHistory_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getborrowerplayhistory_request_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	time_last      u32
	has_time_last  bool
	time_total     u32
	has_time_total bool
}

pub fn (o &CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_time_last {
		res << vproto.pack_uint32_field(o.time_last, 2)
	}
	if o.has_time_total {
		res << vproto.pack_uint32_field(o.time_total, 3)
	}
	return res
}

pub fn cdeviceauth_getborrowerplayhistory_response_gamehistory_unpack(buf []byte) ?CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory {
	mut res := CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_time_last = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last = v
				i = ii
			}
			3 {
				res.has_time_total = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_total = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getborrowerplayhistory_response_gamehistory() CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory {
	return CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getborrowerplayhistory_response_gamehistory(o CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getborrowerplayhistory_response_gamehistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getborrowerplayhistory_response_gamehistory_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	game_history   []CDeviceAuth_GetBorrowerPlayHistory_Response_GameHistory
}

pub fn (o &CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	// [packed=false]
	for _, x in o.game_history {
		res <<
			zzz_vproto_internal_pack_cdeviceauth_getborrowerplayhistory_response_gamehistory(x, 2)
	}
	return res
}

pub fn cdeviceauth_getborrowerplayhistory_response_lenderhistory_unpack(buf []byte) ?CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory {
	mut res := CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getborrowerplayhistory_response_gamehistory(cur_buf,
					tag_wiretype.wire_type)?
				res.game_history << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getborrowerplayhistory_response_lenderhistory() CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory {
	return CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getborrowerplayhistory_response_lenderhistory(o CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getborrowerplayhistory_response_lenderhistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getborrowerplayhistory_response_lenderhistory_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuth_GetBorrowerPlayHistory_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	lender_history []CDeviceAuth_GetBorrowerPlayHistory_Response_LenderHistory
}

pub fn (o &CDeviceAuth_GetBorrowerPlayHistory_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.lender_history {
		res <<
			zzz_vproto_internal_pack_cdeviceauth_getborrowerplayhistory_response_lenderhistory(x, 1)
	}
	return res
}

pub fn cdeviceauth_getborrowerplayhistory_response_unpack(buf []byte) ?CDeviceAuth_GetBorrowerPlayHistory_Response {
	mut res := CDeviceAuth_GetBorrowerPlayHistory_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauth_getborrowerplayhistory_response_lenderhistory(cur_buf,
					tag_wiretype.wire_type)?
				res.lender_history << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauth_getborrowerplayhistory_response() CDeviceAuth_GetBorrowerPlayHistory_Response {
	return CDeviceAuth_GetBorrowerPlayHistory_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauth_getborrowerplayhistory_response(o CDeviceAuth_GetBorrowerPlayHistory_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauth_getborrowerplayhistory_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuth_GetBorrowerPlayHistory_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauth_getborrowerplayhistory_response_unpack(v)?
	return i, unpacked
}
