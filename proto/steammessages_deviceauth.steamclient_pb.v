// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CDeviceAuthGetOwnAuthorizedDevicesRequest {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	steamid              u64
	has_steamid          bool
	include_canceled     bool
	has_include_canceled bool
}

pub fn (o &CDeviceAuthGetOwnAuthorizedDevicesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_include_canceled {
		res << vproto.pack_bool_field(o.include_canceled, 2)
	}
	return res
}

pub fn cdeviceauthgetownauthorizeddevicesrequest_unpack(buf []byte) ?CDeviceAuthGetOwnAuthorizedDevicesRequest {
	mut res := CDeviceAuthGetOwnAuthorizedDevicesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_include_canceled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_canceled = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetownauthorizeddevicesrequest() CDeviceAuthGetOwnAuthorizedDevicesRequest {
	return CDeviceAuthGetOwnAuthorizedDevicesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetownauthorizeddevicesrequest(o CDeviceAuthGetOwnAuthorizedDevicesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetownauthorizeddevicesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetOwnAuthorizedDevicesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetownauthorizeddevicesrequest_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetOwnAuthorizedDevicesResponseDevice {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	auth_device_token     u64
	has_auth_device_token bool
	device_name           string
	has_device_name       bool
	is_pending            bool
	has_is_pending        bool
	is_canceled           bool
	has_is_canceled       bool
	last_time_used        u32
	has_last_time_used    bool
	last_borrower_id      u64
	has_last_borrower_id  bool
	last_app_played       u32
	has_last_app_played   bool
	is_limited            bool
	has_is_limited        bool
}

pub fn (o &CDeviceAuthGetOwnAuthorizedDevicesResponseDevice) pack() []byte {
	mut res := []byte{}
	if o.has_auth_device_token {
		res << vproto.pack_64bit_field(o.auth_device_token, 1)
	}
	if o.has_device_name {
		res << vproto.pack_string_field(o.device_name, 2)
	}
	if o.has_is_pending {
		res << vproto.pack_bool_field(o.is_pending, 3)
	}
	if o.has_is_canceled {
		res << vproto.pack_bool_field(o.is_canceled, 4)
	}
	if o.has_last_time_used {
		res << vproto.pack_uint32_field(o.last_time_used, 5)
	}
	if o.has_last_borrower_id {
		res << vproto.pack_64bit_field(o.last_borrower_id, 6)
	}
	if o.has_last_app_played {
		res << vproto.pack_uint32_field(o.last_app_played, 7)
	}
	if o.has_is_limited {
		res << vproto.pack_bool_field(o.is_limited, 8)
	}
	return res
}

pub fn cdeviceauthgetownauthorizeddevicesresponsedevice_unpack(buf []byte) ?CDeviceAuthGetOwnAuthorizedDevicesResponseDevice {
	mut res := CDeviceAuthGetOwnAuthorizedDevicesResponseDevice{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_auth_device_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_device_token = v
				i = ii
			}
			2 {
				res.has_device_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_name = v
				i = ii
			}
			3 {
				res.has_is_pending = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_pending = v
				i = ii
			}
			4 {
				res.has_is_canceled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_canceled = v
				i = ii
			}
			5 {
				res.has_last_time_used = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_time_used = v
				i = ii
			}
			6 {
				res.has_last_borrower_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.last_borrower_id = v
				i = ii
			}
			7 {
				res.has_last_app_played = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_app_played = v
				i = ii
			}
			8 {
				res.has_is_limited = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_limited = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetownauthorizeddevicesresponsedevice() CDeviceAuthGetOwnAuthorizedDevicesResponseDevice {
	return CDeviceAuthGetOwnAuthorizedDevicesResponseDevice{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetownauthorizeddevicesresponsedevice(o CDeviceAuthGetOwnAuthorizedDevicesResponseDevice, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetownauthorizeddevicesresponsedevice(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetOwnAuthorizedDevicesResponseDevice) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetownauthorizeddevicesresponsedevice_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetOwnAuthorizedDevicesResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	devices        []CDeviceAuthGetOwnAuthorizedDevicesResponseDevice
}

pub fn (o &CDeviceAuthGetOwnAuthorizedDevicesResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.devices {
		res << zzz_vproto_internal_pack_cdeviceauthgetownauthorizeddevicesresponsedevice(x, 1)
	}
	return res
}

pub fn cdeviceauthgetownauthorizeddevicesresponse_unpack(buf []byte) ?CDeviceAuthGetOwnAuthorizedDevicesResponse {
	mut res := CDeviceAuthGetOwnAuthorizedDevicesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauthgetownauthorizeddevicesresponsedevice(cur_buf,
					tag_wiretype.wire_type)?
				res.devices << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetownauthorizeddevicesresponse() CDeviceAuthGetOwnAuthorizedDevicesResponse {
	return CDeviceAuthGetOwnAuthorizedDevicesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetownauthorizeddevicesresponse(o CDeviceAuthGetOwnAuthorizedDevicesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetownauthorizeddevicesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetOwnAuthorizedDevicesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetownauthorizeddevicesresponse_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthAcceptAuthorizationRequestRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steamid               u64
	has_steamid           bool
	auth_device_token     u64
	has_auth_device_token bool
	auth_code             u64
	has_auth_code         bool
	from_steamid          u64
	has_from_steamid      bool
}

pub fn (o &CDeviceAuthAcceptAuthorizationRequestRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_auth_device_token {
		res << vproto.pack_64bit_field(o.auth_device_token, 2)
	}
	if o.has_auth_code {
		res << vproto.pack_64bit_field(o.auth_code, 3)
	}
	if o.has_from_steamid {
		res << vproto.pack_64bit_field(o.from_steamid, 4)
	}
	return res
}

pub fn cdeviceauthacceptauthorizationrequestrequest_unpack(buf []byte) ?CDeviceAuthAcceptAuthorizationRequestRequest {
	mut res := CDeviceAuthAcceptAuthorizationRequestRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_auth_device_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_device_token = v
				i = ii
			}
			3 {
				res.has_auth_code = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_code = v
				i = ii
			}
			4 {
				res.has_from_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.from_steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthacceptauthorizationrequestrequest() CDeviceAuthAcceptAuthorizationRequestRequest {
	return CDeviceAuthAcceptAuthorizationRequestRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthacceptauthorizationrequestrequest(o CDeviceAuthAcceptAuthorizationRequestRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthacceptauthorizationrequestrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthAcceptAuthorizationRequestRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthacceptauthorizationrequestrequest_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthAcceptAuthorizationRequestResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CDeviceAuthAcceptAuthorizationRequestResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cdeviceauthacceptauthorizationrequestresponse_unpack(buf []byte) ?CDeviceAuthAcceptAuthorizationRequestResponse {
	res := CDeviceAuthAcceptAuthorizationRequestResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthacceptauthorizationrequestresponse() CDeviceAuthAcceptAuthorizationRequestResponse {
	return CDeviceAuthAcceptAuthorizationRequestResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthacceptauthorizationrequestresponse(o CDeviceAuthAcceptAuthorizationRequestResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthacceptauthorizationrequestresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthAcceptAuthorizationRequestResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthacceptauthorizationrequestresponse_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthAuthorizeRemoteDeviceRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steamid               u64
	has_steamid           bool
	auth_device_token     u64
	has_auth_device_token bool
}

pub fn (o &CDeviceAuthAuthorizeRemoteDeviceRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_auth_device_token {
		res << vproto.pack_64bit_field(o.auth_device_token, 2)
	}
	return res
}

pub fn cdeviceauthauthorizeremotedevicerequest_unpack(buf []byte) ?CDeviceAuthAuthorizeRemoteDeviceRequest {
	mut res := CDeviceAuthAuthorizeRemoteDeviceRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_auth_device_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_device_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthauthorizeremotedevicerequest() CDeviceAuthAuthorizeRemoteDeviceRequest {
	return CDeviceAuthAuthorizeRemoteDeviceRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthauthorizeremotedevicerequest(o CDeviceAuthAuthorizeRemoteDeviceRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthauthorizeremotedevicerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthAuthorizeRemoteDeviceRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthauthorizeremotedevicerequest_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthAuthorizeRemoteDeviceResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CDeviceAuthAuthorizeRemoteDeviceResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cdeviceauthauthorizeremotedeviceresponse_unpack(buf []byte) ?CDeviceAuthAuthorizeRemoteDeviceResponse {
	res := CDeviceAuthAuthorizeRemoteDeviceResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthauthorizeremotedeviceresponse() CDeviceAuthAuthorizeRemoteDeviceResponse {
	return CDeviceAuthAuthorizeRemoteDeviceResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthauthorizeremotedeviceresponse(o CDeviceAuthAuthorizeRemoteDeviceResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthauthorizeremotedeviceresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthAuthorizeRemoteDeviceResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthauthorizeremotedeviceresponse_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthDeauthorizeRemoteDeviceRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steamid               u64
	has_steamid           bool
	auth_device_token     u64
	has_auth_device_token bool
}

pub fn (o &CDeviceAuthDeauthorizeRemoteDeviceRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_auth_device_token {
		res << vproto.pack_64bit_field(o.auth_device_token, 2)
	}
	return res
}

pub fn cdeviceauthdeauthorizeremotedevicerequest_unpack(buf []byte) ?CDeviceAuthDeauthorizeRemoteDeviceRequest {
	mut res := CDeviceAuthDeauthorizeRemoteDeviceRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_auth_device_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_device_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthdeauthorizeremotedevicerequest() CDeviceAuthDeauthorizeRemoteDeviceRequest {
	return CDeviceAuthDeauthorizeRemoteDeviceRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthdeauthorizeremotedevicerequest(o CDeviceAuthDeauthorizeRemoteDeviceRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthdeauthorizeremotedevicerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthDeauthorizeRemoteDeviceRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthdeauthorizeremotedevicerequest_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthDeauthorizeRemoteDeviceResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CDeviceAuthDeauthorizeRemoteDeviceResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cdeviceauthdeauthorizeremotedeviceresponse_unpack(buf []byte) ?CDeviceAuthDeauthorizeRemoteDeviceResponse {
	res := CDeviceAuthDeauthorizeRemoteDeviceResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthdeauthorizeremotedeviceresponse() CDeviceAuthDeauthorizeRemoteDeviceResponse {
	return CDeviceAuthDeauthorizeRemoteDeviceResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthdeauthorizeremotedeviceresponse(o CDeviceAuthDeauthorizeRemoteDeviceResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthdeauthorizeremotedeviceresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthDeauthorizeRemoteDeviceResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthdeauthorizeremotedeviceresponse_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetUsedAuthorizedDevicesRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CDeviceAuthGetUsedAuthorizedDevicesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cdeviceauthgetusedauthorizeddevicesrequest_unpack(buf []byte) ?CDeviceAuthGetUsedAuthorizedDevicesRequest {
	mut res := CDeviceAuthGetUsedAuthorizedDevicesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetusedauthorizeddevicesrequest() CDeviceAuthGetUsedAuthorizedDevicesRequest {
	return CDeviceAuthGetUsedAuthorizedDevicesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetusedauthorizeddevicesrequest(o CDeviceAuthGetUsedAuthorizedDevicesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetusedauthorizeddevicesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetUsedAuthorizedDevicesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetusedauthorizeddevicesrequest_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetUsedAuthorizedDevicesResponseDevice {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	auth_device_token     u64
	has_auth_device_token bool
	device_name           string
	has_device_name       bool
	owner_steamid         u64
	has_owner_steamid     bool
	last_time_used        u32
	has_last_time_used    bool
	last_app_played       u32
	has_last_app_played   bool
}

pub fn (o &CDeviceAuthGetUsedAuthorizedDevicesResponseDevice) pack() []byte {
	mut res := []byte{}
	if o.has_auth_device_token {
		res << vproto.pack_64bit_field(o.auth_device_token, 1)
	}
	if o.has_device_name {
		res << vproto.pack_string_field(o.device_name, 2)
	}
	if o.has_owner_steamid {
		res << vproto.pack_64bit_field(o.owner_steamid, 3)
	}
	if o.has_last_time_used {
		res << vproto.pack_uint32_field(o.last_time_used, 4)
	}
	if o.has_last_app_played {
		res << vproto.pack_uint32_field(o.last_app_played, 5)
	}
	return res
}

pub fn cdeviceauthgetusedauthorizeddevicesresponsedevice_unpack(buf []byte) ?CDeviceAuthGetUsedAuthorizedDevicesResponseDevice {
	mut res := CDeviceAuthGetUsedAuthorizedDevicesResponseDevice{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_auth_device_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_device_token = v
				i = ii
			}
			2 {
				res.has_device_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_name = v
				i = ii
			}
			3 {
				res.has_owner_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_steamid = v
				i = ii
			}
			4 {
				res.has_last_time_used = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_time_used = v
				i = ii
			}
			5 {
				res.has_last_app_played = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_app_played = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetusedauthorizeddevicesresponsedevice() CDeviceAuthGetUsedAuthorizedDevicesResponseDevice {
	return CDeviceAuthGetUsedAuthorizedDevicesResponseDevice{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetusedauthorizeddevicesresponsedevice(o CDeviceAuthGetUsedAuthorizedDevicesResponseDevice, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetusedauthorizeddevicesresponsedevice(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetUsedAuthorizedDevicesResponseDevice) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetusedauthorizeddevicesresponsedevice_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetUsedAuthorizedDevicesResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	devices        []CDeviceAuthGetUsedAuthorizedDevicesResponseDevice
}

pub fn (o &CDeviceAuthGetUsedAuthorizedDevicesResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.devices {
		res << zzz_vproto_internal_pack_cdeviceauthgetusedauthorizeddevicesresponsedevice(x, 1)
	}
	return res
}

pub fn cdeviceauthgetusedauthorizeddevicesresponse_unpack(buf []byte) ?CDeviceAuthGetUsedAuthorizedDevicesResponse {
	mut res := CDeviceAuthGetUsedAuthorizedDevicesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauthgetusedauthorizeddevicesresponsedevice(cur_buf,
					tag_wiretype.wire_type)?
				res.devices << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetusedauthorizeddevicesresponse() CDeviceAuthGetUsedAuthorizedDevicesResponse {
	return CDeviceAuthGetUsedAuthorizedDevicesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetusedauthorizeddevicesresponse(o CDeviceAuthGetUsedAuthorizedDevicesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetusedauthorizeddevicesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetUsedAuthorizedDevicesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetusedauthorizeddevicesresponse_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetAuthorizedBorrowersRequest {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	steamid              u64
	has_steamid          bool
	include_canceled     bool
	has_include_canceled bool
	include_pending      bool
	has_include_pending  bool
}

pub fn (o &CDeviceAuthGetAuthorizedBorrowersRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_include_canceled {
		res << vproto.pack_bool_field(o.include_canceled, 2)
	}
	if o.has_include_pending {
		res << vproto.pack_bool_field(o.include_pending, 3)
	}
	return res
}

pub fn cdeviceauthgetauthorizedborrowersrequest_unpack(buf []byte) ?CDeviceAuthGetAuthorizedBorrowersRequest {
	mut res := CDeviceAuthGetAuthorizedBorrowersRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_include_canceled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_canceled = v
				i = ii
			}
			3 {
				res.has_include_pending = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_pending = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetauthorizedborrowersrequest() CDeviceAuthGetAuthorizedBorrowersRequest {
	return CDeviceAuthGetAuthorizedBorrowersRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetauthorizedborrowersrequest(o CDeviceAuthGetAuthorizedBorrowersRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetauthorizedborrowersrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetAuthorizedBorrowersRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetauthorizedborrowersrequest_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetAuthorizedBorrowersResponseBorrower {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	is_pending       bool
	has_is_pending   bool
	is_canceled      bool
	has_is_canceled  bool
	time_created     u32
	has_time_created bool
}

pub fn (o &CDeviceAuthGetAuthorizedBorrowersResponseBorrower) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_is_pending {
		res << vproto.pack_bool_field(o.is_pending, 2)
	}
	if o.has_is_canceled {
		res << vproto.pack_bool_field(o.is_canceled, 3)
	}
	if o.has_time_created {
		res << vproto.pack_uint32_field(o.time_created, 4)
	}
	return res
}

pub fn cdeviceauthgetauthorizedborrowersresponseborrower_unpack(buf []byte) ?CDeviceAuthGetAuthorizedBorrowersResponseBorrower {
	mut res := CDeviceAuthGetAuthorizedBorrowersResponseBorrower{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_is_pending = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_pending = v
				i = ii
			}
			3 {
				res.has_is_canceled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_canceled = v
				i = ii
			}
			4 {
				res.has_time_created = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetauthorizedborrowersresponseborrower() CDeviceAuthGetAuthorizedBorrowersResponseBorrower {
	return CDeviceAuthGetAuthorizedBorrowersResponseBorrower{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetauthorizedborrowersresponseborrower(o CDeviceAuthGetAuthorizedBorrowersResponseBorrower, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetauthorizedborrowersresponseborrower(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetAuthorizedBorrowersResponseBorrower) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetauthorizedborrowersresponseborrower_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetAuthorizedBorrowersResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	borrowers      []CDeviceAuthGetAuthorizedBorrowersResponseBorrower
}

pub fn (o &CDeviceAuthGetAuthorizedBorrowersResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.borrowers {
		res << zzz_vproto_internal_pack_cdeviceauthgetauthorizedborrowersresponseborrower(x, 1)
	}
	return res
}

pub fn cdeviceauthgetauthorizedborrowersresponse_unpack(buf []byte) ?CDeviceAuthGetAuthorizedBorrowersResponse {
	mut res := CDeviceAuthGetAuthorizedBorrowersResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauthgetauthorizedborrowersresponseborrower(cur_buf,
					tag_wiretype.wire_type)?
				res.borrowers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetauthorizedborrowersresponse() CDeviceAuthGetAuthorizedBorrowersResponse {
	return CDeviceAuthGetAuthorizedBorrowersResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetauthorizedborrowersresponse(o CDeviceAuthGetAuthorizedBorrowersResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetauthorizedborrowersresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetAuthorizedBorrowersResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetauthorizedborrowersresponse_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthAddAuthorizedBorrowersRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	steamid_borrower []u64
}

pub fn (o &CDeviceAuthAddAuthorizedBorrowersRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	// [packed=false]
	for _, x in o.steamid_borrower {
		res << vproto.pack_64bit_field(x, 2)
	}
	return res
}

pub fn cdeviceauthaddauthorizedborrowersrequest_unpack(buf []byte) ?CDeviceAuthAddAuthorizedBorrowersRequest {
	mut res := CDeviceAuthAddAuthorizedBorrowersRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_borrower << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthaddauthorizedborrowersrequest() CDeviceAuthAddAuthorizedBorrowersRequest {
	return CDeviceAuthAddAuthorizedBorrowersRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthaddauthorizedborrowersrequest(o CDeviceAuthAddAuthorizedBorrowersRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthaddauthorizedborrowersrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthAddAuthorizedBorrowersRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthaddauthorizedborrowersrequest_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthAddAuthorizedBorrowersResponse {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	seconds_to_wait     int
	has_seconds_to_wait bool
}

pub fn (o &CDeviceAuthAddAuthorizedBorrowersResponse) pack() []byte {
	mut res := []byte{}
	if o.has_seconds_to_wait {
		res << vproto.pack_int32_field(o.seconds_to_wait, 1)
	}
	return res
}

pub fn cdeviceauthaddauthorizedborrowersresponse_unpack(buf []byte) ?CDeviceAuthAddAuthorizedBorrowersResponse {
	mut res := CDeviceAuthAddAuthorizedBorrowersResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_seconds_to_wait = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_to_wait = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthaddauthorizedborrowersresponse() CDeviceAuthAddAuthorizedBorrowersResponse {
	return CDeviceAuthAddAuthorizedBorrowersResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthaddauthorizedborrowersresponse(o CDeviceAuthAddAuthorizedBorrowersResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthaddauthorizedborrowersresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthAddAuthorizedBorrowersResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthaddauthorizedborrowersresponse_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthRemoveAuthorizedBorrowersRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	steamid_borrower []u64
}

pub fn (o &CDeviceAuthRemoveAuthorizedBorrowersRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	// [packed=false]
	for _, x in o.steamid_borrower {
		res << vproto.pack_64bit_field(x, 2)
	}
	return res
}

pub fn cdeviceauthremoveauthorizedborrowersrequest_unpack(buf []byte) ?CDeviceAuthRemoveAuthorizedBorrowersRequest {
	mut res := CDeviceAuthRemoveAuthorizedBorrowersRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_borrower << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthremoveauthorizedborrowersrequest() CDeviceAuthRemoveAuthorizedBorrowersRequest {
	return CDeviceAuthRemoveAuthorizedBorrowersRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthremoveauthorizedborrowersrequest(o CDeviceAuthRemoveAuthorizedBorrowersRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthremoveauthorizedborrowersrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthRemoveAuthorizedBorrowersRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthremoveauthorizedborrowersrequest_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthRemoveAuthorizedBorrowersResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CDeviceAuthRemoveAuthorizedBorrowersResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cdeviceauthremoveauthorizedborrowersresponse_unpack(buf []byte) ?CDeviceAuthRemoveAuthorizedBorrowersResponse {
	res := CDeviceAuthRemoveAuthorizedBorrowersResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthremoveauthorizedborrowersresponse() CDeviceAuthRemoveAuthorizedBorrowersResponse {
	return CDeviceAuthRemoveAuthorizedBorrowersResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthremoveauthorizedborrowersresponse(o CDeviceAuthRemoveAuthorizedBorrowersResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthremoveauthorizedborrowersresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthRemoveAuthorizedBorrowersResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthremoveauthorizedborrowersresponse_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetAuthorizedAsBorrowerRequest {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	steamid              u64
	has_steamid          bool
	include_canceled     bool
	has_include_canceled bool
	include_pending      bool
	has_include_pending  bool
}

pub fn (o &CDeviceAuthGetAuthorizedAsBorrowerRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_include_canceled {
		res << vproto.pack_bool_field(o.include_canceled, 2)
	}
	if o.has_include_pending {
		res << vproto.pack_bool_field(o.include_pending, 3)
	}
	return res
}

pub fn cdeviceauthgetauthorizedasborrowerrequest_unpack(buf []byte) ?CDeviceAuthGetAuthorizedAsBorrowerRequest {
	mut res := CDeviceAuthGetAuthorizedAsBorrowerRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_include_canceled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_canceled = v
				i = ii
			}
			3 {
				res.has_include_pending = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_pending = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetauthorizedasborrowerrequest() CDeviceAuthGetAuthorizedAsBorrowerRequest {
	return CDeviceAuthGetAuthorizedAsBorrowerRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetauthorizedasborrowerrequest(o CDeviceAuthGetAuthorizedAsBorrowerRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetauthorizedasborrowerrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetAuthorizedAsBorrowerRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetauthorizedasborrowerrequest_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetAuthorizedAsBorrowerResponseLender {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	time_created     u32
	has_time_created bool
	is_pending       bool
	has_is_pending   bool
	is_canceled      bool
	has_is_canceled  bool
	is_used          bool
	has_is_used      bool
}

pub fn (o &CDeviceAuthGetAuthorizedAsBorrowerResponseLender) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_time_created {
		res << vproto.pack_uint32_field(o.time_created, 2)
	}
	if o.has_is_pending {
		res << vproto.pack_bool_field(o.is_pending, 3)
	}
	if o.has_is_canceled {
		res << vproto.pack_bool_field(o.is_canceled, 4)
	}
	if o.has_is_used {
		res << vproto.pack_bool_field(o.is_used, 5)
	}
	return res
}

pub fn cdeviceauthgetauthorizedasborrowerresponselender_unpack(buf []byte) ?CDeviceAuthGetAuthorizedAsBorrowerResponseLender {
	mut res := CDeviceAuthGetAuthorizedAsBorrowerResponseLender{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_time_created = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			3 {
				res.has_is_pending = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_pending = v
				i = ii
			}
			4 {
				res.has_is_canceled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_canceled = v
				i = ii
			}
			5 {
				res.has_is_used = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_used = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetauthorizedasborrowerresponselender() CDeviceAuthGetAuthorizedAsBorrowerResponseLender {
	return CDeviceAuthGetAuthorizedAsBorrowerResponseLender{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetauthorizedasborrowerresponselender(o CDeviceAuthGetAuthorizedAsBorrowerResponseLender, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetauthorizedasborrowerresponselender(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetAuthorizedAsBorrowerResponseLender) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetauthorizedasborrowerresponselender_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetAuthorizedAsBorrowerResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	lenders        []CDeviceAuthGetAuthorizedAsBorrowerResponseLender
}

pub fn (o &CDeviceAuthGetAuthorizedAsBorrowerResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.lenders {
		res << zzz_vproto_internal_pack_cdeviceauthgetauthorizedasborrowerresponselender(x, 1)
	}
	return res
}

pub fn cdeviceauthgetauthorizedasborrowerresponse_unpack(buf []byte) ?CDeviceAuthGetAuthorizedAsBorrowerResponse {
	mut res := CDeviceAuthGetAuthorizedAsBorrowerResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauthgetauthorizedasborrowerresponselender(cur_buf,
					tag_wiretype.wire_type)?
				res.lenders << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetauthorizedasborrowerresponse() CDeviceAuthGetAuthorizedAsBorrowerResponse {
	return CDeviceAuthGetAuthorizedAsBorrowerResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetauthorizedasborrowerresponse(o CDeviceAuthGetAuthorizedAsBorrowerResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetauthorizedasborrowerresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetAuthorizedAsBorrowerResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetauthorizedasborrowerresponse_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetExcludedGamesInLibraryRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CDeviceAuthGetExcludedGamesInLibraryRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cdeviceauthgetexcludedgamesinlibraryrequest_unpack(buf []byte) ?CDeviceAuthGetExcludedGamesInLibraryRequest {
	mut res := CDeviceAuthGetExcludedGamesInLibraryRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetexcludedgamesinlibraryrequest() CDeviceAuthGetExcludedGamesInLibraryRequest {
	return CDeviceAuthGetExcludedGamesInLibraryRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetexcludedgamesinlibraryrequest(o CDeviceAuthGetExcludedGamesInLibraryRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetexcludedgamesinlibraryrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetExcludedGamesInLibraryRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetexcludedgamesinlibraryrequest_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetExcludedGamesInLibraryResponseExcludedGame {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	appid                u32
	has_appid            bool
	game_name            string
	has_game_name        bool
	vac_banned           bool
	has_vac_banned       bool
	package_excluded     bool
	has_package_excluded bool
}

pub fn (o &CDeviceAuthGetExcludedGamesInLibraryResponseExcludedGame) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_game_name {
		res << vproto.pack_string_field(o.game_name, 2)
	}
	if o.has_vac_banned {
		res << vproto.pack_bool_field(o.vac_banned, 3)
	}
	if o.has_package_excluded {
		res << vproto.pack_bool_field(o.package_excluded, 4)
	}
	return res
}

pub fn cdeviceauthgetexcludedgamesinlibraryresponseexcludedgame_unpack(buf []byte) ?CDeviceAuthGetExcludedGamesInLibraryResponseExcludedGame {
	mut res := CDeviceAuthGetExcludedGamesInLibraryResponseExcludedGame{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_game_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_name = v
				i = ii
			}
			3 {
				res.has_vac_banned = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.vac_banned = v
				i = ii
			}
			4 {
				res.has_package_excluded = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.package_excluded = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetexcludedgamesinlibraryresponseexcludedgame() CDeviceAuthGetExcludedGamesInLibraryResponseExcludedGame {
	return CDeviceAuthGetExcludedGamesInLibraryResponseExcludedGame{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetexcludedgamesinlibraryresponseexcludedgame(o CDeviceAuthGetExcludedGamesInLibraryResponseExcludedGame, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetexcludedgamesinlibraryresponseexcludedgame(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetExcludedGamesInLibraryResponseExcludedGame) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetexcludedgamesinlibraryresponseexcludedgame_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetExcludedGamesInLibraryResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	excluded_games []CDeviceAuthGetExcludedGamesInLibraryResponseExcludedGame
}

pub fn (o &CDeviceAuthGetExcludedGamesInLibraryResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.excluded_games {
		res <<
			zzz_vproto_internal_pack_cdeviceauthgetexcludedgamesinlibraryresponseexcludedgame(x, 1)
	}
	return res
}

pub fn cdeviceauthgetexcludedgamesinlibraryresponse_unpack(buf []byte) ?CDeviceAuthGetExcludedGamesInLibraryResponse {
	mut res := CDeviceAuthGetExcludedGamesInLibraryResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauthgetexcludedgamesinlibraryresponseexcludedgame(cur_buf,
					tag_wiretype.wire_type)?
				res.excluded_games << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetexcludedgamesinlibraryresponse() CDeviceAuthGetExcludedGamesInLibraryResponse {
	return CDeviceAuthGetExcludedGamesInLibraryResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetexcludedgamesinlibraryresponse(o CDeviceAuthGetExcludedGamesInLibraryResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetexcludedgamesinlibraryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetExcludedGamesInLibraryResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetexcludedgamesinlibraryresponse_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetBorrowerPlayHistoryRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CDeviceAuthGetBorrowerPlayHistoryRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cdeviceauthgetborrowerplayhistoryrequest_unpack(buf []byte) ?CDeviceAuthGetBorrowerPlayHistoryRequest {
	mut res := CDeviceAuthGetBorrowerPlayHistoryRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetborrowerplayhistoryrequest() CDeviceAuthGetBorrowerPlayHistoryRequest {
	return CDeviceAuthGetBorrowerPlayHistoryRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetborrowerplayhistoryrequest(o CDeviceAuthGetBorrowerPlayHistoryRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetborrowerplayhistoryrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetBorrowerPlayHistoryRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetborrowerplayhistoryrequest_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetBorrowerPlayHistoryResponseGameHistory {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	time_last      u32
	has_time_last  bool
	time_total     u32
	has_time_total bool
}

pub fn (o &CDeviceAuthGetBorrowerPlayHistoryResponseGameHistory) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_time_last {
		res << vproto.pack_uint32_field(o.time_last, 2)
	}
	if o.has_time_total {
		res << vproto.pack_uint32_field(o.time_total, 3)
	}
	return res
}

pub fn cdeviceauthgetborrowerplayhistoryresponsegamehistory_unpack(buf []byte) ?CDeviceAuthGetBorrowerPlayHistoryResponseGameHistory {
	mut res := CDeviceAuthGetBorrowerPlayHistoryResponseGameHistory{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_time_last = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last = v
				i = ii
			}
			3 {
				res.has_time_total = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_total = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetborrowerplayhistoryresponsegamehistory() CDeviceAuthGetBorrowerPlayHistoryResponseGameHistory {
	return CDeviceAuthGetBorrowerPlayHistoryResponseGameHistory{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetborrowerplayhistoryresponsegamehistory(o CDeviceAuthGetBorrowerPlayHistoryResponseGameHistory, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetborrowerplayhistoryresponsegamehistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetBorrowerPlayHistoryResponseGameHistory) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetborrowerplayhistoryresponsegamehistory_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetBorrowerPlayHistoryResponseLenderHistory {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	game_history   []CDeviceAuthGetBorrowerPlayHistoryResponseGameHistory
}

pub fn (o &CDeviceAuthGetBorrowerPlayHistoryResponseLenderHistory) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	// [packed=false]
	for _, x in o.game_history {
		res << zzz_vproto_internal_pack_cdeviceauthgetborrowerplayhistoryresponsegamehistory(x, 2)
	}
	return res
}

pub fn cdeviceauthgetborrowerplayhistoryresponselenderhistory_unpack(buf []byte) ?CDeviceAuthGetBorrowerPlayHistoryResponseLenderHistory {
	mut res := CDeviceAuthGetBorrowerPlayHistoryResponseLenderHistory{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauthgetborrowerplayhistoryresponsegamehistory(cur_buf,
					tag_wiretype.wire_type)?
				res.game_history << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetborrowerplayhistoryresponselenderhistory() CDeviceAuthGetBorrowerPlayHistoryResponseLenderHistory {
	return CDeviceAuthGetBorrowerPlayHistoryResponseLenderHistory{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetborrowerplayhistoryresponselenderhistory(o CDeviceAuthGetBorrowerPlayHistoryResponseLenderHistory, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetborrowerplayhistoryresponselenderhistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetBorrowerPlayHistoryResponseLenderHistory) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetborrowerplayhistoryresponselenderhistory_unpack(v)?
	return i, unpacked
}

pub struct CDeviceAuthGetBorrowerPlayHistoryResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	lender_history []CDeviceAuthGetBorrowerPlayHistoryResponseLenderHistory
}

pub fn (o &CDeviceAuthGetBorrowerPlayHistoryResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.lender_history {
		res <<
			zzz_vproto_internal_pack_cdeviceauthgetborrowerplayhistoryresponselenderhistory(x, 1)
	}
	return res
}

pub fn cdeviceauthgetborrowerplayhistoryresponse_unpack(buf []byte) ?CDeviceAuthGetBorrowerPlayHistoryResponse {
	mut res := CDeviceAuthGetBorrowerPlayHistoryResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cdeviceauthgetborrowerplayhistoryresponselenderhistory(cur_buf,
					tag_wiretype.wire_type)?
				res.lender_history << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeviceauthgetborrowerplayhistoryresponse() CDeviceAuthGetBorrowerPlayHistoryResponse {
	return CDeviceAuthGetBorrowerPlayHistoryResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeviceauthgetborrowerplayhistoryresponse(o CDeviceAuthGetBorrowerPlayHistoryResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeviceauthgetborrowerplayhistoryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeviceAuthGetBorrowerPlayHistoryResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeviceauthgetborrowerplayhistoryresponse_unpack(v)?
	return i, unpacked
}
