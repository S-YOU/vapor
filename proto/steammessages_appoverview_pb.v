// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EDisplayStatus {
	k_edisplaystatusinvalid = 0
	k_edisplaystatuslaunching = 1
	k_edisplaystatusuninstalling = 2
	k_edisplaystatusinstalling = 3
	k_edisplaystatusrunning = 4
	k_edisplaystatusvalidating = 5
	k_edisplaystatusupdating = 6
	k_edisplaystatusdownloading = 7
	k_edisplaystatussynchronizing = 8
	k_edisplaystatusreadytoinstall = 9
	k_edisplaystatusreadytopreload = 10
	k_edisplaystatusreadytolaunch = 11
	k_edisplaystatusregionrestricted = 12
	k_edisplaystatuspresaleonly = 13
	k_edisplaystatusinvalidplatform = 14
	k_edisplaystatuspreloadcomplete = 16
	k_edisplaystatusborrowerlocked = 17
	k_edisplaystatusupdatepaused = 18
	k_edisplaystatusupdatequeued = 19
	k_edisplaystatusupdaterequired = 20
	k_edisplaystatusupdatedisabled = 21
	k_edisplaystatusdownloadpaused = 22
	k_edisplaystatusdownloadqueued = 23
	k_edisplaystatusdownloadrequired = 24
	k_edisplaystatusdownloaddisabled = 25
	k_edisplaystatuslicensepending = 26
	k_edisplaystatuslicenseexpired = 27
	k_edisplaystatusavailforfree = 28
	k_edisplaystatusavailtoborrow = 29
	k_edisplaystatusavailguestpass = 30
	k_edisplaystatuspurchase = 31
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_edisplaystatus(e EDisplayStatus, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_edisplaystatus(buf []byte, tag_wiretype vproto.WireType) ?(int, EDisplayStatus) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EDisplayStatus(v)
}

[_allow_multiple_values]
enum EProtoAppType {
	k_eapptypeinvalid = 0
	k_eapptypegame = 1
	k_eapptypeapplication = 2
	k_eapptypetool = 4
	k_eapptypedemo = 8
	k_eapptypedeprected = 16
	k_eapptypedlc = 32
	k_eapptypeguide = 64
	k_eapptypedriver = 128
	k_eapptypeconfig = 256
	k_eapptypehardware = 512
	k_eapptypefranchise = 1024
	k_eapptypevideo = 2048
	k_eapptypeplugin = 4096
	k_eapptypemusicalbum = 8192
	k_eapptypeseries = 16384
	k_eapptypecomic = 32768
	k_eapptypebeta = 65536
	k_eapptypeshortcut = 1073741824
	k_eapptypedepotonly = -2147483648
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eprotoapptype(e EProtoAppType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eprotoapptype(buf []byte, tag_wiretype vproto.WireType) ?(int, EProtoAppType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EProtoAppType(v)
}

[_allow_multiple_values]
enum EAppAssociationType {
	k_eappassociationtypeinvalid = 0
	k_eappassociationtypepublisher = 1
	k_eappassociationtypedeveloper = 2
	k_eappassociationtypefranchise = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eappassociationtype(e EAppAssociationType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eappassociationtype(buf []byte, tag_wiretype vproto.WireType) ?(int, EAppAssociationType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EAppAssociationType(v)
}

[_allow_multiple_values]
enum EAppControllerSupportLevel {
	k_eappcontrollersupportlevelnone = 0
	k_eappcontrollersupportlevelpartial = 1
	k_eappcontrollersupportlevelfull = 2
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eappcontrollersupportlevel(e EAppControllerSupportLevel, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eappcontrollersupportlevel(buf []byte, tag_wiretype vproto.WireType) ?(int, EAppControllerSupportLevel) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EAppControllerSupportLevel(v)
}

pub struct CAppOverviewAppAssociation {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	@type          EAppAssociationType
	has_type       bool
	name           string
	has_name       bool
}

pub fn (o &CAppOverviewAppAssociation) pack() []byte {
	mut res := []byte{}
	if o.has_type {
		res << zzz_vproto_internal_pack_eappassociationtype(o.@type, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	return res
}

pub fn cappoverviewappassociation_unpack(buf []byte) ?CAppOverviewAppAssociation {
	mut res := CAppOverviewAppAssociation{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_type = true
				ii, v := zzz_vproto_internal_unpack_eappassociationtype(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cappoverviewappassociation() CAppOverviewAppAssociation {
	return CAppOverviewAppAssociation{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cappoverviewappassociation(o CAppOverviewAppAssociation, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cappoverviewappassociation(buf []byte, tag_wiretype vproto.WireType) ?(int, CAppOverviewAppAssociation) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cappoverviewappassociation_unpack(v)?
	return i, unpacked
}

pub struct CAppOverviewPerClientData {
mut:
	unknown_fields                       []vproto.UnknownField
pub mut:
	clientid                             u64
	has_clientid                         bool
	client_name                          string
	has_client_name                      bool
	display_status                       EDisplayStatus
	has_display_status                   bool
	status_percentage                    u32
	has_status_percentage                bool
	active_beta                          string
	has_active_beta                      bool
	installed                            bool
	has_installed                        bool
	bytes_downloaded                     u64
	has_bytes_downloaded                 bool
	bytes_total                          u64
	has_bytes_total                      bool
	streaming_to_local_client            bool
	has_streaming_to_local_client        bool
	is_available_on_current_platform     bool
	has_is_available_on_current_platform bool
	is_invalid_os_type                   bool
	has_is_invalid_os_type               bool
	playtime_left                        u32
	has_playtime_left                    bool
}

pub fn (o &CAppOverviewPerClientData) pack() []byte {
	mut res := []byte{}
	if o.has_clientid {
		res << vproto.pack_uint64_field(o.clientid, 1)
	}
	if o.has_client_name {
		res << vproto.pack_string_field(o.client_name, 2)
	}
	if o.has_display_status {
		res << zzz_vproto_internal_pack_edisplaystatus(o.display_status, 3)
	}
	if o.has_status_percentage {
		res << vproto.pack_uint32_field(o.status_percentage, 4)
	}
	if o.has_active_beta {
		res << vproto.pack_string_field(o.active_beta, 5)
	}
	if o.has_installed {
		res << vproto.pack_bool_field(o.installed, 6)
	}
	if o.has_bytes_downloaded {
		res << vproto.pack_uint64_field(o.bytes_downloaded, 7)
	}
	if o.has_bytes_total {
		res << vproto.pack_uint64_field(o.bytes_total, 8)
	}
	if o.has_streaming_to_local_client {
		res << vproto.pack_bool_field(o.streaming_to_local_client, 9)
	}
	if o.has_is_available_on_current_platform {
		res << vproto.pack_bool_field(o.is_available_on_current_platform, 10)
	}
	if o.has_is_invalid_os_type {
		res << vproto.pack_bool_field(o.is_invalid_os_type, 11)
	}
	if o.has_playtime_left {
		res << vproto.pack_uint32_field(o.playtime_left, 12)
	}
	return res
}

pub fn cappoverviewperclientdata_unpack(buf []byte) ?CAppOverviewPerClientData {
	mut res := CAppOverviewPerClientData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_clientid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.clientid = v
				i = ii
			}
			2 {
				res.has_client_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.client_name = v
				i = ii
			}
			3 {
				res.has_display_status = true
				ii, v := zzz_vproto_internal_unpack_edisplaystatus(cur_buf, tag_wiretype.wire_type)?
				res.display_status = v
				i = ii
			}
			4 {
				res.has_status_percentage = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.status_percentage = v
				i = ii
			}
			5 {
				res.has_active_beta = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.active_beta = v
				i = ii
			}
			6 {
				res.has_installed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.installed = v
				i = ii
			}
			7 {
				res.has_bytes_downloaded = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_downloaded = v
				i = ii
			}
			8 {
				res.has_bytes_total = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_total = v
				i = ii
			}
			9 {
				res.has_streaming_to_local_client = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.streaming_to_local_client = v
				i = ii
			}
			10 {
				res.has_is_available_on_current_platform = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_available_on_current_platform = v
				i = ii
			}
			11 {
				res.has_is_invalid_os_type = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_invalid_os_type = v
				i = ii
			}
			12 {
				res.has_playtime_left = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.playtime_left = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cappoverviewperclientdata() CAppOverviewPerClientData {
	return CAppOverviewPerClientData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cappoverviewperclientdata(o CAppOverviewPerClientData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cappoverviewperclientdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CAppOverviewPerClientData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cappoverviewperclientdata_unpack(v)?
	return i, unpacked
}

pub struct CAppOverview {
mut:
	unknown_fields                      []vproto.UnknownField
pub mut:
	appid                               u32
	has_appid                           bool
	display_name                        string
	has_display_name                    bool
	visible_in_game_list                bool
	has_visible_in_game_list            bool
	sort_as                             string
	has_sort_as                         bool
	app_type                            EProtoAppType
	has_app_type                        bool
	mru_index                           u32
	has_mru_index                       bool
	rt_recent_activity_time             u32
	has_rt_recent_activity_time         bool
	minutes_playtime_forever            u32
	has_minutes_playtime_forever        bool
	minutes_playtime_last_two_weeks     u32
	has_minutes_playtime_last_two_weeks bool
	rt_last_time_played                 u32
	has_rt_last_time_played             bool
	store_tag                           []u32
	association                         []CAppOverviewAppAssociation
	store_category                      []u32
	rt_original_release_date            u32
	has_rt_original_release_date        bool
	rt_steam_release_date               u32
	has_rt_steam_release_date           bool
	icon_hash                           string
	has_icon_hash                       bool
	logo_hash                           string
	has_logo_hash                       bool
	controller_support                  EAppControllerSupportLevel
	has_controller_support              bool
	vr_supported                        bool
	has_vr_supported                    bool
	metacritic_score                    u32
	has_metacritic_score                bool
	size_on_disk                        u64
	has_size_on_disk                    bool
	third_party_mod                     bool
	has_third_party_mod                 bool
	icon_data                           string
	has_icon_data                       bool
	icon_data_format                    string
	has_icon_data_format                bool
	gameid                              string
	has_gameid                          bool
	library_capsule_filename            string
	has_library_capsule_filename        bool
	per_client_data                     []CAppOverviewPerClientData
	most_available_clientid             u64
	has_most_available_clientid         bool
	selected_clientid                   u64
	has_selected_clientid               bool
	rt_store_asset_mtime                u32
	has_rt_store_asset_mtime            bool
	rt_custom_image_mtime               u32
	has_rt_custom_image_mtime           bool
	optional_parent_app_id              u32
	has_optional_parent_app_id          bool
	owner_account_id                    u32
	has_owner_account_id                bool
	compat_mapping_enabled              bool
	has_compat_mapping_enabled          bool
	compat_mapping_priority             u32
	has_compat_mapping_priority         bool
	compat_mapping_tool_name            string
	has_compat_mapping_tool_name        bool
	review_score_with_bombs             u32
	has_review_score_with_bombs         bool
	review_percentage_with_bombs        u32
	has_review_percentage_with_bombs    bool
	review_score_without_bombs          u32
	has_review_score_without_bombs      bool
	review_percentage_without_bombs     u32
	has_review_percentage_without_bombs bool
	library_id                          string
	has_library_id                      bool
}

pub fn (o &CAppOverview) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_display_name {
		res << vproto.pack_string_field(o.display_name, 2)
	}
	if o.has_visible_in_game_list {
		res << vproto.pack_bool_field(o.visible_in_game_list, 4)
	}
	if o.has_sort_as {
		res << vproto.pack_string_field(o.sort_as, 6)
	}
	if o.has_app_type {
		res << zzz_vproto_internal_pack_eprotoapptype(o.app_type, 7)
	}
	if o.has_mru_index {
		res << vproto.pack_uint32_field(o.mru_index, 13)
	}
	if o.has_rt_recent_activity_time {
		res << vproto.pack_uint32_field(o.rt_recent_activity_time, 14)
	}
	if o.has_minutes_playtime_forever {
		res << vproto.pack_uint32_field(o.minutes_playtime_forever, 16)
	}
	if o.has_minutes_playtime_last_two_weeks {
		res << vproto.pack_uint32_field(o.minutes_playtime_last_two_weeks, 17)
	}
	if o.has_rt_last_time_played {
		res << vproto.pack_uint32_field(o.rt_last_time_played, 18)
	}
	// [packed=false]
	for _, x in o.store_tag {
		res << vproto.pack_uint32_field(x, 19)
	}
	// [packed=false]
	for _, x in o.association {
		res << zzz_vproto_internal_pack_cappoverviewappassociation(x, 20)
	}
	// [packed=false]
	for _, x in o.store_category {
		res << vproto.pack_uint32_field(x, 23)
	}
	if o.has_rt_original_release_date {
		res << vproto.pack_uint32_field(o.rt_original_release_date, 25)
	}
	if o.has_rt_steam_release_date {
		res << vproto.pack_uint32_field(o.rt_steam_release_date, 26)
	}
	if o.has_icon_hash {
		res << vproto.pack_string_field(o.icon_hash, 27)
	}
	if o.has_logo_hash {
		res << vproto.pack_string_field(o.logo_hash, 30)
	}
	if o.has_controller_support {
		res << zzz_vproto_internal_pack_eappcontrollersupportlevel(o.controller_support, 31)
	}
	if o.has_vr_supported {
		res << vproto.pack_bool_field(o.vr_supported, 32)
	}
	if o.has_metacritic_score {
		res << vproto.pack_uint32_field(o.metacritic_score, 36)
	}
	if o.has_size_on_disk {
		res << vproto.pack_uint64_field(o.size_on_disk, 37)
	}
	if o.has_third_party_mod {
		res << vproto.pack_bool_field(o.third_party_mod, 38)
	}
	if o.has_icon_data {
		res << vproto.pack_string_field(o.icon_data, 39)
	}
	if o.has_icon_data_format {
		res << vproto.pack_string_field(o.icon_data_format, 40)
	}
	if o.has_gameid {
		res << vproto.pack_string_field(o.gameid, 41)
	}
	if o.has_library_capsule_filename {
		res << vproto.pack_string_field(o.library_capsule_filename, 42)
	}
	// [packed=false]
	for _, x in o.per_client_data {
		res << zzz_vproto_internal_pack_cappoverviewperclientdata(x, 43)
	}
	if o.has_most_available_clientid {
		res << vproto.pack_uint64_field(o.most_available_clientid, 44)
	}
	if o.has_selected_clientid {
		res << vproto.pack_uint64_field(o.selected_clientid, 45)
	}
	if o.has_rt_store_asset_mtime {
		res << vproto.pack_uint32_field(o.rt_store_asset_mtime, 46)
	}
	if o.has_rt_custom_image_mtime {
		res << vproto.pack_uint32_field(o.rt_custom_image_mtime, 47)
	}
	if o.has_optional_parent_app_id {
		res << vproto.pack_uint32_field(o.optional_parent_app_id, 48)
	}
	if o.has_owner_account_id {
		res << vproto.pack_uint32_field(o.owner_account_id, 49)
	}
	if o.has_compat_mapping_enabled {
		res << vproto.pack_bool_field(o.compat_mapping_enabled, 50)
	}
	if o.has_compat_mapping_priority {
		res << vproto.pack_uint32_field(o.compat_mapping_priority, 51)
	}
	if o.has_compat_mapping_tool_name {
		res << vproto.pack_string_field(o.compat_mapping_tool_name, 52)
	}
	if o.has_review_score_with_bombs {
		res << vproto.pack_uint32_field(o.review_score_with_bombs, 53)
	}
	if o.has_review_percentage_with_bombs {
		res << vproto.pack_uint32_field(o.review_percentage_with_bombs, 54)
	}
	if o.has_review_score_without_bombs {
		res << vproto.pack_uint32_field(o.review_score_without_bombs, 55)
	}
	if o.has_review_percentage_without_bombs {
		res << vproto.pack_uint32_field(o.review_percentage_without_bombs, 56)
	}
	if o.has_library_id {
		res << vproto.pack_string_field(o.library_id, 57)
	}
	return res
}

pub fn cappoverview_unpack(buf []byte) ?CAppOverview {
	mut res := CAppOverview{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_display_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.display_name = v
				i = ii
			}
			4 {
				res.has_visible_in_game_list = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.visible_in_game_list = v
				i = ii
			}
			6 {
				res.has_sort_as = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sort_as = v
				i = ii
			}
			7 {
				res.has_app_type = true
				ii, v := zzz_vproto_internal_unpack_eprotoapptype(cur_buf, tag_wiretype.wire_type)?
				res.app_type = v
				i = ii
			}
			13 {
				res.has_mru_index = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.mru_index = v
				i = ii
			}
			14 {
				res.has_rt_recent_activity_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rt_recent_activity_time = v
				i = ii
			}
			16 {
				res.has_minutes_playtime_forever = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.minutes_playtime_forever = v
				i = ii
			}
			17 {
				res.has_minutes_playtime_last_two_weeks = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.minutes_playtime_last_two_weeks = v
				i = ii
			}
			18 {
				res.has_rt_last_time_played = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rt_last_time_played = v
				i = ii
			}
			19 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.store_tag << v
				i = ii
			}
			20 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cappoverviewappassociation(cur_buf,
					tag_wiretype.wire_type)?
				res.association << v
				i = ii
			}
			23 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.store_category << v
				i = ii
			}
			25 {
				res.has_rt_original_release_date = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rt_original_release_date = v
				i = ii
			}
			26 {
				res.has_rt_steam_release_date = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rt_steam_release_date = v
				i = ii
			}
			27 {
				res.has_icon_hash = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon_hash = v
				i = ii
			}
			30 {
				res.has_logo_hash = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.logo_hash = v
				i = ii
			}
			31 {
				res.has_controller_support = true
				ii, v := zzz_vproto_internal_unpack_eappcontrollersupportlevel(cur_buf,
					tag_wiretype.wire_type)?
				res.controller_support = v
				i = ii
			}
			32 {
				res.has_vr_supported = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.vr_supported = v
				i = ii
			}
			36 {
				res.has_metacritic_score = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.metacritic_score = v
				i = ii
			}
			37 {
				res.has_size_on_disk = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.size_on_disk = v
				i = ii
			}
			38 {
				res.has_third_party_mod = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.third_party_mod = v
				i = ii
			}
			39 {
				res.has_icon_data = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon_data = v
				i = ii
			}
			40 {
				res.has_icon_data_format = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon_data_format = v
				i = ii
			}
			41 {
				res.has_gameid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			42 {
				res.has_library_capsule_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.library_capsule_filename = v
				i = ii
			}
			43 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cappoverviewperclientdata(cur_buf,
					tag_wiretype.wire_type)?
				res.per_client_data << v
				i = ii
			}
			44 {
				res.has_most_available_clientid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.most_available_clientid = v
				i = ii
			}
			45 {
				res.has_selected_clientid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.selected_clientid = v
				i = ii
			}
			46 {
				res.has_rt_store_asset_mtime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rt_store_asset_mtime = v
				i = ii
			}
			47 {
				res.has_rt_custom_image_mtime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rt_custom_image_mtime = v
				i = ii
			}
			48 {
				res.has_optional_parent_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.optional_parent_app_id = v
				i = ii
			}
			49 {
				res.has_owner_account_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_account_id = v
				i = ii
			}
			50 {
				res.has_compat_mapping_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.compat_mapping_enabled = v
				i = ii
			}
			51 {
				res.has_compat_mapping_priority = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.compat_mapping_priority = v
				i = ii
			}
			52 {
				res.has_compat_mapping_tool_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.compat_mapping_tool_name = v
				i = ii
			}
			53 {
				res.has_review_score_with_bombs = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.review_score_with_bombs = v
				i = ii
			}
			54 {
				res.has_review_percentage_with_bombs = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.review_percentage_with_bombs = v
				i = ii
			}
			55 {
				res.has_review_score_without_bombs = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.review_score_without_bombs = v
				i = ii
			}
			56 {
				res.has_review_percentage_without_bombs = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.review_percentage_without_bombs = v
				i = ii
			}
			57 {
				res.has_library_id = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.library_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cappoverview() CAppOverview {
	return CAppOverview{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cappoverview(o CAppOverview, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cappoverview(buf []byte, tag_wiretype vproto.WireType) ?(int, CAppOverview) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cappoverview_unpack(v)?
	return i, unpacked
}

pub struct CAppOverviewChange {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_overview   []CAppOverview
	removed_appid  []u32
}

pub fn (o &CAppOverviewChange) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.app_overview {
		res << zzz_vproto_internal_pack_cappoverview(x, 1)
	}
	// [packed=false]
	for _, x in o.removed_appid {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cappoverviewchange_unpack(buf []byte) ?CAppOverviewChange {
	mut res := CAppOverviewChange{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cappoverview(cur_buf, tag_wiretype.wire_type)?
				res.app_overview << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.removed_appid << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cappoverviewchange() CAppOverviewChange {
	return CAppOverviewChange{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cappoverviewchange(o CAppOverviewChange, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cappoverviewchange(buf []byte, tag_wiretype vproto.WireType) ?(int, CAppOverviewChange) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cappoverviewchange_unpack(v)?
	return i, unpacked
}

pub struct CAppBootstrapData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	hidden         bool
	has_hidden     bool
	user_tag       []string
}

pub fn (o &CAppBootstrapData) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_hidden {
		res << vproto.pack_bool_field(o.hidden, 2)
	}
	// [packed=false]
	for _, x in o.user_tag {
		res << vproto.pack_string_field(x, 3)
	}
	return res
}

pub fn cappbootstrapdata_unpack(buf []byte) ?CAppBootstrapData {
	mut res := CAppBootstrapData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_hidden = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hidden = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.user_tag << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cappbootstrapdata() CAppBootstrapData {
	return CAppBootstrapData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cappbootstrapdata(o CAppBootstrapData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cappbootstrapdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CAppBootstrapData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cappbootstrapdata_unpack(v)?
	return i, unpacked
}

pub struct CLibraryBootstrapData {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_data       []CAppBootstrapData
}

pub fn (o &CLibraryBootstrapData) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.app_data {
		res << zzz_vproto_internal_pack_cappbootstrapdata(x, 1)
	}
	return res
}

pub fn clibrarybootstrapdata_unpack(buf []byte) ?CLibraryBootstrapData {
	mut res := CLibraryBootstrapData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cappbootstrapdata(cur_buf, tag_wiretype.wire_type)?
				res.app_data << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_clibrarybootstrapdata() CLibraryBootstrapData {
	return CLibraryBootstrapData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_clibrarybootstrapdata(o CLibraryBootstrapData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_clibrarybootstrapdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CLibraryBootstrapData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := clibrarybootstrapdata_unpack(v)?
	return i, unpacked
}
