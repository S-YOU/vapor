
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


pub struct CMsgSteamDatagramRelayAuthTicketExtraField {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
has_name bool
string_value string
has_string_value bool
int64_value i64
has_int64_value bool
fixed64_value u64
has_fixed64_value bool
}
pub fn (o &CMsgSteamDatagramRelayAuthTicketExtraField) pack() []byte {
mut res := []byte{}
if o.has_name {
res << vproto.pack_string_field(o.name, 1)
}

if o.has_string_value {
res << vproto.pack_string_field(o.string_value, 2)
}

if o.has_int64_value {
res << vproto.pack_sint64_field(o.int64_value, 3)
}

if o.has_fixed64_value {
res << vproto.pack_64bit_field(o.fixed64_value, 5)
}

return res
}

pub fn cmsgsteamdatagramrelayauthticketextrafield_unpack(buf []byte) ?CMsgSteamDatagramRelayAuthTicketExtraField {
mut res := CMsgSteamDatagramRelayAuthTicketExtraField{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

2 {
res.has_string_value = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.string_value = v
i = ii
}

3 {
res.has_int64_value = true
ii, v := vproto.unpack_sint64_field(cur_buf, tag_wiretype.wire_type)?
res.int64_value = v
i = ii
}

5 {
res.has_fixed64_value = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.fixed64_value = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrelayauthticketextrafield() CMsgSteamDatagramRelayAuthTicketExtraField {
return CMsgSteamDatagramRelayAuthTicketExtraField{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrelayauthticketextrafield(o CMsgSteamDatagramRelayAuthTicketExtraField, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrelayauthticketextrafield(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRelayAuthTicketExtraField) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramrelayauthticketextrafield_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramRelayAuthTicket {
mut:
unknown_fields []vproto.UnknownField
pub mut:
time_expiry u32
has_time_expiry bool
authorized_client_identity_string string
has_authorized_client_identity_string bool
gameserver_identity_string string
has_gameserver_identity_string bool
authorized_public_ip u32
has_authorized_public_ip bool
gameserver_address []byte
has_gameserver_address bool
app_id u32
has_app_id bool
virtual_port u32
has_virtual_port bool
extra_fields []CMsgSteamDatagramRelayAuthTicketExtraField
legacy_authorized_steam_id u64
has_legacy_authorized_steam_id bool
legacy_gameserver_steam_id u64
has_legacy_gameserver_steam_id bool
legacy_gameserver_net_id u64
has_legacy_gameserver_net_id bool
legacy_gameserver_pop_id u32
has_legacy_gameserver_pop_id bool
legacy_authorized_client_identity_binary []byte
has_legacy_authorized_client_identity_binary bool
legacy_gameserver_identity_binary []byte
has_legacy_gameserver_identity_binary bool
}
pub fn (o &CMsgSteamDatagramRelayAuthTicket) pack() []byte {
mut res := []byte{}
if o.has_time_expiry {
res << vproto.pack_32bit_field(o.time_expiry, 1)
}

if o.has_authorized_client_identity_string {
res << vproto.pack_string_field(o.authorized_client_identity_string, 14)
}

if o.has_gameserver_identity_string {
res << vproto.pack_string_field(o.gameserver_identity_string, 15)
}

if o.has_authorized_public_ip {
res << vproto.pack_32bit_field(o.authorized_public_ip, 3)
}

if o.has_gameserver_address {
res << vproto.pack_bytes_field(o.gameserver_address, 11)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 7)
}

if o.has_virtual_port {
res << vproto.pack_uint32_field(o.virtual_port, 10)
}

// [packed=false]
for _, x in o.extra_fields {
res << zzz_vproto_internal_pack_cmsgsteamdatagramrelayauthticketextrafield(x, 8)
}

if o.has_legacy_authorized_steam_id {
res << vproto.pack_64bit_field(o.legacy_authorized_steam_id, 2)
}

if o.has_legacy_gameserver_steam_id {
res << vproto.pack_64bit_field(o.legacy_gameserver_steam_id, 4)
}

if o.has_legacy_gameserver_net_id {
res << vproto.pack_64bit_field(o.legacy_gameserver_net_id, 5)
}

if o.has_legacy_gameserver_pop_id {
res << vproto.pack_32bit_field(o.legacy_gameserver_pop_id, 9)
}

if o.has_legacy_authorized_client_identity_binary {
res << vproto.pack_bytes_field(o.legacy_authorized_client_identity_binary, 12)
}

if o.has_legacy_gameserver_identity_binary {
res << vproto.pack_bytes_field(o.legacy_gameserver_identity_binary, 13)
}

return res
}

pub fn cmsgsteamdatagramrelayauthticket_unpack(buf []byte) ?CMsgSteamDatagramRelayAuthTicket {
mut res := CMsgSteamDatagramRelayAuthTicket{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_time_expiry = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.time_expiry = v
i = ii
}

14 {
res.has_authorized_client_identity_string = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.authorized_client_identity_string = v
i = ii
}

15 {
res.has_gameserver_identity_string = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.gameserver_identity_string = v
i = ii
}

3 {
res.has_authorized_public_ip = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.authorized_public_ip = v
i = ii
}

11 {
res.has_gameserver_address = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.gameserver_address = v
i = ii
}

7 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

10 {
res.has_virtual_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.virtual_port = v
i = ii
}

8 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramrelayauthticketextrafield(cur_buf, tag_wiretype.wire_type)?
res.extra_fields << v
i = ii
}

2 {
res.has_legacy_authorized_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_authorized_steam_id = v
i = ii
}

4 {
res.has_legacy_gameserver_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_gameserver_steam_id = v
i = ii
}

5 {
res.has_legacy_gameserver_net_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_gameserver_net_id = v
i = ii
}

9 {
res.has_legacy_gameserver_pop_id = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_gameserver_pop_id = v
i = ii
}

12 {
res.has_legacy_authorized_client_identity_binary = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_authorized_client_identity_binary = v
i = ii
}

13 {
res.has_legacy_gameserver_identity_binary = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_gameserver_identity_binary = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramrelayauthticket() CMsgSteamDatagramRelayAuthTicket {
return CMsgSteamDatagramRelayAuthTicket{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramrelayauthticket(o CMsgSteamDatagramRelayAuthTicket, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramrelayauthticket(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramRelayAuthTicket) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramrelayauthticket_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramSignedRelayAuthTicket {
mut:
unknown_fields []vproto.UnknownField
pub mut:
reserved_do_not_use u64
has_reserved_do_not_use bool
key_id u64
has_key_id bool
ticket []byte
has_ticket bool
signature []byte
has_signature bool
}
pub fn (o &CMsgSteamDatagramSignedRelayAuthTicket) pack() []byte {
mut res := []byte{}
if o.has_reserved_do_not_use {
res << vproto.pack_64bit_field(o.reserved_do_not_use, 1)
}

if o.has_key_id {
res << vproto.pack_64bit_field(o.key_id, 2)
}

if o.has_ticket {
res << vproto.pack_bytes_field(o.ticket, 3)
}

if o.has_signature {
res << vproto.pack_bytes_field(o.signature, 4)
}

return res
}

pub fn cmsgsteamdatagramsignedrelayauthticket_unpack(buf []byte) ?CMsgSteamDatagramSignedRelayAuthTicket {
mut res := CMsgSteamDatagramSignedRelayAuthTicket{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_reserved_do_not_use = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.reserved_do_not_use = v
i = ii
}

2 {
res.has_key_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.key_id = v
i = ii
}

3 {
res.has_ticket = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.ticket = v
i = ii
}

4 {
res.has_signature = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.signature = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramsignedrelayauthticket() CMsgSteamDatagramSignedRelayAuthTicket {
return CMsgSteamDatagramSignedRelayAuthTicket{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramsignedrelayauthticket(o CMsgSteamDatagramSignedRelayAuthTicket, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramsignedrelayauthticket(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramSignedRelayAuthTicket) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramsignedrelayauthticket_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramCachedCredentialsForApp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
private_key []byte
has_private_key bool
cert []byte
has_cert bool
relay_tickets [][]byte
}
pub fn (o &CMsgSteamDatagramCachedCredentialsForApp) pack() []byte {
mut res := []byte{}
if o.has_private_key {
res << vproto.pack_bytes_field(o.private_key, 1)
}

if o.has_cert {
res << vproto.pack_bytes_field(o.cert, 2)
}

// [packed=false]
for _, x in o.relay_tickets {
res << vproto.pack_bytes_field(x, 3)
}

return res
}

pub fn cmsgsteamdatagramcachedcredentialsforapp_unpack(buf []byte) ?CMsgSteamDatagramCachedCredentialsForApp {
mut res := CMsgSteamDatagramCachedCredentialsForApp{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_private_key = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.private_key = v
i = ii
}

2 {
res.has_cert = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.cert = v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.relay_tickets << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramcachedcredentialsforapp() CMsgSteamDatagramCachedCredentialsForApp {
return CMsgSteamDatagramCachedCredentialsForApp{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramcachedcredentialsforapp(o CMsgSteamDatagramCachedCredentialsForApp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramcachedcredentialsforapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramCachedCredentialsForApp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramcachedcredentialsforapp_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramGameCoordinatorServerLogin {
mut:
unknown_fields []vproto.UnknownField
pub mut:
time_generated u32
has_time_generated bool
appid u32
has_appid bool
routing []byte
has_routing bool
appdata []byte
has_appdata bool
legacy_identity_binary []byte
has_legacy_identity_binary bool
identity_string string
has_identity_string bool
dummy_steam_id u64
has_dummy_steam_id bool
}
pub fn (o &CMsgSteamDatagramGameCoordinatorServerLogin) pack() []byte {
mut res := []byte{}
if o.has_time_generated {
res << vproto.pack_uint32_field(o.time_generated, 1)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 2)
}

if o.has_routing {
res << vproto.pack_bytes_field(o.routing, 3)
}

if o.has_appdata {
res << vproto.pack_bytes_field(o.appdata, 4)
}

if o.has_legacy_identity_binary {
res << vproto.pack_bytes_field(o.legacy_identity_binary, 5)
}

if o.has_identity_string {
res << vproto.pack_string_field(o.identity_string, 6)
}

if o.has_dummy_steam_id {
res << vproto.pack_64bit_field(o.dummy_steam_id, 99)
}

return res
}

pub fn cmsgsteamdatagramgamecoordinatorserverlogin_unpack(buf []byte) ?CMsgSteamDatagramGameCoordinatorServerLogin {
mut res := CMsgSteamDatagramGameCoordinatorServerLogin{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_time_generated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_generated = v
i = ii
}

2 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

3 {
res.has_routing = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.routing = v
i = ii
}

4 {
res.has_appdata = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.appdata = v
i = ii
}

5 {
res.has_legacy_identity_binary = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.legacy_identity_binary = v
i = ii
}

6 {
res.has_identity_string = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.identity_string = v
i = ii
}

99 {
res.has_dummy_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.dummy_steam_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramgamecoordinatorserverlogin() CMsgSteamDatagramGameCoordinatorServerLogin {
return CMsgSteamDatagramGameCoordinatorServerLogin{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramgamecoordinatorserverlogin(o CMsgSteamDatagramGameCoordinatorServerLogin, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramgamecoordinatorserverlogin(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramGameCoordinatorServerLogin) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramgamecoordinatorserverlogin_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramSignedGameCoordinatorServerLogin {
mut:
unknown_fields []vproto.UnknownField
pub mut:
cert CMsgSteamDatagramCertificateSigned
has_cert bool
login []byte
has_login bool
signature []byte
has_signature bool
}
pub fn (o &CMsgSteamDatagramSignedGameCoordinatorServerLogin) pack() []byte {
mut res := []byte{}
if o.has_cert {
res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 1)
}

if o.has_login {
res << vproto.pack_bytes_field(o.login, 2)
}

if o.has_signature {
res << vproto.pack_bytes_field(o.signature, 3)
}

return res
}

pub fn cmsgsteamdatagramsignedgamecoordinatorserverlogin_unpack(buf []byte) ?CMsgSteamDatagramSignedGameCoordinatorServerLogin {
mut res := CMsgSteamDatagramSignedGameCoordinatorServerLogin{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_cert = true
ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf, tag_wiretype.wire_type)?
res.cert = v
i = ii
}

2 {
res.has_login = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.login = v
i = ii
}

3 {
res.has_signature = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.signature = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramsignedgamecoordinatorserverlogin() CMsgSteamDatagramSignedGameCoordinatorServerLogin {
return CMsgSteamDatagramSignedGameCoordinatorServerLogin{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramsignedgamecoordinatorserverlogin(o CMsgSteamDatagramSignedGameCoordinatorServerLogin, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramsignedgamecoordinatorserverlogin(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramSignedGameCoordinatorServerLogin) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramsignedgamecoordinatorserverlogin_unpack(v)?
return i, unpacked
}
pub struct CMsgSteamDatagramHostedServerAddressPlaintext {
mut:
unknown_fields []vproto.UnknownField
pub mut:
ipv4 u32
has_ipv4 bool
ipv6 []byte
has_ipv6 bool
port u32
has_port bool
routing_secret u64
has_routing_secret bool
}
pub fn (o &CMsgSteamDatagramHostedServerAddressPlaintext) pack() []byte {
mut res := []byte{}
if o.has_ipv4 {
res << vproto.pack_32bit_field(o.ipv4, 1)
}

if o.has_ipv6 {
res << vproto.pack_bytes_field(o.ipv6, 2)
}

if o.has_port {
res << vproto.pack_uint32_field(o.port, 3)
}

if o.has_routing_secret {
res << vproto.pack_64bit_field(o.routing_secret, 4)
}

return res
}

pub fn cmsgsteamdatagramhostedserveraddressplaintext_unpack(buf []byte) ?CMsgSteamDatagramHostedServerAddressPlaintext {
mut res := CMsgSteamDatagramHostedServerAddressPlaintext{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_ipv4 = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.ipv4 = v
i = ii
}

2 {
res.has_ipv6 = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.ipv6 = v
i = ii
}

3 {
res.has_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.port = v
i = ii
}

4 {
res.has_routing_secret = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.routing_secret = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramhostedserveraddressplaintext() CMsgSteamDatagramHostedServerAddressPlaintext {
return CMsgSteamDatagramHostedServerAddressPlaintext{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramhostedserveraddressplaintext(o CMsgSteamDatagramHostedServerAddressPlaintext, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramhostedserveraddressplaintext(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramHostedServerAddressPlaintext) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgsteamdatagramhostedserveraddressplaintext_unpack(v)?
return i, unpacked
}
