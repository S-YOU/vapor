// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum ERemoteClientBroadcastMsg {
	k_eremoteclientbroadcastmsgdiscovery = 0
	k_eremoteclientbroadcastmsgstatus = 1
	k_eremoteclientbroadcastmsgoffline = 2
	k_eremotedeviceauthorizationrequest = 3
	k_eremotedeviceauthorizationresponse = 4
	k_eremotedevicestreamingrequest = 5
	k_eremotedevicestreamingresponse = 6
	k_eremotedeviceproofrequest = 7
	k_eremotedeviceproofresponse = 8
	k_eremotedeviceauthorizationcancelrequest = 9
	k_eremotedevicestreamingcancelrequest = 10
	k_eremoteclientbroadcastmsgclientiddeconflict = 11
	k_eremotedevicestreamtransportsignal = 12
	k_eremotedevicestreamingprogress = 13
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eremoteclientbroadcastmsg(e ERemoteClientBroadcastMsg, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eremoteclientbroadcastmsg_packed(e []ERemoteClientBroadcastMsg, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eremoteclientbroadcastmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, ERemoteClientBroadcastMsg) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, ERemoteClientBroadcastMsg(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eremoteclientbroadcastmsg_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []ERemoteClientBroadcastMsg) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum ERemoteClientService {
	k_eremoteclientservicenone = 0
	k_eremoteclientserviceremotecontrol = 1
	k_eremoteclientservicegamestreaming = 2
	k_eremoteclientservicesitelicense = 4
	k_eremoteclientservicecontentcache = 8
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eremoteclientservice(e ERemoteClientService, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eremoteclientservice_packed(e []ERemoteClientService, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eremoteclientservice(buf []byte, tag_wiretype vproto.WireType) ?(int, ERemoteClientService) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, ERemoteClientService(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eremoteclientservice_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []ERemoteClientService) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum ERemoteDeviceAuthorizationResult {
	k_eremotedeviceauthorizationsuccess = 0
	k_eremotedeviceauthorizationdenied = 1
	k_eremotedeviceauthorizationnotloggedin = 2
	k_eremotedeviceauthorizationoffline = 3
	k_eremotedeviceauthorizationbusy = 4
	k_eremotedeviceauthorizationinprogress = 5
	k_eremotedeviceauthorizationtimedout = 6
	k_eremotedeviceauthorizationfailed = 7
	k_eremotedeviceauthorizationcanceled = 8
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eremotedeviceauthorizationresult(e ERemoteDeviceAuthorizationResult, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eremotedeviceauthorizationresult_packed(e []ERemoteDeviceAuthorizationResult, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eremotedeviceauthorizationresult(buf []byte, tag_wiretype vproto.WireType) ?(int, ERemoteDeviceAuthorizationResult) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, ERemoteDeviceAuthorizationResult(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eremotedeviceauthorizationresult_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []ERemoteDeviceAuthorizationResult) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamDeviceFormFactor {
	k_estreamdeviceformfactorunknown = 0
	k_estreamdeviceformfactorphone = 1
	k_estreamdeviceformfactortablet = 2
	k_estreamdeviceformfactorcomputer = 3
	k_estreamdeviceformfactortv = 4
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamdeviceformfactor(e EStreamDeviceFormFactor, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamdeviceformfactor_packed(e []EStreamDeviceFormFactor, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamdeviceformfactor(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamDeviceFormFactor) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamDeviceFormFactor(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamdeviceformfactor_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamDeviceFormFactor) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamTransport {
	k_estreamtransportnone = 0
	k_estreamtransportudp = 1
	k_estreamtransportudprelay = 2
	k_estreamtransportwebrtc = 3
	k_estreamtransportsdr = 4
	k_estreamtransportudp_sns = 5
	k_estreamtransportudprelay_sns = 6
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamtransport(e EStreamTransport, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamtransport_packed(e []EStreamTransport, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamtransport(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamTransport) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamTransport(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamtransport_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamTransport) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamInterface {
	k_estreaminterfacedefault = 0
	k_estreaminterfacerecentgames = 1
	k_estreaminterfacebigpicture = 2
	k_estreaminterfacedesktop = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreaminterface(e EStreamInterface, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreaminterface_packed(e []EStreamInterface, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreaminterface(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamInterface) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamInterface(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreaminterface_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamInterface) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum ERemoteDeviceStreamingResult {
	k_eremotedevicestreamingsuccess = 0
	k_eremotedevicestreamingunauthorized = 1
	k_eremotedevicestreamingscreenlocked = 2
	k_eremotedevicestreamingfailed = 3
	k_eremotedevicestreamingbusy = 4
	k_eremotedevicestreaminginprogress = 5
	k_eremotedevicestreamingcanceled = 6
	k_eremotedevicestreamingdriversnotinstalled = 7
	k_eremotedevicestreamingdisabled = 8
	k_eremotedevicestreamingbroadcastingactive = 9
	k_eremotedevicestreamingvractive = 10
	k_eremotedevicestreamingpinrequired = 11
	k_eremotedevicestreamingtransportunavailable = 12
	k_eremotedevicestreaminginvisible = 13
	k_eremotedevicestreaminggamelaunchfailed = 14
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eremotedevicestreamingresult(e ERemoteDeviceStreamingResult, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eremotedevicestreamingresult_packed(e []ERemoteDeviceStreamingResult, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eremotedevicestreamingresult(buf []byte, tag_wiretype vproto.WireType) ?(int, ERemoteDeviceStreamingResult) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, ERemoteDeviceStreamingResult(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eremotedevicestreamingresult_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []ERemoteDeviceStreamingResult) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgRemoteClientBroadcastHeader {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	client_id        u64
	has_client_id    bool
	msg_type         ERemoteClientBroadcastMsg
	has_msg_type     bool
	instance_id      u64
	has_instance_id  bool
	device_id        u64
	has_device_id    bool
	device_token     []byte
	has_device_token bool
}

pub fn (o &CMsgRemoteClientBroadcastHeader) pack() []byte {
	mut res := []byte{}
	if o.has_client_id {
		res << vproto.pack_uint64_field(o.client_id, 1)
	}
	if o.has_msg_type {
		res << zzz_vproto_internal_pack_eremoteclientbroadcastmsg(o.msg_type, 2)
	}
	if o.has_instance_id {
		res << vproto.pack_uint64_field(o.instance_id, 3)
	}
	if o.has_device_id {
		res << vproto.pack_uint64_field(o.device_id, 4)
	}
	if o.has_device_token {
		res << vproto.pack_bytes_field(o.device_token, 5)
	}
	return res
}

pub fn cmsgremoteclientbroadcastheader_unpack(buf []byte) ?CMsgRemoteClientBroadcastHeader {
	mut res := CMsgRemoteClientBroadcastHeader{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_client_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.client_id = v
				i = ii
			}
			2 {
				res.has_msg_type = true
				ii, v := zzz_vproto_internal_unpack_eremoteclientbroadcastmsg(cur_buf,
					tag_wiretype.wire_type)?
				res.msg_type = v
				i = ii
			}
			3 {
				res.has_instance_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.instance_id = v
				i = ii
			}
			4 {
				res.has_device_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.device_id = v
				i = ii
			}
			5 {
				res.has_device_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.device_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremoteclientbroadcastheader() CMsgRemoteClientBroadcastHeader {
	return CMsgRemoteClientBroadcastHeader{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremoteclientbroadcastheader(o CMsgRemoteClientBroadcastHeader, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremoteclientbroadcastheader(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientBroadcastHeader) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremoteclientbroadcastheader_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteClientBroadcastStatus_User {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	steamid         u64
	has_steamid     bool
	auth_key_id     u32
	has_auth_key_id bool
}

pub fn (o &CMsgRemoteClientBroadcastStatus_User) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_auth_key_id {
		res << vproto.pack_uint32_field(o.auth_key_id, 2)
	}
	return res
}

pub fn cmsgremoteclientbroadcaststatus_user_unpack(buf []byte) ?CMsgRemoteClientBroadcastStatus_User {
	mut res := CMsgRemoteClientBroadcastStatus_User{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_auth_key_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_key_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremoteclientbroadcaststatus_user() CMsgRemoteClientBroadcastStatus_User {
	return CMsgRemoteClientBroadcastStatus_User{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremoteclientbroadcaststatus_user(o CMsgRemoteClientBroadcastStatus_User, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremoteclientbroadcaststatus_user(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientBroadcastStatus_User) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremoteclientbroadcaststatus_user_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteClientBroadcastStatus {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	version                     int
	has_version                 bool
	min_version                 int
	has_min_version             bool
	connect_port                u32
	has_connect_port            bool
	hostname                    string
	has_hostname                bool
	enabled_services            u32
	has_enabled_services        bool
	ostype                      int
	has_ostype                  bool
	is64bit                     bool
	has_is64bit                 bool
	users                       []CMsgRemoteClientBroadcastStatus_User
	euniverse                   int
	has_euniverse               bool
	timestamp                   u32
	has_timestamp               bool
	screen_locked               bool
	has_screen_locked           bool
	games_running               bool
	has_games_running           bool
	mac_addresses               []string
	download_lan_peer_group     u32
	has_download_lan_peer_group bool
	broadcasting_active         bool
	has_broadcasting_active     bool
	vr_active                   bool
	has_vr_active               bool
	content_cache_port          u32
	has_content_cache_port      bool
	ip_addresses                []string
	public_ip_address           string
	has_public_ip_address       bool
	remoteplay_active           bool
	has_remoteplay_active       bool
}

pub fn (o &CMsgRemoteClientBroadcastStatus) pack() []byte {
	mut res := []byte{}
	if o.has_version {
		res << vproto.pack_int32_field(o.version, 1)
	}
	if o.has_min_version {
		res << vproto.pack_int32_field(o.min_version, 2)
	}
	if o.has_connect_port {
		res << vproto.pack_uint32_field(o.connect_port, 3)
	}
	if o.has_hostname {
		res << vproto.pack_string_field(o.hostname, 4)
	}
	if o.has_enabled_services {
		res << vproto.pack_uint32_field(o.enabled_services, 6)
	}
	if o.has_ostype {
		res << vproto.pack_int32_field(o.ostype, 7)
	}
	if o.has_is64bit {
		res << vproto.pack_bool_field(o.is64bit, 8)
	}
	// [packed=false]
	for _, x in o.users {
		res << zzz_vproto_internal_pack_cmsgremoteclientbroadcaststatus_user(x, 9)
	}
	if o.has_euniverse {
		res << vproto.pack_int32_field(o.euniverse, 11)
	}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 12)
	}
	if o.has_screen_locked {
		res << vproto.pack_bool_field(o.screen_locked, 13)
	}
	if o.has_games_running {
		res << vproto.pack_bool_field(o.games_running, 14)
	}
	// [packed=false]
	for _, x in o.mac_addresses {
		res << vproto.pack_string_field(x, 15)
	}
	if o.has_download_lan_peer_group {
		res << vproto.pack_uint32_field(o.download_lan_peer_group, 16)
	}
	if o.has_broadcasting_active {
		res << vproto.pack_bool_field(o.broadcasting_active, 17)
	}
	if o.has_vr_active {
		res << vproto.pack_bool_field(o.vr_active, 18)
	}
	if o.has_content_cache_port {
		res << vproto.pack_uint32_field(o.content_cache_port, 19)
	}
	// [packed=false]
	for _, x in o.ip_addresses {
		res << vproto.pack_string_field(x, 20)
	}
	if o.has_public_ip_address {
		res << vproto.pack_string_field(o.public_ip_address, 21)
	}
	if o.has_remoteplay_active {
		res << vproto.pack_bool_field(o.remoteplay_active, 22)
	}
	return res
}

pub fn cmsgremoteclientbroadcaststatus_unpack(buf []byte) ?CMsgRemoteClientBroadcastStatus {
	mut res := CMsgRemoteClientBroadcastStatus{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_version = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.version = v
				i = ii
			}
			2 {
				res.has_min_version = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.min_version = v
				i = ii
			}
			3 {
				res.has_connect_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.connect_port = v
				i = ii
			}
			4 {
				res.has_hostname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.hostname = v
				i = ii
			}
			6 {
				res.has_enabled_services = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.enabled_services = v
				i = ii
			}
			7 {
				res.has_ostype = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ostype = v
				i = ii
			}
			8 {
				res.has_is64bit = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is64bit = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgremoteclientbroadcaststatus_user(cur_buf,
					tag_wiretype.wire_type)?
				res.users << v
				i = ii
			}
			11 {
				res.has_euniverse = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.euniverse = v
				i = ii
			}
			12 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			13 {
				res.has_screen_locked = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.screen_locked = v
				i = ii
			}
			14 {
				res.has_games_running = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.games_running = v
				i = ii
			}
			15 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.mac_addresses << v
				i = ii
			}
			16 {
				res.has_download_lan_peer_group = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.download_lan_peer_group = v
				i = ii
			}
			17 {
				res.has_broadcasting_active = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcasting_active = v
				i = ii
			}
			18 {
				res.has_vr_active = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.vr_active = v
				i = ii
			}
			19 {
				res.has_content_cache_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.content_cache_port = v
				i = ii
			}
			20 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.ip_addresses << v
				i = ii
			}
			21 {
				res.has_public_ip_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.public_ip_address = v
				i = ii
			}
			22 {
				res.has_remoteplay_active = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.remoteplay_active = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremoteclientbroadcaststatus() CMsgRemoteClientBroadcastStatus {
	return CMsgRemoteClientBroadcastStatus{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremoteclientbroadcaststatus(o CMsgRemoteClientBroadcastStatus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremoteclientbroadcaststatus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientBroadcastStatus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremoteclientbroadcaststatus_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteClientBroadcastDiscovery {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	seq_num        u32
	has_seq_num    bool
	client_ids     []u64
}

pub fn (o &CMsgRemoteClientBroadcastDiscovery) pack() []byte {
	mut res := []byte{}
	if o.has_seq_num {
		res << vproto.pack_uint32_field(o.seq_num, 1)
	}
	// [packed=false]
	for _, x in o.client_ids {
		res << vproto.pack_uint64_field(x, 2)
	}
	return res
}

pub fn cmsgremoteclientbroadcastdiscovery_unpack(buf []byte) ?CMsgRemoteClientBroadcastDiscovery {
	mut res := CMsgRemoteClientBroadcastDiscovery{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_seq_num = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.client_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremoteclientbroadcastdiscovery() CMsgRemoteClientBroadcastDiscovery {
	return CMsgRemoteClientBroadcastDiscovery{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremoteclientbroadcastdiscovery(o CMsgRemoteClientBroadcastDiscovery, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremoteclientbroadcastdiscovery(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientBroadcastDiscovery) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremoteclientbroadcastdiscovery_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteClientBroadcastClientIDDeconflict {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	client_ids     []u64
}

pub fn (o &CMsgRemoteClientBroadcastClientIDDeconflict) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.client_ids {
		res << vproto.pack_uint64_field(x, 2)
	}
	return res
}

pub fn cmsgremoteclientbroadcastclientiddeconflict_unpack(buf []byte) ?CMsgRemoteClientBroadcastClientIDDeconflict {
	mut res := CMsgRemoteClientBroadcastClientIDDeconflict{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.client_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremoteclientbroadcastclientiddeconflict() CMsgRemoteClientBroadcastClientIDDeconflict {
	return CMsgRemoteClientBroadcastClientIDDeconflict{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremoteclientbroadcastclientiddeconflict(o CMsgRemoteClientBroadcastClientIDDeconflict, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremoteclientbroadcastclientiddeconflict(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteClientBroadcastClientIDDeconflict) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremoteclientbroadcastclientiddeconflict_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	password                   []byte
	has_password               bool
	identifier                 u64
	has_identifier             bool
	payload                    []byte
	has_payload                bool
	timestamp                  u32
	has_timestamp              bool
	usage                      CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage
	has_usage                  bool
	device_name                string
	has_device_name            bool
	device_model               string
	has_device_model           bool
	device_serial              string
	has_device_serial          bool
	device_provisioning_id     u32
	has_device_provisioning_id bool
}

pub fn (o &CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket) pack() []byte {
	mut res := []byte{}
	if o.has_password {
		res << vproto.pack_bytes_field(o.password, 1)
	}
	if o.has_identifier {
		res << vproto.pack_uint64_field(o.identifier, 2)
	}
	if o.has_payload {
		res << vproto.pack_bytes_field(o.payload, 3)
	}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 4)
	}
	if o.has_usage {
		res <<
			zzz_vproto_internal_pack_cmsgremotedeviceauthorizationrequest_ekeyescrowusage(o.usage, 5)
	}
	if o.has_device_name {
		res << vproto.pack_string_field(o.device_name, 6)
	}
	if o.has_device_model {
		res << vproto.pack_string_field(o.device_model, 7)
	}
	if o.has_device_serial {
		res << vproto.pack_string_field(o.device_serial, 8)
	}
	if o.has_device_provisioning_id {
		res << vproto.pack_uint32_field(o.device_provisioning_id, 9)
	}
	return res
}

pub fn cmsgremotedeviceauthorizationrequest_ckeyescrow_ticket_unpack(buf []byte) ?CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
	mut res := CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_password = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.password = v
				i = ii
			}
			2 {
				res.has_identifier = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.identifier = v
				i = ii
			}
			3 {
				res.has_payload = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.payload = v
				i = ii
			}
			4 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			5 {
				res.has_usage = true
				ii, v := zzz_vproto_internal_unpack_cmsgremotedeviceauthorizationrequest_ekeyescrowusage(cur_buf,
					tag_wiretype.wire_type)?
				res.usage = v
				i = ii
			}
			6 {
				res.has_device_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_name = v
				i = ii
			}
			7 {
				res.has_device_model = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_model = v
				i = ii
			}
			8 {
				res.has_device_serial = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_serial = v
				i = ii
			}
			9 {
				res.has_device_provisioning_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device_provisioning_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremotedeviceauthorizationrequest_ckeyescrow_ticket() CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket {
	return CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremotedeviceauthorizationrequest_ckeyescrow_ticket(o CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremotedeviceauthorizationrequest_ckeyescrow_ticket(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremotedeviceauthorizationrequest_ckeyescrow_ticket_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage {
	k_ekeyescrowusagestreamingdevice = 0
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgremotedeviceauthorizationrequest_ekeyescrowusage(e CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgremotedeviceauthorizationrequest_ekeyescrowusage_packed(e []CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgremotedeviceauthorizationrequest_ekeyescrowusage(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgremotedeviceauthorizationrequest_ekeyescrowusage_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgRemoteDeviceAuthorizationRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	device_token      []byte
	device_name       string
	has_device_name   bool
	encrypted_request []byte
}

pub fn (o &CMsgRemoteDeviceAuthorizationRequest) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_bytes_field(o.device_token, 1)
	if o.has_device_name {
		res << vproto.pack_string_field(o.device_name, 2)
	}
	res << vproto.pack_bytes_field(o.encrypted_request, 3)
	return res
}

pub fn cmsgremotedeviceauthorizationrequest_unpack(buf []byte) ?CMsgRemoteDeviceAuthorizationRequest {
	mut res := CMsgRemoteDeviceAuthorizationRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.device_token = v
				i = ii
			}
			2 {
				res.has_device_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_name = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.encrypted_request = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremotedeviceauthorizationrequest() CMsgRemoteDeviceAuthorizationRequest {
	return CMsgRemoteDeviceAuthorizationRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremotedeviceauthorizationrequest(o CMsgRemoteDeviceAuthorizationRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremotedeviceauthorizationrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteDeviceAuthorizationRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremotedeviceauthorizationrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteDeviceAuthorizationCancelRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgRemoteDeviceAuthorizationCancelRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgremotedeviceauthorizationcancelrequest_unpack(buf []byte) ?CMsgRemoteDeviceAuthorizationCancelRequest {
	res := CMsgRemoteDeviceAuthorizationCancelRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremotedeviceauthorizationcancelrequest() CMsgRemoteDeviceAuthorizationCancelRequest {
	return CMsgRemoteDeviceAuthorizationCancelRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremotedeviceauthorizationcancelrequest(o CMsgRemoteDeviceAuthorizationCancelRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremotedeviceauthorizationcancelrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteDeviceAuthorizationCancelRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremotedeviceauthorizationcancelrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteDeviceAuthorizationResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         ERemoteDeviceAuthorizationResult
	steamid        u64
	has_steamid    bool
}

pub fn (o &CMsgRemoteDeviceAuthorizationResponse) pack() []byte {
	mut res := []byte{}
	res << zzz_vproto_internal_pack_eremotedeviceauthorizationresult(o.result, 1)
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	return res
}

pub fn cmsgremotedeviceauthorizationresponse_unpack(buf []byte) ?CMsgRemoteDeviceAuthorizationResponse {
	mut res := CMsgRemoteDeviceAuthorizationResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_eremotedeviceauthorizationresult(cur_buf,
					tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremotedeviceauthorizationresponse() CMsgRemoteDeviceAuthorizationResponse {
	return CMsgRemoteDeviceAuthorizationResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremotedeviceauthorizationresponse(o CMsgRemoteDeviceAuthorizationResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremotedeviceauthorizationresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteDeviceAuthorizationResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremotedeviceauthorizationresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	controller_type        u32
	has_controller_type    bool
	controller_subtype     u32
	has_controller_subtype bool
}

pub fn (o &CMsgRemoteDeviceStreamingRequest_ReservedGamepad) pack() []byte {
	mut res := []byte{}
	if o.has_controller_type {
		res << vproto.pack_uint32_field(o.controller_type, 1)
	}
	if o.has_controller_subtype {
		res << vproto.pack_uint32_field(o.controller_subtype, 2)
	}
	return res
}

pub fn cmsgremotedevicestreamingrequest_reservedgamepad_unpack(buf []byte) ?CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
	mut res := CMsgRemoteDeviceStreamingRequest_ReservedGamepad{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_controller_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_type = v
				i = ii
			}
			2 {
				res.has_controller_subtype = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_subtype = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremotedevicestreamingrequest_reservedgamepad() CMsgRemoteDeviceStreamingRequest_ReservedGamepad {
	return CMsgRemoteDeviceStreamingRequest_ReservedGamepad{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremotedevicestreamingrequest_reservedgamepad(o CMsgRemoteDeviceStreamingRequest_ReservedGamepad, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremotedevicestreamingrequest_reservedgamepad(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteDeviceStreamingRequest_ReservedGamepad) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremotedevicestreamingrequest_reservedgamepad_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteDeviceStreamingRequest {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	request_id                 u32
	maximum_resolution_x       int
	has_maximum_resolution_x   bool
	maximum_resolution_y       int
	has_maximum_resolution_y   bool
	audio_channel_count        int
	has_audio_channel_count    bool
	device_version             string
	has_device_version         bool
	stream_desktop             bool
	has_stream_desktop         bool
	device_token               []byte
	has_device_token           bool
	pin                        []byte
	has_pin                    bool
	enable_video_streaming     bool
	has_enable_video_streaming bool
	enable_audio_streaming     bool
	has_enable_audio_streaming bool
	enable_input_streaming     bool
	has_enable_input_streaming bool
	network_test               bool
	has_network_test           bool
	client_id                  u64
	has_client_id              bool
	supported_transport        []EStreamTransport
	restricted                 bool
	has_restricted             bool
	form_factor                EStreamDeviceFormFactor
	has_form_factor            bool
	gamepad_count              int
	has_gamepad_count          bool
	gamepads                   []CMsgRemoteDeviceStreamingRequest_ReservedGamepad
	gameid                     u64
	has_gameid                 bool
	stream_interface           EStreamInterface
	has_stream_interface       bool
}

pub fn (o &CMsgRemoteDeviceStreamingRequest) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint32_field(o.request_id, 1)
	if o.has_maximum_resolution_x {
		res << vproto.pack_int32_field(o.maximum_resolution_x, 2)
	}
	if o.has_maximum_resolution_y {
		res << vproto.pack_int32_field(o.maximum_resolution_y, 3)
	}
	if o.has_audio_channel_count {
		res << vproto.pack_int32_field(o.audio_channel_count, 4)
	}
	if o.has_device_version {
		res << vproto.pack_string_field(o.device_version, 5)
	}
	if o.has_stream_desktop {
		res << vproto.pack_bool_field(o.stream_desktop, 6)
	}
	if o.has_device_token {
		res << vproto.pack_bytes_field(o.device_token, 7)
	}
	if o.has_pin {
		res << vproto.pack_bytes_field(o.pin, 8)
	}
	if o.has_enable_video_streaming {
		res << vproto.pack_bool_field(o.enable_video_streaming, 9)
	}
	if o.has_enable_audio_streaming {
		res << vproto.pack_bool_field(o.enable_audio_streaming, 10)
	}
	if o.has_enable_input_streaming {
		res << vproto.pack_bool_field(o.enable_input_streaming, 11)
	}
	if o.has_network_test {
		res << vproto.pack_bool_field(o.network_test, 12)
	}
	if o.has_client_id {
		res << vproto.pack_uint64_field(o.client_id, 13)
	}
	// [packed=false]
	for _, x in o.supported_transport {
		res << zzz_vproto_internal_pack_estreamtransport(x, 14)
	}
	if o.has_restricted {
		res << vproto.pack_bool_field(o.restricted, 15)
	}
	if o.has_form_factor {
		res << zzz_vproto_internal_pack_estreamdeviceformfactor(o.form_factor, 16)
	}
	if o.has_gamepad_count {
		res << vproto.pack_int32_field(o.gamepad_count, 17)
	}
	// [packed=false]
	for _, x in o.gamepads {
		res << zzz_vproto_internal_pack_cmsgremotedevicestreamingrequest_reservedgamepad(x, 18)
	}
	if o.has_gameid {
		res << vproto.pack_uint64_field(o.gameid, 19)
	}
	if o.has_stream_interface {
		res << zzz_vproto_internal_pack_estreaminterface(o.stream_interface, 20)
	}
	return res
}

pub fn cmsgremotedevicestreamingrequest_unpack(buf []byte) ?CMsgRemoteDeviceStreamingRequest {
	mut res := CMsgRemoteDeviceStreamingRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.request_id = v
				i = ii
			}
			2 {
				res.has_maximum_resolution_x = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.maximum_resolution_x = v
				i = ii
			}
			3 {
				res.has_maximum_resolution_y = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.maximum_resolution_y = v
				i = ii
			}
			4 {
				res.has_audio_channel_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.audio_channel_count = v
				i = ii
			}
			5 {
				res.has_device_version = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_version = v
				i = ii
			}
			6 {
				res.has_stream_desktop = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.stream_desktop = v
				i = ii
			}
			7 {
				res.has_device_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.device_token = v
				i = ii
			}
			8 {
				res.has_pin = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.pin = v
				i = ii
			}
			9 {
				res.has_enable_video_streaming = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_video_streaming = v
				i = ii
			}
			10 {
				res.has_enable_audio_streaming = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_audio_streaming = v
				i = ii
			}
			11 {
				res.has_enable_input_streaming = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_input_streaming = v
				i = ii
			}
			12 {
				res.has_network_test = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.network_test = v
				i = ii
			}
			13 {
				res.has_client_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.client_id = v
				i = ii
			}
			14 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_estreamtransport(cur_buf, tag_wiretype.wire_type)?
				res.supported_transport << v
				i = ii
			}
			15 {
				res.has_restricted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.restricted = v
				i = ii
			}
			16 {
				res.has_form_factor = true
				ii, v := zzz_vproto_internal_unpack_estreamdeviceformfactor(cur_buf, tag_wiretype.wire_type)?
				res.form_factor = v
				i = ii
			}
			17 {
				res.has_gamepad_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.gamepad_count = v
				i = ii
			}
			18 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgremotedevicestreamingrequest_reservedgamepad(cur_buf,
					tag_wiretype.wire_type)?
				res.gamepads << v
				i = ii
			}
			19 {
				res.has_gameid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			20 {
				res.has_stream_interface = true
				ii, v := zzz_vproto_internal_unpack_estreaminterface(cur_buf, tag_wiretype.wire_type)?
				res.stream_interface = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremotedevicestreamingrequest() CMsgRemoteDeviceStreamingRequest {
	return CMsgRemoteDeviceStreamingRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremotedevicestreamingrequest(o CMsgRemoteDeviceStreamingRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremotedevicestreamingrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteDeviceStreamingRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremotedevicestreamingrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteDeviceStreamingCancelRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	request_id     u32
}

pub fn (o &CMsgRemoteDeviceStreamingCancelRequest) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint32_field(o.request_id, 1)
	return res
}

pub fn cmsgremotedevicestreamingcancelrequest_unpack(buf []byte) ?CMsgRemoteDeviceStreamingCancelRequest {
	mut res := CMsgRemoteDeviceStreamingCancelRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.request_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremotedevicestreamingcancelrequest() CMsgRemoteDeviceStreamingCancelRequest {
	return CMsgRemoteDeviceStreamingCancelRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremotedevicestreamingcancelrequest(o CMsgRemoteDeviceStreamingCancelRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremotedevicestreamingcancelrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteDeviceStreamingCancelRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremotedevicestreamingcancelrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteDeviceStreamingProgress {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	request_id     u32
	progress       f32
	has_progress   bool
}

pub fn (o &CMsgRemoteDeviceStreamingProgress) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint32_field(o.request_id, 1)
	if o.has_progress {
		res << vproto.pack_float_field(o.progress, 2)
	}
	return res
}

pub fn cmsgremotedevicestreamingprogress_unpack(buf []byte) ?CMsgRemoteDeviceStreamingProgress {
	mut res := CMsgRemoteDeviceStreamingProgress{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.request_id = v
				i = ii
			}
			2 {
				res.has_progress = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.progress = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremotedevicestreamingprogress() CMsgRemoteDeviceStreamingProgress {
	return CMsgRemoteDeviceStreamingProgress{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremotedevicestreamingprogress(o CMsgRemoteDeviceStreamingProgress, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremotedevicestreamingprogress(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteDeviceStreamingProgress) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremotedevicestreamingprogress_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteDeviceStreamingResponse {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	request_id                u32
	result                    ERemoteDeviceStreamingResult
	port                      u32
	has_port                  bool
	encrypted_session_key     []byte
	has_encrypted_session_key bool
	transport                 EStreamTransport
	has_transport             bool
	relay_server              string
	has_relay_server          bool
	cert                      string
	has_cert                  bool
}

pub fn (o &CMsgRemoteDeviceStreamingResponse) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint32_field(o.request_id, 1)
	res << zzz_vproto_internal_pack_eremotedevicestreamingresult(o.result, 2)
	if o.has_port {
		res << vproto.pack_uint32_field(o.port, 3)
	}
	if o.has_encrypted_session_key {
		res << vproto.pack_bytes_field(o.encrypted_session_key, 4)
	}
	if o.has_transport {
		res << zzz_vproto_internal_pack_estreamtransport(o.transport, 6)
	}
	if o.has_relay_server {
		res << vproto.pack_string_field(o.relay_server, 7)
	}
	if o.has_cert {
		res << vproto.pack_string_field(o.cert, 8)
	}
	return res
}

pub fn cmsgremotedevicestreamingresponse_unpack(buf []byte) ?CMsgRemoteDeviceStreamingResponse {
	mut res := CMsgRemoteDeviceStreamingResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.request_id = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_eremotedevicestreamingresult(cur_buf,
					tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			3 {
				res.has_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.port = v
				i = ii
			}
			4 {
				res.has_encrypted_session_key = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.encrypted_session_key = v
				i = ii
			}
			6 {
				res.has_transport = true
				ii, v := zzz_vproto_internal_unpack_estreamtransport(cur_buf, tag_wiretype.wire_type)?
				res.transport = v
				i = ii
			}
			7 {
				res.has_relay_server = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.relay_server = v
				i = ii
			}
			8 {
				res.has_cert = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cert = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremotedevicestreamingresponse() CMsgRemoteDeviceStreamingResponse {
	return CMsgRemoteDeviceStreamingResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremotedevicestreamingresponse(o CMsgRemoteDeviceStreamingResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremotedevicestreamingresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteDeviceStreamingResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremotedevicestreamingresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteDeviceProofRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	challenge      []byte
	request_id     u32
	has_request_id bool
}

pub fn (o &CMsgRemoteDeviceProofRequest) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_bytes_field(o.challenge, 1)
	if o.has_request_id {
		res << vproto.pack_uint32_field(o.request_id, 2)
	}
	return res
}

pub fn cmsgremotedeviceproofrequest_unpack(buf []byte) ?CMsgRemoteDeviceProofRequest {
	mut res := CMsgRemoteDeviceProofRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.challenge = v
				i = ii
			}
			2 {
				res.has_request_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.request_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremotedeviceproofrequest() CMsgRemoteDeviceProofRequest {
	return CMsgRemoteDeviceProofRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremotedeviceproofrequest(o CMsgRemoteDeviceProofRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremotedeviceproofrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteDeviceProofRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremotedeviceproofrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteDeviceProofResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	response       []byte
	request_id     u32
	has_request_id bool
}

pub fn (o &CMsgRemoteDeviceProofResponse) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_bytes_field(o.response, 1)
	if o.has_request_id {
		res << vproto.pack_uint32_field(o.request_id, 2)
	}
	return res
}

pub fn cmsgremotedeviceproofresponse_unpack(buf []byte) ?CMsgRemoteDeviceProofResponse {
	mut res := CMsgRemoteDeviceProofResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.response = v
				i = ii
			}
			2 {
				res.has_request_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.request_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremotedeviceproofresponse() CMsgRemoteDeviceProofResponse {
	return CMsgRemoteDeviceProofResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremotedeviceproofresponse(o CMsgRemoteDeviceProofResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremotedeviceproofresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteDeviceProofResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremotedeviceproofresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgRemoteDeviceStreamTransportSignal {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	token          []byte
	has_token      bool
	payload        []byte
	has_payload    bool
}

pub fn (o &CMsgRemoteDeviceStreamTransportSignal) pack() []byte {
	mut res := []byte{}
	if o.has_token {
		res << vproto.pack_bytes_field(o.token, 1)
	}
	if o.has_payload {
		res << vproto.pack_bytes_field(o.payload, 2)
	}
	return res
}

pub fn cmsgremotedevicestreamtransportsignal_unpack(buf []byte) ?CMsgRemoteDeviceStreamTransportSignal {
	mut res := CMsgRemoteDeviceStreamTransportSignal{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			2 {
				res.has_payload = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.payload = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgremotedevicestreamtransportsignal() CMsgRemoteDeviceStreamTransportSignal {
	return CMsgRemoteDeviceStreamTransportSignal{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgremotedevicestreamtransportsignal(o CMsgRemoteDeviceStreamTransportSignal, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgremotedevicestreamtransportsignal(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRemoteDeviceStreamTransportSignal) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgremotedevicestreamtransportsignal_unpack(v)?
	return i, unpacked
}
