// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CGameServersGetServerListRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	filter         string
	has_filter     bool
	limit          u32
	has_limit      bool
}

pub fn (o &CGameServersGetServerListRequest) pack() []byte {
	mut res := []byte{}
	if o.has_filter {
		res << vproto.pack_string_field(o.filter, 1)
	}
	if o.has_limit {
		res << vproto.pack_uint32_field(o.limit, 2)
	}
	return res
}

pub fn cgameserversgetserverlistrequest_unpack(buf []byte) ?CGameServersGetServerListRequest {
	mut res := CGameServersGetServerListRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_filter = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filter = v
				i = ii
			}
			2 {
				res.has_limit = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.limit = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgameserversgetserverlistrequest() CGameServersGetServerListRequest {
	return CGameServersGetServerListRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgameserversgetserverlistrequest(o CGameServersGetServerListRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgameserversgetserverlistrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameServersGetServerListRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgameserversgetserverlistrequest_unpack(v)?
	return i, unpacked
}

pub struct CGameServersGetServerListResponseServer {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	addr            string
	has_addr        bool
	gameport        u32
	has_gameport    bool
	specport        u32
	has_specport    bool
	steamid         u64
	has_steamid     bool
	name            string
	has_name        bool
	appid           u32
	has_appid       bool
	gamedir         string
	has_gamedir     bool
	version         string
	has_version     bool
	product         string
	has_product     bool
	region          int
	has_region      bool
	players         int
	has_players     bool
	max_players     int
	has_max_players bool
	bots            int
	has_bots        bool
	map             string
	has_map         bool
	secure          bool
	has_secure      bool
	dedicated       bool
	has_dedicated   bool
	os              string
	has_os          bool
	gametype        string
	has_gametype    bool
}

pub fn (o &CGameServersGetServerListResponseServer) pack() []byte {
	mut res := []byte{}
	if o.has_addr {
		res << vproto.pack_string_field(o.addr, 1)
	}
	if o.has_gameport {
		res << vproto.pack_uint32_field(o.gameport, 2)
	}
	if o.has_specport {
		res << vproto.pack_uint32_field(o.specport, 3)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 4)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 5)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 6)
	}
	if o.has_gamedir {
		res << vproto.pack_string_field(o.gamedir, 7)
	}
	if o.has_version {
		res << vproto.pack_string_field(o.version, 8)
	}
	if o.has_product {
		res << vproto.pack_string_field(o.product, 9)
	}
	if o.has_region {
		res << vproto.pack_int32_field(o.region, 10)
	}
	if o.has_players {
		res << vproto.pack_int32_field(o.players, 11)
	}
	if o.has_max_players {
		res << vproto.pack_int32_field(o.max_players, 12)
	}
	if o.has_bots {
		res << vproto.pack_int32_field(o.bots, 13)
	}
	if o.has_map {
		res << vproto.pack_string_field(o.map, 14)
	}
	if o.has_secure {
		res << vproto.pack_bool_field(o.secure, 15)
	}
	if o.has_dedicated {
		res << vproto.pack_bool_field(o.dedicated, 16)
	}
	if o.has_os {
		res << vproto.pack_string_field(o.os, 17)
	}
	if o.has_gametype {
		res << vproto.pack_string_field(o.gametype, 18)
	}
	return res
}

pub fn cgameserversgetserverlistresponseserver_unpack(buf []byte) ?CGameServersGetServerListResponseServer {
	mut res := CGameServersGetServerListResponseServer{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_addr = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.addr = v
				i = ii
			}
			2 {
				res.has_gameport = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.gameport = v
				i = ii
			}
			3 {
				res.has_specport = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.specport = v
				i = ii
			}
			4 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			5 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			6 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			7 {
				res.has_gamedir = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.gamedir = v
				i = ii
			}
			8 {
				res.has_version = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.version = v
				i = ii
			}
			9 {
				res.has_product = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.product = v
				i = ii
			}
			10 {
				res.has_region = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.region = v
				i = ii
			}
			11 {
				res.has_players = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.players = v
				i = ii
			}
			12 {
				res.has_max_players = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_players = v
				i = ii
			}
			13 {
				res.has_bots = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.bots = v
				i = ii
			}
			14 {
				res.has_map = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.map = v
				i = ii
			}
			15 {
				res.has_secure = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.secure = v
				i = ii
			}
			16 {
				res.has_dedicated = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.dedicated = v
				i = ii
			}
			17 {
				res.has_os = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.os = v
				i = ii
			}
			18 {
				res.has_gametype = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.gametype = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgameserversgetserverlistresponseserver() CGameServersGetServerListResponseServer {
	return CGameServersGetServerListResponseServer{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgameserversgetserverlistresponseserver(o CGameServersGetServerListResponseServer, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgameserversgetserverlistresponseserver(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameServersGetServerListResponseServer) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgameserversgetserverlistresponseserver_unpack(v)?
	return i, unpacked
}

pub struct CGameServersGetServerListResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	servers        []CGameServersGetServerListResponseServer
}

pub fn (o &CGameServersGetServerListResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.servers {
		res << zzz_vproto_internal_pack_cgameserversgetserverlistresponseserver(x, 1)
	}
	return res
}

pub fn cgameserversgetserverlistresponse_unpack(buf []byte) ?CGameServersGetServerListResponse {
	mut res := CGameServersGetServerListResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgameserversgetserverlistresponseserver(cur_buf,
					tag_wiretype.wire_type)?
				res.servers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgameserversgetserverlistresponse() CGameServersGetServerListResponse {
	return CGameServersGetServerListResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgameserversgetserverlistresponse(o CGameServersGetServerListResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgameserversgetserverlistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameServersGetServerListResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgameserversgetserverlistresponse_unpack(v)?
	return i, unpacked
}

pub struct CGameServersGetServerSteamIDsByIPrequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	server_ips     []string
}

pub fn (o &CGameServersGetServerSteamIDsByIPrequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.server_ips {
		res << vproto.pack_string_field(x, 1)
	}
	return res
}

pub fn cgameserversgetserversteamidsbyiprequest_unpack(buf []byte) ?CGameServersGetServerSteamIDsByIPrequest {
	mut res := CGameServersGetServerSteamIDsByIPrequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.server_ips << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgameserversgetserversteamidsbyiprequest() CGameServersGetServerSteamIDsByIPrequest {
	return CGameServersGetServerSteamIDsByIPrequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgameserversgetserversteamidsbyiprequest(o CGameServersGetServerSteamIDsByIPrequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgameserversgetserversteamidsbyiprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameServersGetServerSteamIDsByIPrequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgameserversgetserversteamidsbyiprequest_unpack(v)?
	return i, unpacked
}

pub struct CGameServersIPsWithSteamIDsResponseServer {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	addr           string
	has_addr       bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CGameServersIPsWithSteamIDsResponseServer) pack() []byte {
	mut res := []byte{}
	if o.has_addr {
		res << vproto.pack_string_field(o.addr, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	return res
}

pub fn cgameserversipswithsteamidsresponseserver_unpack(buf []byte) ?CGameServersIPsWithSteamIDsResponseServer {
	mut res := CGameServersIPsWithSteamIDsResponseServer{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_addr = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.addr = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgameserversipswithsteamidsresponseserver() CGameServersIPsWithSteamIDsResponseServer {
	return CGameServersIPsWithSteamIDsResponseServer{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgameserversipswithsteamidsresponseserver(o CGameServersIPsWithSteamIDsResponseServer, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgameserversipswithsteamidsresponseserver(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameServersIPsWithSteamIDsResponseServer) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgameserversipswithsteamidsresponseserver_unpack(v)?
	return i, unpacked
}

pub struct CGameServersIPsWithSteamIDsResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	servers        []CGameServersIPsWithSteamIDsResponseServer
}

pub fn (o &CGameServersIPsWithSteamIDsResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.servers {
		res << zzz_vproto_internal_pack_cgameserversipswithsteamidsresponseserver(x, 1)
	}
	return res
}

pub fn cgameserversipswithsteamidsresponse_unpack(buf []byte) ?CGameServersIPsWithSteamIDsResponse {
	mut res := CGameServersIPsWithSteamIDsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgameserversipswithsteamidsresponseserver(cur_buf,
					tag_wiretype.wire_type)?
				res.servers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgameserversipswithsteamidsresponse() CGameServersIPsWithSteamIDsResponse {
	return CGameServersIPsWithSteamIDsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgameserversipswithsteamidsresponse(o CGameServersIPsWithSteamIDsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgameserversipswithsteamidsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameServersIPsWithSteamIDsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgameserversipswithsteamidsresponse_unpack(v)?
	return i, unpacked
}

pub struct CGameServersGetServerIPsBySteamIDrequest {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	server_steamids []u64
}

pub fn (o &CGameServersGetServerIPsBySteamIDrequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.server_steamids {
		res << vproto.pack_64bit_field(x, 1)
	}
	return res
}

pub fn cgameserversgetserveripsbysteamidrequest_unpack(buf []byte) ?CGameServersGetServerIPsBySteamIDrequest {
	mut res := CGameServersGetServerIPsBySteamIDrequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.server_steamids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgameserversgetserveripsbysteamidrequest() CGameServersGetServerIPsBySteamIDrequest {
	return CGameServersGetServerIPsBySteamIDrequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgameserversgetserveripsbysteamidrequest(o CGameServersGetServerIPsBySteamIDrequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgameserversgetserveripsbysteamidrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameServersGetServerIPsBySteamIDrequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgameserversgetserveripsbysteamidrequest_unpack(v)?
	return i, unpacked
}
