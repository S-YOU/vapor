
// Generated by vproto - Do not modify
module protobuf

import emily33901.vproto


pub struct FileDescriptorSet {
mut:
unknown_fields []vproto.UnknownField
pub mut:
file []FileDescriptorProto
}
pub fn (o &FileDescriptorSet) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.file {
res << zzz_vproto_internal_pack_filedescriptorproto(x, 1)
}

return res
}

pub fn filedescriptorset_unpack(buf []byte) ?FileDescriptorSet {
mut res := FileDescriptorSet{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_filedescriptorproto(cur_buf, tag_wiretype.wire_type)?
res.file << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_filedescriptorset() FileDescriptorSet {
return FileDescriptorSet{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_filedescriptorset(o FileDescriptorSet, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_filedescriptorset(buf []byte, tag_wiretype vproto.WireType) ?(int, FileDescriptorSet) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := filedescriptorset_unpack(v)?
return i, unpacked
}
pub struct FileDescriptorProto {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
has_name bool
package string
has_package bool
dependency []string
public_dependency []int
weak_dependency []int
message_type []DescriptorProto
enum_type []EnumDescriptorProto
service []ServiceDescriptorProto
extension []FieldDescriptorProto
options FileOptions
has_options bool
source_code_info SourceCodeInfo
has_source_code_info bool
}
pub fn (o &FileDescriptorProto) pack() []byte {
mut res := []byte{}
if o.has_name {
res << vproto.pack_string_field(o.name, 1)
}

if o.has_package {
res << vproto.pack_string_field(o.package, 2)
}

// [packed=false]
for _, x in o.dependency {
res << vproto.pack_string_field(x, 3)
}

// [packed=false]
for _, x in o.public_dependency {
res << vproto.pack_int32_field(x, 10)
}

// [packed=false]
for _, x in o.weak_dependency {
res << vproto.pack_int32_field(x, 11)
}

// [packed=false]
for _, x in o.message_type {
res << zzz_vproto_internal_pack_descriptorproto(x, 4)
}

// [packed=false]
for _, x in o.enum_type {
res << zzz_vproto_internal_pack_enumdescriptorproto(x, 5)
}

// [packed=false]
for _, x in o.service {
res << zzz_vproto_internal_pack_servicedescriptorproto(x, 6)
}

// [packed=false]
for _, x in o.extension {
res << zzz_vproto_internal_pack_fielddescriptorproto(x, 7)
}

if o.has_options {
res << zzz_vproto_internal_pack_fileoptions(o.options, 8)
}

if o.has_source_code_info {
res << zzz_vproto_internal_pack_sourcecodeinfo(o.source_code_info, 9)
}

return res
}

pub fn filedescriptorproto_unpack(buf []byte) ?FileDescriptorProto {
mut res := FileDescriptorProto{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

2 {
res.has_package = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.package = v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.dependency << v
i = ii
}

10 {
// [packed=false]
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.public_dependency << v
i = ii
}

11 {
// [packed=false]
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.weak_dependency << v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_descriptorproto(cur_buf, tag_wiretype.wire_type)?
res.message_type << v
i = ii
}

5 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_enumdescriptorproto(cur_buf, tag_wiretype.wire_type)?
res.enum_type << v
i = ii
}

6 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_servicedescriptorproto(cur_buf, tag_wiretype.wire_type)?
res.service << v
i = ii
}

7 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_fielddescriptorproto(cur_buf, tag_wiretype.wire_type)?
res.extension << v
i = ii
}

8 {
res.has_options = true
ii, v := zzz_vproto_internal_unpack_fileoptions(cur_buf, tag_wiretype.wire_type)?
res.options = v
i = ii
}

9 {
res.has_source_code_info = true
ii, v := zzz_vproto_internal_unpack_sourcecodeinfo(cur_buf, tag_wiretype.wire_type)?
res.source_code_info = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_filedescriptorproto() FileDescriptorProto {
return FileDescriptorProto{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_filedescriptorproto(o FileDescriptorProto, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_filedescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, FileDescriptorProto) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := filedescriptorproto_unpack(v)?
return i, unpacked
}
pub struct DescriptorProtoExtensionRange {
mut:
unknown_fields []vproto.UnknownField
pub mut:
start int
has_start bool
end int
has_end bool
}
pub fn (o &DescriptorProtoExtensionRange) pack() []byte {
mut res := []byte{}
if o.has_start {
res << vproto.pack_int32_field(o.start, 1)
}

if o.has_end {
res << vproto.pack_int32_field(o.end, 2)
}

return res
}

pub fn descriptorprotoextensionrange_unpack(buf []byte) ?DescriptorProtoExtensionRange {
mut res := DescriptorProtoExtensionRange{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_start = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.start = v
i = ii
}

2 {
res.has_end = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.end = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_descriptorprotoextensionrange() DescriptorProtoExtensionRange {
return DescriptorProtoExtensionRange{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_descriptorprotoextensionrange(o DescriptorProtoExtensionRange, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_descriptorprotoextensionrange(buf []byte, tag_wiretype vproto.WireType) ?(int, DescriptorProtoExtensionRange) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := descriptorprotoextensionrange_unpack(v)?
return i, unpacked
}
pub struct DescriptorProto {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
has_name bool
field []FieldDescriptorProto
extension []FieldDescriptorProto
nested_type []DescriptorProto
enum_type []EnumDescriptorProto
extension_range []DescriptorProtoExtensionRange
oneof_decl []OneofDescriptorProto
options MessageOptions
has_options bool
}
pub fn (o &DescriptorProto) pack() []byte {
mut res := []byte{}
if o.has_name {
res << vproto.pack_string_field(o.name, 1)
}

// [packed=false]
for _, x in o.field {
res << zzz_vproto_internal_pack_fielddescriptorproto(x, 2)
}

// [packed=false]
for _, x in o.extension {
res << zzz_vproto_internal_pack_fielddescriptorproto(x, 6)
}

// [packed=false]
for _, x in o.nested_type {
res << zzz_vproto_internal_pack_descriptorproto(x, 3)
}

// [packed=false]
for _, x in o.enum_type {
res << zzz_vproto_internal_pack_enumdescriptorproto(x, 4)
}

// [packed=false]
for _, x in o.extension_range {
res << zzz_vproto_internal_pack_descriptorprotoextensionrange(x, 5)
}

// [packed=false]
for _, x in o.oneof_decl {
res << zzz_vproto_internal_pack_oneofdescriptorproto(x, 8)
}

if o.has_options {
res << zzz_vproto_internal_pack_messageoptions(o.options, 7)
}

return res
}

pub fn descriptorproto_unpack(buf []byte) ?DescriptorProto {
mut res := DescriptorProto{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_fielddescriptorproto(cur_buf, tag_wiretype.wire_type)?
res.field << v
i = ii
}

6 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_fielddescriptorproto(cur_buf, tag_wiretype.wire_type)?
res.extension << v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_descriptorproto(cur_buf, tag_wiretype.wire_type)?
res.nested_type << v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_enumdescriptorproto(cur_buf, tag_wiretype.wire_type)?
res.enum_type << v
i = ii
}

5 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_descriptorprotoextensionrange(cur_buf, tag_wiretype.wire_type)?
res.extension_range << v
i = ii
}

8 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_oneofdescriptorproto(cur_buf, tag_wiretype.wire_type)?
res.oneof_decl << v
i = ii
}

7 {
res.has_options = true
ii, v := zzz_vproto_internal_unpack_messageoptions(cur_buf, tag_wiretype.wire_type)?
res.options = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_descriptorproto() DescriptorProto {
return DescriptorProto{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_descriptorproto(o DescriptorProto, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_descriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, DescriptorProto) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := descriptorproto_unpack(v)?
return i, unpacked
}
[_allow_multiple_values]
enum FieldDescriptorProtoType {
type_double = 1
type_float = 2
type_int64 = 3
type_uint64 = 4
type_int32 = 5
type_fixed64 = 6
type_fixed32 = 7
type_bool = 8
type_string = 9
type_group = 10
type_message = 11
type_bytes = 12
type_uint32 = 13
type_enum = 14
type_sfixed32 = 15
type_sfixed64 = 16
type_sint32 = 17
type_sint64 = 18
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_fielddescriptorprototype(e FieldDescriptorProtoType, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_fielddescriptorprototype(buf []byte, tag_wiretype vproto.WireType) ?(int, FieldDescriptorProtoType) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, FieldDescriptorProtoType(v)
}
[_allow_multiple_values]
enum FieldDescriptorProtoLabel {
label_optional = 1
label_required = 2
label_repeated = 3
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_fielddescriptorprotolabel(e FieldDescriptorProtoLabel, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_fielddescriptorprotolabel(buf []byte, tag_wiretype vproto.WireType) ?(int, FieldDescriptorProtoLabel) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, FieldDescriptorProtoLabel(v)
}
pub struct FieldDescriptorProto {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
has_name bool
number int
has_number bool
label FieldDescriptorProtoLabel
has_label bool
@type FieldDescriptorProtoType
has_type bool
type_name string
has_type_name bool
extendee string
has_extendee bool
default_value string
has_default_value bool
oneof_index int
has_oneof_index bool
options FieldOptions
has_options bool
}
pub fn (o &FieldDescriptorProto) pack() []byte {
mut res := []byte{}
if o.has_name {
res << vproto.pack_string_field(o.name, 1)
}

if o.has_number {
res << vproto.pack_int32_field(o.number, 3)
}

if o.has_label {
res << zzz_vproto_internal_pack_fielddescriptorprotolabel(o.label, 4)
}

if o.has_type {
res << zzz_vproto_internal_pack_fielddescriptorprototype(o.@type, 5)
}

if o.has_type_name {
res << vproto.pack_string_field(o.type_name, 6)
}

if o.has_extendee {
res << vproto.pack_string_field(o.extendee, 2)
}

if o.has_default_value {
res << vproto.pack_string_field(o.default_value, 7)
}

if o.has_oneof_index {
res << vproto.pack_int32_field(o.oneof_index, 9)
}

if o.has_options {
res << zzz_vproto_internal_pack_fieldoptions(o.options, 8)
}

return res
}

pub fn fielddescriptorproto_unpack(buf []byte) ?FieldDescriptorProto {
mut res := FieldDescriptorProto{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

3 {
res.has_number = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.number = v
i = ii
}

4 {
res.has_label = true
ii, v := zzz_vproto_internal_unpack_fielddescriptorprotolabel(cur_buf, tag_wiretype.wire_type)?
res.label = v
i = ii
}

5 {
res.has_type = true
ii, v := zzz_vproto_internal_unpack_fielddescriptorprototype(cur_buf, tag_wiretype.wire_type)?
res.@type = v
i = ii
}

6 {
res.has_type_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.type_name = v
i = ii
}

2 {
res.has_extendee = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.extendee = v
i = ii
}

7 {
res.has_default_value = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.default_value = v
i = ii
}

9 {
res.has_oneof_index = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.oneof_index = v
i = ii
}

8 {
res.has_options = true
ii, v := zzz_vproto_internal_unpack_fieldoptions(cur_buf, tag_wiretype.wire_type)?
res.options = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_fielddescriptorproto() FieldDescriptorProto {
return FieldDescriptorProto{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_fielddescriptorproto(o FieldDescriptorProto, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_fielddescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, FieldDescriptorProto) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := fielddescriptorproto_unpack(v)?
return i, unpacked
}
pub struct OneofDescriptorProto {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
has_name bool
}
pub fn (o &OneofDescriptorProto) pack() []byte {
mut res := []byte{}
if o.has_name {
res << vproto.pack_string_field(o.name, 1)
}

return res
}

pub fn oneofdescriptorproto_unpack(buf []byte) ?OneofDescriptorProto {
mut res := OneofDescriptorProto{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_oneofdescriptorproto() OneofDescriptorProto {
return OneofDescriptorProto{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_oneofdescriptorproto(o OneofDescriptorProto, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_oneofdescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, OneofDescriptorProto) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := oneofdescriptorproto_unpack(v)?
return i, unpacked
}
pub struct EnumDescriptorProto {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
has_name bool
value []EnumValueDescriptorProto
options EnumOptions
has_options bool
}
pub fn (o &EnumDescriptorProto) pack() []byte {
mut res := []byte{}
if o.has_name {
res << vproto.pack_string_field(o.name, 1)
}

// [packed=false]
for _, x in o.value {
res << zzz_vproto_internal_pack_enumvaluedescriptorproto(x, 2)
}

if o.has_options {
res << zzz_vproto_internal_pack_enumoptions(o.options, 3)
}

return res
}

pub fn enumdescriptorproto_unpack(buf []byte) ?EnumDescriptorProto {
mut res := EnumDescriptorProto{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_enumvaluedescriptorproto(cur_buf, tag_wiretype.wire_type)?
res.value << v
i = ii
}

3 {
res.has_options = true
ii, v := zzz_vproto_internal_unpack_enumoptions(cur_buf, tag_wiretype.wire_type)?
res.options = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_enumdescriptorproto() EnumDescriptorProto {
return EnumDescriptorProto{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_enumdescriptorproto(o EnumDescriptorProto, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_enumdescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, EnumDescriptorProto) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := enumdescriptorproto_unpack(v)?
return i, unpacked
}
pub struct EnumValueDescriptorProto {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
has_name bool
number int
has_number bool
options EnumValueOptions
has_options bool
}
pub fn (o &EnumValueDescriptorProto) pack() []byte {
mut res := []byte{}
if o.has_name {
res << vproto.pack_string_field(o.name, 1)
}

if o.has_number {
res << vproto.pack_int32_field(o.number, 2)
}

if o.has_options {
res << zzz_vproto_internal_pack_enumvalueoptions(o.options, 3)
}

return res
}

pub fn enumvaluedescriptorproto_unpack(buf []byte) ?EnumValueDescriptorProto {
mut res := EnumValueDescriptorProto{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

2 {
res.has_number = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.number = v
i = ii
}

3 {
res.has_options = true
ii, v := zzz_vproto_internal_unpack_enumvalueoptions(cur_buf, tag_wiretype.wire_type)?
res.options = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_enumvaluedescriptorproto() EnumValueDescriptorProto {
return EnumValueDescriptorProto{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_enumvaluedescriptorproto(o EnumValueDescriptorProto, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_enumvaluedescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, EnumValueDescriptorProto) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := enumvaluedescriptorproto_unpack(v)?
return i, unpacked
}
pub struct ServiceDescriptorProto {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
has_name bool
method []MethodDescriptorProto
options ServiceOptions
has_options bool
}
pub fn (o &ServiceDescriptorProto) pack() []byte {
mut res := []byte{}
if o.has_name {
res << vproto.pack_string_field(o.name, 1)
}

// [packed=false]
for _, x in o.method {
res << zzz_vproto_internal_pack_methoddescriptorproto(x, 2)
}

if o.has_options {
res << zzz_vproto_internal_pack_serviceoptions(o.options, 3)
}

return res
}

pub fn servicedescriptorproto_unpack(buf []byte) ?ServiceDescriptorProto {
mut res := ServiceDescriptorProto{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_methoddescriptorproto(cur_buf, tag_wiretype.wire_type)?
res.method << v
i = ii
}

3 {
res.has_options = true
ii, v := zzz_vproto_internal_unpack_serviceoptions(cur_buf, tag_wiretype.wire_type)?
res.options = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_servicedescriptorproto() ServiceDescriptorProto {
return ServiceDescriptorProto{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_servicedescriptorproto(o ServiceDescriptorProto, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_servicedescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, ServiceDescriptorProto) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := servicedescriptorproto_unpack(v)?
return i, unpacked
}
pub struct MethodDescriptorProto {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
has_name bool
input_type string
has_input_type bool
output_type string
has_output_type bool
options MethodOptions
has_options bool
}
pub fn (o &MethodDescriptorProto) pack() []byte {
mut res := []byte{}
if o.has_name {
res << vproto.pack_string_field(o.name, 1)
}

if o.has_input_type {
res << vproto.pack_string_field(o.input_type, 2)
}

if o.has_output_type {
res << vproto.pack_string_field(o.output_type, 3)
}

if o.has_options {
res << zzz_vproto_internal_pack_methodoptions(o.options, 4)
}

return res
}

pub fn methoddescriptorproto_unpack(buf []byte) ?MethodDescriptorProto {
mut res := MethodDescriptorProto{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

2 {
res.has_input_type = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.input_type = v
i = ii
}

3 {
res.has_output_type = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.output_type = v
i = ii
}

4 {
res.has_options = true
ii, v := zzz_vproto_internal_unpack_methodoptions(cur_buf, tag_wiretype.wire_type)?
res.options = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_methoddescriptorproto() MethodDescriptorProto {
return MethodDescriptorProto{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_methoddescriptorproto(o MethodDescriptorProto, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_methoddescriptorproto(buf []byte, tag_wiretype vproto.WireType) ?(int, MethodDescriptorProto) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := methoddescriptorproto_unpack(v)?
return i, unpacked
}
[_allow_multiple_values]
enum FileOptionsOptimizeMode {
speed = 1
code_size = 2
lite_runtime = 3
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_fileoptionsoptimizemode(e FileOptionsOptimizeMode, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_fileoptionsoptimizemode(buf []byte, tag_wiretype vproto.WireType) ?(int, FileOptionsOptimizeMode) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, FileOptionsOptimizeMode(v)
}
pub struct FileOptions {
mut:
unknown_fields []vproto.UnknownField
pub mut:
java_package string
has_java_package bool
java_outer_classname string
has_java_outer_classname bool
java_multiple_files bool
has_java_multiple_files bool
java_generate_equals_and_hash bool
has_java_generate_equals_and_hash bool
java_string_check_utf8 bool
has_java_string_check_utf8 bool
optimize_for FileOptionsOptimizeMode
has_optimize_for bool
go_package string
has_go_package bool
cc_generic_services bool
has_cc_generic_services bool
java_generic_services bool
has_java_generic_services bool
py_generic_services bool
has_py_generic_services bool
deprecated bool
has_deprecated bool
uninterpreted_option []UninterpretedOption
}
pub fn (o &FileOptions) pack() []byte {
mut res := []byte{}
if o.has_java_package {
res << vproto.pack_string_field(o.java_package, 1)
}

if o.has_java_outer_classname {
res << vproto.pack_string_field(o.java_outer_classname, 8)
}

if o.has_java_multiple_files {
res << vproto.pack_bool_field(o.java_multiple_files, 10)
}

if o.has_java_generate_equals_and_hash {
res << vproto.pack_bool_field(o.java_generate_equals_and_hash, 20)
}

if o.has_java_string_check_utf8 {
res << vproto.pack_bool_field(o.java_string_check_utf8, 27)
}

if o.has_optimize_for {
res << zzz_vproto_internal_pack_fileoptionsoptimizemode(o.optimize_for, 9)
}

if o.has_go_package {
res << vproto.pack_string_field(o.go_package, 11)
}

if o.has_cc_generic_services {
res << vproto.pack_bool_field(o.cc_generic_services, 16)
}

if o.has_java_generic_services {
res << vproto.pack_bool_field(o.java_generic_services, 17)
}

if o.has_py_generic_services {
res << vproto.pack_bool_field(o.py_generic_services, 18)
}

if o.has_deprecated {
res << vproto.pack_bool_field(o.deprecated, 23)
}

// [packed=false]
for _, x in o.uninterpreted_option {
res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
}

return res
}

pub fn fileoptions_unpack(buf []byte) ?FileOptions {
mut res := FileOptions{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_java_package = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.java_package = v
i = ii
}

8 {
res.has_java_outer_classname = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.java_outer_classname = v
i = ii
}

10 {
res.has_java_multiple_files = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.java_multiple_files = v
i = ii
}

20 {
res.has_java_generate_equals_and_hash = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.java_generate_equals_and_hash = v
i = ii
}

27 {
res.has_java_string_check_utf8 = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.java_string_check_utf8 = v
i = ii
}

9 {
res.has_optimize_for = true
ii, v := zzz_vproto_internal_unpack_fileoptionsoptimizemode(cur_buf, tag_wiretype.wire_type)?
res.optimize_for = v
i = ii
}

11 {
res.has_go_package = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.go_package = v
i = ii
}

16 {
res.has_cc_generic_services = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.cc_generic_services = v
i = ii
}

17 {
res.has_java_generic_services = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.java_generic_services = v
i = ii
}

18 {
res.has_py_generic_services = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.py_generic_services = v
i = ii
}

23 {
res.has_deprecated = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated = v
i = ii
}

999 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)?
res.uninterpreted_option << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_fileoptions() FileOptions {
return FileOptions{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_fileoptions(o FileOptions, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_fileoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, FileOptions) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := fileoptions_unpack(v)?
return i, unpacked
}
pub struct MessageOptions {
mut:
unknown_fields []vproto.UnknownField
pub mut:
message_set_wire_format bool
has_message_set_wire_format bool
no_standard_descriptor_accessor bool
has_no_standard_descriptor_accessor bool
deprecated bool
has_deprecated bool
uninterpreted_option []UninterpretedOption
}
pub fn (o &MessageOptions) pack() []byte {
mut res := []byte{}
if o.has_message_set_wire_format {
res << vproto.pack_bool_field(o.message_set_wire_format, 1)
}

if o.has_no_standard_descriptor_accessor {
res << vproto.pack_bool_field(o.no_standard_descriptor_accessor, 2)
}

if o.has_deprecated {
res << vproto.pack_bool_field(o.deprecated, 3)
}

// [packed=false]
for _, x in o.uninterpreted_option {
res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
}

return res
}

pub fn messageoptions_unpack(buf []byte) ?MessageOptions {
mut res := MessageOptions{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_message_set_wire_format = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.message_set_wire_format = v
i = ii
}

2 {
res.has_no_standard_descriptor_accessor = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.no_standard_descriptor_accessor = v
i = ii
}

3 {
res.has_deprecated = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated = v
i = ii
}

999 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)?
res.uninterpreted_option << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_messageoptions() MessageOptions {
return MessageOptions{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_messageoptions(o MessageOptions, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_messageoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, MessageOptions) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := messageoptions_unpack(v)?
return i, unpacked
}
[_allow_multiple_values]
enum FieldOptionsCType {
string = 0
cord = 1
string_piece = 2
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_fieldoptionsctype(e FieldOptionsCType, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_fieldoptionsctype(buf []byte, tag_wiretype vproto.WireType) ?(int, FieldOptionsCType) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, FieldOptionsCType(v)
}
pub struct FieldOptions {
mut:
unknown_fields []vproto.UnknownField
pub mut:
ctype FieldOptionsCType
has_ctype bool
packed bool
has_packed bool
lazy bool
has_lazy bool
deprecated bool
has_deprecated bool
experimental_map_key string
has_experimental_map_key bool
weak bool
has_weak bool
uninterpreted_option []UninterpretedOption
}
pub fn (o &FieldOptions) pack() []byte {
mut res := []byte{}
if o.has_ctype {
res << zzz_vproto_internal_pack_fieldoptionsctype(o.ctype, 1)
}

if o.has_packed {
res << vproto.pack_bool_field(o.packed, 2)
}

if o.has_lazy {
res << vproto.pack_bool_field(o.lazy, 5)
}

if o.has_deprecated {
res << vproto.pack_bool_field(o.deprecated, 3)
}

if o.has_experimental_map_key {
res << vproto.pack_string_field(o.experimental_map_key, 9)
}

if o.has_weak {
res << vproto.pack_bool_field(o.weak, 10)
}

// [packed=false]
for _, x in o.uninterpreted_option {
res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
}

return res
}

pub fn fieldoptions_unpack(buf []byte) ?FieldOptions {
mut res := FieldOptions{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_ctype = true
ii, v := zzz_vproto_internal_unpack_fieldoptionsctype(cur_buf, tag_wiretype.wire_type)?
res.ctype = v
i = ii
}

2 {
res.has_packed = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.packed = v
i = ii
}

5 {
res.has_lazy = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.lazy = v
i = ii
}

3 {
res.has_deprecated = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated = v
i = ii
}

9 {
res.has_experimental_map_key = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.experimental_map_key = v
i = ii
}

10 {
res.has_weak = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.weak = v
i = ii
}

999 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)?
res.uninterpreted_option << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_fieldoptions() FieldOptions {
return FieldOptions{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_fieldoptions(o FieldOptions, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_fieldoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, FieldOptions) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := fieldoptions_unpack(v)?
return i, unpacked
}
pub struct EnumOptions {
mut:
unknown_fields []vproto.UnknownField
pub mut:
allow_alias bool
has_allow_alias bool
deprecated bool
has_deprecated bool
uninterpreted_option []UninterpretedOption
}
pub fn (o &EnumOptions) pack() []byte {
mut res := []byte{}
if o.has_allow_alias {
res << vproto.pack_bool_field(o.allow_alias, 2)
}

if o.has_deprecated {
res << vproto.pack_bool_field(o.deprecated, 3)
}

// [packed=false]
for _, x in o.uninterpreted_option {
res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
}

return res
}

pub fn enumoptions_unpack(buf []byte) ?EnumOptions {
mut res := EnumOptions{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
2 {
res.has_allow_alias = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.allow_alias = v
i = ii
}

3 {
res.has_deprecated = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated = v
i = ii
}

999 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)?
res.uninterpreted_option << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_enumoptions() EnumOptions {
return EnumOptions{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_enumoptions(o EnumOptions, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_enumoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, EnumOptions) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := enumoptions_unpack(v)?
return i, unpacked
}
pub struct EnumValueOptions {
mut:
unknown_fields []vproto.UnknownField
pub mut:
deprecated bool
has_deprecated bool
uninterpreted_option []UninterpretedOption
}
pub fn (o &EnumValueOptions) pack() []byte {
mut res := []byte{}
if o.has_deprecated {
res << vproto.pack_bool_field(o.deprecated, 1)
}

// [packed=false]
for _, x in o.uninterpreted_option {
res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
}

return res
}

pub fn enumvalueoptions_unpack(buf []byte) ?EnumValueOptions {
mut res := EnumValueOptions{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_deprecated = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated = v
i = ii
}

999 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)?
res.uninterpreted_option << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_enumvalueoptions() EnumValueOptions {
return EnumValueOptions{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_enumvalueoptions(o EnumValueOptions, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_enumvalueoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, EnumValueOptions) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := enumvalueoptions_unpack(v)?
return i, unpacked
}
pub struct ServiceOptions {
mut:
unknown_fields []vproto.UnknownField
pub mut:
deprecated bool
has_deprecated bool
uninterpreted_option []UninterpretedOption
}
pub fn (o &ServiceOptions) pack() []byte {
mut res := []byte{}
if o.has_deprecated {
res << vproto.pack_bool_field(o.deprecated, 33)
}

// [packed=false]
for _, x in o.uninterpreted_option {
res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
}

return res
}

pub fn serviceoptions_unpack(buf []byte) ?ServiceOptions {
mut res := ServiceOptions{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
33 {
res.has_deprecated = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated = v
i = ii
}

999 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)?
res.uninterpreted_option << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_serviceoptions() ServiceOptions {
return ServiceOptions{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_serviceoptions(o ServiceOptions, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_serviceoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, ServiceOptions) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := serviceoptions_unpack(v)?
return i, unpacked
}
pub struct MethodOptions {
mut:
unknown_fields []vproto.UnknownField
pub mut:
deprecated bool
has_deprecated bool
uninterpreted_option []UninterpretedOption
}
pub fn (o &MethodOptions) pack() []byte {
mut res := []byte{}
if o.has_deprecated {
res << vproto.pack_bool_field(o.deprecated, 33)
}

// [packed=false]
for _, x in o.uninterpreted_option {
res << zzz_vproto_internal_pack_uninterpretedoption(x, 999)
}

return res
}

pub fn methodoptions_unpack(buf []byte) ?MethodOptions {
mut res := MethodOptions{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
33 {
res.has_deprecated = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated = v
i = ii
}

999 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_uninterpretedoption(cur_buf, tag_wiretype.wire_type)?
res.uninterpreted_option << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_methodoptions() MethodOptions {
return MethodOptions{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_methodoptions(o MethodOptions, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_methodoptions(buf []byte, tag_wiretype vproto.WireType) ?(int, MethodOptions) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := methodoptions_unpack(v)?
return i, unpacked
}
pub struct UninterpretedOptionNamePart {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name_part string
is_extension bool
}
pub fn (o &UninterpretedOptionNamePart) pack() []byte {
mut res := []byte{}
res << vproto.pack_string_field(o.name_part, 1)

res << vproto.pack_bool_field(o.is_extension, 2)

return res
}

pub fn uninterpretedoptionnamepart_unpack(buf []byte) ?UninterpretedOptionNamePart {
mut res := UninterpretedOptionNamePart{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name_part = v
i = ii
}

2 {
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_extension = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_uninterpretedoptionnamepart() UninterpretedOptionNamePart {
return UninterpretedOptionNamePart{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_uninterpretedoptionnamepart(o UninterpretedOptionNamePart, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_uninterpretedoptionnamepart(buf []byte, tag_wiretype vproto.WireType) ?(int, UninterpretedOptionNamePart) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := uninterpretedoptionnamepart_unpack(v)?
return i, unpacked
}
pub struct UninterpretedOption {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name []UninterpretedOptionNamePart
identifier_value string
has_identifier_value bool
positive_int_value u64
has_positive_int_value bool
negative_int_value i64
has_negative_int_value bool
double_value f64
has_double_value bool
string_value []byte
has_string_value bool
aggregate_value string
has_aggregate_value bool
}
pub fn (o &UninterpretedOption) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.name {
res << zzz_vproto_internal_pack_uninterpretedoptionnamepart(x, 2)
}

if o.has_identifier_value {
res << vproto.pack_string_field(o.identifier_value, 3)
}

if o.has_positive_int_value {
res << vproto.pack_uint64_field(o.positive_int_value, 4)
}

if o.has_negative_int_value {
res << vproto.pack_int64_field(o.negative_int_value, 5)
}

if o.has_double_value {
res << vproto.pack_double_field(o.double_value, 6)
}

if o.has_string_value {
res << vproto.pack_bytes_field(o.string_value, 7)
}

if o.has_aggregate_value {
res << vproto.pack_string_field(o.aggregate_value, 8)
}

return res
}

pub fn uninterpretedoption_unpack(buf []byte) ?UninterpretedOption {
mut res := UninterpretedOption{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_uninterpretedoptionnamepart(cur_buf, tag_wiretype.wire_type)?
res.name << v
i = ii
}

3 {
res.has_identifier_value = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.identifier_value = v
i = ii
}

4 {
res.has_positive_int_value = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.positive_int_value = v
i = ii
}

5 {
res.has_negative_int_value = true
ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
res.negative_int_value = v
i = ii
}

6 {
res.has_double_value = true
ii, v := vproto.unpack_double_field(cur_buf, tag_wiretype.wire_type)?
res.double_value = v
i = ii
}

7 {
res.has_string_value = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.string_value = v
i = ii
}

8 {
res.has_aggregate_value = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.aggregate_value = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_uninterpretedoption() UninterpretedOption {
return UninterpretedOption{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_uninterpretedoption(o UninterpretedOption, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_uninterpretedoption(buf []byte, tag_wiretype vproto.WireType) ?(int, UninterpretedOption) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := uninterpretedoption_unpack(v)?
return i, unpacked
}
pub struct SourceCodeInfoLocation {
mut:
unknown_fields []vproto.UnknownField
pub mut:
path []int
span []int
leading_comments string
has_leading_comments bool
trailing_comments string
has_trailing_comments bool
}
pub fn (o &SourceCodeInfoLocation) pack() []byte {
mut res := []byte{}
// [packed=true]
res << vproto.pack_int32_field_packed(o.path, 1)

// [packed=true]
res << vproto.pack_int32_field_packed(o.span, 2)

if o.has_leading_comments {
res << vproto.pack_string_field(o.leading_comments, 3)
}

if o.has_trailing_comments {
res << vproto.pack_string_field(o.trailing_comments, 4)
}

return res
}

pub fn sourcecodeinfolocation_unpack(buf []byte) ?SourceCodeInfoLocation {
mut res := SourceCodeInfoLocation{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=true]
ii, v := vproto.unpack_int32_field_packed(cur_buf, tag_wiretype.wire_type) ?
res.path << v
i = ii
}

2 {
// [packed=true]
ii, v := vproto.unpack_int32_field_packed(cur_buf, tag_wiretype.wire_type) ?
res.span << v
i = ii
}

3 {
res.has_leading_comments = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.leading_comments = v
i = ii
}

4 {
res.has_trailing_comments = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.trailing_comments = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_sourcecodeinfolocation() SourceCodeInfoLocation {
return SourceCodeInfoLocation{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_sourcecodeinfolocation(o SourceCodeInfoLocation, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_sourcecodeinfolocation(buf []byte, tag_wiretype vproto.WireType) ?(int, SourceCodeInfoLocation) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := sourcecodeinfolocation_unpack(v)?
return i, unpacked
}
pub struct SourceCodeInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
location []SourceCodeInfoLocation
}
pub fn (o &SourceCodeInfo) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.location {
res << zzz_vproto_internal_pack_sourcecodeinfolocation(x, 1)
}

return res
}

pub fn sourcecodeinfo_unpack(buf []byte) ?SourceCodeInfo {
mut res := SourceCodeInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_sourcecodeinfolocation(cur_buf, tag_wiretype.wire_type)?
res.location << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_sourcecodeinfo() SourceCodeInfo {
return SourceCodeInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_sourcecodeinfo(o SourceCodeInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_sourcecodeinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, SourceCodeInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := sourcecodeinfo_unpack(v)?
return i, unpacked
}
