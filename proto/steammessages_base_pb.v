// Generated by vproto - Do not modify
module proto

import emily33901.vproto
import proto.google.protobuf

[_allow_multiple_values]
enum EProtoClanEventType {
	k_eclanotherevent = 1
	k_eclangameevent = 2
	k_eclanpartyevent = 3
	k_eclanmeetingevent = 4
	k_eclanspecialcauseevent = 5
	k_eclanmusicandartsevent = 6
	k_eclansportsevent = 7
	k_eclantripevent = 8
	k_eclanchatevent = 9
	k_eclangamereleaseevent = 10
	k_eclanbroadcastevent = 11
	k_eclansmallupdateevent = 12
	k_eclanpreannouncemajorupdateevent = 13
	k_eclanmajorupdateevent = 14
	k_eclandlcreleaseevent = 15
	k_eclanfuturereleaseevent = 16
	k_eclanesporttournamentstreamevent = 17
	k_eclandevstreamevent = 18
	k_eclanfamousstreamevent = 19
	k_eclangamesalesevent = 20
	k_eclangameitemsalesevent = 21
	k_eclaningamebonusxpevent = 22
	k_eclaningamelootevent = 23
	k_eclaningameperksevent = 24
	k_eclaningamechallengeevent = 25
	k_eclaningamecontestevent = 26
	k_eclanirlevent = 27
	k_eclannewsevent = 28
	k_eclanbetareleaseevent = 29
	k_eclaningamecontentreleaseevent = 30
	k_eclanfreetrial = 31
	k_eclanseasonrelease = 32
	k_eclanseasonupdate = 33
	k_eclancrosspostevent = 34
	k_eclaningameeventgeneral = 35
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eprotoclaneventtype(e EProtoClanEventType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eprotoclaneventtype_packed(e []EProtoClanEventType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eprotoclaneventtype(buf []byte, tag_wiretype vproto.WireType) ?(int, EProtoClanEventType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EProtoClanEventType(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eprotoclaneventtype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EProtoClanEventType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum PartnerEventNotificationType {
	k_eeventstart = 0
	k_eeventbroadcaststart = 1
	k_eeventmatchstart = 2
	k_eeventpartnermaxtype = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_partnereventnotificationtype(e PartnerEventNotificationType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_partnereventnotificationtype_packed(e []PartnerEventNotificationType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_partnereventnotificationtype(buf []byte, tag_wiretype vproto.WireType) ?(int, PartnerEventNotificationType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, PartnerEventNotificationType(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_partnereventnotificationtype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []PartnerEventNotificationType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgIPAddress {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgIPAddress) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgipaddress_unpack(buf []byte) ?CMsgIPAddress {
	res := CMsgIPAddress{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgipaddress() CMsgIPAddress {
	return CMsgIPAddress{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgipaddress(o CMsgIPAddress, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgipaddress(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgIPAddress) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgipaddress_unpack(v)?
	return i, unpacked
}

pub struct CMsgIPAddressBucket {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	original_ip_address     CMsgIPAddress
	has_original_ip_address bool
	bucket                  u64
	has_bucket              bool
}

pub fn (o &CMsgIPAddressBucket) pack() []byte {
	mut res := []byte{}
	if o.has_original_ip_address {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.original_ip_address, 1)
	}
	if o.has_bucket {
		res << vproto.pack_64bit_field(o.bucket, 2)
	}
	return res
}

pub fn cmsgipaddressbucket_unpack(buf []byte) ?CMsgIPAddressBucket {
	mut res := CMsgIPAddressBucket{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_original_ip_address = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.original_ip_address = v
				i = ii
			}
			2 {
				res.has_bucket = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.bucket = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgipaddressbucket() CMsgIPAddressBucket {
	return CMsgIPAddressBucket{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgipaddressbucket(o CMsgIPAddressBucket, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgipaddressbucket(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgIPAddressBucket) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgipaddressbucket_unpack(v)?
	return i, unpacked
}

pub struct CMsgProtoBufHeader {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	steamid                     u64
	has_steamid                 bool
	client_sessionid            int
	has_client_sessionid        bool
	routing_appid               u32
	has_routing_appid           bool
	jobid_source                u64
	has_jobid_source            bool
	jobid_target                u64
	has_jobid_target            bool
	target_job_name             string
	has_target_job_name         bool
	seq_num                     int
	has_seq_num                 bool
	eresult                     int
	has_eresult                 bool
	error_message               string
	has_error_message           bool
	auth_account_flags          u32
	has_auth_account_flags      bool
	token_source                u32
	has_token_source            bool
	admin_spoofing_user         bool
	has_admin_spoofing_user     bool
	transport_error             int
	has_transport_error         bool
	messageid                   u64
	has_messageid               bool
	publisher_group_id          u32
	has_publisher_group_id      bool
	sysid                       u32
	has_sysid                   bool
	trace_tag                   u64
	has_trace_tag               bool
	webapi_key_id               u32
	has_webapi_key_id           bool
	is_from_external_source     bool
	has_is_from_external_source bool
	forward_to_sysid            []u32
	cm_sysid                    u32
	has_cm_sysid                bool
	wg_token                    string
	has_wg_token                bool
	launcher_type               u32
	has_launcher_type           bool
	realm                       u32
	has_realm                   bool
}

pub fn (o &CMsgProtoBufHeader) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_client_sessionid {
		res << vproto.pack_int32_field(o.client_sessionid, 2)
	}
	if o.has_routing_appid {
		res << vproto.pack_uint32_field(o.routing_appid, 3)
	}
	if o.has_jobid_source {
		res << vproto.pack_64bit_field(o.jobid_source, 10)
	}
	if o.has_jobid_target {
		res << vproto.pack_64bit_field(o.jobid_target, 11)
	}
	if o.has_target_job_name {
		res << vproto.pack_string_field(o.target_job_name, 12)
	}
	if o.has_seq_num {
		res << vproto.pack_int32_field(o.seq_num, 24)
	}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 13)
	}
	if o.has_error_message {
		res << vproto.pack_string_field(o.error_message, 14)
	}
	if o.has_auth_account_flags {
		res << vproto.pack_uint32_field(o.auth_account_flags, 16)
	}
	if o.has_token_source {
		res << vproto.pack_uint32_field(o.token_source, 22)
	}
	if o.has_admin_spoofing_user {
		res << vproto.pack_bool_field(o.admin_spoofing_user, 23)
	}
	if o.has_transport_error {
		res << vproto.pack_int32_field(o.transport_error, 17)
	}
	if o.has_messageid {
		res << vproto.pack_uint64_field(o.messageid, 18)
	}
	if o.has_publisher_group_id {
		res << vproto.pack_uint32_field(o.publisher_group_id, 19)
	}
	if o.has_sysid {
		res << vproto.pack_uint32_field(o.sysid, 20)
	}
	if o.has_trace_tag {
		res << vproto.pack_uint64_field(o.trace_tag, 21)
	}
	if o.has_webapi_key_id {
		res << vproto.pack_uint32_field(o.webapi_key_id, 25)
	}
	if o.has_is_from_external_source {
		res << vproto.pack_bool_field(o.is_from_external_source, 26)
	}
	// [packed=false]
	for _, x in o.forward_to_sysid {
		res << vproto.pack_uint32_field(x, 27)
	}
	if o.has_cm_sysid {
		res << vproto.pack_uint32_field(o.cm_sysid, 28)
	}
	if o.has_wg_token {
		res << vproto.pack_string_field(o.wg_token, 30)
	}
	if o.has_launcher_type {
		res << vproto.pack_uint32_field(o.launcher_type, 31)
	}
	if o.has_realm {
		res << vproto.pack_uint32_field(o.realm, 32)
	}
	return res
}

pub fn cmsgprotobufheader_unpack(buf []byte) ?CMsgProtoBufHeader {
	mut res := CMsgProtoBufHeader{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_client_sessionid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_sessionid = v
				i = ii
			}
			3 {
				res.has_routing_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.routing_appid = v
				i = ii
			}
			10 {
				res.has_jobid_source = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.jobid_source = v
				i = ii
			}
			11 {
				res.has_jobid_target = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.jobid_target = v
				i = ii
			}
			12 {
				res.has_target_job_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.target_job_name = v
				i = ii
			}
			24 {
				res.has_seq_num = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.seq_num = v
				i = ii
			}
			13 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			14 {
				res.has_error_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.error_message = v
				i = ii
			}
			16 {
				res.has_auth_account_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_account_flags = v
				i = ii
			}
			22 {
				res.has_token_source = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.token_source = v
				i = ii
			}
			23 {
				res.has_admin_spoofing_user = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.admin_spoofing_user = v
				i = ii
			}
			17 {
				res.has_transport_error = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.transport_error = v
				i = ii
			}
			18 {
				res.has_messageid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.messageid = v
				i = ii
			}
			19 {
				res.has_publisher_group_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.publisher_group_id = v
				i = ii
			}
			20 {
				res.has_sysid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sysid = v
				i = ii
			}
			21 {
				res.has_trace_tag = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.trace_tag = v
				i = ii
			}
			25 {
				res.has_webapi_key_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.webapi_key_id = v
				i = ii
			}
			26 {
				res.has_is_from_external_source = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_from_external_source = v
				i = ii
			}
			27 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.forward_to_sysid << v
				i = ii
			}
			28 {
				res.has_cm_sysid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cm_sysid = v
				i = ii
			}
			30 {
				res.has_wg_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.wg_token = v
				i = ii
			}
			31 {
				res.has_launcher_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.launcher_type = v
				i = ii
			}
			32 {
				res.has_realm = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.realm = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgprotobufheader() CMsgProtoBufHeader {
	return CMsgProtoBufHeader{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgprotobufheader(o CMsgProtoBufHeader, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgprotobufheader(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgProtoBufHeader) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgprotobufheader_unpack(v)?
	return i, unpacked
}

pub struct CMsgMulti {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	size_unzipped     u32
	has_size_unzipped bool
	message_body      []byte
	has_message_body  bool
}

pub fn (o &CMsgMulti) pack() []byte {
	mut res := []byte{}
	if o.has_size_unzipped {
		res << vproto.pack_uint32_field(o.size_unzipped, 1)
	}
	if o.has_message_body {
		res << vproto.pack_bytes_field(o.message_body, 2)
	}
	return res
}

pub fn cmsgmulti_unpack(buf []byte) ?CMsgMulti {
	mut res := CMsgMulti{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_size_unzipped = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.size_unzipped = v
				i = ii
			}
			2 {
				res.has_message_body = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.message_body = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgmulti() CMsgMulti {
	return CMsgMulti{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgmulti(o CMsgMulti, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgmulti(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMulti) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmulti_unpack(v)?
	return i, unpacked
}

pub struct CMsgProtobufWrapped {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	message_body     []byte
	has_message_body bool
}

pub fn (o &CMsgProtobufWrapped) pack() []byte {
	mut res := []byte{}
	if o.has_message_body {
		res << vproto.pack_bytes_field(o.message_body, 1)
	}
	return res
}

pub fn cmsgprotobufwrapped_unpack(buf []byte) ?CMsgProtobufWrapped {
	mut res := CMsgProtobufWrapped{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_message_body = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.message_body = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgprotobufwrapped() CMsgProtobufWrapped {
	return CMsgProtobufWrapped{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgprotobufwrapped(o CMsgProtobufWrapped, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgprotobufwrapped(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgProtobufWrapped) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgprotobufwrapped_unpack(v)?
	return i, unpacked
}

pub struct CMsgAuthTicket {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	estate           u32
	has_estate       bool
	eresult          u32
	has_eresult      bool
	steamid          u64
	has_steamid      bool
	gameid           u64
	has_gameid       bool
	h_steam_pipe     u32
	has_h_steam_pipe bool
	ticket_crc       u32
	has_ticket_crc   bool
	ticket           []byte
	has_ticket       bool
}

pub fn (o &CMsgAuthTicket) pack() []byte {
	mut res := []byte{}
	if o.has_estate {
		res << vproto.pack_uint32_field(o.estate, 1)
	}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 2)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 3)
	}
	if o.has_gameid {
		res << vproto.pack_64bit_field(o.gameid, 4)
	}
	if o.has_h_steam_pipe {
		res << vproto.pack_uint32_field(o.h_steam_pipe, 5)
	}
	if o.has_ticket_crc {
		res << vproto.pack_uint32_field(o.ticket_crc, 6)
	}
	if o.has_ticket {
		res << vproto.pack_bytes_field(o.ticket, 7)
	}
	return res
}

pub fn cmsgauthticket_unpack(buf []byte) ?CMsgAuthTicket {
	mut res := CMsgAuthTicket{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_estate = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.estate = v
				i = ii
			}
			2 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			3 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			4 {
				res.has_gameid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			5 {
				res.has_h_steam_pipe = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.h_steam_pipe = v
				i = ii
			}
			6 {
				res.has_ticket_crc = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ticket_crc = v
				i = ii
			}
			7 {
				res.has_ticket = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.ticket = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgauthticket() CMsgAuthTicket {
	return CMsgAuthTicket{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgauthticket(o CMsgAuthTicket, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgauthticket(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAuthTicket) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgauthticket_unpack(v)?
	return i, unpacked
}

pub struct CCDDBAppDetailCommon {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	appid                       u32
	has_appid                   bool
	name                        string
	has_name                    bool
	icon                        string
	has_icon                    bool
	logo                        string
	has_logo                    bool
	logo_small                  string
	has_logo_small              bool
	tool                        bool
	has_tool                    bool
	demo                        bool
	has_demo                    bool
	media                       bool
	has_media                   bool
	community_visible_stats     bool
	has_community_visible_stats bool
	friendly_name               string
	has_friendly_name           bool
	propagation                 string
	has_propagation             bool
	has_adult_content           bool
	has_has_adult_content       bool
}

pub fn (o &CCDDBAppDetailCommon) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	if o.has_icon {
		res << vproto.pack_string_field(o.icon, 3)
	}
	if o.has_logo {
		res << vproto.pack_string_field(o.logo, 4)
	}
	if o.has_logo_small {
		res << vproto.pack_string_field(o.logo_small, 5)
	}
	if o.has_tool {
		res << vproto.pack_bool_field(o.tool, 6)
	}
	if o.has_demo {
		res << vproto.pack_bool_field(o.demo, 7)
	}
	if o.has_media {
		res << vproto.pack_bool_field(o.media, 8)
	}
	if o.has_community_visible_stats {
		res << vproto.pack_bool_field(o.community_visible_stats, 9)
	}
	if o.has_friendly_name {
		res << vproto.pack_string_field(o.friendly_name, 10)
	}
	if o.has_propagation {
		res << vproto.pack_string_field(o.propagation, 11)
	}
	if o.has_has_adult_content {
		res << vproto.pack_bool_field(o.has_adult_content, 12)
	}
	return res
}

pub fn ccddbappdetailcommon_unpack(buf []byte) ?CCDDBAppDetailCommon {
	mut res := CCDDBAppDetailCommon{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				res.has_icon = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon = v
				i = ii
			}
			4 {
				res.has_logo = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.logo = v
				i = ii
			}
			5 {
				res.has_logo_small = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.logo_small = v
				i = ii
			}
			6 {
				res.has_tool = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.tool = v
				i = ii
			}
			7 {
				res.has_demo = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.demo = v
				i = ii
			}
			8 {
				res.has_media = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.media = v
				i = ii
			}
			9 {
				res.has_community_visible_stats = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.community_visible_stats = v
				i = ii
			}
			10 {
				res.has_friendly_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.friendly_name = v
				i = ii
			}
			11 {
				res.has_propagation = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.propagation = v
				i = ii
			}
			12 {
				res.has_has_adult_content = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.has_adult_content = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccddbappdetailcommon() CCDDBAppDetailCommon {
	return CCDDBAppDetailCommon{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccddbappdetailcommon(o CCDDBAppDetailCommon, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccddbappdetailcommon(buf []byte, tag_wiretype vproto.WireType) ?(int, CCDDBAppDetailCommon) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccddbappdetailcommon_unpack(v)?
	return i, unpacked
}

pub struct CMsgAppRights {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	edit_info                      bool
	has_edit_info                  bool
	publish                        bool
	has_publish                    bool
	view_error_data                bool
	has_view_error_data            bool
	download                       bool
	has_download                   bool
	upload_cdkeys                  bool
	has_upload_cdkeys              bool
	generate_cdkeys                bool
	has_generate_cdkeys            bool
	view_financials                bool
	has_view_financials            bool
	manage_ceg                     bool
	has_manage_ceg                 bool
	manage_signing                 bool
	has_manage_signing             bool
	manage_cdkeys                  bool
	has_manage_cdkeys              bool
	edit_marketing                 bool
	has_edit_marketing             bool
	economy_support                bool
	has_economy_support            bool
	economy_support_supervisor     bool
	has_economy_support_supervisor bool
	manage_pricing                 bool
	has_manage_pricing             bool
	broadcast_live                 bool
	has_broadcast_live             bool
	view_marketing_traffic         bool
	has_view_marketing_traffic     bool
}

pub fn (o &CMsgAppRights) pack() []byte {
	mut res := []byte{}
	if o.has_edit_info {
		res << vproto.pack_bool_field(o.edit_info, 1)
	}
	if o.has_publish {
		res << vproto.pack_bool_field(o.publish, 2)
	}
	if o.has_view_error_data {
		res << vproto.pack_bool_field(o.view_error_data, 3)
	}
	if o.has_download {
		res << vproto.pack_bool_field(o.download, 4)
	}
	if o.has_upload_cdkeys {
		res << vproto.pack_bool_field(o.upload_cdkeys, 5)
	}
	if o.has_generate_cdkeys {
		res << vproto.pack_bool_field(o.generate_cdkeys, 6)
	}
	if o.has_view_financials {
		res << vproto.pack_bool_field(o.view_financials, 7)
	}
	if o.has_manage_ceg {
		res << vproto.pack_bool_field(o.manage_ceg, 8)
	}
	if o.has_manage_signing {
		res << vproto.pack_bool_field(o.manage_signing, 9)
	}
	if o.has_manage_cdkeys {
		res << vproto.pack_bool_field(o.manage_cdkeys, 10)
	}
	if o.has_edit_marketing {
		res << vproto.pack_bool_field(o.edit_marketing, 11)
	}
	if o.has_economy_support {
		res << vproto.pack_bool_field(o.economy_support, 12)
	}
	if o.has_economy_support_supervisor {
		res << vproto.pack_bool_field(o.economy_support_supervisor, 13)
	}
	if o.has_manage_pricing {
		res << vproto.pack_bool_field(o.manage_pricing, 14)
	}
	if o.has_broadcast_live {
		res << vproto.pack_bool_field(o.broadcast_live, 15)
	}
	if o.has_view_marketing_traffic {
		res << vproto.pack_bool_field(o.view_marketing_traffic, 16)
	}
	return res
}

pub fn cmsgapprights_unpack(buf []byte) ?CMsgAppRights {
	mut res := CMsgAppRights{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_edit_info = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.edit_info = v
				i = ii
			}
			2 {
				res.has_publish = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.publish = v
				i = ii
			}
			3 {
				res.has_view_error_data = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.view_error_data = v
				i = ii
			}
			4 {
				res.has_download = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.download = v
				i = ii
			}
			5 {
				res.has_upload_cdkeys = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_cdkeys = v
				i = ii
			}
			6 {
				res.has_generate_cdkeys = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.generate_cdkeys = v
				i = ii
			}
			7 {
				res.has_view_financials = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.view_financials = v
				i = ii
			}
			8 {
				res.has_manage_ceg = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.manage_ceg = v
				i = ii
			}
			9 {
				res.has_manage_signing = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.manage_signing = v
				i = ii
			}
			10 {
				res.has_manage_cdkeys = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.manage_cdkeys = v
				i = ii
			}
			11 {
				res.has_edit_marketing = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.edit_marketing = v
				i = ii
			}
			12 {
				res.has_economy_support = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.economy_support = v
				i = ii
			}
			13 {
				res.has_economy_support_supervisor = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.economy_support_supervisor = v
				i = ii
			}
			14 {
				res.has_manage_pricing = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.manage_pricing = v
				i = ii
			}
			15 {
				res.has_broadcast_live = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_live = v
				i = ii
			}
			16 {
				res.has_view_marketing_traffic = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.view_marketing_traffic = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgapprights() CMsgAppRights {
	return CMsgAppRights{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgapprights(o CMsgAppRights, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgapprights(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAppRights) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgapprights_unpack(v)?
	return i, unpacked
}

pub struct CCuratorPreferences {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	supported_languages        u32
	has_supported_languages    bool
	platform_windows           bool
	has_platform_windows       bool
	platform_mac               bool
	has_platform_mac           bool
	platform_linux             bool
	has_platform_linux         bool
	vr_content                 bool
	has_vr_content             bool
	adult_content_violence     bool
	has_adult_content_violence bool
	adult_content_sex          bool
	has_adult_content_sex      bool
	timestamp_updated          u32
	has_timestamp_updated      bool
	tagids_curated             []u32
	tagids_filtered            []u32
	website_title              string
	has_website_title          bool
	website_url                string
	has_website_url            bool
	discussion_url             string
	has_discussion_url         bool
	show_broadcast             bool
	has_show_broadcast         bool
}

pub fn (o &CCuratorPreferences) pack() []byte {
	mut res := []byte{}
	if o.has_supported_languages {
		res << vproto.pack_uint32_field(o.supported_languages, 1)
	}
	if o.has_platform_windows {
		res << vproto.pack_bool_field(o.platform_windows, 2)
	}
	if o.has_platform_mac {
		res << vproto.pack_bool_field(o.platform_mac, 3)
	}
	if o.has_platform_linux {
		res << vproto.pack_bool_field(o.platform_linux, 4)
	}
	if o.has_vr_content {
		res << vproto.pack_bool_field(o.vr_content, 5)
	}
	if o.has_adult_content_violence {
		res << vproto.pack_bool_field(o.adult_content_violence, 6)
	}
	if o.has_adult_content_sex {
		res << vproto.pack_bool_field(o.adult_content_sex, 7)
	}
	if o.has_timestamp_updated {
		res << vproto.pack_uint32_field(o.timestamp_updated, 8)
	}
	// [packed=false]
	for _, x in o.tagids_curated {
		res << vproto.pack_uint32_field(x, 9)
	}
	// [packed=false]
	for _, x in o.tagids_filtered {
		res << vproto.pack_uint32_field(x, 10)
	}
	if o.has_website_title {
		res << vproto.pack_string_field(o.website_title, 11)
	}
	if o.has_website_url {
		res << vproto.pack_string_field(o.website_url, 12)
	}
	if o.has_discussion_url {
		res << vproto.pack_string_field(o.discussion_url, 13)
	}
	if o.has_show_broadcast {
		res << vproto.pack_bool_field(o.show_broadcast, 14)
	}
	return res
}

pub fn ccuratorpreferences_unpack(buf []byte) ?CCuratorPreferences {
	mut res := CCuratorPreferences{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_supported_languages = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.supported_languages = v
				i = ii
			}
			2 {
				res.has_platform_windows = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.platform_windows = v
				i = ii
			}
			3 {
				res.has_platform_mac = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.platform_mac = v
				i = ii
			}
			4 {
				res.has_platform_linux = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.platform_linux = v
				i = ii
			}
			5 {
				res.has_vr_content = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.vr_content = v
				i = ii
			}
			6 {
				res.has_adult_content_violence = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.adult_content_violence = v
				i = ii
			}
			7 {
				res.has_adult_content_sex = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.adult_content_sex = v
				i = ii
			}
			8 {
				res.has_timestamp_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_updated = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tagids_curated << v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tagids_filtered << v
				i = ii
			}
			11 {
				res.has_website_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.website_title = v
				i = ii
			}
			12 {
				res.has_website_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.website_url = v
				i = ii
			}
			13 {
				res.has_discussion_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.discussion_url = v
				i = ii
			}
			14 {
				res.has_show_broadcast = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.show_broadcast = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccuratorpreferences() CCuratorPreferences {
	return CCuratorPreferences{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccuratorpreferences(o CCuratorPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccuratorpreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CCuratorPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccuratorpreferences_unpack(v)?
	return i, unpacked
}

pub struct CLocalizationToken {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	language             u32
	has_language         bool
	localized_string     string
	has_localized_string bool
}

pub fn (o &CLocalizationToken) pack() []byte {
	mut res := []byte{}
	if o.has_language {
		res << vproto.pack_uint32_field(o.language, 1)
	}
	if o.has_localized_string {
		res << vproto.pack_string_field(o.localized_string, 2)
	}
	return res
}

pub fn clocalizationtoken_unpack(buf []byte) ?CLocalizationToken {
	mut res := CLocalizationToken{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_language = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			2 {
				res.has_localized_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.localized_string = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_clocalizationtoken() CLocalizationToken {
	return CLocalizationToken{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_clocalizationtoken(o CLocalizationToken, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_clocalizationtoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CLocalizationToken) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := clocalizationtoken_unpack(v)?
	return i, unpacked
}

pub struct CClanEventUserNewsTuple {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	clanid                    u32
	has_clanid                bool
	event_gid                 u64
	has_event_gid             bool
	announcement_gid          u64
	has_announcement_gid      bool
	rtime_start               u32
	has_rtime_start           bool
	rtime_end                 u32
	has_rtime_end             bool
	priority_score            u32
	has_priority_score        bool
	@type                     u32
	has_type                  bool
	clamp_range_slot          u32
	has_clamp_range_slot      bool
	appid                     u32
	has_appid                 bool
	rtime32_last_modified     u32
	has_rtime32_last_modified bool
}

pub fn (o &CClanEventUserNewsTuple) pack() []byte {
	mut res := []byte{}
	if o.has_clanid {
		res << vproto.pack_uint32_field(o.clanid, 1)
	}
	if o.has_event_gid {
		res << vproto.pack_64bit_field(o.event_gid, 2)
	}
	if o.has_announcement_gid {
		res << vproto.pack_64bit_field(o.announcement_gid, 3)
	}
	if o.has_rtime_start {
		res << vproto.pack_uint32_field(o.rtime_start, 4)
	}
	if o.has_rtime_end {
		res << vproto.pack_uint32_field(o.rtime_end, 5)
	}
	if o.has_priority_score {
		res << vproto.pack_uint32_field(o.priority_score, 6)
	}
	if o.has_type {
		res << vproto.pack_uint32_field(o.@type, 7)
	}
	if o.has_clamp_range_slot {
		res << vproto.pack_uint32_field(o.clamp_range_slot, 8)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 9)
	}
	if o.has_rtime32_last_modified {
		res << vproto.pack_uint32_field(o.rtime32_last_modified, 10)
	}
	return res
}

pub fn cclaneventusernewstuple_unpack(buf []byte) ?CClanEventUserNewsTuple {
	mut res := CClanEventUserNewsTuple{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_clanid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.clanid = v
				i = ii
			}
			2 {
				res.has_event_gid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.event_gid = v
				i = ii
			}
			3 {
				res.has_announcement_gid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.announcement_gid = v
				i = ii
			}
			4 {
				res.has_rtime_start = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_start = v
				i = ii
			}
			5 {
				res.has_rtime_end = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_end = v
				i = ii
			}
			6 {
				res.has_priority_score = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.priority_score = v
				i = ii
			}
			7 {
				res.has_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			8 {
				res.has_clamp_range_slot = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.clamp_range_slot = v
				i = ii
			}
			9 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			10 {
				res.has_rtime32_last_modified = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_last_modified = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclaneventusernewstuple() CClanEventUserNewsTuple {
	return CClanEventUserNewsTuple{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclaneventusernewstuple(o CClanEventUserNewsTuple, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclaneventusernewstuple(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanEventUserNewsTuple) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclaneventusernewstuple_unpack(v)?
	return i, unpacked
}

pub struct CClanMatchEventByRange {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	rtime_before     u32
	has_rtime_before bool
	rtime_after      u32
	has_rtime_after  bool
	qualified        u32
	has_qualified    bool
	events           []CClanEventUserNewsTuple
}

pub fn (o &CClanMatchEventByRange) pack() []byte {
	mut res := []byte{}
	if o.has_rtime_before {
		res << vproto.pack_uint32_field(o.rtime_before, 1)
	}
	if o.has_rtime_after {
		res << vproto.pack_uint32_field(o.rtime_after, 2)
	}
	if o.has_qualified {
		res << vproto.pack_uint32_field(o.qualified, 3)
	}
	// [packed=false]
	for _, x in o.events {
		res << zzz_vproto_internal_pack_cclaneventusernewstuple(x, 4)
	}
	return res
}

pub fn cclanmatcheventbyrange_unpack(buf []byte) ?CClanMatchEventByRange {
	mut res := CClanMatchEventByRange{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_rtime_before = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_before = v
				i = ii
			}
			2 {
				res.has_rtime_after = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_after = v
				i = ii
			}
			3 {
				res.has_qualified = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.qualified = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cclaneventusernewstuple(cur_buf, tag_wiretype.wire_type)?
				res.events << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclanmatcheventbyrange() CClanMatchEventByRange {
	return CClanMatchEventByRange{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclanmatcheventbyrange(o CClanMatchEventByRange, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclanmatcheventbyrange(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanMatchEventByRange) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclanmatcheventbyrange_unpack(v)?
	return i, unpacked
}

pub struct CCommunity_ClanAnnouncementInfo {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	gid                u64
	has_gid            bool
	clanid             u64
	has_clanid         bool
	posterid           u64
	has_posterid       bool
	headline           string
	has_headline       bool
	posttime           u32
	has_posttime       bool
	updatetime         u32
	has_updatetime     bool
	body               string
	has_body           bool
	commentcount       int
	has_commentcount   bool
	tags               []string
	language           int
	has_language       bool
	hidden             bool
	has_hidden         bool
	forum_topic_id     u64
	has_forum_topic_id bool
	event_gid          u64
	has_event_gid      bool
	voteupcount        int
	has_voteupcount    bool
	votedowncount      int
	has_votedowncount  bool
}

pub fn (o &CCommunity_ClanAnnouncementInfo) pack() []byte {
	mut res := []byte{}
	if o.has_gid {
		res << vproto.pack_uint64_field(o.gid, 1)
	}
	if o.has_clanid {
		res << vproto.pack_uint64_field(o.clanid, 2)
	}
	if o.has_posterid {
		res << vproto.pack_uint64_field(o.posterid, 3)
	}
	if o.has_headline {
		res << vproto.pack_string_field(o.headline, 4)
	}
	if o.has_posttime {
		res << vproto.pack_uint32_field(o.posttime, 5)
	}
	if o.has_updatetime {
		res << vproto.pack_uint32_field(o.updatetime, 6)
	}
	if o.has_body {
		res << vproto.pack_string_field(o.body, 7)
	}
	if o.has_commentcount {
		res << vproto.pack_int32_field(o.commentcount, 8)
	}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 9)
	}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 10)
	}
	if o.has_hidden {
		res << vproto.pack_bool_field(o.hidden, 11)
	}
	if o.has_forum_topic_id {
		res << vproto.pack_64bit_field(o.forum_topic_id, 12)
	}
	if o.has_event_gid {
		res << vproto.pack_64bit_field(o.event_gid, 13)
	}
	if o.has_voteupcount {
		res << vproto.pack_int32_field(o.voteupcount, 14)
	}
	if o.has_votedowncount {
		res << vproto.pack_int32_field(o.votedowncount, 15)
	}
	return res
}

pub fn ccommunity_clanannouncementinfo_unpack(buf []byte) ?CCommunity_ClanAnnouncementInfo {
	mut res := CCommunity_ClanAnnouncementInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_gid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.gid = v
				i = ii
			}
			2 {
				res.has_clanid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.clanid = v
				i = ii
			}
			3 {
				res.has_posterid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.posterid = v
				i = ii
			}
			4 {
				res.has_headline = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.headline = v
				i = ii
			}
			5 {
				res.has_posttime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.posttime = v
				i = ii
			}
			6 {
				res.has_updatetime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.updatetime = v
				i = ii
			}
			7 {
				res.has_body = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.body = v
				i = ii
			}
			8 {
				res.has_commentcount = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.commentcount = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			10 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			11 {
				res.has_hidden = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hidden = v
				i = ii
			}
			12 {
				res.has_forum_topic_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.forum_topic_id = v
				i = ii
			}
			13 {
				res.has_event_gid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.event_gid = v
				i = ii
			}
			14 {
				res.has_voteupcount = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.voteupcount = v
				i = ii
			}
			15 {
				res.has_votedowncount = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.votedowncount = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccommunity_clanannouncementinfo() CCommunity_ClanAnnouncementInfo {
	return CCommunity_ClanAnnouncementInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccommunity_clanannouncementinfo(o CCommunity_ClanAnnouncementInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccommunity_clanannouncementinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CCommunity_ClanAnnouncementInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccommunity_clanannouncementinfo_unpack(v)?
	return i, unpacked
}

pub struct CClanEventData {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	gid                          u64
	has_gid                      bool
	clan_steamid                 u64
	has_clan_steamid             bool
	event_name                   string
	has_event_name               bool
	event_type                   EProtoClanEventType
	has_event_type               bool
	appid                        u32
	has_appid                    bool
	server_address               string
	has_server_address           bool
	server_password              string
	has_server_password          bool
	rtime32_start_time           u32
	has_rtime32_start_time       bool
	rtime32_end_time             u32
	has_rtime32_end_time         bool
	comment_count                int
	has_comment_count            bool
	creator_steamid              u64
	has_creator_steamid          bool
	last_update_steamid          u64
	has_last_update_steamid      bool
	event_notes                  string
	has_event_notes              bool
	jsondata                     string
	has_jsondata                 bool
	announcement_body            CCommunity_ClanAnnouncementInfo
	has_announcement_body        bool
	published                    bool
	has_published                bool
	hidden                       bool
	has_hidden                   bool
	rtime32_visibility_start     u32
	has_rtime32_visibility_start bool
	rtime32_visibility_end       u32
	has_rtime32_visibility_end   bool
	broadcaster_accountid        u32
	has_broadcaster_accountid    bool
	follower_count               u32
	has_follower_count           bool
	ignore_count                 u32
	has_ignore_count             bool
	forum_topic_id               u64
	has_forum_topic_id           bool
	rtime32_last_modified        u32
	has_rtime32_last_modified    bool
	news_post_gid                u64
	has_news_post_gid            bool
	rtime_mod_reviewed           u32
	has_rtime_mod_reviewed       bool
}

pub fn (o &CClanEventData) pack() []byte {
	mut res := []byte{}
	if o.has_gid {
		res << vproto.pack_64bit_field(o.gid, 1)
	}
	if o.has_clan_steamid {
		res << vproto.pack_64bit_field(o.clan_steamid, 2)
	}
	if o.has_event_name {
		res << vproto.pack_string_field(o.event_name, 3)
	}
	if o.has_event_type {
		res << zzz_vproto_internal_pack_eprotoclaneventtype(o.event_type, 4)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 5)
	}
	if o.has_server_address {
		res << vproto.pack_string_field(o.server_address, 6)
	}
	if o.has_server_password {
		res << vproto.pack_string_field(o.server_password, 7)
	}
	if o.has_rtime32_start_time {
		res << vproto.pack_uint32_field(o.rtime32_start_time, 8)
	}
	if o.has_rtime32_end_time {
		res << vproto.pack_uint32_field(o.rtime32_end_time, 9)
	}
	if o.has_comment_count {
		res << vproto.pack_int32_field(o.comment_count, 10)
	}
	if o.has_creator_steamid {
		res << vproto.pack_64bit_field(o.creator_steamid, 11)
	}
	if o.has_last_update_steamid {
		res << vproto.pack_64bit_field(o.last_update_steamid, 12)
	}
	if o.has_event_notes {
		res << vproto.pack_string_field(o.event_notes, 13)
	}
	if o.has_jsondata {
		res << vproto.pack_string_field(o.jsondata, 14)
	}
	if o.has_announcement_body {
		res << zzz_vproto_internal_pack_ccommunity_clanannouncementinfo(o.announcement_body, 15)
	}
	if o.has_published {
		res << vproto.pack_bool_field(o.published, 16)
	}
	if o.has_hidden {
		res << vproto.pack_bool_field(o.hidden, 17)
	}
	if o.has_rtime32_visibility_start {
		res << vproto.pack_uint32_field(o.rtime32_visibility_start, 18)
	}
	if o.has_rtime32_visibility_end {
		res << vproto.pack_uint32_field(o.rtime32_visibility_end, 19)
	}
	if o.has_broadcaster_accountid {
		res << vproto.pack_uint32_field(o.broadcaster_accountid, 20)
	}
	if o.has_follower_count {
		res << vproto.pack_uint32_field(o.follower_count, 21)
	}
	if o.has_ignore_count {
		res << vproto.pack_uint32_field(o.ignore_count, 22)
	}
	if o.has_forum_topic_id {
		res << vproto.pack_64bit_field(o.forum_topic_id, 23)
	}
	if o.has_rtime32_last_modified {
		res << vproto.pack_uint32_field(o.rtime32_last_modified, 24)
	}
	if o.has_news_post_gid {
		res << vproto.pack_64bit_field(o.news_post_gid, 25)
	}
	if o.has_rtime_mod_reviewed {
		res << vproto.pack_uint32_field(o.rtime_mod_reviewed, 26)
	}
	return res
}

pub fn cclaneventdata_unpack(buf []byte) ?CClanEventData {
	mut res := CClanEventData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_gid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.gid = v
				i = ii
			}
			2 {
				res.has_clan_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.clan_steamid = v
				i = ii
			}
			3 {
				res.has_event_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.event_name = v
				i = ii
			}
			4 {
				res.has_event_type = true
				ii, v := zzz_vproto_internal_unpack_eprotoclaneventtype(cur_buf, tag_wiretype.wire_type)?
				res.event_type = v
				i = ii
			}
			5 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			6 {
				res.has_server_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.server_address = v
				i = ii
			}
			7 {
				res.has_server_password = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.server_password = v
				i = ii
			}
			8 {
				res.has_rtime32_start_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_start_time = v
				i = ii
			}
			9 {
				res.has_rtime32_end_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_end_time = v
				i = ii
			}
			10 {
				res.has_comment_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.comment_count = v
				i = ii
			}
			11 {
				res.has_creator_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.creator_steamid = v
				i = ii
			}
			12 {
				res.has_last_update_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.last_update_steamid = v
				i = ii
			}
			13 {
				res.has_event_notes = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.event_notes = v
				i = ii
			}
			14 {
				res.has_jsondata = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.jsondata = v
				i = ii
			}
			15 {
				res.has_announcement_body = true
				ii, v := zzz_vproto_internal_unpack_ccommunity_clanannouncementinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.announcement_body = v
				i = ii
			}
			16 {
				res.has_published = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.published = v
				i = ii
			}
			17 {
				res.has_hidden = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hidden = v
				i = ii
			}
			18 {
				res.has_rtime32_visibility_start = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_visibility_start = v
				i = ii
			}
			19 {
				res.has_rtime32_visibility_end = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_visibility_end = v
				i = ii
			}
			20 {
				res.has_broadcaster_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcaster_accountid = v
				i = ii
			}
			21 {
				res.has_follower_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.follower_count = v
				i = ii
			}
			22 {
				res.has_ignore_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ignore_count = v
				i = ii
			}
			23 {
				res.has_forum_topic_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.forum_topic_id = v
				i = ii
			}
			24 {
				res.has_rtime32_last_modified = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_last_modified = v
				i = ii
			}
			25 {
				res.has_news_post_gid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.news_post_gid = v
				i = ii
			}
			26 {
				res.has_rtime_mod_reviewed = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_mod_reviewed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclaneventdata() CClanEventData {
	return CClanEventData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclaneventdata(o CClanEventData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclaneventdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CClanEventData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclaneventdata_unpack(v)?
	return i, unpacked
}

pub struct CBilling_Address {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	first_name       string
	has_first_name   bool
	last_name        string
	has_last_name    bool
	address1         string
	has_address1     bool
	address2         string
	has_address2     bool
	city             string
	has_city         bool
	us_state         string
	has_us_state     bool
	country_code     string
	has_country_code bool
	postcode         string
	has_postcode     bool
	zip_plus4        int
	has_zip_plus4    bool
	phone            string
	has_phone        bool
}

pub fn (o &CBilling_Address) pack() []byte {
	mut res := []byte{}
	if o.has_first_name {
		res << vproto.pack_string_field(o.first_name, 1)
	}
	if o.has_last_name {
		res << vproto.pack_string_field(o.last_name, 2)
	}
	if o.has_address1 {
		res << vproto.pack_string_field(o.address1, 3)
	}
	if o.has_address2 {
		res << vproto.pack_string_field(o.address2, 4)
	}
	if o.has_city {
		res << vproto.pack_string_field(o.city, 5)
	}
	if o.has_us_state {
		res << vproto.pack_string_field(o.us_state, 6)
	}
	if o.has_country_code {
		res << vproto.pack_string_field(o.country_code, 7)
	}
	if o.has_postcode {
		res << vproto.pack_string_field(o.postcode, 8)
	}
	if o.has_zip_plus4 {
		res << vproto.pack_int32_field(o.zip_plus4, 9)
	}
	if o.has_phone {
		res << vproto.pack_string_field(o.phone, 10)
	}
	return res
}

pub fn cbilling_address_unpack(buf []byte) ?CBilling_Address {
	mut res := CBilling_Address{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_first_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.first_name = v
				i = ii
			}
			2 {
				res.has_last_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.last_name = v
				i = ii
			}
			3 {
				res.has_address1 = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.address1 = v
				i = ii
			}
			4 {
				res.has_address2 = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.address2 = v
				i = ii
			}
			5 {
				res.has_city = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.city = v
				i = ii
			}
			6 {
				res.has_us_state = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.us_state = v
				i = ii
			}
			7 {
				res.has_country_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.country_code = v
				i = ii
			}
			8 {
				res.has_postcode = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.postcode = v
				i = ii
			}
			9 {
				res.has_zip_plus4 = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.zip_plus4 = v
				i = ii
			}
			10 {
				res.has_phone = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.phone = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbilling_address() CBilling_Address {
	return CBilling_Address{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbilling_address(o CBilling_Address, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbilling_address(buf []byte, tag_wiretype vproto.WireType) ?(int, CBilling_Address) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbilling_address_unpack(v)?
	return i, unpacked
}
