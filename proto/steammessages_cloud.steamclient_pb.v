// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CCloudGetUploadServerInfoRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
}

pub fn (o &CCloudGetUploadServerInfoRequest) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn ccloudgetuploadserverinforequest_unpack(buf []byte) ?CCloudGetUploadServerInfoRequest {
	mut res := CCloudGetUploadServerInfoRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudgetuploadserverinforequest() CCloudGetUploadServerInfoRequest {
	return CCloudGetUploadServerInfoRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudgetuploadserverinforequest(o CCloudGetUploadServerInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudgetuploadserverinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudGetUploadServerInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudgetuploadserverinforequest_unpack(v)?
	return i, unpacked
}

pub struct CCloudGetUploadServerInfoResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	server_url     string
	has_server_url bool
}

pub fn (o &CCloudGetUploadServerInfoResponse) pack() []byte {
	mut res := []byte{}
	if o.has_server_url {
		res << vproto.pack_string_field(o.server_url, 1)
	}
	return res
}

pub fn ccloudgetuploadserverinforesponse_unpack(buf []byte) ?CCloudGetUploadServerInfoResponse {
	mut res := CCloudGetUploadServerInfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_server_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.server_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudgetuploadserverinforesponse() CCloudGetUploadServerInfoResponse {
	return CCloudGetUploadServerInfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudgetuploadserverinforesponse(o CCloudGetUploadServerInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudgetuploadserverinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudGetUploadServerInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudgetuploadserverinforesponse_unpack(v)?
	return i, unpacked
}

pub struct CCloudBeginHTtpuploadRequest {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	appid                  u32
	has_appid              bool
	file_size              u32
	has_file_size          bool
	filename               string
	has_filename           bool
	file_sha               string
	has_file_sha           bool
	is_public              bool
	has_is_public          bool
	platforms_to_sync      []string
	request_headers_names  []string
	request_headers_values []string
}

pub fn (o &CCloudBeginHTtpuploadRequest) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 2)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 3)
	}
	if o.has_file_sha {
		res << vproto.pack_string_field(o.file_sha, 4)
	}
	if o.has_is_public {
		res << vproto.pack_bool_field(o.is_public, 5)
	}
	// [packed=false]
	for _, x in o.platforms_to_sync {
		res << vproto.pack_string_field(x, 6)
	}
	// [packed=false]
	for _, x in o.request_headers_names {
		res << vproto.pack_string_field(x, 7)
	}
	// [packed=false]
	for _, x in o.request_headers_values {
		res << vproto.pack_string_field(x, 8)
	}
	return res
}

pub fn ccloudbeginhttpuploadrequest_unpack(buf []byte) ?CCloudBeginHTtpuploadRequest {
	mut res := CCloudBeginHTtpuploadRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			3 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			4 {
				res.has_file_sha = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_sha = v
				i = ii
			}
			5 {
				res.has_is_public = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_public = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.platforms_to_sync << v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.request_headers_names << v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.request_headers_values << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudbeginhttpuploadrequest() CCloudBeginHTtpuploadRequest {
	return CCloudBeginHTtpuploadRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudbeginhttpuploadrequest(o CCloudBeginHTtpuploadRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudbeginhttpuploadrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudBeginHTtpuploadRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudbeginhttpuploadrequest_unpack(v)?
	return i, unpacked
}

pub struct CCloudBeginHTtpuploadResponseHTtpheaders {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	value          string
	has_value      bool
}

pub fn (o &CCloudBeginHTtpuploadResponseHTtpheaders) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn ccloudbeginhttpuploadresponsehttpheaders_unpack(buf []byte) ?CCloudBeginHTtpuploadResponseHTtpheaders {
	mut res := CCloudBeginHTtpuploadResponseHTtpheaders{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudbeginhttpuploadresponsehttpheaders() CCloudBeginHTtpuploadResponseHTtpheaders {
	return CCloudBeginHTtpuploadResponseHTtpheaders{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudbeginhttpuploadresponsehttpheaders(o CCloudBeginHTtpuploadResponseHTtpheaders, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudbeginhttpuploadresponsehttpheaders(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudBeginHTtpuploadResponseHTtpheaders) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudbeginhttpuploadresponsehttpheaders_unpack(v)?
	return i, unpacked
}

pub struct CCloudBeginHTtpuploadResponse {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	ugcid           u64
	has_ugcid       bool
	timestamp       u32
	has_timestamp   bool
	url_host        string
	has_url_host    bool
	url_path        string
	has_url_path    bool
	use_https       bool
	has_use_https   bool
	request_headers []CCloudBeginHTtpuploadResponseHTtpheaders
}

pub fn (o &CCloudBeginHTtpuploadResponse) pack() []byte {
	mut res := []byte{}
	if o.has_ugcid {
		res << vproto.pack_64bit_field(o.ugcid, 1)
	}
	if o.has_timestamp {
		res << vproto.pack_32bit_field(o.timestamp, 2)
	}
	if o.has_url_host {
		res << vproto.pack_string_field(o.url_host, 3)
	}
	if o.has_url_path {
		res << vproto.pack_string_field(o.url_path, 4)
	}
	if o.has_use_https {
		res << vproto.pack_bool_field(o.use_https, 5)
	}
	// [packed=false]
	for _, x in o.request_headers {
		res << zzz_vproto_internal_pack_ccloudbeginhttpuploadresponsehttpheaders(x, 6)
	}
	return res
}

pub fn ccloudbeginhttpuploadresponse_unpack(buf []byte) ?CCloudBeginHTtpuploadResponse {
	mut res := CCloudBeginHTtpuploadResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ugcid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ugcid = v
				i = ii
			}
			2 {
				res.has_timestamp = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			3 {
				res.has_url_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_host = v
				i = ii
			}
			4 {
				res.has_url_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_path = v
				i = ii
			}
			5 {
				res.has_use_https = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_https = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccloudbeginhttpuploadresponsehttpheaders(cur_buf,
					tag_wiretype.wire_type)?
				res.request_headers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudbeginhttpuploadresponse() CCloudBeginHTtpuploadResponse {
	return CCloudBeginHTtpuploadResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudbeginhttpuploadresponse(o CCloudBeginHTtpuploadResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudbeginhttpuploadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudBeginHTtpuploadResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudbeginhttpuploadresponse_unpack(v)?
	return i, unpacked
}

pub struct CCloudCommitHTtpuploadRequest {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	transfer_succeeded     bool
	has_transfer_succeeded bool
	appid                  u32
	has_appid              bool
	file_sha               string
	has_file_sha           bool
	filename               string
	has_filename           bool
}

pub fn (o &CCloudCommitHTtpuploadRequest) pack() []byte {
	mut res := []byte{}
	if o.has_transfer_succeeded {
		res << vproto.pack_bool_field(o.transfer_succeeded, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_file_sha {
		res << vproto.pack_string_field(o.file_sha, 3)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 4)
	}
	return res
}

pub fn ccloudcommithttpuploadrequest_unpack(buf []byte) ?CCloudCommitHTtpuploadRequest {
	mut res := CCloudCommitHTtpuploadRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_transfer_succeeded = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.transfer_succeeded = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_file_sha = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_sha = v
				i = ii
			}
			4 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudcommithttpuploadrequest() CCloudCommitHTtpuploadRequest {
	return CCloudCommitHTtpuploadRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudcommithttpuploadrequest(o CCloudCommitHTtpuploadRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudcommithttpuploadrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudCommitHTtpuploadRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudcommithttpuploadrequest_unpack(v)?
	return i, unpacked
}

pub struct CCloudCommitHTtpuploadResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	file_committed     bool
	has_file_committed bool
}

pub fn (o &CCloudCommitHTtpuploadResponse) pack() []byte {
	mut res := []byte{}
	if o.has_file_committed {
		res << vproto.pack_bool_field(o.file_committed, 1)
	}
	return res
}

pub fn ccloudcommithttpuploadresponse_unpack(buf []byte) ?CCloudCommitHTtpuploadResponse {
	mut res := CCloudCommitHTtpuploadResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_file_committed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.file_committed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudcommithttpuploadresponse() CCloudCommitHTtpuploadResponse {
	return CCloudCommitHTtpuploadResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudcommithttpuploadresponse(o CCloudCommitHTtpuploadResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudcommithttpuploadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudCommitHTtpuploadResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudcommithttpuploadresponse_unpack(v)?
	return i, unpacked
}

pub struct CCloudGetFileDetailsRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ugcid          u64
	has_ugcid      bool
	appid          u32
	has_appid      bool
}

pub fn (o &CCloudGetFileDetailsRequest) pack() []byte {
	mut res := []byte{}
	if o.has_ugcid {
		res << vproto.pack_uint64_field(o.ugcid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	return res
}

pub fn ccloudgetfiledetailsrequest_unpack(buf []byte) ?CCloudGetFileDetailsRequest {
	mut res := CCloudGetFileDetailsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ugcid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.ugcid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudgetfiledetailsrequest() CCloudGetFileDetailsRequest {
	return CCloudGetFileDetailsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudgetfiledetailsrequest(o CCloudGetFileDetailsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudgetfiledetailsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudGetFileDetailsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudgetfiledetailsrequest_unpack(v)?
	return i, unpacked
}

pub struct CCloudUserFile {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	appid               u32
	has_appid           bool
	ugcid               u64
	has_ugcid           bool
	filename            string
	has_filename        bool
	timestamp           u64
	has_timestamp       bool
	file_size           u32
	has_file_size       bool
	url                 string
	has_url             bool
	steamid_creator     u64
	has_steamid_creator bool
	flags               u32
	has_flags           bool
	platforms_to_sync   []string
	file_sha            string
	has_file_sha        bool
}

pub fn (o &CCloudUserFile) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_ugcid {
		res << vproto.pack_uint64_field(o.ugcid, 2)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 3)
	}
	if o.has_timestamp {
		res << vproto.pack_uint64_field(o.timestamp, 4)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 5)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 6)
	}
	if o.has_steamid_creator {
		res << vproto.pack_64bit_field(o.steamid_creator, 7)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 8)
	}
	// [packed=false]
	for _, x in o.platforms_to_sync {
		res << vproto.pack_string_field(x, 9)
	}
	if o.has_file_sha {
		res << vproto.pack_string_field(o.file_sha, 10)
	}
	return res
}

pub fn cclouduserfile_unpack(buf []byte) ?CCloudUserFile {
	mut res := CCloudUserFile{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_ugcid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.ugcid = v
				i = ii
			}
			3 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			4 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			5 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			6 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			7 {
				res.has_steamid_creator = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_creator = v
				i = ii
			}
			8 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.platforms_to_sync << v
				i = ii
			}
			10 {
				res.has_file_sha = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_sha = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclouduserfile() CCloudUserFile {
	return CCloudUserFile{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclouduserfile(o CCloudUserFile, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclouduserfile(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudUserFile) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclouduserfile_unpack(v)?
	return i, unpacked
}

pub struct CCloudGetFileDetailsResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	details        CCloudUserFile
	has_details    bool
}

pub fn (o &CCloudGetFileDetailsResponse) pack() []byte {
	mut res := []byte{}
	if o.has_details {
		res << zzz_vproto_internal_pack_cclouduserfile(o.details, 1)
	}
	return res
}

pub fn ccloudgetfiledetailsresponse_unpack(buf []byte) ?CCloudGetFileDetailsResponse {
	mut res := CCloudGetFileDetailsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_details = true
				ii, v := zzz_vproto_internal_unpack_cclouduserfile(cur_buf, tag_wiretype.wire_type)?
				res.details = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudgetfiledetailsresponse() CCloudGetFileDetailsResponse {
	return CCloudGetFileDetailsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudgetfiledetailsresponse(o CCloudGetFileDetailsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudgetfiledetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudGetFileDetailsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudgetfiledetailsresponse_unpack(v)?
	return i, unpacked
}

pub struct CCloudEnumerateUserFilesRequest {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	appid                u32
	has_appid            bool
	extended_details     bool
	has_extended_details bool
	count                u32
	has_count            bool
	start_index          u32
	has_start_index      bool
}

pub fn (o &CCloudEnumerateUserFilesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_extended_details {
		res << vproto.pack_bool_field(o.extended_details, 2)
	}
	if o.has_count {
		res << vproto.pack_uint32_field(o.count, 3)
	}
	if o.has_start_index {
		res << vproto.pack_uint32_field(o.start_index, 4)
	}
	return res
}

pub fn ccloudenumerateuserfilesrequest_unpack(buf []byte) ?CCloudEnumerateUserFilesRequest {
	mut res := CCloudEnumerateUserFilesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_extended_details = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.extended_details = v
				i = ii
			}
			3 {
				res.has_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			4 {
				res.has_start_index = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_index = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudenumerateuserfilesrequest() CCloudEnumerateUserFilesRequest {
	return CCloudEnumerateUserFilesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudenumerateuserfilesrequest(o CCloudEnumerateUserFilesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudenumerateuserfilesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudEnumerateUserFilesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudenumerateuserfilesrequest_unpack(v)?
	return i, unpacked
}

pub struct CCloudEnumerateUserFilesResponse {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	files           []CCloudUserFile
	total_files     u32
	has_total_files bool
}

pub fn (o &CCloudEnumerateUserFilesResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.files {
		res << zzz_vproto_internal_pack_cclouduserfile(x, 1)
	}
	if o.has_total_files {
		res << vproto.pack_uint32_field(o.total_files, 2)
	}
	return res
}

pub fn ccloudenumerateuserfilesresponse_unpack(buf []byte) ?CCloudEnumerateUserFilesResponse {
	mut res := CCloudEnumerateUserFilesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cclouduserfile(cur_buf, tag_wiretype.wire_type)?
				res.files << v
				i = ii
			}
			2 {
				res.has_total_files = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_files = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudenumerateuserfilesresponse() CCloudEnumerateUserFilesResponse {
	return CCloudEnumerateUserFilesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudenumerateuserfilesresponse(o CCloudEnumerateUserFilesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudenumerateuserfilesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudEnumerateUserFilesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudenumerateuserfilesresponse_unpack(v)?
	return i, unpacked
}

pub struct CCloudDeleteRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	filename       string
	has_filename   bool
	appid          u32
	has_appid      bool
}

pub fn (o &CCloudDeleteRequest) pack() []byte {
	mut res := []byte{}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	return res
}

pub fn cclouddeleterequest_unpack(buf []byte) ?CCloudDeleteRequest {
	mut res := CCloudDeleteRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclouddeleterequest() CCloudDeleteRequest {
	return CCloudDeleteRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclouddeleterequest(o CCloudDeleteRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclouddeleterequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudDeleteRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclouddeleterequest_unpack(v)?
	return i, unpacked
}

pub struct CCloudDeleteResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CCloudDeleteResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cclouddeleteresponse_unpack(buf []byte) ?CCloudDeleteResponse {
	res := CCloudDeleteResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclouddeleteresponse() CCloudDeleteResponse {
	return CCloudDeleteResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclouddeleteresponse(o CCloudDeleteResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclouddeleteresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudDeleteResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclouddeleteresponse_unpack(v)?
	return i, unpacked
}

pub struct CCloudGetClientEncryptionKeyRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CCloudGetClientEncryptionKeyRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn ccloudgetclientencryptionkeyrequest_unpack(buf []byte) ?CCloudGetClientEncryptionKeyRequest {
	res := CCloudGetClientEncryptionKeyRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudgetclientencryptionkeyrequest() CCloudGetClientEncryptionKeyRequest {
	return CCloudGetClientEncryptionKeyRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudgetclientencryptionkeyrequest(o CCloudGetClientEncryptionKeyRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudgetclientencryptionkeyrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudGetClientEncryptionKeyRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudgetclientencryptionkeyrequest_unpack(v)?
	return i, unpacked
}

pub struct CCloudGetClientEncryptionKeyResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            []byte
	has_key        bool
	crc            int
	has_crc        bool
}

pub fn (o &CCloudGetClientEncryptionKeyResponse) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_bytes_field(o.key, 1)
	}
	if o.has_crc {
		res << vproto.pack_int32_field(o.crc, 2)
	}
	return res
}

pub fn ccloudgetclientencryptionkeyresponse_unpack(buf []byte) ?CCloudGetClientEncryptionKeyResponse {
	mut res := CCloudGetClientEncryptionKeyResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_crc = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.crc = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudgetclientencryptionkeyresponse() CCloudGetClientEncryptionKeyResponse {
	return CCloudGetClientEncryptionKeyResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudgetclientencryptionkeyresponse(o CCloudGetClientEncryptionKeyResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudgetclientencryptionkeyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudGetClientEncryptionKeyResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudgetclientencryptionkeyresponse_unpack(v)?
	return i, unpacked
}

pub struct CCloudCDnreportNotification {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	steamid              u64
	has_steamid          bool
	url                  string
	has_url              bool
	success              bool
	has_success          bool
	http_status_code     u32
	has_http_status_code bool
	expected_bytes       u64
	has_expected_bytes   bool
	received_bytes       u64
	has_received_bytes   bool
	duration             u32
	has_duration         bool
}

pub fn (o &CCloudCDnreportNotification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_success {
		res << vproto.pack_bool_field(o.success, 3)
	}
	if o.has_http_status_code {
		res << vproto.pack_uint32_field(o.http_status_code, 4)
	}
	if o.has_expected_bytes {
		res << vproto.pack_uint64_field(o.expected_bytes, 5)
	}
	if o.has_received_bytes {
		res << vproto.pack_uint64_field(o.received_bytes, 6)
	}
	if o.has_duration {
		res << vproto.pack_uint32_field(o.duration, 7)
	}
	return res
}

pub fn ccloudcdnreportnotification_unpack(buf []byte) ?CCloudCDnreportNotification {
	mut res := CCloudCDnreportNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_success = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.success = v
				i = ii
			}
			4 {
				res.has_http_status_code = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.http_status_code = v
				i = ii
			}
			5 {
				res.has_expected_bytes = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.expected_bytes = v
				i = ii
			}
			6 {
				res.has_received_bytes = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.received_bytes = v
				i = ii
			}
			7 {
				res.has_duration = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.duration = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudcdnreportnotification() CCloudCDnreportNotification {
	return CCloudCDnreportNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudcdnreportnotification(o CCloudCDnreportNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudcdnreportnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudCDnreportNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudcdnreportnotification_unpack(v)?
	return i, unpacked
}

pub struct CCloudExternalStorageTransferReportNotification {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	host                 string
	has_host             bool
	path                 string
	has_path             bool
	is_upload            bool
	has_is_upload        bool
	success              bool
	has_success          bool
	http_status_code     u32
	has_http_status_code bool
	bytes_expected       u64
	has_bytes_expected   bool
	bytes_actual         u64
	has_bytes_actual     bool
	duration_ms          u32
	has_duration_ms      bool
	cellid               u32
	has_cellid           bool
	proxied              bool
	has_proxied          bool
	ipv6_local           bool
	has_ipv6_local       bool
	ipv6_remote          bool
	has_ipv6_remote      bool
}

pub fn (o &CCloudExternalStorageTransferReportNotification) pack() []byte {
	mut res := []byte{}
	if o.has_host {
		res << vproto.pack_string_field(o.host, 1)
	}
	if o.has_path {
		res << vproto.pack_string_field(o.path, 2)
	}
	if o.has_is_upload {
		res << vproto.pack_bool_field(o.is_upload, 3)
	}
	if o.has_success {
		res << vproto.pack_bool_field(o.success, 4)
	}
	if o.has_http_status_code {
		res << vproto.pack_uint32_field(o.http_status_code, 5)
	}
	if o.has_bytes_expected {
		res << vproto.pack_uint64_field(o.bytes_expected, 6)
	}
	if o.has_bytes_actual {
		res << vproto.pack_uint64_field(o.bytes_actual, 7)
	}
	if o.has_duration_ms {
		res << vproto.pack_uint32_field(o.duration_ms, 8)
	}
	if o.has_cellid {
		res << vproto.pack_uint32_field(o.cellid, 9)
	}
	if o.has_proxied {
		res << vproto.pack_bool_field(o.proxied, 10)
	}
	if o.has_ipv6_local {
		res << vproto.pack_bool_field(o.ipv6_local, 11)
	}
	if o.has_ipv6_remote {
		res << vproto.pack_bool_field(o.ipv6_remote, 12)
	}
	return res
}

pub fn ccloudexternalstoragetransferreportnotification_unpack(buf []byte) ?CCloudExternalStorageTransferReportNotification {
	mut res := CCloudExternalStorageTransferReportNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.host = v
				i = ii
			}
			2 {
				res.has_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.path = v
				i = ii
			}
			3 {
				res.has_is_upload = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_upload = v
				i = ii
			}
			4 {
				res.has_success = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.success = v
				i = ii
			}
			5 {
				res.has_http_status_code = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.http_status_code = v
				i = ii
			}
			6 {
				res.has_bytes_expected = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_expected = v
				i = ii
			}
			7 {
				res.has_bytes_actual = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_actual = v
				i = ii
			}
			8 {
				res.has_duration_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.duration_ms = v
				i = ii
			}
			9 {
				res.has_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cellid = v
				i = ii
			}
			10 {
				res.has_proxied = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.proxied = v
				i = ii
			}
			11 {
				res.has_ipv6_local = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ipv6_local = v
				i = ii
			}
			12 {
				res.has_ipv6_remote = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ipv6_remote = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudexternalstoragetransferreportnotification() CCloudExternalStorageTransferReportNotification {
	return CCloudExternalStorageTransferReportNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudexternalstoragetransferreportnotification(o CCloudExternalStorageTransferReportNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudexternalstoragetransferreportnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudExternalStorageTransferReportNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudexternalstoragetransferreportnotification_unpack(v)?
	return i, unpacked
}

pub struct CCloudClientBeginFileUploadRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	appid                 u32
	has_appid             bool
	file_size             u32
	has_file_size         bool
	raw_file_size         u32
	has_raw_file_size     bool
	file_sha              []byte
	has_file_sha          bool
	time_stamp            u64
	has_time_stamp        bool
	filename              string
	has_filename          bool
	platforms_to_sync     u32
	has_platforms_to_sync bool
	cell_id               u32
	has_cell_id           bool
	can_encrypt           bool
	has_can_encrypt       bool
	is_shared_file        bool
	has_is_shared_file    bool
	realm                 u32
	has_realm             bool
}

pub fn (o &CCloudClientBeginFileUploadRequest) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 2)
	}
	if o.has_raw_file_size {
		res << vproto.pack_uint32_field(o.raw_file_size, 3)
	}
	if o.has_file_sha {
		res << vproto.pack_bytes_field(o.file_sha, 4)
	}
	if o.has_time_stamp {
		res << vproto.pack_uint64_field(o.time_stamp, 5)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 6)
	}
	if o.has_platforms_to_sync {
		res << vproto.pack_uint32_field(o.platforms_to_sync, 7)
	}
	if o.has_cell_id {
		res << vproto.pack_uint32_field(o.cell_id, 9)
	}
	if o.has_can_encrypt {
		res << vproto.pack_bool_field(o.can_encrypt, 10)
	}
	if o.has_is_shared_file {
		res << vproto.pack_bool_field(o.is_shared_file, 11)
	}
	if o.has_realm {
		res << vproto.pack_uint32_field(o.realm, 12)
	}
	return res
}

pub fn ccloudclientbeginfileuploadrequest_unpack(buf []byte) ?CCloudClientBeginFileUploadRequest {
	mut res := CCloudClientBeginFileUploadRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			3 {
				res.has_raw_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.raw_file_size = v
				i = ii
			}
			4 {
				res.has_file_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.file_sha = v
				i = ii
			}
			5 {
				res.has_time_stamp = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.time_stamp = v
				i = ii
			}
			6 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			7 {
				res.has_platforms_to_sync = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.platforms_to_sync = v
				i = ii
			}
			9 {
				res.has_cell_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			10 {
				res.has_can_encrypt = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_encrypt = v
				i = ii
			}
			11 {
				res.has_is_shared_file = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_shared_file = v
				i = ii
			}
			12 {
				res.has_realm = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.realm = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudclientbeginfileuploadrequest() CCloudClientBeginFileUploadRequest {
	return CCloudClientBeginFileUploadRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudclientbeginfileuploadrequest(o CCloudClientBeginFileUploadRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudclientbeginfileuploadrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudClientBeginFileUploadRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudclientbeginfileuploadrequest_unpack(v)?
	return i, unpacked
}

pub struct ClientCloudFileUploadBlockDetailsHTtpheaders {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	value          string
	has_value      bool
}

pub fn (o &ClientCloudFileUploadBlockDetailsHTtpheaders) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn clientcloudfileuploadblockdetailshttpheaders_unpack(buf []byte) ?ClientCloudFileUploadBlockDetailsHTtpheaders {
	mut res := ClientCloudFileUploadBlockDetailsHTtpheaders{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_clientcloudfileuploadblockdetailshttpheaders() ClientCloudFileUploadBlockDetailsHTtpheaders {
	return ClientCloudFileUploadBlockDetailsHTtpheaders{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_clientcloudfileuploadblockdetailshttpheaders(o ClientCloudFileUploadBlockDetailsHTtpheaders, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_clientcloudfileuploadblockdetailshttpheaders(buf []byte, tag_wiretype vproto.WireType) ?(int, ClientCloudFileUploadBlockDetailsHTtpheaders) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := clientcloudfileuploadblockdetailshttpheaders_unpack(v)?
	return i, unpacked
}

pub struct ClientCloudFileUploadBlockDetails {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	url_host               string
	has_url_host           bool
	url_path               string
	has_url_path           bool
	use_https              bool
	has_use_https          bool
	http_method            int
	has_http_method        bool
	request_headers        []ClientCloudFileUploadBlockDetailsHTtpheaders
	block_offset           u64
	has_block_offset       bool
	block_length           u32
	has_block_length       bool
	explicit_body_data     []byte
	has_explicit_body_data bool
	may_parallelize        bool
	has_may_parallelize    bool
}

pub fn (o &ClientCloudFileUploadBlockDetails) pack() []byte {
	mut res := []byte{}
	if o.has_url_host {
		res << vproto.pack_string_field(o.url_host, 1)
	}
	if o.has_url_path {
		res << vproto.pack_string_field(o.url_path, 2)
	}
	if o.has_use_https {
		res << vproto.pack_bool_field(o.use_https, 3)
	}
	if o.has_http_method {
		res << vproto.pack_int32_field(o.http_method, 4)
	}
	// [packed=false]
	for _, x in o.request_headers {
		res << zzz_vproto_internal_pack_clientcloudfileuploadblockdetailshttpheaders(x, 5)
	}
	if o.has_block_offset {
		res << vproto.pack_uint64_field(o.block_offset, 6)
	}
	if o.has_block_length {
		res << vproto.pack_uint32_field(o.block_length, 7)
	}
	if o.has_explicit_body_data {
		res << vproto.pack_bytes_field(o.explicit_body_data, 8)
	}
	if o.has_may_parallelize {
		res << vproto.pack_bool_field(o.may_parallelize, 9)
	}
	return res
}

pub fn clientcloudfileuploadblockdetails_unpack(buf []byte) ?ClientCloudFileUploadBlockDetails {
	mut res := ClientCloudFileUploadBlockDetails{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_url_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_host = v
				i = ii
			}
			2 {
				res.has_url_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_path = v
				i = ii
			}
			3 {
				res.has_use_https = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_https = v
				i = ii
			}
			4 {
				res.has_http_method = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.http_method = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_clientcloudfileuploadblockdetailshttpheaders(cur_buf,
					tag_wiretype.wire_type)?
				res.request_headers << v
				i = ii
			}
			6 {
				res.has_block_offset = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.block_offset = v
				i = ii
			}
			7 {
				res.has_block_length = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.block_length = v
				i = ii
			}
			8 {
				res.has_explicit_body_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.explicit_body_data = v
				i = ii
			}
			9 {
				res.has_may_parallelize = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.may_parallelize = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_clientcloudfileuploadblockdetails() ClientCloudFileUploadBlockDetails {
	return ClientCloudFileUploadBlockDetails{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_clientcloudfileuploadblockdetails(o ClientCloudFileUploadBlockDetails, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_clientcloudfileuploadblockdetails(buf []byte, tag_wiretype vproto.WireType) ?(int, ClientCloudFileUploadBlockDetails) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := clientcloudfileuploadblockdetails_unpack(v)?
	return i, unpacked
}

pub struct CCloudClientBeginFileUploadResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	encrypt_file     bool
	has_encrypt_file bool
	block_requests   []ClientCloudFileUploadBlockDetails
}

pub fn (o &CCloudClientBeginFileUploadResponse) pack() []byte {
	mut res := []byte{}
	if o.has_encrypt_file {
		res << vproto.pack_bool_field(o.encrypt_file, 1)
	}
	// [packed=false]
	for _, x in o.block_requests {
		res << zzz_vproto_internal_pack_clientcloudfileuploadblockdetails(x, 2)
	}
	return res
}

pub fn ccloudclientbeginfileuploadresponse_unpack(buf []byte) ?CCloudClientBeginFileUploadResponse {
	mut res := CCloudClientBeginFileUploadResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_encrypt_file = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.encrypt_file = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_clientcloudfileuploadblockdetails(cur_buf,
					tag_wiretype.wire_type)?
				res.block_requests << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudclientbeginfileuploadresponse() CCloudClientBeginFileUploadResponse {
	return CCloudClientBeginFileUploadResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudclientbeginfileuploadresponse(o CCloudClientBeginFileUploadResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudclientbeginfileuploadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudClientBeginFileUploadResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudclientbeginfileuploadresponse_unpack(v)?
	return i, unpacked
}

pub struct CCloudClientCommitFileUploadRequest {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	transfer_succeeded     bool
	has_transfer_succeeded bool
	appid                  u32
	has_appid              bool
	file_sha               []byte
	has_file_sha           bool
	filename               string
	has_filename           bool
}

pub fn (o &CCloudClientCommitFileUploadRequest) pack() []byte {
	mut res := []byte{}
	if o.has_transfer_succeeded {
		res << vproto.pack_bool_field(o.transfer_succeeded, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_file_sha {
		res << vproto.pack_bytes_field(o.file_sha, 3)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 4)
	}
	return res
}

pub fn ccloudclientcommitfileuploadrequest_unpack(buf []byte) ?CCloudClientCommitFileUploadRequest {
	mut res := CCloudClientCommitFileUploadRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_transfer_succeeded = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.transfer_succeeded = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_file_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.file_sha = v
				i = ii
			}
			4 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudclientcommitfileuploadrequest() CCloudClientCommitFileUploadRequest {
	return CCloudClientCommitFileUploadRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudclientcommitfileuploadrequest(o CCloudClientCommitFileUploadRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudclientcommitfileuploadrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudClientCommitFileUploadRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudclientcommitfileuploadrequest_unpack(v)?
	return i, unpacked
}

pub struct CCloudClientCommitFileUploadResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	file_committed     bool
	has_file_committed bool
}

pub fn (o &CCloudClientCommitFileUploadResponse) pack() []byte {
	mut res := []byte{}
	if o.has_file_committed {
		res << vproto.pack_bool_field(o.file_committed, 1)
	}
	return res
}

pub fn ccloudclientcommitfileuploadresponse_unpack(buf []byte) ?CCloudClientCommitFileUploadResponse {
	mut res := CCloudClientCommitFileUploadResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_file_committed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.file_committed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudclientcommitfileuploadresponse() CCloudClientCommitFileUploadResponse {
	return CCloudClientCommitFileUploadResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudclientcommitfileuploadresponse(o CCloudClientCommitFileUploadResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudclientcommitfileuploadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudClientCommitFileUploadResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudclientcommitfileuploadresponse_unpack(v)?
	return i, unpacked
}

pub struct CCloudClientFileDownloadRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	filename       string
	has_filename   bool
	realm          u32
	has_realm      bool
}

pub fn (o &CCloudClientFileDownloadRequest) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 2)
	}
	if o.has_realm {
		res << vproto.pack_uint32_field(o.realm, 3)
	}
	return res
}

pub fn ccloudclientfiledownloadrequest_unpack(buf []byte) ?CCloudClientFileDownloadRequest {
	mut res := CCloudClientFileDownloadRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			3 {
				res.has_realm = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.realm = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudclientfiledownloadrequest() CCloudClientFileDownloadRequest {
	return CCloudClientFileDownloadRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudclientfiledownloadrequest(o CCloudClientFileDownloadRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudclientfiledownloadrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudClientFileDownloadRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudclientfiledownloadrequest_unpack(v)?
	return i, unpacked
}

pub struct CCloudClientFileDownloadResponseHTtpheaders {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	value          string
	has_value      bool
}

pub fn (o &CCloudClientFileDownloadResponseHTtpheaders) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn ccloudclientfiledownloadresponsehttpheaders_unpack(buf []byte) ?CCloudClientFileDownloadResponseHTtpheaders {
	mut res := CCloudClientFileDownloadResponseHTtpheaders{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudclientfiledownloadresponsehttpheaders() CCloudClientFileDownloadResponseHTtpheaders {
	return CCloudClientFileDownloadResponseHTtpheaders{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudclientfiledownloadresponsehttpheaders(o CCloudClientFileDownloadResponseHTtpheaders, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudclientfiledownloadresponsehttpheaders(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudClientFileDownloadResponseHTtpheaders) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudclientfiledownloadresponsehttpheaders_unpack(v)?
	return i, unpacked
}

pub struct CCloudClientFileDownloadResponse {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	appid                  u32
	has_appid              bool
	file_size              u32
	has_file_size          bool
	raw_file_size          u32
	has_raw_file_size      bool
	sha_file               []byte
	has_sha_file           bool
	time_stamp             u64
	has_time_stamp         bool
	is_explicit_delete     bool
	has_is_explicit_delete bool
	url_host               string
	has_url_host           bool
	url_path               string
	has_url_path           bool
	use_https              bool
	has_use_https          bool
	request_headers        []CCloudClientFileDownloadResponseHTtpheaders
	encrypted              bool
	has_encrypted          bool
}

pub fn (o &CCloudClientFileDownloadResponse) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 2)
	}
	if o.has_raw_file_size {
		res << vproto.pack_uint32_field(o.raw_file_size, 3)
	}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 4)
	}
	if o.has_time_stamp {
		res << vproto.pack_uint64_field(o.time_stamp, 5)
	}
	if o.has_is_explicit_delete {
		res << vproto.pack_bool_field(o.is_explicit_delete, 6)
	}
	if o.has_url_host {
		res << vproto.pack_string_field(o.url_host, 7)
	}
	if o.has_url_path {
		res << vproto.pack_string_field(o.url_path, 8)
	}
	if o.has_use_https {
		res << vproto.pack_bool_field(o.use_https, 9)
	}
	// [packed=false]
	for _, x in o.request_headers {
		res << zzz_vproto_internal_pack_ccloudclientfiledownloadresponsehttpheaders(x, 10)
	}
	if o.has_encrypted {
		res << vproto.pack_bool_field(o.encrypted, 11)
	}
	return res
}

pub fn ccloudclientfiledownloadresponse_unpack(buf []byte) ?CCloudClientFileDownloadResponse {
	mut res := CCloudClientFileDownloadResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			3 {
				res.has_raw_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.raw_file_size = v
				i = ii
			}
			4 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			5 {
				res.has_time_stamp = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.time_stamp = v
				i = ii
			}
			6 {
				res.has_is_explicit_delete = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_explicit_delete = v
				i = ii
			}
			7 {
				res.has_url_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_host = v
				i = ii
			}
			8 {
				res.has_url_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_path = v
				i = ii
			}
			9 {
				res.has_use_https = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_https = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccloudclientfiledownloadresponsehttpheaders(cur_buf,
					tag_wiretype.wire_type)?
				res.request_headers << v
				i = ii
			}
			11 {
				res.has_encrypted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.encrypted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudclientfiledownloadresponse() CCloudClientFileDownloadResponse {
	return CCloudClientFileDownloadResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudclientfiledownloadresponse(o CCloudClientFileDownloadResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudclientfiledownloadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudClientFileDownloadResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudclientfiledownloadresponse_unpack(v)?
	return i, unpacked
}

pub struct CCloudClientDeleteFileRequest {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	appid                  u32
	has_appid              bool
	filename               string
	has_filename           bool
	is_explicit_delete     bool
	has_is_explicit_delete bool
}

pub fn (o &CCloudClientDeleteFileRequest) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 2)
	}
	if o.has_is_explicit_delete {
		res << vproto.pack_bool_field(o.is_explicit_delete, 3)
	}
	return res
}

pub fn ccloudclientdeletefilerequest_unpack(buf []byte) ?CCloudClientDeleteFileRequest {
	mut res := CCloudClientDeleteFileRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			3 {
				res.has_is_explicit_delete = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_explicit_delete = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudclientdeletefilerequest() CCloudClientDeleteFileRequest {
	return CCloudClientDeleteFileRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudclientdeletefilerequest(o CCloudClientDeleteFileRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudclientdeletefilerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudClientDeleteFileRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudclientdeletefilerequest_unpack(v)?
	return i, unpacked
}

pub struct CCloudClientDeleteFileResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CCloudClientDeleteFileResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn ccloudclientdeletefileresponse_unpack(buf []byte) ?CCloudClientDeleteFileResponse {
	res := CCloudClientDeleteFileResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudclientdeletefileresponse() CCloudClientDeleteFileResponse {
	return CCloudClientDeleteFileResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudclientdeletefileresponse(o CCloudClientDeleteFileResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudclientdeletefileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudClientDeleteFileResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudclientdeletefileresponse_unpack(v)?
	return i, unpacked
}

pub struct CCloudClientConflictResolutionNotification {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	appid                 u32
	has_appid             bool
	chose_local_files     bool
	has_chose_local_files bool
}

pub fn (o &CCloudClientConflictResolutionNotification) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_chose_local_files {
		res << vproto.pack_bool_field(o.chose_local_files, 2)
	}
	return res
}

pub fn ccloudclientconflictresolutionnotification_unpack(buf []byte) ?CCloudClientConflictResolutionNotification {
	mut res := CCloudClientConflictResolutionNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_chose_local_files = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.chose_local_files = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudclientconflictresolutionnotification() CCloudClientConflictResolutionNotification {
	return CCloudClientConflictResolutionNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudclientconflictresolutionnotification(o CCloudClientConflictResolutionNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudclientconflictresolutionnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudClientConflictResolutionNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudclientconflictresolutionnotification_unpack(v)?
	return i, unpacked
}

pub struct CCloudEnumerateUserAppsRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CCloudEnumerateUserAppsRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn ccloudenumerateuserappsrequest_unpack(buf []byte) ?CCloudEnumerateUserAppsRequest {
	res := CCloudEnumerateUserAppsRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudenumerateuserappsrequest() CCloudEnumerateUserAppsRequest {
	return CCloudEnumerateUserAppsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudenumerateuserappsrequest(o CCloudEnumerateUserAppsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudenumerateuserappsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudEnumerateUserAppsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudenumerateuserappsrequest_unpack(v)?
	return i, unpacked
}

pub struct CCloudEnumerateUserAppsResponseApps {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	totalcount     int
	has_totalcount bool
	totalsize      i64
	has_totalsize  bool
}

pub fn (o &CCloudEnumerateUserAppsResponseApps) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_totalcount {
		res << vproto.pack_int32_field(o.totalcount, 2)
	}
	if o.has_totalsize {
		res << vproto.pack_int64_field(o.totalsize, 3)
	}
	return res
}

pub fn ccloudenumerateuserappsresponseapps_unpack(buf []byte) ?CCloudEnumerateUserAppsResponseApps {
	mut res := CCloudEnumerateUserAppsResponseApps{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_totalcount = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.totalcount = v
				i = ii
			}
			3 {
				res.has_totalsize = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
				res.totalsize = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudenumerateuserappsresponseapps() CCloudEnumerateUserAppsResponseApps {
	return CCloudEnumerateUserAppsResponseApps{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudenumerateuserappsresponseapps(o CCloudEnumerateUserAppsResponseApps, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudenumerateuserappsresponseapps(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudEnumerateUserAppsResponseApps) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudenumerateuserappsresponseapps_unpack(v)?
	return i, unpacked
}

pub struct CCloudEnumerateUserAppsResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	apps           []CCloudEnumerateUserAppsResponseApps
}

pub fn (o &CCloudEnumerateUserAppsResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_ccloudenumerateuserappsresponseapps(x, 1)
	}
	return res
}

pub fn ccloudenumerateuserappsresponse_unpack(buf []byte) ?CCloudEnumerateUserAppsResponse {
	mut res := CCloudEnumerateUserAppsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccloudenumerateuserappsresponseapps(cur_buf,
					tag_wiretype.wire_type)?
				res.apps << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloudenumerateuserappsresponse() CCloudEnumerateUserAppsResponse {
	return CCloudEnumerateUserAppsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloudenumerateuserappsresponse(o CCloudEnumerateUserAppsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloudenumerateuserappsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloudEnumerateUserAppsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloudenumerateuserappsresponse_unpack(v)?
	return i, unpacked
}
