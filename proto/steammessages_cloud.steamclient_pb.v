// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CCloud_GetUploadServerInfo_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
}

pub fn (o &CCloud_GetUploadServerInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn ccloud_getuploadserverinfo_request_unpack(buf []byte) ?CCloud_GetUploadServerInfo_Request {
	mut res := CCloud_GetUploadServerInfo_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_getuploadserverinfo_request() CCloud_GetUploadServerInfo_Request {
	return CCloud_GetUploadServerInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_getuploadserverinfo_request(o CCloud_GetUploadServerInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_getuploadserverinfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_GetUploadServerInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_getuploadserverinfo_request_unpack(v)?
	return i, unpacked
}

pub struct CCloud_GetUploadServerInfo_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	server_url     string
	has_server_url bool
}

pub fn (o &CCloud_GetUploadServerInfo_Response) pack() []byte {
	mut res := []byte{}
	if o.has_server_url {
		res << vproto.pack_string_field(o.server_url, 1)
	}
	return res
}

pub fn ccloud_getuploadserverinfo_response_unpack(buf []byte) ?CCloud_GetUploadServerInfo_Response {
	mut res := CCloud_GetUploadServerInfo_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_server_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.server_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_getuploadserverinfo_response() CCloud_GetUploadServerInfo_Response {
	return CCloud_GetUploadServerInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_getuploadserverinfo_response(o CCloud_GetUploadServerInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_getuploadserverinfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_GetUploadServerInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_getuploadserverinfo_response_unpack(v)?
	return i, unpacked
}

pub struct CCloud_BeginHTTPUpload_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	appid                  u32
	has_appid              bool
	file_size              u32
	has_file_size          bool
	filename               string
	has_filename           bool
	file_sha               string
	has_file_sha           bool
	is_public              bool
	has_is_public          bool
	platforms_to_sync      []string
	request_headers_names  []string
	request_headers_values []string
}

pub fn (o &CCloud_BeginHTTPUpload_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 2)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 3)
	}
	if o.has_file_sha {
		res << vproto.pack_string_field(o.file_sha, 4)
	}
	if o.has_is_public {
		res << vproto.pack_bool_field(o.is_public, 5)
	}
	// [packed=false]
	for _, x in o.platforms_to_sync {
		res << vproto.pack_string_field(x, 6)
	}
	// [packed=false]
	for _, x in o.request_headers_names {
		res << vproto.pack_string_field(x, 7)
	}
	// [packed=false]
	for _, x in o.request_headers_values {
		res << vproto.pack_string_field(x, 8)
	}
	return res
}

pub fn ccloud_beginhttpupload_request_unpack(buf []byte) ?CCloud_BeginHTTPUpload_Request {
	mut res := CCloud_BeginHTTPUpload_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			3 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			4 {
				res.has_file_sha = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_sha = v
				i = ii
			}
			5 {
				res.has_is_public = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_public = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.platforms_to_sync << v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.request_headers_names << v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.request_headers_values << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_beginhttpupload_request() CCloud_BeginHTTPUpload_Request {
	return CCloud_BeginHTTPUpload_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_beginhttpupload_request(o CCloud_BeginHTTPUpload_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_beginhttpupload_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_BeginHTTPUpload_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_beginhttpupload_request_unpack(v)?
	return i, unpacked
}

pub struct CCloud_BeginHTTPUpload_Response_HTTPHeaders {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	value          string
	has_value      bool
}

pub fn (o &CCloud_BeginHTTPUpload_Response_HTTPHeaders) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn ccloud_beginhttpupload_response_httpheaders_unpack(buf []byte) ?CCloud_BeginHTTPUpload_Response_HTTPHeaders {
	mut res := CCloud_BeginHTTPUpload_Response_HTTPHeaders{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_beginhttpupload_response_httpheaders() CCloud_BeginHTTPUpload_Response_HTTPHeaders {
	return CCloud_BeginHTTPUpload_Response_HTTPHeaders{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_beginhttpupload_response_httpheaders(o CCloud_BeginHTTPUpload_Response_HTTPHeaders, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_beginhttpupload_response_httpheaders(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_BeginHTTPUpload_Response_HTTPHeaders) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_beginhttpupload_response_httpheaders_unpack(v)?
	return i, unpacked
}

pub struct CCloud_BeginHTTPUpload_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	ugcid           u64
	has_ugcid       bool
	timestamp       u32
	has_timestamp   bool
	url_host        string
	has_url_host    bool
	url_path        string
	has_url_path    bool
	use_https       bool
	has_use_https   bool
	request_headers []CCloud_BeginHTTPUpload_Response_HTTPHeaders
}

pub fn (o &CCloud_BeginHTTPUpload_Response) pack() []byte {
	mut res := []byte{}
	if o.has_ugcid {
		res << vproto.pack_64bit_field(o.ugcid, 1)
	}
	if o.has_timestamp {
		res << vproto.pack_32bit_field(o.timestamp, 2)
	}
	if o.has_url_host {
		res << vproto.pack_string_field(o.url_host, 3)
	}
	if o.has_url_path {
		res << vproto.pack_string_field(o.url_path, 4)
	}
	if o.has_use_https {
		res << vproto.pack_bool_field(o.use_https, 5)
	}
	// [packed=false]
	for _, x in o.request_headers {
		res << zzz_vproto_internal_pack_ccloud_beginhttpupload_response_httpheaders(x, 6)
	}
	return res
}

pub fn ccloud_beginhttpupload_response_unpack(buf []byte) ?CCloud_BeginHTTPUpload_Response {
	mut res := CCloud_BeginHTTPUpload_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ugcid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ugcid = v
				i = ii
			}
			2 {
				res.has_timestamp = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			3 {
				res.has_url_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_host = v
				i = ii
			}
			4 {
				res.has_url_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_path = v
				i = ii
			}
			5 {
				res.has_use_https = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_https = v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccloud_beginhttpupload_response_httpheaders(cur_buf,
					tag_wiretype.wire_type)?
				res.request_headers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_beginhttpupload_response() CCloud_BeginHTTPUpload_Response {
	return CCloud_BeginHTTPUpload_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_beginhttpupload_response(o CCloud_BeginHTTPUpload_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_beginhttpupload_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_BeginHTTPUpload_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_beginhttpupload_response_unpack(v)?
	return i, unpacked
}

pub struct CCloud_CommitHTTPUpload_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	transfer_succeeded     bool
	has_transfer_succeeded bool
	appid                  u32
	has_appid              bool
	file_sha               string
	has_file_sha           bool
	filename               string
	has_filename           bool
}

pub fn (o &CCloud_CommitHTTPUpload_Request) pack() []byte {
	mut res := []byte{}
	if o.has_transfer_succeeded {
		res << vproto.pack_bool_field(o.transfer_succeeded, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_file_sha {
		res << vproto.pack_string_field(o.file_sha, 3)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 4)
	}
	return res
}

pub fn ccloud_commithttpupload_request_unpack(buf []byte) ?CCloud_CommitHTTPUpload_Request {
	mut res := CCloud_CommitHTTPUpload_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_transfer_succeeded = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.transfer_succeeded = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_file_sha = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_sha = v
				i = ii
			}
			4 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_commithttpupload_request() CCloud_CommitHTTPUpload_Request {
	return CCloud_CommitHTTPUpload_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_commithttpupload_request(o CCloud_CommitHTTPUpload_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_commithttpupload_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_CommitHTTPUpload_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_commithttpupload_request_unpack(v)?
	return i, unpacked
}

pub struct CCloud_CommitHTTPUpload_Response {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	file_committed     bool
	has_file_committed bool
}

pub fn (o &CCloud_CommitHTTPUpload_Response) pack() []byte {
	mut res := []byte{}
	if o.has_file_committed {
		res << vproto.pack_bool_field(o.file_committed, 1)
	}
	return res
}

pub fn ccloud_commithttpupload_response_unpack(buf []byte) ?CCloud_CommitHTTPUpload_Response {
	mut res := CCloud_CommitHTTPUpload_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_file_committed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.file_committed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_commithttpupload_response() CCloud_CommitHTTPUpload_Response {
	return CCloud_CommitHTTPUpload_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_commithttpupload_response(o CCloud_CommitHTTPUpload_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_commithttpupload_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_CommitHTTPUpload_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_commithttpupload_response_unpack(v)?
	return i, unpacked
}

pub struct CCloud_GetFileDetails_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ugcid          u64
	has_ugcid      bool
	appid          u32
	has_appid      bool
}

pub fn (o &CCloud_GetFileDetails_Request) pack() []byte {
	mut res := []byte{}
	if o.has_ugcid {
		res << vproto.pack_uint64_field(o.ugcid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	return res
}

pub fn ccloud_getfiledetails_request_unpack(buf []byte) ?CCloud_GetFileDetails_Request {
	mut res := CCloud_GetFileDetails_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ugcid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.ugcid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_getfiledetails_request() CCloud_GetFileDetails_Request {
	return CCloud_GetFileDetails_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_getfiledetails_request(o CCloud_GetFileDetails_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_getfiledetails_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_GetFileDetails_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_getfiledetails_request_unpack(v)?
	return i, unpacked
}

pub struct CCloud_UserFile {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	appid               u32
	has_appid           bool
	ugcid               u64
	has_ugcid           bool
	filename            string
	has_filename        bool
	timestamp           u64
	has_timestamp       bool
	file_size           u32
	has_file_size       bool
	url                 string
	has_url             bool
	steamid_creator     u64
	has_steamid_creator bool
	flags               u32
	has_flags           bool
	platforms_to_sync   []string
	file_sha            string
	has_file_sha        bool
}

pub fn (o &CCloud_UserFile) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_ugcid {
		res << vproto.pack_uint64_field(o.ugcid, 2)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 3)
	}
	if o.has_timestamp {
		res << vproto.pack_uint64_field(o.timestamp, 4)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 5)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 6)
	}
	if o.has_steamid_creator {
		res << vproto.pack_64bit_field(o.steamid_creator, 7)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 8)
	}
	// [packed=false]
	for _, x in o.platforms_to_sync {
		res << vproto.pack_string_field(x, 9)
	}
	if o.has_file_sha {
		res << vproto.pack_string_field(o.file_sha, 10)
	}
	return res
}

pub fn ccloud_userfile_unpack(buf []byte) ?CCloud_UserFile {
	mut res := CCloud_UserFile{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_ugcid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.ugcid = v
				i = ii
			}
			3 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			4 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			5 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			6 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			7 {
				res.has_steamid_creator = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_creator = v
				i = ii
			}
			8 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.platforms_to_sync << v
				i = ii
			}
			10 {
				res.has_file_sha = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_sha = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_userfile() CCloud_UserFile {
	return CCloud_UserFile{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_userfile(o CCloud_UserFile, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_userfile(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_UserFile) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_userfile_unpack(v)?
	return i, unpacked
}

pub struct CCloud_GetFileDetails_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	details        CCloud_UserFile
	has_details    bool
}

pub fn (o &CCloud_GetFileDetails_Response) pack() []byte {
	mut res := []byte{}
	if o.has_details {
		res << zzz_vproto_internal_pack_ccloud_userfile(o.details, 1)
	}
	return res
}

pub fn ccloud_getfiledetails_response_unpack(buf []byte) ?CCloud_GetFileDetails_Response {
	mut res := CCloud_GetFileDetails_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_details = true
				ii, v := zzz_vproto_internal_unpack_ccloud_userfile(cur_buf, tag_wiretype.wire_type)?
				res.details = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_getfiledetails_response() CCloud_GetFileDetails_Response {
	return CCloud_GetFileDetails_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_getfiledetails_response(o CCloud_GetFileDetails_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_getfiledetails_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_GetFileDetails_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_getfiledetails_response_unpack(v)?
	return i, unpacked
}

pub struct CCloud_EnumerateUserFiles_Request {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	appid                u32
	has_appid            bool
	extended_details     bool
	has_extended_details bool
	count                u32
	has_count            bool
	start_index          u32
	has_start_index      bool
}

pub fn (o &CCloud_EnumerateUserFiles_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_extended_details {
		res << vproto.pack_bool_field(o.extended_details, 2)
	}
	if o.has_count {
		res << vproto.pack_uint32_field(o.count, 3)
	}
	if o.has_start_index {
		res << vproto.pack_uint32_field(o.start_index, 4)
	}
	return res
}

pub fn ccloud_enumerateuserfiles_request_unpack(buf []byte) ?CCloud_EnumerateUserFiles_Request {
	mut res := CCloud_EnumerateUserFiles_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_extended_details = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.extended_details = v
				i = ii
			}
			3 {
				res.has_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			4 {
				res.has_start_index = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_index = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_enumerateuserfiles_request() CCloud_EnumerateUserFiles_Request {
	return CCloud_EnumerateUserFiles_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_enumerateuserfiles_request(o CCloud_EnumerateUserFiles_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_enumerateuserfiles_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_EnumerateUserFiles_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_enumerateuserfiles_request_unpack(v)?
	return i, unpacked
}

pub struct CCloud_EnumerateUserFiles_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	files           []CCloud_UserFile
	total_files     u32
	has_total_files bool
}

pub fn (o &CCloud_EnumerateUserFiles_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.files {
		res << zzz_vproto_internal_pack_ccloud_userfile(x, 1)
	}
	if o.has_total_files {
		res << vproto.pack_uint32_field(o.total_files, 2)
	}
	return res
}

pub fn ccloud_enumerateuserfiles_response_unpack(buf []byte) ?CCloud_EnumerateUserFiles_Response {
	mut res := CCloud_EnumerateUserFiles_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccloud_userfile(cur_buf, tag_wiretype.wire_type)?
				res.files << v
				i = ii
			}
			2 {
				res.has_total_files = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_files = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_enumerateuserfiles_response() CCloud_EnumerateUserFiles_Response {
	return CCloud_EnumerateUserFiles_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_enumerateuserfiles_response(o CCloud_EnumerateUserFiles_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_enumerateuserfiles_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_EnumerateUserFiles_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_enumerateuserfiles_response_unpack(v)?
	return i, unpacked
}

pub struct CCloud_Delete_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	filename       string
	has_filename   bool
	appid          u32
	has_appid      bool
}

pub fn (o &CCloud_Delete_Request) pack() []byte {
	mut res := []byte{}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	return res
}

pub fn ccloud_delete_request_unpack(buf []byte) ?CCloud_Delete_Request {
	mut res := CCloud_Delete_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_delete_request() CCloud_Delete_Request {
	return CCloud_Delete_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_delete_request(o CCloud_Delete_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_delete_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_Delete_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_delete_request_unpack(v)?
	return i, unpacked
}

pub struct CCloud_Delete_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CCloud_Delete_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn ccloud_delete_response_unpack(buf []byte) ?CCloud_Delete_Response {
	res := CCloud_Delete_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_delete_response() CCloud_Delete_Response {
	return CCloud_Delete_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_delete_response(o CCloud_Delete_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_delete_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_Delete_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_delete_response_unpack(v)?
	return i, unpacked
}

pub struct CCloud_GetClientEncryptionKey_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CCloud_GetClientEncryptionKey_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn ccloud_getclientencryptionkey_request_unpack(buf []byte) ?CCloud_GetClientEncryptionKey_Request {
	res := CCloud_GetClientEncryptionKey_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_getclientencryptionkey_request() CCloud_GetClientEncryptionKey_Request {
	return CCloud_GetClientEncryptionKey_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_getclientencryptionkey_request(o CCloud_GetClientEncryptionKey_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_getclientencryptionkey_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_GetClientEncryptionKey_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_getclientencryptionkey_request_unpack(v)?
	return i, unpacked
}

pub struct CCloud_GetClientEncryptionKey_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            []byte
	has_key        bool
	crc            int
	has_crc        bool
}

pub fn (o &CCloud_GetClientEncryptionKey_Response) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_bytes_field(o.key, 1)
	}
	if o.has_crc {
		res << vproto.pack_int32_field(o.crc, 2)
	}
	return res
}

pub fn ccloud_getclientencryptionkey_response_unpack(buf []byte) ?CCloud_GetClientEncryptionKey_Response {
	mut res := CCloud_GetClientEncryptionKey_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_crc = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.crc = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_getclientencryptionkey_response() CCloud_GetClientEncryptionKey_Response {
	return CCloud_GetClientEncryptionKey_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_getclientencryptionkey_response(o CCloud_GetClientEncryptionKey_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_getclientencryptionkey_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_GetClientEncryptionKey_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_getclientencryptionkey_response_unpack(v)?
	return i, unpacked
}

pub struct CCloud_CDNReport_Notification {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	steamid              u64
	has_steamid          bool
	url                  string
	has_url              bool
	success              bool
	has_success          bool
	http_status_code     u32
	has_http_status_code bool
	expected_bytes       u64
	has_expected_bytes   bool
	received_bytes       u64
	has_received_bytes   bool
	duration             u32
	has_duration         bool
}

pub fn (o &CCloud_CDNReport_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_success {
		res << vproto.pack_bool_field(o.success, 3)
	}
	if o.has_http_status_code {
		res << vproto.pack_uint32_field(o.http_status_code, 4)
	}
	if o.has_expected_bytes {
		res << vproto.pack_uint64_field(o.expected_bytes, 5)
	}
	if o.has_received_bytes {
		res << vproto.pack_uint64_field(o.received_bytes, 6)
	}
	if o.has_duration {
		res << vproto.pack_uint32_field(o.duration, 7)
	}
	return res
}

pub fn ccloud_cdnreport_notification_unpack(buf []byte) ?CCloud_CDNReport_Notification {
	mut res := CCloud_CDNReport_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_success = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.success = v
				i = ii
			}
			4 {
				res.has_http_status_code = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.http_status_code = v
				i = ii
			}
			5 {
				res.has_expected_bytes = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.expected_bytes = v
				i = ii
			}
			6 {
				res.has_received_bytes = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.received_bytes = v
				i = ii
			}
			7 {
				res.has_duration = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.duration = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_cdnreport_notification() CCloud_CDNReport_Notification {
	return CCloud_CDNReport_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_cdnreport_notification(o CCloud_CDNReport_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_cdnreport_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_CDNReport_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_cdnreport_notification_unpack(v)?
	return i, unpacked
}

pub struct CCloud_ExternalStorageTransferReport_Notification {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	host                 string
	has_host             bool
	path                 string
	has_path             bool
	is_upload            bool
	has_is_upload        bool
	success              bool
	has_success          bool
	http_status_code     u32
	has_http_status_code bool
	bytes_expected       u64
	has_bytes_expected   bool
	bytes_actual         u64
	has_bytes_actual     bool
	duration_ms          u32
	has_duration_ms      bool
	cellid               u32
	has_cellid           bool
	proxied              bool
	has_proxied          bool
	ipv6_local           bool
	has_ipv6_local       bool
	ipv6_remote          bool
	has_ipv6_remote      bool
}

pub fn (o &CCloud_ExternalStorageTransferReport_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_host {
		res << vproto.pack_string_field(o.host, 1)
	}
	if o.has_path {
		res << vproto.pack_string_field(o.path, 2)
	}
	if o.has_is_upload {
		res << vproto.pack_bool_field(o.is_upload, 3)
	}
	if o.has_success {
		res << vproto.pack_bool_field(o.success, 4)
	}
	if o.has_http_status_code {
		res << vproto.pack_uint32_field(o.http_status_code, 5)
	}
	if o.has_bytes_expected {
		res << vproto.pack_uint64_field(o.bytes_expected, 6)
	}
	if o.has_bytes_actual {
		res << vproto.pack_uint64_field(o.bytes_actual, 7)
	}
	if o.has_duration_ms {
		res << vproto.pack_uint32_field(o.duration_ms, 8)
	}
	if o.has_cellid {
		res << vproto.pack_uint32_field(o.cellid, 9)
	}
	if o.has_proxied {
		res << vproto.pack_bool_field(o.proxied, 10)
	}
	if o.has_ipv6_local {
		res << vproto.pack_bool_field(o.ipv6_local, 11)
	}
	if o.has_ipv6_remote {
		res << vproto.pack_bool_field(o.ipv6_remote, 12)
	}
	return res
}

pub fn ccloud_externalstoragetransferreport_notification_unpack(buf []byte) ?CCloud_ExternalStorageTransferReport_Notification {
	mut res := CCloud_ExternalStorageTransferReport_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.host = v
				i = ii
			}
			2 {
				res.has_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.path = v
				i = ii
			}
			3 {
				res.has_is_upload = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_upload = v
				i = ii
			}
			4 {
				res.has_success = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.success = v
				i = ii
			}
			5 {
				res.has_http_status_code = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.http_status_code = v
				i = ii
			}
			6 {
				res.has_bytes_expected = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_expected = v
				i = ii
			}
			7 {
				res.has_bytes_actual = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_actual = v
				i = ii
			}
			8 {
				res.has_duration_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.duration_ms = v
				i = ii
			}
			9 {
				res.has_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cellid = v
				i = ii
			}
			10 {
				res.has_proxied = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.proxied = v
				i = ii
			}
			11 {
				res.has_ipv6_local = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ipv6_local = v
				i = ii
			}
			12 {
				res.has_ipv6_remote = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ipv6_remote = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_externalstoragetransferreport_notification() CCloud_ExternalStorageTransferReport_Notification {
	return CCloud_ExternalStorageTransferReport_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_externalstoragetransferreport_notification(o CCloud_ExternalStorageTransferReport_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_externalstoragetransferreport_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_ExternalStorageTransferReport_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_externalstoragetransferreport_notification_unpack(v)?
	return i, unpacked
}

pub struct CCloud_ClientBeginFileUpload_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	appid                 u32
	has_appid             bool
	file_size             u32
	has_file_size         bool
	raw_file_size         u32
	has_raw_file_size     bool
	file_sha              []byte
	has_file_sha          bool
	time_stamp            u64
	has_time_stamp        bool
	filename              string
	has_filename          bool
	platforms_to_sync     u32
	has_platforms_to_sync bool
	cell_id               u32
	has_cell_id           bool
	can_encrypt           bool
	has_can_encrypt       bool
	is_shared_file        bool
	has_is_shared_file    bool
	realm                 u32
	has_realm             bool
}

pub fn (o &CCloud_ClientBeginFileUpload_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 2)
	}
	if o.has_raw_file_size {
		res << vproto.pack_uint32_field(o.raw_file_size, 3)
	}
	if o.has_file_sha {
		res << vproto.pack_bytes_field(o.file_sha, 4)
	}
	if o.has_time_stamp {
		res << vproto.pack_uint64_field(o.time_stamp, 5)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 6)
	}
	if o.has_platforms_to_sync {
		res << vproto.pack_uint32_field(o.platforms_to_sync, 7)
	}
	if o.has_cell_id {
		res << vproto.pack_uint32_field(o.cell_id, 9)
	}
	if o.has_can_encrypt {
		res << vproto.pack_bool_field(o.can_encrypt, 10)
	}
	if o.has_is_shared_file {
		res << vproto.pack_bool_field(o.is_shared_file, 11)
	}
	if o.has_realm {
		res << vproto.pack_uint32_field(o.realm, 12)
	}
	return res
}

pub fn ccloud_clientbeginfileupload_request_unpack(buf []byte) ?CCloud_ClientBeginFileUpload_Request {
	mut res := CCloud_ClientBeginFileUpload_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			3 {
				res.has_raw_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.raw_file_size = v
				i = ii
			}
			4 {
				res.has_file_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.file_sha = v
				i = ii
			}
			5 {
				res.has_time_stamp = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.time_stamp = v
				i = ii
			}
			6 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			7 {
				res.has_platforms_to_sync = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.platforms_to_sync = v
				i = ii
			}
			9 {
				res.has_cell_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			10 {
				res.has_can_encrypt = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.can_encrypt = v
				i = ii
			}
			11 {
				res.has_is_shared_file = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_shared_file = v
				i = ii
			}
			12 {
				res.has_realm = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.realm = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_clientbeginfileupload_request() CCloud_ClientBeginFileUpload_Request {
	return CCloud_ClientBeginFileUpload_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_clientbeginfileupload_request(o CCloud_ClientBeginFileUpload_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_clientbeginfileupload_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_ClientBeginFileUpload_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_clientbeginfileupload_request_unpack(v)?
	return i, unpacked
}

pub struct ClientCloudFileUploadBlockDetails_HTTPHeaders {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	value          string
	has_value      bool
}

pub fn (o &ClientCloudFileUploadBlockDetails_HTTPHeaders) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn clientcloudfileuploadblockdetails_httpheaders_unpack(buf []byte) ?ClientCloudFileUploadBlockDetails_HTTPHeaders {
	mut res := ClientCloudFileUploadBlockDetails_HTTPHeaders{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_clientcloudfileuploadblockdetails_httpheaders() ClientCloudFileUploadBlockDetails_HTTPHeaders {
	return ClientCloudFileUploadBlockDetails_HTTPHeaders{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_clientcloudfileuploadblockdetails_httpheaders(o ClientCloudFileUploadBlockDetails_HTTPHeaders, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_clientcloudfileuploadblockdetails_httpheaders(buf []byte, tag_wiretype vproto.WireType) ?(int, ClientCloudFileUploadBlockDetails_HTTPHeaders) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := clientcloudfileuploadblockdetails_httpheaders_unpack(v)?
	return i, unpacked
}

pub struct ClientCloudFileUploadBlockDetails {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	url_host               string
	has_url_host           bool
	url_path               string
	has_url_path           bool
	use_https              bool
	has_use_https          bool
	http_method            int
	has_http_method        bool
	request_headers        []ClientCloudFileUploadBlockDetails_HTTPHeaders
	block_offset           u64
	has_block_offset       bool
	block_length           u32
	has_block_length       bool
	explicit_body_data     []byte
	has_explicit_body_data bool
	may_parallelize        bool
	has_may_parallelize    bool
}

pub fn (o &ClientCloudFileUploadBlockDetails) pack() []byte {
	mut res := []byte{}
	if o.has_url_host {
		res << vproto.pack_string_field(o.url_host, 1)
	}
	if o.has_url_path {
		res << vproto.pack_string_field(o.url_path, 2)
	}
	if o.has_use_https {
		res << vproto.pack_bool_field(o.use_https, 3)
	}
	if o.has_http_method {
		res << vproto.pack_int32_field(o.http_method, 4)
	}
	// [packed=false]
	for _, x in o.request_headers {
		res << zzz_vproto_internal_pack_clientcloudfileuploadblockdetails_httpheaders(x, 5)
	}
	if o.has_block_offset {
		res << vproto.pack_uint64_field(o.block_offset, 6)
	}
	if o.has_block_length {
		res << vproto.pack_uint32_field(o.block_length, 7)
	}
	if o.has_explicit_body_data {
		res << vproto.pack_bytes_field(o.explicit_body_data, 8)
	}
	if o.has_may_parallelize {
		res << vproto.pack_bool_field(o.may_parallelize, 9)
	}
	return res
}

pub fn clientcloudfileuploadblockdetails_unpack(buf []byte) ?ClientCloudFileUploadBlockDetails {
	mut res := ClientCloudFileUploadBlockDetails{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_url_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_host = v
				i = ii
			}
			2 {
				res.has_url_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_path = v
				i = ii
			}
			3 {
				res.has_use_https = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_https = v
				i = ii
			}
			4 {
				res.has_http_method = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.http_method = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_clientcloudfileuploadblockdetails_httpheaders(cur_buf,
					tag_wiretype.wire_type)?
				res.request_headers << v
				i = ii
			}
			6 {
				res.has_block_offset = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.block_offset = v
				i = ii
			}
			7 {
				res.has_block_length = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.block_length = v
				i = ii
			}
			8 {
				res.has_explicit_body_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.explicit_body_data = v
				i = ii
			}
			9 {
				res.has_may_parallelize = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.may_parallelize = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_clientcloudfileuploadblockdetails() ClientCloudFileUploadBlockDetails {
	return ClientCloudFileUploadBlockDetails{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_clientcloudfileuploadblockdetails(o ClientCloudFileUploadBlockDetails, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_clientcloudfileuploadblockdetails(buf []byte, tag_wiretype vproto.WireType) ?(int, ClientCloudFileUploadBlockDetails) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := clientcloudfileuploadblockdetails_unpack(v)?
	return i, unpacked
}

pub struct CCloud_ClientBeginFileUpload_Response {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	encrypt_file     bool
	has_encrypt_file bool
	block_requests   []ClientCloudFileUploadBlockDetails
}

pub fn (o &CCloud_ClientBeginFileUpload_Response) pack() []byte {
	mut res := []byte{}
	if o.has_encrypt_file {
		res << vproto.pack_bool_field(o.encrypt_file, 1)
	}
	// [packed=false]
	for _, x in o.block_requests {
		res << zzz_vproto_internal_pack_clientcloudfileuploadblockdetails(x, 2)
	}
	return res
}

pub fn ccloud_clientbeginfileupload_response_unpack(buf []byte) ?CCloud_ClientBeginFileUpload_Response {
	mut res := CCloud_ClientBeginFileUpload_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_encrypt_file = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.encrypt_file = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_clientcloudfileuploadblockdetails(cur_buf,
					tag_wiretype.wire_type)?
				res.block_requests << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_clientbeginfileupload_response() CCloud_ClientBeginFileUpload_Response {
	return CCloud_ClientBeginFileUpload_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_clientbeginfileupload_response(o CCloud_ClientBeginFileUpload_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_clientbeginfileupload_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_ClientBeginFileUpload_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_clientbeginfileupload_response_unpack(v)?
	return i, unpacked
}

pub struct CCloud_ClientCommitFileUpload_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	transfer_succeeded     bool
	has_transfer_succeeded bool
	appid                  u32
	has_appid              bool
	file_sha               []byte
	has_file_sha           bool
	filename               string
	has_filename           bool
}

pub fn (o &CCloud_ClientCommitFileUpload_Request) pack() []byte {
	mut res := []byte{}
	if o.has_transfer_succeeded {
		res << vproto.pack_bool_field(o.transfer_succeeded, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_file_sha {
		res << vproto.pack_bytes_field(o.file_sha, 3)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 4)
	}
	return res
}

pub fn ccloud_clientcommitfileupload_request_unpack(buf []byte) ?CCloud_ClientCommitFileUpload_Request {
	mut res := CCloud_ClientCommitFileUpload_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_transfer_succeeded = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.transfer_succeeded = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_file_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.file_sha = v
				i = ii
			}
			4 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_clientcommitfileupload_request() CCloud_ClientCommitFileUpload_Request {
	return CCloud_ClientCommitFileUpload_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_clientcommitfileupload_request(o CCloud_ClientCommitFileUpload_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_clientcommitfileupload_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_ClientCommitFileUpload_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_clientcommitfileupload_request_unpack(v)?
	return i, unpacked
}

pub struct CCloud_ClientCommitFileUpload_Response {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	file_committed     bool
	has_file_committed bool
}

pub fn (o &CCloud_ClientCommitFileUpload_Response) pack() []byte {
	mut res := []byte{}
	if o.has_file_committed {
		res << vproto.pack_bool_field(o.file_committed, 1)
	}
	return res
}

pub fn ccloud_clientcommitfileupload_response_unpack(buf []byte) ?CCloud_ClientCommitFileUpload_Response {
	mut res := CCloud_ClientCommitFileUpload_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_file_committed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.file_committed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_clientcommitfileupload_response() CCloud_ClientCommitFileUpload_Response {
	return CCloud_ClientCommitFileUpload_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_clientcommitfileupload_response(o CCloud_ClientCommitFileUpload_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_clientcommitfileupload_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_ClientCommitFileUpload_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_clientcommitfileupload_response_unpack(v)?
	return i, unpacked
}

pub struct CCloud_ClientFileDownload_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	filename       string
	has_filename   bool
	realm          u32
	has_realm      bool
}

pub fn (o &CCloud_ClientFileDownload_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 2)
	}
	if o.has_realm {
		res << vproto.pack_uint32_field(o.realm, 3)
	}
	return res
}

pub fn ccloud_clientfiledownload_request_unpack(buf []byte) ?CCloud_ClientFileDownload_Request {
	mut res := CCloud_ClientFileDownload_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			3 {
				res.has_realm = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.realm = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_clientfiledownload_request() CCloud_ClientFileDownload_Request {
	return CCloud_ClientFileDownload_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_clientfiledownload_request(o CCloud_ClientFileDownload_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_clientfiledownload_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_ClientFileDownload_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_clientfiledownload_request_unpack(v)?
	return i, unpacked
}

pub struct CCloud_ClientFileDownload_Response_HTTPHeaders {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	value          string
	has_value      bool
}

pub fn (o &CCloud_ClientFileDownload_Response_HTTPHeaders) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn ccloud_clientfiledownload_response_httpheaders_unpack(buf []byte) ?CCloud_ClientFileDownload_Response_HTTPHeaders {
	mut res := CCloud_ClientFileDownload_Response_HTTPHeaders{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_clientfiledownload_response_httpheaders() CCloud_ClientFileDownload_Response_HTTPHeaders {
	return CCloud_ClientFileDownload_Response_HTTPHeaders{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_clientfiledownload_response_httpheaders(o CCloud_ClientFileDownload_Response_HTTPHeaders, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_clientfiledownload_response_httpheaders(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_ClientFileDownload_Response_HTTPHeaders) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_clientfiledownload_response_httpheaders_unpack(v)?
	return i, unpacked
}

pub struct CCloud_ClientFileDownload_Response {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	appid                  u32
	has_appid              bool
	file_size              u32
	has_file_size          bool
	raw_file_size          u32
	has_raw_file_size      bool
	sha_file               []byte
	has_sha_file           bool
	time_stamp             u64
	has_time_stamp         bool
	is_explicit_delete     bool
	has_is_explicit_delete bool
	url_host               string
	has_url_host           bool
	url_path               string
	has_url_path           bool
	use_https              bool
	has_use_https          bool
	request_headers        []CCloud_ClientFileDownload_Response_HTTPHeaders
	encrypted              bool
	has_encrypted          bool
}

pub fn (o &CCloud_ClientFileDownload_Response) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 2)
	}
	if o.has_raw_file_size {
		res << vproto.pack_uint32_field(o.raw_file_size, 3)
	}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 4)
	}
	if o.has_time_stamp {
		res << vproto.pack_uint64_field(o.time_stamp, 5)
	}
	if o.has_is_explicit_delete {
		res << vproto.pack_bool_field(o.is_explicit_delete, 6)
	}
	if o.has_url_host {
		res << vproto.pack_string_field(o.url_host, 7)
	}
	if o.has_url_path {
		res << vproto.pack_string_field(o.url_path, 8)
	}
	if o.has_use_https {
		res << vproto.pack_bool_field(o.use_https, 9)
	}
	// [packed=false]
	for _, x in o.request_headers {
		res << zzz_vproto_internal_pack_ccloud_clientfiledownload_response_httpheaders(x, 10)
	}
	if o.has_encrypted {
		res << vproto.pack_bool_field(o.encrypted, 11)
	}
	return res
}

pub fn ccloud_clientfiledownload_response_unpack(buf []byte) ?CCloud_ClientFileDownload_Response {
	mut res := CCloud_ClientFileDownload_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			3 {
				res.has_raw_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.raw_file_size = v
				i = ii
			}
			4 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			5 {
				res.has_time_stamp = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.time_stamp = v
				i = ii
			}
			6 {
				res.has_is_explicit_delete = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_explicit_delete = v
				i = ii
			}
			7 {
				res.has_url_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_host = v
				i = ii
			}
			8 {
				res.has_url_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_path = v
				i = ii
			}
			9 {
				res.has_use_https = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_https = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccloud_clientfiledownload_response_httpheaders(cur_buf,
					tag_wiretype.wire_type)?
				res.request_headers << v
				i = ii
			}
			11 {
				res.has_encrypted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.encrypted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_clientfiledownload_response() CCloud_ClientFileDownload_Response {
	return CCloud_ClientFileDownload_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_clientfiledownload_response(o CCloud_ClientFileDownload_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_clientfiledownload_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_ClientFileDownload_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_clientfiledownload_response_unpack(v)?
	return i, unpacked
}

pub struct CCloud_ClientDeleteFile_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	appid                  u32
	has_appid              bool
	filename               string
	has_filename           bool
	is_explicit_delete     bool
	has_is_explicit_delete bool
}

pub fn (o &CCloud_ClientDeleteFile_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 2)
	}
	if o.has_is_explicit_delete {
		res << vproto.pack_bool_field(o.is_explicit_delete, 3)
	}
	return res
}

pub fn ccloud_clientdeletefile_request_unpack(buf []byte) ?CCloud_ClientDeleteFile_Request {
	mut res := CCloud_ClientDeleteFile_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			3 {
				res.has_is_explicit_delete = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_explicit_delete = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_clientdeletefile_request() CCloud_ClientDeleteFile_Request {
	return CCloud_ClientDeleteFile_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_clientdeletefile_request(o CCloud_ClientDeleteFile_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_clientdeletefile_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_ClientDeleteFile_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_clientdeletefile_request_unpack(v)?
	return i, unpacked
}

pub struct CCloud_ClientDeleteFile_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CCloud_ClientDeleteFile_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn ccloud_clientdeletefile_response_unpack(buf []byte) ?CCloud_ClientDeleteFile_Response {
	res := CCloud_ClientDeleteFile_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_clientdeletefile_response() CCloud_ClientDeleteFile_Response {
	return CCloud_ClientDeleteFile_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_clientdeletefile_response(o CCloud_ClientDeleteFile_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_clientdeletefile_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_ClientDeleteFile_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_clientdeletefile_response_unpack(v)?
	return i, unpacked
}

pub struct CCloud_ClientConflictResolution_Notification {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	appid                 u32
	has_appid             bool
	chose_local_files     bool
	has_chose_local_files bool
}

pub fn (o &CCloud_ClientConflictResolution_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_chose_local_files {
		res << vproto.pack_bool_field(o.chose_local_files, 2)
	}
	return res
}

pub fn ccloud_clientconflictresolution_notification_unpack(buf []byte) ?CCloud_ClientConflictResolution_Notification {
	mut res := CCloud_ClientConflictResolution_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_chose_local_files = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.chose_local_files = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_clientconflictresolution_notification() CCloud_ClientConflictResolution_Notification {
	return CCloud_ClientConflictResolution_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_clientconflictresolution_notification(o CCloud_ClientConflictResolution_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_clientconflictresolution_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_ClientConflictResolution_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_clientconflictresolution_notification_unpack(v)?
	return i, unpacked
}

pub struct CCloud_EnumerateUserApps_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CCloud_EnumerateUserApps_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn ccloud_enumerateuserapps_request_unpack(buf []byte) ?CCloud_EnumerateUserApps_Request {
	res := CCloud_EnumerateUserApps_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_enumerateuserapps_request() CCloud_EnumerateUserApps_Request {
	return CCloud_EnumerateUserApps_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_enumerateuserapps_request(o CCloud_EnumerateUserApps_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_enumerateuserapps_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_EnumerateUserApps_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_enumerateuserapps_request_unpack(v)?
	return i, unpacked
}

pub struct CCloud_EnumerateUserApps_Response_Apps {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	totalcount     int
	has_totalcount bool
	totalsize      i64
	has_totalsize  bool
}

pub fn (o &CCloud_EnumerateUserApps_Response_Apps) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_totalcount {
		res << vproto.pack_int32_field(o.totalcount, 2)
	}
	if o.has_totalsize {
		res << vproto.pack_int64_field(o.totalsize, 3)
	}
	return res
}

pub fn ccloud_enumerateuserapps_response_apps_unpack(buf []byte) ?CCloud_EnumerateUserApps_Response_Apps {
	mut res := CCloud_EnumerateUserApps_Response_Apps{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_totalcount = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.totalcount = v
				i = ii
			}
			3 {
				res.has_totalsize = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
				res.totalsize = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_enumerateuserapps_response_apps() CCloud_EnumerateUserApps_Response_Apps {
	return CCloud_EnumerateUserApps_Response_Apps{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_enumerateuserapps_response_apps(o CCloud_EnumerateUserApps_Response_Apps, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_enumerateuserapps_response_apps(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_EnumerateUserApps_Response_Apps) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_enumerateuserapps_response_apps_unpack(v)?
	return i, unpacked
}

pub struct CCloud_EnumerateUserApps_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	apps           []CCloud_EnumerateUserApps_Response_Apps
}

pub fn (o &CCloud_EnumerateUserApps_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_ccloud_enumerateuserapps_response_apps(x, 1)
	}
	return res
}

pub fn ccloud_enumerateuserapps_response_unpack(buf []byte) ?CCloud_EnumerateUserApps_Response {
	mut res := CCloud_EnumerateUserApps_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccloud_enumerateuserapps_response_apps(cur_buf,
					tag_wiretype.wire_type)?
				res.apps << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccloud_enumerateuserapps_response() CCloud_EnumerateUserApps_Response {
	return CCloud_EnumerateUserApps_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccloud_enumerateuserapps_response(o CCloud_EnumerateUserApps_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccloud_enumerateuserapps_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CCloud_EnumerateUserApps_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccloud_enumerateuserapps_response_unpack(v)?
	return i, unpacked
}
