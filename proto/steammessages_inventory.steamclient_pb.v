
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


pub struct CInventoryGetInventoryRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
steamid u64
has_steamid bool
}
pub fn (o &CInventoryGetInventoryRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_steamid {
res << vproto.pack_uint64_field(o.steamid, 2)
}

return res
}

pub fn cinventorygetinventoryrequest_unpack(buf []byte) ?CInventoryGetInventoryRequest {
mut res := CInventoryGetInventoryRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorygetinventoryrequest() CInventoryGetInventoryRequest {
return CInventoryGetInventoryRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorygetinventoryrequest(o CInventoryGetInventoryRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorygetinventoryrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryGetInventoryRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorygetinventoryrequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
etag string
has_etag bool
removeditemids []u64
item_json string
has_item_json bool
itemdef_json string
has_itemdef_json bool
ticket []byte
has_ticket bool
replayed bool
has_replayed bool
}
pub fn (o &CInventoryResponse) pack() []byte {
mut res := []byte{}
if o.has_etag {
res << vproto.pack_string_field(o.etag, 1)
}

// [packed=false]
for _, x in o.removeditemids {
res << vproto.pack_uint64_field(x, 2)
}

if o.has_item_json {
res << vproto.pack_string_field(o.item_json, 3)
}

if o.has_itemdef_json {
res << vproto.pack_string_field(o.itemdef_json, 4)
}

if o.has_ticket {
res << vproto.pack_bytes_field(o.ticket, 5)
}

if o.has_replayed {
res << vproto.pack_bool_field(o.replayed, 6)
}

return res
}

pub fn cinventoryresponse_unpack(buf []byte) ?CInventoryResponse {
mut res := CInventoryResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_etag = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.etag = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.removeditemids << v
i = ii
}

3 {
res.has_item_json = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.item_json = v
i = ii
}

4 {
res.has_itemdef_json = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.itemdef_json = v
i = ii
}

5 {
res.has_ticket = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.ticket = v
i = ii
}

6 {
res.has_replayed = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.replayed = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventoryresponse() CInventoryResponse {
return CInventoryResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventoryresponse(o CInventoryResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventoryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventoryresponse_unpack(v)?
return i, unpacked
}
pub struct CInventoryExchangeItemRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
steamid u64
has_steamid bool
materialsitemid []u64
materialsquantity []u32
outputitemdefid u64
has_outputitemdefid bool
}
pub fn (o &CInventoryExchangeItemRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_steamid {
res << vproto.pack_uint64_field(o.steamid, 2)
}

// [packed=false]
for _, x in o.materialsitemid {
res << vproto.pack_uint64_field(x, 3)
}

// [packed=false]
for _, x in o.materialsquantity {
res << vproto.pack_uint32_field(x, 4)
}

if o.has_outputitemdefid {
res << vproto.pack_uint64_field(o.outputitemdefid, 5)
}

return res
}

pub fn cinventoryexchangeitemrequest_unpack(buf []byte) ?CInventoryExchangeItemRequest {
mut res := CInventoryExchangeItemRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.materialsitemid << v
i = ii
}

4 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.materialsquantity << v
i = ii
}

5 {
res.has_outputitemdefid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.outputitemdefid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventoryexchangeitemrequest() CInventoryExchangeItemRequest {
return CInventoryExchangeItemRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventoryexchangeitemrequest(o CInventoryExchangeItemRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventoryexchangeitemrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryExchangeItemRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventoryexchangeitemrequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryGetEligiblePromoItemDefIDsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
steamid u64
has_steamid bool
}
pub fn (o &CInventoryGetEligiblePromoItemDefIDsRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_steamid {
res << vproto.pack_uint64_field(o.steamid, 2)
}

return res
}

pub fn cinventorygeteligiblepromoitemdefidsrequest_unpack(buf []byte) ?CInventoryGetEligiblePromoItemDefIDsRequest {
mut res := CInventoryGetEligiblePromoItemDefIDsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorygeteligiblepromoitemdefidsrequest() CInventoryGetEligiblePromoItemDefIDsRequest {
return CInventoryGetEligiblePromoItemDefIDsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorygeteligiblepromoitemdefidsrequest(o CInventoryGetEligiblePromoItemDefIDsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorygeteligiblepromoitemdefidsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryGetEligiblePromoItemDefIDsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorygeteligiblepromoitemdefidsrequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryGetEligiblePromoItemDefIDsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
itemdefids []u64
}
pub fn (o &CInventoryGetEligiblePromoItemDefIDsResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.itemdefids {
res << vproto.pack_uint64_field(x, 1)
}

return res
}

pub fn cinventorygeteligiblepromoitemdefidsresponse_unpack(buf []byte) ?CInventoryGetEligiblePromoItemDefIDsResponse {
mut res := CInventoryGetEligiblePromoItemDefIDsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.itemdefids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorygeteligiblepromoitemdefidsresponse() CInventoryGetEligiblePromoItemDefIDsResponse {
return CInventoryGetEligiblePromoItemDefIDsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorygeteligiblepromoitemdefidsresponse(o CInventoryGetEligiblePromoItemDefIDsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorygeteligiblepromoitemdefidsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryGetEligiblePromoItemDefIDsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorygeteligiblepromoitemdefidsresponse_unpack(v)?
return i, unpacked
}
pub struct CInventoryAddItemRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
itemdefid []u64
itempropsjson []string
steamid u64
has_steamid bool
notify bool
has_notify bool
requestid u64
has_requestid bool
trade_restriction bool
has_trade_restriction bool
is_purchase bool
has_is_purchase bool
}
pub fn (o &CInventoryAddItemRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

// [packed=false]
for _, x in o.itemdefid {
res << vproto.pack_uint64_field(x, 2)
}

// [packed=false]
for _, x in o.itempropsjson {
res << vproto.pack_string_field(x, 3)
}

if o.has_steamid {
res << vproto.pack_uint64_field(o.steamid, 4)
}

if o.has_notify {
res << vproto.pack_bool_field(o.notify, 5)
}

if o.has_requestid {
res << vproto.pack_uint64_field(o.requestid, 6)
}

if o.has_trade_restriction {
res << vproto.pack_bool_field(o.trade_restriction, 7)
}

if o.has_is_purchase {
res << vproto.pack_bool_field(o.is_purchase, 8)
}

return res
}

pub fn cinventoryadditemrequest_unpack(buf []byte) ?CInventoryAddItemRequest {
mut res := CInventoryAddItemRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.itemdefid << v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.itempropsjson << v
i = ii
}

4 {
res.has_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

5 {
res.has_notify = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.notify = v
i = ii
}

6 {
res.has_requestid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.requestid = v
i = ii
}

7 {
res.has_trade_restriction = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.trade_restriction = v
i = ii
}

8 {
res.has_is_purchase = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_purchase = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventoryadditemrequest() CInventoryAddItemRequest {
return CInventoryAddItemRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventoryadditemrequest(o CInventoryAddItemRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventoryadditemrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryAddItemRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventoryadditemrequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryModifyItemsRequestItemPropertyUpdate {
mut:
unknown_fields []vproto.UnknownField
pub mut:
itemid u64
has_itemid bool
remove_property bool
has_remove_property bool
property_name string
has_property_name bool
property_value_bool bool
has_property_value_bool bool
property_value_int i64
has_property_value_int bool
property_value_string string
has_property_value_string bool
property_value_float f32
has_property_value_float bool
}
pub fn (o &CInventoryModifyItemsRequestItemPropertyUpdate) pack() []byte {
mut res := []byte{}
if o.has_itemid {
res << vproto.pack_uint64_field(o.itemid, 1)
}

if o.has_remove_property {
res << vproto.pack_bool_field(o.remove_property, 2)
}

if o.has_property_name {
res << vproto.pack_string_field(o.property_name, 3)
}

if o.has_property_value_bool {
res << vproto.pack_bool_field(o.property_value_bool, 4)
}

if o.has_property_value_int {
res << vproto.pack_int64_field(o.property_value_int, 5)
}

if o.has_property_value_string {
res << vproto.pack_string_field(o.property_value_string, 6)
}

if o.has_property_value_float {
res << vproto.pack_float_field(o.property_value_float, 7)
}

return res
}

pub fn cinventorymodifyitemsrequestitempropertyupdate_unpack(buf []byte) ?CInventoryModifyItemsRequestItemPropertyUpdate {
mut res := CInventoryModifyItemsRequestItemPropertyUpdate{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_itemid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.itemid = v
i = ii
}

2 {
res.has_remove_property = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.remove_property = v
i = ii
}

3 {
res.has_property_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.property_name = v
i = ii
}

4 {
res.has_property_value_bool = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.property_value_bool = v
i = ii
}

5 {
res.has_property_value_int = true
ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
res.property_value_int = v
i = ii
}

6 {
res.has_property_value_string = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.property_value_string = v
i = ii
}

7 {
res.has_property_value_float = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.property_value_float = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorymodifyitemsrequestitempropertyupdate() CInventoryModifyItemsRequestItemPropertyUpdate {
return CInventoryModifyItemsRequestItemPropertyUpdate{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorymodifyitemsrequestitempropertyupdate(o CInventoryModifyItemsRequestItemPropertyUpdate, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorymodifyitemsrequestitempropertyupdate(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryModifyItemsRequestItemPropertyUpdate) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorymodifyitemsrequestitempropertyupdate_unpack(v)?
return i, unpacked
}
pub struct CInventoryModifyItemsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
steamid u64
has_steamid bool
updates []CInventoryModifyItemsRequestItemPropertyUpdate
timestamp u32
has_timestamp bool
}
pub fn (o &CInventoryModifyItemsRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_steamid {
res << vproto.pack_uint64_field(o.steamid, 2)
}

// [packed=false]
for _, x in o.updates {
res << zzz_vproto_internal_pack_cinventorymodifyitemsrequestitempropertyupdate(x, 3)
}

if o.has_timestamp {
res << vproto.pack_uint32_field(o.timestamp, 4)
}

return res
}

pub fn cinventorymodifyitemsrequest_unpack(buf []byte) ?CInventoryModifyItemsRequest {
mut res := CInventoryModifyItemsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cinventorymodifyitemsrequestitempropertyupdate(cur_buf, tag_wiretype.wire_type)?
res.updates << v
i = ii
}

4 {
res.has_timestamp = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorymodifyitemsrequest() CInventoryModifyItemsRequest {
return CInventoryModifyItemsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorymodifyitemsrequest(o CInventoryModifyItemsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorymodifyitemsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryModifyItemsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorymodifyitemsrequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryConsumePlaytimeRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
itemdefid u64
has_itemdefid bool
}
pub fn (o &CInventoryConsumePlaytimeRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_itemdefid {
res << vproto.pack_uint64_field(o.itemdefid, 2)
}

return res
}

pub fn cinventoryconsumeplaytimerequest_unpack(buf []byte) ?CInventoryConsumePlaytimeRequest {
mut res := CInventoryConsumePlaytimeRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_itemdefid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.itemdefid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventoryconsumeplaytimerequest() CInventoryConsumePlaytimeRequest {
return CInventoryConsumePlaytimeRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventoryconsumeplaytimerequest(o CInventoryConsumePlaytimeRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventoryconsumeplaytimerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryConsumePlaytimeRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventoryconsumeplaytimerequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryConsumeItemRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
itemid u64
has_itemid bool
quantity u32
has_quantity bool
timestamp string
has_timestamp bool
steamid u64
has_steamid bool
requestid u64
has_requestid bool
}
pub fn (o &CInventoryConsumeItemRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_itemid {
res << vproto.pack_uint64_field(o.itemid, 2)
}

if o.has_quantity {
res << vproto.pack_uint32_field(o.quantity, 3)
}

if o.has_timestamp {
res << vproto.pack_string_field(o.timestamp, 4)
}

if o.has_steamid {
res << vproto.pack_uint64_field(o.steamid, 5)
}

if o.has_requestid {
res << vproto.pack_uint64_field(o.requestid, 6)
}

return res
}

pub fn cinventoryconsumeitemrequest_unpack(buf []byte) ?CInventoryConsumeItemRequest {
mut res := CInventoryConsumeItemRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_itemid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.itemid = v
i = ii
}

3 {
res.has_quantity = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.quantity = v
i = ii
}

4 {
res.has_timestamp = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp = v
i = ii
}

5 {
res.has_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

6 {
res.has_requestid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.requestid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventoryconsumeitemrequest() CInventoryConsumeItemRequest {
return CInventoryConsumeItemRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventoryconsumeitemrequest(o CInventoryConsumeItemRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventoryconsumeitemrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryConsumeItemRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventoryconsumeitemrequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryDevSetNextDropRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
itemdefid u64
has_itemdefid bool
droptime string
has_droptime bool
}
pub fn (o &CInventoryDevSetNextDropRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_itemdefid {
res << vproto.pack_uint64_field(o.itemdefid, 2)
}

if o.has_droptime {
res << vproto.pack_string_field(o.droptime, 3)
}

return res
}

pub fn cinventorydevsetnextdroprequest_unpack(buf []byte) ?CInventoryDevSetNextDropRequest {
mut res := CInventoryDevSetNextDropRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_itemdefid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.itemdefid = v
i = ii
}

3 {
res.has_droptime = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.droptime = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorydevsetnextdroprequest() CInventoryDevSetNextDropRequest {
return CInventoryDevSetNextDropRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorydevsetnextdroprequest(o CInventoryDevSetNextDropRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorydevsetnextdroprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryDevSetNextDropRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorydevsetnextdroprequest_unpack(v)?
return i, unpacked
}
pub struct CInventorySplitItemStackRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
itemid u64
has_itemid bool
quantity u32
has_quantity bool
steamid u64
has_steamid bool
}
pub fn (o &CInventorySplitItemStackRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_itemid {
res << vproto.pack_uint64_field(o.itemid, 2)
}

if o.has_quantity {
res << vproto.pack_uint32_field(o.quantity, 3)
}

if o.has_steamid {
res << vproto.pack_uint64_field(o.steamid, 5)
}

return res
}

pub fn cinventorysplititemstackrequest_unpack(buf []byte) ?CInventorySplitItemStackRequest {
mut res := CInventorySplitItemStackRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_itemid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.itemid = v
i = ii
}

3 {
res.has_quantity = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.quantity = v
i = ii
}

5 {
res.has_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorysplititemstackrequest() CInventorySplitItemStackRequest {
return CInventorySplitItemStackRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorysplititemstackrequest(o CInventorySplitItemStackRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorysplititemstackrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventorySplitItemStackRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorysplititemstackrequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryCombineItemStacksRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
fromitemid u64
has_fromitemid bool
destitemid u64
has_destitemid bool
quantity u32
has_quantity bool
steamid u64
has_steamid bool
}
pub fn (o &CInventoryCombineItemStacksRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_fromitemid {
res << vproto.pack_uint64_field(o.fromitemid, 2)
}

if o.has_destitemid {
res << vproto.pack_uint64_field(o.destitemid, 3)
}

if o.has_quantity {
res << vproto.pack_uint32_field(o.quantity, 4)
}

if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 7)
}

return res
}

pub fn cinventorycombineitemstacksrequest_unpack(buf []byte) ?CInventoryCombineItemStacksRequest {
mut res := CInventoryCombineItemStacksRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_fromitemid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.fromitemid = v
i = ii
}

3 {
res.has_destitemid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.destitemid = v
i = ii
}

4 {
res.has_quantity = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.quantity = v
i = ii
}

7 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorycombineitemstacksrequest() CInventoryCombineItemStacksRequest {
return CInventoryCombineItemStacksRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorycombineitemstacksrequest(o CInventoryCombineItemStacksRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorycombineitemstacksrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryCombineItemStacksRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorycombineitemstacksrequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryGetItemDefMetaRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
}
pub fn (o &CInventoryGetItemDefMetaRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

return res
}

pub fn cinventorygetitemdefmetarequest_unpack(buf []byte) ?CInventoryGetItemDefMetaRequest {
mut res := CInventoryGetItemDefMetaRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorygetitemdefmetarequest() CInventoryGetItemDefMetaRequest {
return CInventoryGetItemDefMetaRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorygetitemdefmetarequest(o CInventoryGetItemDefMetaRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorygetitemdefmetarequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryGetItemDefMetaRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorygetitemdefmetarequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryGetItemDefMetaResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
modified u32
has_modified bool
digest string
has_digest bool
}
pub fn (o &CInventoryGetItemDefMetaResponse) pack() []byte {
mut res := []byte{}
if o.has_modified {
res << vproto.pack_uint32_field(o.modified, 1)
}

if o.has_digest {
res << vproto.pack_string_field(o.digest, 2)
}

return res
}

pub fn cinventorygetitemdefmetaresponse_unpack(buf []byte) ?CInventoryGetItemDefMetaResponse {
mut res := CInventoryGetItemDefMetaResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_modified = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.modified = v
i = ii
}

2 {
res.has_digest = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.digest = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorygetitemdefmetaresponse() CInventoryGetItemDefMetaResponse {
return CInventoryGetItemDefMetaResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorygetitemdefmetaresponse(o CInventoryGetItemDefMetaResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorygetitemdefmetaresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryGetItemDefMetaResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorygetitemdefmetaresponse_unpack(v)?
return i, unpacked
}
pub struct CInventoryGetUserPurchaseInfoRequest {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CInventoryGetUserPurchaseInfoRequest) pack() []byte {
res := []byte{}
return res
}

pub fn cinventorygetuserpurchaseinforequest_unpack(buf []byte) ?CInventoryGetUserPurchaseInfoRequest {
res := CInventoryGetUserPurchaseInfoRequest{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorygetuserpurchaseinforequest() CInventoryGetUserPurchaseInfoRequest {
return CInventoryGetUserPurchaseInfoRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorygetuserpurchaseinforequest(o CInventoryGetUserPurchaseInfoRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorygetuserpurchaseinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryGetUserPurchaseInfoRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorygetuserpurchaseinforequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryGetUserPurchaseInfoResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
ecurrency int
has_ecurrency bool
}
pub fn (o &CInventoryGetUserPurchaseInfoResponse) pack() []byte {
mut res := []byte{}
if o.has_ecurrency {
res << vproto.pack_int32_field(o.ecurrency, 1)
}

return res
}

pub fn cinventorygetuserpurchaseinforesponse_unpack(buf []byte) ?CInventoryGetUserPurchaseInfoResponse {
mut res := CInventoryGetUserPurchaseInfoResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_ecurrency = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.ecurrency = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorygetuserpurchaseinforesponse() CInventoryGetUserPurchaseInfoResponse {
return CInventoryGetUserPurchaseInfoResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorygetuserpurchaseinforesponse(o CInventoryGetUserPurchaseInfoResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorygetuserpurchaseinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryGetUserPurchaseInfoResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorygetuserpurchaseinforesponse_unpack(v)?
return i, unpacked
}
pub struct CInventoryPurchaseInitRequestLineItem {
mut:
unknown_fields []vproto.UnknownField
pub mut:
itemdefid u64
has_itemdefid bool
quantity u32
has_quantity bool
}
pub fn (o &CInventoryPurchaseInitRequestLineItem) pack() []byte {
mut res := []byte{}
if o.has_itemdefid {
res << vproto.pack_uint64_field(o.itemdefid, 1)
}

if o.has_quantity {
res << vproto.pack_uint32_field(o.quantity, 2)
}

return res
}

pub fn cinventorypurchaseinitrequestlineitem_unpack(buf []byte) ?CInventoryPurchaseInitRequestLineItem {
mut res := CInventoryPurchaseInitRequestLineItem{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_itemdefid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.itemdefid = v
i = ii
}

2 {
res.has_quantity = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.quantity = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorypurchaseinitrequestlineitem() CInventoryPurchaseInitRequestLineItem {
return CInventoryPurchaseInitRequestLineItem{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorypurchaseinitrequestlineitem(o CInventoryPurchaseInitRequestLineItem, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorypurchaseinitrequestlineitem(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryPurchaseInitRequestLineItem) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorypurchaseinitrequestlineitem_unpack(v)?
return i, unpacked
}
pub struct CInventoryPurchaseInitRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
language int
has_language bool
line_items []CInventoryPurchaseInitRequestLineItem
}
pub fn (o &CInventoryPurchaseInitRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_language {
res << vproto.pack_int32_field(o.language, 2)
}

// [packed=false]
for _, x in o.line_items {
res << zzz_vproto_internal_pack_cinventorypurchaseinitrequestlineitem(x, 3)
}

return res
}

pub fn cinventorypurchaseinitrequest_unpack(buf []byte) ?CInventoryPurchaseInitRequest {
mut res := CInventoryPurchaseInitRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_language = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cinventorypurchaseinitrequestlineitem(cur_buf, tag_wiretype.wire_type)?
res.line_items << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorypurchaseinitrequest() CInventoryPurchaseInitRequest {
return CInventoryPurchaseInitRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorypurchaseinitrequest(o CInventoryPurchaseInitRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorypurchaseinitrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryPurchaseInitRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorypurchaseinitrequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryPurchaseInitResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
orderid u64
has_orderid bool
transid u64
has_transid bool
}
pub fn (o &CInventoryPurchaseInitResponse) pack() []byte {
mut res := []byte{}
if o.has_orderid {
res << vproto.pack_uint64_field(o.orderid, 1)
}

if o.has_transid {
res << vproto.pack_uint64_field(o.transid, 2)
}

return res
}

pub fn cinventorypurchaseinitresponse_unpack(buf []byte) ?CInventoryPurchaseInitResponse {
mut res := CInventoryPurchaseInitResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_orderid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.orderid = v
i = ii
}

2 {
res.has_transid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.transid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorypurchaseinitresponse() CInventoryPurchaseInitResponse {
return CInventoryPurchaseInitResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorypurchaseinitresponse(o CInventoryPurchaseInitResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorypurchaseinitresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryPurchaseInitResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorypurchaseinitresponse_unpack(v)?
return i, unpacked
}
pub struct CInventoryPurchaseFinalizeRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
language int
has_language bool
orderid u64
has_orderid bool
}
pub fn (o &CInventoryPurchaseFinalizeRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_language {
res << vproto.pack_int32_field(o.language, 2)
}

if o.has_orderid {
res << vproto.pack_uint64_field(o.orderid, 3)
}

return res
}

pub fn cinventorypurchasefinalizerequest_unpack(buf []byte) ?CInventoryPurchaseFinalizeRequest {
mut res := CInventoryPurchaseFinalizeRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_language = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

3 {
res.has_orderid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.orderid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventorypurchasefinalizerequest() CInventoryPurchaseFinalizeRequest {
return CInventoryPurchaseFinalizeRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventorypurchasefinalizerequest(o CInventoryPurchaseFinalizeRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventorypurchasefinalizerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryPurchaseFinalizeRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventorypurchasefinalizerequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryInspectItemRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
itemdefid u64
has_itemdefid bool
itemid u64
has_itemid bool
tags string
has_tags bool
}
pub fn (o &CInventoryInspectItemRequest) pack() []byte {
mut res := []byte{}
if o.has_itemdefid {
res << vproto.pack_uint64_field(o.itemdefid, 1)
}

if o.has_itemid {
res << vproto.pack_64bit_field(o.itemid, 2)
}

if o.has_tags {
res << vproto.pack_string_field(o.tags, 3)
}

return res
}

pub fn cinventoryinspectitemrequest_unpack(buf []byte) ?CInventoryInspectItemRequest {
mut res := CInventoryInspectItemRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_itemdefid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.itemdefid = v
i = ii
}

2 {
res.has_itemid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.itemid = v
i = ii
}

3 {
res.has_tags = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.tags = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventoryinspectitemrequest() CInventoryInspectItemRequest {
return CInventoryInspectItemRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventoryinspectitemrequest(o CInventoryInspectItemRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventoryinspectitemrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryInspectItemRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventoryinspectitemrequest_unpack(v)?
return i, unpacked
}
pub struct CInventoryClientNewItemsNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
inventory_response CInventoryResponse
has_inventory_response bool
}
pub fn (o &CInventoryClientNewItemsNotification) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_inventory_response {
res << zzz_vproto_internal_pack_cinventoryresponse(o.inventory_response, 2)
}

return res
}

pub fn cinventoryclientnewitemsnotification_unpack(buf []byte) ?CInventoryClientNewItemsNotification {
mut res := CInventoryClientNewItemsNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_inventory_response = true
ii, v := zzz_vproto_internal_unpack_cinventoryresponse(cur_buf, tag_wiretype.wire_type)?
res.inventory_response = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventoryclientnewitemsnotification() CInventoryClientNewItemsNotification {
return CInventoryClientNewItemsNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventoryclientnewitemsnotification(o CInventoryClientNewItemsNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventoryclientnewitemsnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryClientNewItemsNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cinventoryclientnewitemsnotification_unpack(v)?
return i, unpacked
}
