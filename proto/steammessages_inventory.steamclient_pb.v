// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CInventory_GetInventory_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CInventory_GetInventory_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 2)
	}
	return res
}

pub fn cinventory_getinventory_request_unpack(buf []byte) ?CInventory_GetInventory_Request {
	mut res := CInventory_GetInventory_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_getinventory_request() CInventory_GetInventory_Request {
	return CInventory_GetInventory_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_getinventory_request(o CInventory_GetInventory_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_getinventory_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetInventory_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_getinventory_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_Response {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	etag             string
	has_etag         bool
	removeditemids   []u64
	item_json        string
	has_item_json    bool
	itemdef_json     string
	has_itemdef_json bool
	ticket           []byte
	has_ticket       bool
	replayed         bool
	has_replayed     bool
}

pub fn (o &CInventory_Response) pack() []byte {
	mut res := []byte{}
	if o.has_etag {
		res << vproto.pack_string_field(o.etag, 1)
	}
	// [packed=false]
	for _, x in o.removeditemids {
		res << vproto.pack_uint64_field(x, 2)
	}
	if o.has_item_json {
		res << vproto.pack_string_field(o.item_json, 3)
	}
	if o.has_itemdef_json {
		res << vproto.pack_string_field(o.itemdef_json, 4)
	}
	if o.has_ticket {
		res << vproto.pack_bytes_field(o.ticket, 5)
	}
	if o.has_replayed {
		res << vproto.pack_bool_field(o.replayed, 6)
	}
	return res
}

pub fn cinventory_response_unpack(buf []byte) ?CInventory_Response {
	mut res := CInventory_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_etag = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.etag = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.removeditemids << v
				i = ii
			}
			3 {
				res.has_item_json = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.item_json = v
				i = ii
			}
			4 {
				res.has_itemdef_json = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdef_json = v
				i = ii
			}
			5 {
				res.has_ticket = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.ticket = v
				i = ii
			}
			6 {
				res.has_replayed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.replayed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_response() CInventory_Response {
	return CInventory_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_response(o CInventory_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_response_unpack(v)?
	return i, unpacked
}

pub struct CInventory_ExchangeItem_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	appid               u32
	has_appid           bool
	steamid             u64
	has_steamid         bool
	materialsitemid     []u64
	materialsquantity   []u32
	outputitemdefid     u64
	has_outputitemdefid bool
}

pub fn (o &CInventory_ExchangeItem_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 2)
	}
	// [packed=false]
	for _, x in o.materialsitemid {
		res << vproto.pack_uint64_field(x, 3)
	}
	// [packed=false]
	for _, x in o.materialsquantity {
		res << vproto.pack_uint32_field(x, 4)
	}
	if o.has_outputitemdefid {
		res << vproto.pack_uint64_field(o.outputitemdefid, 5)
	}
	return res
}

pub fn cinventory_exchangeitem_request_unpack(buf []byte) ?CInventory_ExchangeItem_Request {
	mut res := CInventory_ExchangeItem_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.materialsitemid << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.materialsquantity << v
				i = ii
			}
			5 {
				res.has_outputitemdefid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.outputitemdefid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_exchangeitem_request() CInventory_ExchangeItem_Request {
	return CInventory_ExchangeItem_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_exchangeitem_request(o CInventory_ExchangeItem_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_exchangeitem_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_ExchangeItem_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_exchangeitem_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_GetEligiblePromoItemDefIDs_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CInventory_GetEligiblePromoItemDefIDs_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 2)
	}
	return res
}

pub fn cinventory_geteligiblepromoitemdefids_request_unpack(buf []byte) ?CInventory_GetEligiblePromoItemDefIDs_Request {
	mut res := CInventory_GetEligiblePromoItemDefIDs_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_geteligiblepromoitemdefids_request() CInventory_GetEligiblePromoItemDefIDs_Request {
	return CInventory_GetEligiblePromoItemDefIDs_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_geteligiblepromoitemdefids_request(o CInventory_GetEligiblePromoItemDefIDs_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_geteligiblepromoitemdefids_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetEligiblePromoItemDefIDs_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_geteligiblepromoitemdefids_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_GetEligiblePromoItemDefIDs_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	itemdefids     []u64
}

pub fn (o &CInventory_GetEligiblePromoItemDefIDs_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.itemdefids {
		res << vproto.pack_uint64_field(x, 1)
	}
	return res
}

pub fn cinventory_geteligiblepromoitemdefids_response_unpack(buf []byte) ?CInventory_GetEligiblePromoItemDefIDs_Response {
	mut res := CInventory_GetEligiblePromoItemDefIDs_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdefids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_geteligiblepromoitemdefids_response() CInventory_GetEligiblePromoItemDefIDs_Response {
	return CInventory_GetEligiblePromoItemDefIDs_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_geteligiblepromoitemdefids_response(o CInventory_GetEligiblePromoItemDefIDs_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_geteligiblepromoitemdefids_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetEligiblePromoItemDefIDs_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_geteligiblepromoitemdefids_response_unpack(v)?
	return i, unpacked
}

pub struct CInventory_AddItem_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	appid                 u32
	has_appid             bool
	itemdefid             []u64
	itempropsjson         []string
	steamid               u64
	has_steamid           bool
	notify                bool
	has_notify            bool
	requestid             u64
	has_requestid         bool
	trade_restriction     bool
	has_trade_restriction bool
	is_purchase           bool
	has_is_purchase       bool
}

pub fn (o &CInventory_AddItem_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.itemdefid {
		res << vproto.pack_uint64_field(x, 2)
	}
	// [packed=false]
	for _, x in o.itempropsjson {
		res << vproto.pack_string_field(x, 3)
	}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 4)
	}
	if o.has_notify {
		res << vproto.pack_bool_field(o.notify, 5)
	}
	if o.has_requestid {
		res << vproto.pack_uint64_field(o.requestid, 6)
	}
	if o.has_trade_restriction {
		res << vproto.pack_bool_field(o.trade_restriction, 7)
	}
	if o.has_is_purchase {
		res << vproto.pack_bool_field(o.is_purchase, 8)
	}
	return res
}

pub fn cinventory_additem_request_unpack(buf []byte) ?CInventory_AddItem_Request {
	mut res := CInventory_AddItem_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdefid << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.itempropsjson << v
				i = ii
			}
			4 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			5 {
				res.has_notify = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.notify = v
				i = ii
			}
			6 {
				res.has_requestid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.requestid = v
				i = ii
			}
			7 {
				res.has_trade_restriction = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.trade_restriction = v
				i = ii
			}
			8 {
				res.has_is_purchase = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_purchase = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_additem_request() CInventory_AddItem_Request {
	return CInventory_AddItem_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_additem_request(o CInventory_AddItem_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_additem_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_AddItem_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_additem_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_ModifyItems_Request_ItemPropertyUpdate {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	itemid                    u64
	has_itemid                bool
	remove_property           bool
	has_remove_property       bool
	property_name             string
	has_property_name         bool
	property_value_bool       bool
	has_property_value_bool   bool
	property_value_int        i64
	has_property_value_int    bool
	property_value_string     string
	has_property_value_string bool
	property_value_float      f32
	has_property_value_float  bool
}

pub fn (o &CInventory_ModifyItems_Request_ItemPropertyUpdate) pack() []byte {
	mut res := []byte{}
	if o.has_itemid {
		res << vproto.pack_uint64_field(o.itemid, 1)
	}
	if o.has_remove_property {
		res << vproto.pack_bool_field(o.remove_property, 2)
	}
	if o.has_property_name {
		res << vproto.pack_string_field(o.property_name, 3)
	}
	if o.has_property_value_bool {
		res << vproto.pack_bool_field(o.property_value_bool, 4)
	}
	if o.has_property_value_int {
		res << vproto.pack_int64_field(o.property_value_int, 5)
	}
	if o.has_property_value_string {
		res << vproto.pack_string_field(o.property_value_string, 6)
	}
	if o.has_property_value_float {
		res << vproto.pack_float_field(o.property_value_float, 7)
	}
	return res
}

pub fn cinventory_modifyitems_request_itempropertyupdate_unpack(buf []byte) ?CInventory_ModifyItems_Request_ItemPropertyUpdate {
	mut res := CInventory_ModifyItems_Request_ItemPropertyUpdate{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_itemid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemid = v
				i = ii
			}
			2 {
				res.has_remove_property = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.remove_property = v
				i = ii
			}
			3 {
				res.has_property_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.property_name = v
				i = ii
			}
			4 {
				res.has_property_value_bool = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.property_value_bool = v
				i = ii
			}
			5 {
				res.has_property_value_int = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
				res.property_value_int = v
				i = ii
			}
			6 {
				res.has_property_value_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.property_value_string = v
				i = ii
			}
			7 {
				res.has_property_value_float = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.property_value_float = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_modifyitems_request_itempropertyupdate() CInventory_ModifyItems_Request_ItemPropertyUpdate {
	return CInventory_ModifyItems_Request_ItemPropertyUpdate{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_modifyitems_request_itempropertyupdate(o CInventory_ModifyItems_Request_ItemPropertyUpdate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_modifyitems_request_itempropertyupdate(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_ModifyItems_Request_ItemPropertyUpdate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_modifyitems_request_itempropertyupdate_unpack(v)?
	return i, unpacked
}

pub struct CInventory_ModifyItems_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	steamid        u64
	has_steamid    bool
	updates        []CInventory_ModifyItems_Request_ItemPropertyUpdate
	timestamp      u32
	has_timestamp  bool
}

pub fn (o &CInventory_ModifyItems_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 2)
	}
	// [packed=false]
	for _, x in o.updates {
		res << zzz_vproto_internal_pack_cinventory_modifyitems_request_itempropertyupdate(x, 3)
	}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 4)
	}
	return res
}

pub fn cinventory_modifyitems_request_unpack(buf []byte) ?CInventory_ModifyItems_Request {
	mut res := CInventory_ModifyItems_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cinventory_modifyitems_request_itempropertyupdate(cur_buf,
					tag_wiretype.wire_type)?
				res.updates << v
				i = ii
			}
			4 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_modifyitems_request() CInventory_ModifyItems_Request {
	return CInventory_ModifyItems_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_modifyitems_request(o CInventory_ModifyItems_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_modifyitems_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_ModifyItems_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_modifyitems_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_ConsumePlaytime_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	itemdefid      u64
	has_itemdefid  bool
}

pub fn (o &CInventory_ConsumePlaytime_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_itemdefid {
		res << vproto.pack_uint64_field(o.itemdefid, 2)
	}
	return res
}

pub fn cinventory_consumeplaytime_request_unpack(buf []byte) ?CInventory_ConsumePlaytime_Request {
	mut res := CInventory_ConsumePlaytime_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_itemdefid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdefid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_consumeplaytime_request() CInventory_ConsumePlaytime_Request {
	return CInventory_ConsumePlaytime_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_consumeplaytime_request(o CInventory_ConsumePlaytime_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_consumeplaytime_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_ConsumePlaytime_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_consumeplaytime_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_ConsumeItem_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	itemid         u64
	has_itemid     bool
	quantity       u32
	has_quantity   bool
	timestamp      string
	has_timestamp  bool
	steamid        u64
	has_steamid    bool
	requestid      u64
	has_requestid  bool
}

pub fn (o &CInventory_ConsumeItem_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_itemid {
		res << vproto.pack_uint64_field(o.itemid, 2)
	}
	if o.has_quantity {
		res << vproto.pack_uint32_field(o.quantity, 3)
	}
	if o.has_timestamp {
		res << vproto.pack_string_field(o.timestamp, 4)
	}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 5)
	}
	if o.has_requestid {
		res << vproto.pack_uint64_field(o.requestid, 6)
	}
	return res
}

pub fn cinventory_consumeitem_request_unpack(buf []byte) ?CInventory_ConsumeItem_Request {
	mut res := CInventory_ConsumeItem_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_itemid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemid = v
				i = ii
			}
			3 {
				res.has_quantity = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quantity = v
				i = ii
			}
			4 {
				res.has_timestamp = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			5 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			6 {
				res.has_requestid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.requestid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_consumeitem_request() CInventory_ConsumeItem_Request {
	return CInventory_ConsumeItem_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_consumeitem_request(o CInventory_ConsumeItem_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_consumeitem_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_ConsumeItem_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_consumeitem_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_DevSetNextDrop_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	itemdefid      u64
	has_itemdefid  bool
	droptime       string
	has_droptime   bool
}

pub fn (o &CInventory_DevSetNextDrop_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_itemdefid {
		res << vproto.pack_uint64_field(o.itemdefid, 2)
	}
	if o.has_droptime {
		res << vproto.pack_string_field(o.droptime, 3)
	}
	return res
}

pub fn cinventory_devsetnextdrop_request_unpack(buf []byte) ?CInventory_DevSetNextDrop_Request {
	mut res := CInventory_DevSetNextDrop_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_itemdefid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdefid = v
				i = ii
			}
			3 {
				res.has_droptime = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.droptime = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_devsetnextdrop_request() CInventory_DevSetNextDrop_Request {
	return CInventory_DevSetNextDrop_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_devsetnextdrop_request(o CInventory_DevSetNextDrop_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_devsetnextdrop_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_DevSetNextDrop_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_devsetnextdrop_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_SplitItemStack_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	itemid         u64
	has_itemid     bool
	quantity       u32
	has_quantity   bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CInventory_SplitItemStack_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_itemid {
		res << vproto.pack_uint64_field(o.itemid, 2)
	}
	if o.has_quantity {
		res << vproto.pack_uint32_field(o.quantity, 3)
	}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 5)
	}
	return res
}

pub fn cinventory_splititemstack_request_unpack(buf []byte) ?CInventory_SplitItemStack_Request {
	mut res := CInventory_SplitItemStack_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_itemid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemid = v
				i = ii
			}
			3 {
				res.has_quantity = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quantity = v
				i = ii
			}
			5 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_splititemstack_request() CInventory_SplitItemStack_Request {
	return CInventory_SplitItemStack_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_splititemstack_request(o CInventory_SplitItemStack_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_splititemstack_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_SplitItemStack_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_splititemstack_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_CombineItemStacks_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	fromitemid     u64
	has_fromitemid bool
	destitemid     u64
	has_destitemid bool
	quantity       u32
	has_quantity   bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CInventory_CombineItemStacks_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_fromitemid {
		res << vproto.pack_uint64_field(o.fromitemid, 2)
	}
	if o.has_destitemid {
		res << vproto.pack_uint64_field(o.destitemid, 3)
	}
	if o.has_quantity {
		res << vproto.pack_uint32_field(o.quantity, 4)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 7)
	}
	return res
}

pub fn cinventory_combineitemstacks_request_unpack(buf []byte) ?CInventory_CombineItemStacks_Request {
	mut res := CInventory_CombineItemStacks_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_fromitemid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.fromitemid = v
				i = ii
			}
			3 {
				res.has_destitemid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.destitemid = v
				i = ii
			}
			4 {
				res.has_quantity = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quantity = v
				i = ii
			}
			7 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_combineitemstacks_request() CInventory_CombineItemStacks_Request {
	return CInventory_CombineItemStacks_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_combineitemstacks_request(o CInventory_CombineItemStacks_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_combineitemstacks_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_CombineItemStacks_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_combineitemstacks_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_GetItemDefMeta_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
}

pub fn (o &CInventory_GetItemDefMeta_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cinventory_getitemdefmeta_request_unpack(buf []byte) ?CInventory_GetItemDefMeta_Request {
	mut res := CInventory_GetItemDefMeta_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_getitemdefmeta_request() CInventory_GetItemDefMeta_Request {
	return CInventory_GetItemDefMeta_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_getitemdefmeta_request(o CInventory_GetItemDefMeta_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_getitemdefmeta_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetItemDefMeta_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_getitemdefmeta_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_GetItemDefMeta_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	modified       u32
	has_modified   bool
	digest         string
	has_digest     bool
}

pub fn (o &CInventory_GetItemDefMeta_Response) pack() []byte {
	mut res := []byte{}
	if o.has_modified {
		res << vproto.pack_uint32_field(o.modified, 1)
	}
	if o.has_digest {
		res << vproto.pack_string_field(o.digest, 2)
	}
	return res
}

pub fn cinventory_getitemdefmeta_response_unpack(buf []byte) ?CInventory_GetItemDefMeta_Response {
	mut res := CInventory_GetItemDefMeta_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_modified = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modified = v
				i = ii
			}
			2 {
				res.has_digest = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.digest = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_getitemdefmeta_response() CInventory_GetItemDefMeta_Response {
	return CInventory_GetItemDefMeta_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_getitemdefmeta_response(o CInventory_GetItemDefMeta_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_getitemdefmeta_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetItemDefMeta_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_getitemdefmeta_response_unpack(v)?
	return i, unpacked
}

pub struct CInventory_GetUserPurchaseInfo_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CInventory_GetUserPurchaseInfo_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cinventory_getuserpurchaseinfo_request_unpack(buf []byte) ?CInventory_GetUserPurchaseInfo_Request {
	res := CInventory_GetUserPurchaseInfo_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_getuserpurchaseinfo_request() CInventory_GetUserPurchaseInfo_Request {
	return CInventory_GetUserPurchaseInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_getuserpurchaseinfo_request(o CInventory_GetUserPurchaseInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_getuserpurchaseinfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetUserPurchaseInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_getuserpurchaseinfo_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_GetUserPurchaseInfo_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ecurrency      int
	has_ecurrency  bool
}

pub fn (o &CInventory_GetUserPurchaseInfo_Response) pack() []byte {
	mut res := []byte{}
	if o.has_ecurrency {
		res << vproto.pack_int32_field(o.ecurrency, 1)
	}
	return res
}

pub fn cinventory_getuserpurchaseinfo_response_unpack(buf []byte) ?CInventory_GetUserPurchaseInfo_Response {
	mut res := CInventory_GetUserPurchaseInfo_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ecurrency = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ecurrency = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_getuserpurchaseinfo_response() CInventory_GetUserPurchaseInfo_Response {
	return CInventory_GetUserPurchaseInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_getuserpurchaseinfo_response(o CInventory_GetUserPurchaseInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_getuserpurchaseinfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_GetUserPurchaseInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_getuserpurchaseinfo_response_unpack(v)?
	return i, unpacked
}

pub struct CInventory_PurchaseInit_Request_LineItem {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	itemdefid      u64
	has_itemdefid  bool
	quantity       u32
	has_quantity   bool
}

pub fn (o &CInventory_PurchaseInit_Request_LineItem) pack() []byte {
	mut res := []byte{}
	if o.has_itemdefid {
		res << vproto.pack_uint64_field(o.itemdefid, 1)
	}
	if o.has_quantity {
		res << vproto.pack_uint32_field(o.quantity, 2)
	}
	return res
}

pub fn cinventory_purchaseinit_request_lineitem_unpack(buf []byte) ?CInventory_PurchaseInit_Request_LineItem {
	mut res := CInventory_PurchaseInit_Request_LineItem{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_itemdefid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdefid = v
				i = ii
			}
			2 {
				res.has_quantity = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quantity = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_purchaseinit_request_lineitem() CInventory_PurchaseInit_Request_LineItem {
	return CInventory_PurchaseInit_Request_LineItem{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_purchaseinit_request_lineitem(o CInventory_PurchaseInit_Request_LineItem, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_purchaseinit_request_lineitem(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_PurchaseInit_Request_LineItem) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_purchaseinit_request_lineitem_unpack(v)?
	return i, unpacked
}

pub struct CInventory_PurchaseInit_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	language       int
	has_language   bool
	line_items     []CInventory_PurchaseInit_Request_LineItem
}

pub fn (o &CInventory_PurchaseInit_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 2)
	}
	// [packed=false]
	for _, x in o.line_items {
		res << zzz_vproto_internal_pack_cinventory_purchaseinit_request_lineitem(x, 3)
	}
	return res
}

pub fn cinventory_purchaseinit_request_unpack(buf []byte) ?CInventory_PurchaseInit_Request {
	mut res := CInventory_PurchaseInit_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cinventory_purchaseinit_request_lineitem(cur_buf,
					tag_wiretype.wire_type)?
				res.line_items << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_purchaseinit_request() CInventory_PurchaseInit_Request {
	return CInventory_PurchaseInit_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_purchaseinit_request(o CInventory_PurchaseInit_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_purchaseinit_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_PurchaseInit_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_purchaseinit_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_PurchaseInit_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	orderid        u64
	has_orderid    bool
	transid        u64
	has_transid    bool
}

pub fn (o &CInventory_PurchaseInit_Response) pack() []byte {
	mut res := []byte{}
	if o.has_orderid {
		res << vproto.pack_uint64_field(o.orderid, 1)
	}
	if o.has_transid {
		res << vproto.pack_uint64_field(o.transid, 2)
	}
	return res
}

pub fn cinventory_purchaseinit_response_unpack(buf []byte) ?CInventory_PurchaseInit_Response {
	mut res := CInventory_PurchaseInit_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_orderid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.orderid = v
				i = ii
			}
			2 {
				res.has_transid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.transid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_purchaseinit_response() CInventory_PurchaseInit_Response {
	return CInventory_PurchaseInit_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_purchaseinit_response(o CInventory_PurchaseInit_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_purchaseinit_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_PurchaseInit_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_purchaseinit_response_unpack(v)?
	return i, unpacked
}

pub struct CInventory_PurchaseFinalize_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	language       int
	has_language   bool
	orderid        u64
	has_orderid    bool
}

pub fn (o &CInventory_PurchaseFinalize_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 2)
	}
	if o.has_orderid {
		res << vproto.pack_uint64_field(o.orderid, 3)
	}
	return res
}

pub fn cinventory_purchasefinalize_request_unpack(buf []byte) ?CInventory_PurchaseFinalize_Request {
	mut res := CInventory_PurchaseFinalize_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			3 {
				res.has_orderid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.orderid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_purchasefinalize_request() CInventory_PurchaseFinalize_Request {
	return CInventory_PurchaseFinalize_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_purchasefinalize_request(o CInventory_PurchaseFinalize_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_purchasefinalize_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_PurchaseFinalize_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_purchasefinalize_request_unpack(v)?
	return i, unpacked
}

pub struct CInventory_InspectItem_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	itemdefid      u64
	has_itemdefid  bool
	itemid         u64
	has_itemid     bool
	tags           string
	has_tags       bool
}

pub fn (o &CInventory_InspectItem_Request) pack() []byte {
	mut res := []byte{}
	if o.has_itemdefid {
		res << vproto.pack_uint64_field(o.itemdefid, 1)
	}
	if o.has_itemid {
		res << vproto.pack_64bit_field(o.itemid, 2)
	}
	if o.has_tags {
		res << vproto.pack_string_field(o.tags, 3)
	}
	return res
}

pub fn cinventory_inspectitem_request_unpack(buf []byte) ?CInventory_InspectItem_Request {
	mut res := CInventory_InspectItem_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_itemdefid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.itemdefid = v
				i = ii
			}
			2 {
				res.has_itemid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.itemid = v
				i = ii
			}
			3 {
				res.has_tags = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventory_inspectitem_request() CInventory_InspectItem_Request {
	return CInventory_InspectItem_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventory_inspectitem_request(o CInventory_InspectItem_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventory_inspectitem_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventory_InspectItem_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventory_inspectitem_request_unpack(v)?
	return i, unpacked
}

pub struct CInventoryClient_NewItems_Notification {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	appid                  u32
	has_appid              bool
	inventory_response     CInventory_Response
	has_inventory_response bool
}

pub fn (o &CInventoryClient_NewItems_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_inventory_response {
		res << zzz_vproto_internal_pack_cinventory_response(o.inventory_response, 2)
	}
	return res
}

pub fn cinventoryclient_newitems_notification_unpack(buf []byte) ?CInventoryClient_NewItems_Notification {
	mut res := CInventoryClient_NewItems_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_inventory_response = true
				ii, v := zzz_vproto_internal_unpack_cinventory_response(cur_buf, tag_wiretype.wire_type)?
				res.inventory_response = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinventoryclient_newitems_notification() CInventoryClient_NewItems_Notification {
	return CInventoryClient_NewItems_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinventoryclient_newitems_notification(o CInventoryClient_NewItems_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinventoryclient_newitems_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CInventoryClient_NewItems_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinventoryclient_newitems_notification_unpack(v)?
	return i, unpacked
}
