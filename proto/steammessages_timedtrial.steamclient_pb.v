
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


pub struct CTimedTrialGetTimeRemainingRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
}
pub fn (o &CTimedTrialGetTimeRemainingRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

return res
}

pub fn ctimedtrialgettimeremainingrequest_unpack(buf []byte) ?CTimedTrialGetTimeRemainingRequest {
mut res := CTimedTrialGetTimeRemainingRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctimedtrialgettimeremainingrequest() CTimedTrialGetTimeRemainingRequest {
return CTimedTrialGetTimeRemainingRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctimedtrialgettimeremainingrequest(o CTimedTrialGetTimeRemainingRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctimedtrialgettimeremainingrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CTimedTrialGetTimeRemainingRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ctimedtrialgettimeremainingrequest_unpack(v)?
return i, unpacked
}
pub struct CTimedTrialGetTimeRemainingResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
seconds_played u32
has_seconds_played bool
seconds_allowed u32
has_seconds_allowed bool
}
pub fn (o &CTimedTrialGetTimeRemainingResponse) pack() []byte {
mut res := []byte{}
if o.has_seconds_played {
res << vproto.pack_uint32_field(o.seconds_played, 1)
}

if o.has_seconds_allowed {
res << vproto.pack_uint32_field(o.seconds_allowed, 2)
}

return res
}

pub fn ctimedtrialgettimeremainingresponse_unpack(buf []byte) ?CTimedTrialGetTimeRemainingResponse {
mut res := CTimedTrialGetTimeRemainingResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_seconds_played = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_played = v
i = ii
}

2 {
res.has_seconds_allowed = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_allowed = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctimedtrialgettimeremainingresponse() CTimedTrialGetTimeRemainingResponse {
return CTimedTrialGetTimeRemainingResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctimedtrialgettimeremainingresponse(o CTimedTrialGetTimeRemainingResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctimedtrialgettimeremainingresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CTimedTrialGetTimeRemainingResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ctimedtrialgettimeremainingresponse_unpack(v)?
return i, unpacked
}
pub struct CTimedTrialRecordPlaytimeRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
seconds_played u32
has_seconds_played bool
}
pub fn (o &CTimedTrialRecordPlaytimeRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_seconds_played {
res << vproto.pack_uint32_field(o.seconds_played, 2)
}

return res
}

pub fn ctimedtrialrecordplaytimerequest_unpack(buf []byte) ?CTimedTrialRecordPlaytimeRequest {
mut res := CTimedTrialRecordPlaytimeRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_seconds_played = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_played = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctimedtrialrecordplaytimerequest() CTimedTrialRecordPlaytimeRequest {
return CTimedTrialRecordPlaytimeRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctimedtrialrecordplaytimerequest(o CTimedTrialRecordPlaytimeRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctimedtrialrecordplaytimerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CTimedTrialRecordPlaytimeRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ctimedtrialrecordplaytimerequest_unpack(v)?
return i, unpacked
}
pub struct CTimedTrialRecordPlaytimeResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
seconds_played u32
has_seconds_played bool
seconds_allowed u32
has_seconds_allowed bool
}
pub fn (o &CTimedTrialRecordPlaytimeResponse) pack() []byte {
mut res := []byte{}
if o.has_seconds_played {
res << vproto.pack_uint32_field(o.seconds_played, 1)
}

if o.has_seconds_allowed {
res << vproto.pack_uint32_field(o.seconds_allowed, 2)
}

return res
}

pub fn ctimedtrialrecordplaytimeresponse_unpack(buf []byte) ?CTimedTrialRecordPlaytimeResponse {
mut res := CTimedTrialRecordPlaytimeResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_seconds_played = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_played = v
i = ii
}

2 {
res.has_seconds_allowed = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_allowed = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctimedtrialrecordplaytimeresponse() CTimedTrialRecordPlaytimeResponse {
return CTimedTrialRecordPlaytimeResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctimedtrialrecordplaytimeresponse(o CTimedTrialRecordPlaytimeResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctimedtrialrecordplaytimeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CTimedTrialRecordPlaytimeResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ctimedtrialrecordplaytimeresponse_unpack(v)?
return i, unpacked
}
pub struct CTimedTrialResetPlaytimeRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
}
pub fn (o &CTimedTrialResetPlaytimeRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

return res
}

pub fn ctimedtrialresetplaytimerequest_unpack(buf []byte) ?CTimedTrialResetPlaytimeRequest {
mut res := CTimedTrialResetPlaytimeRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctimedtrialresetplaytimerequest() CTimedTrialResetPlaytimeRequest {
return CTimedTrialResetPlaytimeRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctimedtrialresetplaytimerequest(o CTimedTrialResetPlaytimeRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctimedtrialresetplaytimerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CTimedTrialResetPlaytimeRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ctimedtrialresetplaytimerequest_unpack(v)?
return i, unpacked
}
pub struct CTimedTrialResetPlaytimeResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
seconds_played u32
has_seconds_played bool
seconds_allowed u32
has_seconds_allowed bool
}
pub fn (o &CTimedTrialResetPlaytimeResponse) pack() []byte {
mut res := []byte{}
if o.has_seconds_played {
res << vproto.pack_uint32_field(o.seconds_played, 1)
}

if o.has_seconds_allowed {
res << vproto.pack_uint32_field(o.seconds_allowed, 2)
}

return res
}

pub fn ctimedtrialresetplaytimeresponse_unpack(buf []byte) ?CTimedTrialResetPlaytimeResponse {
mut res := CTimedTrialResetPlaytimeResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_seconds_played = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_played = v
i = ii
}

2 {
res.has_seconds_allowed = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_allowed = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctimedtrialresetplaytimeresponse() CTimedTrialResetPlaytimeResponse {
return CTimedTrialResetPlaytimeResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctimedtrialresetplaytimeresponse(o CTimedTrialResetPlaytimeResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctimedtrialresetplaytimeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CTimedTrialResetPlaytimeResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ctimedtrialresetplaytimeresponse_unpack(v)?
return i, unpacked
}
