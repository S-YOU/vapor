
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


pub struct CPartnerAppsRequestUploadTokenRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
filename string
has_filename bool
appid u32
has_appid bool
}
pub fn (o &CPartnerAppsRequestUploadTokenRequest) pack() []byte {
mut res := []byte{}
if o.has_filename {
res << vproto.pack_string_field(o.filename, 1)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 2)
}

return res
}

pub fn cpartnerappsrequestuploadtokenrequest_unpack(buf []byte) ?CPartnerAppsRequestUploadTokenRequest {
mut res := CPartnerAppsRequestUploadTokenRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename = v
i = ii
}

2 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsrequestuploadtokenrequest() CPartnerAppsRequestUploadTokenRequest {
return CPartnerAppsRequestUploadTokenRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsrequestuploadtokenrequest(o CPartnerAppsRequestUploadTokenRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsrequestuploadtokenrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsRequestUploadTokenRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsrequestuploadtokenrequest_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsRequestUploadTokenResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
upload_token u64
has_upload_token bool
location string
has_location bool
routing_id u64
has_routing_id bool
}
pub fn (o &CPartnerAppsRequestUploadTokenResponse) pack() []byte {
mut res := []byte{}
if o.has_upload_token {
res << vproto.pack_uint64_field(o.upload_token, 1)
}

if o.has_location {
res << vproto.pack_string_field(o.location, 2)
}

if o.has_routing_id {
res << vproto.pack_uint64_field(o.routing_id, 3)
}

return res
}

pub fn cpartnerappsrequestuploadtokenresponse_unpack(buf []byte) ?CPartnerAppsRequestUploadTokenResponse {
mut res := CPartnerAppsRequestUploadTokenResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_upload_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.upload_token = v
i = ii
}

2 {
res.has_location = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.location = v
i = ii
}

3 {
res.has_routing_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.routing_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsrequestuploadtokenresponse() CPartnerAppsRequestUploadTokenResponse {
return CPartnerAppsRequestUploadTokenResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsrequestuploadtokenresponse(o CPartnerAppsRequestUploadTokenResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsrequestuploadtokenresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsRequestUploadTokenResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsrequestuploadtokenresponse_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsFinishUploadRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
upload_token u64
has_upload_token bool
routing_id u64
has_routing_id bool
app_id u32
has_app_id bool
}
pub fn (o &CPartnerAppsFinishUploadRequest) pack() []byte {
mut res := []byte{}
if o.has_upload_token {
res << vproto.pack_uint64_field(o.upload_token, 1)
}

if o.has_routing_id {
res << vproto.pack_uint64_field(o.routing_id, 2)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 3)
}

return res
}

pub fn cpartnerappsfinishuploadrequest_unpack(buf []byte) ?CPartnerAppsFinishUploadRequest {
mut res := CPartnerAppsFinishUploadRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_upload_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.upload_token = v
i = ii
}

2 {
res.has_routing_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.routing_id = v
i = ii
}

3 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsfinishuploadrequest() CPartnerAppsFinishUploadRequest {
return CPartnerAppsFinishUploadRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsfinishuploadrequest(o CPartnerAppsFinishUploadRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsfinishuploadrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsFinishUploadRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsfinishuploadrequest_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsFinishUploadKVsignResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
signed_installscript string
has_signed_installscript bool
}
pub fn (o &CPartnerAppsFinishUploadKVsignResponse) pack() []byte {
mut res := []byte{}
if o.has_signed_installscript {
res << vproto.pack_string_field(o.signed_installscript, 1)
}

return res
}

pub fn cpartnerappsfinishuploadkvsignresponse_unpack(buf []byte) ?CPartnerAppsFinishUploadKVsignResponse {
mut res := CPartnerAppsFinishUploadKVsignResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_signed_installscript = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.signed_installscript = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsfinishuploadkvsignresponse() CPartnerAppsFinishUploadKVsignResponse {
return CPartnerAppsFinishUploadKVsignResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsfinishuploadkvsignresponse(o CPartnerAppsFinishUploadKVsignResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsfinishuploadkvsignresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsFinishUploadKVsignResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsfinishuploadkvsignresponse_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsFinishUploadLegacyDRmrequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
upload_token u64
has_upload_token bool
routing_id u64
has_routing_id bool
app_id u32
has_app_id bool
flags u32
has_flags bool
tool_name string
has_tool_name bool
}
pub fn (o &CPartnerAppsFinishUploadLegacyDRmrequest) pack() []byte {
mut res := []byte{}
if o.has_upload_token {
res << vproto.pack_uint64_field(o.upload_token, 1)
}

if o.has_routing_id {
res << vproto.pack_uint64_field(o.routing_id, 2)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 3)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 4)
}

if o.has_tool_name {
res << vproto.pack_string_field(o.tool_name, 5)
}

return res
}

pub fn cpartnerappsfinishuploadlegacydrmrequest_unpack(buf []byte) ?CPartnerAppsFinishUploadLegacyDRmrequest {
mut res := CPartnerAppsFinishUploadLegacyDRmrequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_upload_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.upload_token = v
i = ii
}

2 {
res.has_routing_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.routing_id = v
i = ii
}

3 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

4 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

5 {
res.has_tool_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.tool_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsfinishuploadlegacydrmrequest() CPartnerAppsFinishUploadLegacyDRmrequest {
return CPartnerAppsFinishUploadLegacyDRmrequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsfinishuploadlegacydrmrequest(o CPartnerAppsFinishUploadLegacyDRmrequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsfinishuploadlegacydrmrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsFinishUploadLegacyDRmrequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsfinishuploadlegacydrmrequest_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsFinishUploadLegacyDRmresponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
file_id string
has_file_id bool
}
pub fn (o &CPartnerAppsFinishUploadLegacyDRmresponse) pack() []byte {
mut res := []byte{}
if o.has_file_id {
res << vproto.pack_string_field(o.file_id, 1)
}

return res
}

pub fn cpartnerappsfinishuploadlegacydrmresponse_unpack(buf []byte) ?CPartnerAppsFinishUploadLegacyDRmresponse {
mut res := CPartnerAppsFinishUploadLegacyDRmresponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_file_id = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsfinishuploadlegacydrmresponse() CPartnerAppsFinishUploadLegacyDRmresponse {
return CPartnerAppsFinishUploadLegacyDRmresponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsfinishuploadlegacydrmresponse(o CPartnerAppsFinishUploadLegacyDRmresponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsfinishuploadlegacydrmresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsFinishUploadLegacyDRmresponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsfinishuploadlegacydrmresponse_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsFinishUploadResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPartnerAppsFinishUploadResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpartnerappsfinishuploadresponse_unpack(buf []byte) ?CPartnerAppsFinishUploadResponse {
res := CPartnerAppsFinishUploadResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsfinishuploadresponse() CPartnerAppsFinishUploadResponse {
return CPartnerAppsFinishUploadResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsfinishuploadresponse(o CPartnerAppsFinishUploadResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsfinishuploadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsFinishUploadResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsfinishuploadresponse_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsFinishUploadDepotRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
upload_token u64
has_upload_token bool
routing_id u64
has_routing_id bool
app_id u32
has_app_id bool
depot_id u32
has_depot_id bool
build_flags u32
has_build_flags bool
}
pub fn (o &CPartnerAppsFinishUploadDepotRequest) pack() []byte {
mut res := []byte{}
if o.has_upload_token {
res << vproto.pack_uint64_field(o.upload_token, 1)
}

if o.has_routing_id {
res << vproto.pack_uint64_field(o.routing_id, 2)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 3)
}

if o.has_depot_id {
res << vproto.pack_uint32_field(o.depot_id, 4)
}

if o.has_build_flags {
res << vproto.pack_uint32_field(o.build_flags, 5)
}

return res
}

pub fn cpartnerappsfinishuploaddepotrequest_unpack(buf []byte) ?CPartnerAppsFinishUploadDepotRequest {
mut res := CPartnerAppsFinishUploadDepotRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_upload_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.upload_token = v
i = ii
}

2 {
res.has_routing_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.routing_id = v
i = ii
}

3 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

4 {
res.has_depot_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.depot_id = v
i = ii
}

5 {
res.has_build_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.build_flags = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsfinishuploaddepotrequest() CPartnerAppsFinishUploadDepotRequest {
return CPartnerAppsFinishUploadDepotRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsfinishuploaddepotrequest(o CPartnerAppsFinishUploadDepotRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsfinishuploaddepotrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsFinishUploadDepotRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsfinishuploaddepotrequest_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsFinishUploadDepotResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPartnerAppsFinishUploadDepotResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cpartnerappsfinishuploaddepotresponse_unpack(buf []byte) ?CPartnerAppsFinishUploadDepotResponse {
res := CPartnerAppsFinishUploadDepotResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsfinishuploaddepotresponse() CPartnerAppsFinishUploadDepotResponse {
return CPartnerAppsFinishUploadDepotResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsfinishuploaddepotresponse(o CPartnerAppsFinishUploadDepotResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsfinishuploaddepotresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsFinishUploadDepotResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsfinishuploaddepotresponse_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsGetDepotBuildResultRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
upload_token u64
has_upload_token bool
routing_id u64
has_routing_id bool
}
pub fn (o &CPartnerAppsGetDepotBuildResultRequest) pack() []byte {
mut res := []byte{}
if o.has_upload_token {
res << vproto.pack_uint64_field(o.upload_token, 1)
}

if o.has_routing_id {
res << vproto.pack_uint64_field(o.routing_id, 2)
}

return res
}

pub fn cpartnerappsgetdepotbuildresultrequest_unpack(buf []byte) ?CPartnerAppsGetDepotBuildResultRequest {
mut res := CPartnerAppsGetDepotBuildResultRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_upload_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.upload_token = v
i = ii
}

2 {
res.has_routing_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.routing_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsgetdepotbuildresultrequest() CPartnerAppsGetDepotBuildResultRequest {
return CPartnerAppsGetDepotBuildResultRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsgetdepotbuildresultrequest(o CPartnerAppsGetDepotBuildResultRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsgetdepotbuildresultrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsGetDepotBuildResultRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsgetdepotbuildresultrequest_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsGetDepotBuildResultResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
manifest_id u64
has_manifest_id bool
error_msg string
has_error_msg bool
}
pub fn (o &CPartnerAppsGetDepotBuildResultResponse) pack() []byte {
mut res := []byte{}
if o.has_manifest_id {
res << vproto.pack_uint64_field(o.manifest_id, 1)
}

if o.has_error_msg {
res << vproto.pack_string_field(o.error_msg, 2)
}

return res
}

pub fn cpartnerappsgetdepotbuildresultresponse_unpack(buf []byte) ?CPartnerAppsGetDepotBuildResultResponse {
mut res := CPartnerAppsGetDepotBuildResultResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_manifest_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.manifest_id = v
i = ii
}

2 {
res.has_error_msg = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.error_msg = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsgetdepotbuildresultresponse() CPartnerAppsGetDepotBuildResultResponse {
return CPartnerAppsGetDepotBuildResultResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsgetdepotbuildresultresponse(o CPartnerAppsGetDepotBuildResultResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsgetdepotbuildresultresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsGetDepotBuildResultResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsgetdepotbuildresultresponse_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsFindDRmuploadsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id int
has_app_id bool
}
pub fn (o &CPartnerAppsFindDRmuploadsRequest) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_int32_field(o.app_id, 1)
}

return res
}

pub fn cpartnerappsfinddrmuploadsrequest_unpack(buf []byte) ?CPartnerAppsFindDRmuploadsRequest {
mut res := CPartnerAppsFindDRmuploadsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsfinddrmuploadsrequest() CPartnerAppsFindDRmuploadsRequest {
return CPartnerAppsFindDRmuploadsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsfinddrmuploadsrequest(o CPartnerAppsFindDRmuploadsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsfinddrmuploadsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsFindDRmuploadsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsfinddrmuploadsrequest_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsExistingDRmupload {
mut:
unknown_fields []vproto.UnknownField
pub mut:
file_id string
has_file_id bool
app_id u32
has_app_id bool
actor_id int
has_actor_id bool
supplied_name string
has_supplied_name bool
flags u32
has_flags bool
mod_type string
has_mod_type bool
timestamp u32
has_timestamp bool
orig_file_id string
has_orig_file_id bool
}
pub fn (o &CPartnerAppsExistingDRmupload) pack() []byte {
mut res := []byte{}
if o.has_file_id {
res << vproto.pack_string_field(o.file_id, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

if o.has_actor_id {
res << vproto.pack_int32_field(o.actor_id, 3)
}

if o.has_supplied_name {
res << vproto.pack_string_field(o.supplied_name, 5)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 6)
}

if o.has_mod_type {
res << vproto.pack_string_field(o.mod_type, 7)
}

if o.has_timestamp {
res << vproto.pack_32bit_field(o.timestamp, 8)
}

if o.has_orig_file_id {
res << vproto.pack_string_field(o.orig_file_id, 9)
}

return res
}

pub fn cpartnerappsexistingdrmupload_unpack(buf []byte) ?CPartnerAppsExistingDRmupload {
mut res := CPartnerAppsExistingDRmupload{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_file_id = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_id = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

3 {
res.has_actor_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.actor_id = v
i = ii
}

5 {
res.has_supplied_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.supplied_name = v
i = ii
}

6 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

7 {
res.has_mod_type = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.mod_type = v
i = ii
}

8 {
res.has_timestamp = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp = v
i = ii
}

9 {
res.has_orig_file_id = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.orig_file_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsexistingdrmupload() CPartnerAppsExistingDRmupload {
return CPartnerAppsExistingDRmupload{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsexistingdrmupload(o CPartnerAppsExistingDRmupload, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsexistingdrmupload(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsExistingDRmupload) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsexistingdrmupload_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsFindDRmuploadsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
uploads []CPartnerAppsExistingDRmupload
}
pub fn (o &CPartnerAppsFindDRmuploadsResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.uploads {
res << zzz_vproto_internal_pack_cpartnerappsexistingdrmupload(x, 1)
}

return res
}

pub fn cpartnerappsfinddrmuploadsresponse_unpack(buf []byte) ?CPartnerAppsFindDRmuploadsResponse {
mut res := CPartnerAppsFindDRmuploadsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cpartnerappsexistingdrmupload(cur_buf, tag_wiretype.wire_type)?
res.uploads << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsfinddrmuploadsresponse() CPartnerAppsFindDRmuploadsResponse {
return CPartnerAppsFindDRmuploadsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsfinddrmuploadsresponse(o CPartnerAppsFindDRmuploadsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsfinddrmuploadsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsFindDRmuploadsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsfinddrmuploadsresponse_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsDownloadRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
file_id string
has_file_id bool
app_id int
has_app_id bool
}
pub fn (o &CPartnerAppsDownloadRequest) pack() []byte {
mut res := []byte{}
if o.has_file_id {
res << vproto.pack_string_field(o.file_id, 1)
}

if o.has_app_id {
res << vproto.pack_int32_field(o.app_id, 2)
}

return res
}

pub fn cpartnerappsdownloadrequest_unpack(buf []byte) ?CPartnerAppsDownloadRequest {
mut res := CPartnerAppsDownloadRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_file_id = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_id = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsdownloadrequest() CPartnerAppsDownloadRequest {
return CPartnerAppsDownloadRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsdownloadrequest(o CPartnerAppsDownloadRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsdownloadrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsDownloadRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsdownloadrequest_unpack(v)?
return i, unpacked
}
pub struct CPartnerAppsDownloadResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
download_url string
has_download_url bool
app_id int
has_app_id bool
}
pub fn (o &CPartnerAppsDownloadResponse) pack() []byte {
mut res := []byte{}
if o.has_download_url {
res << vproto.pack_string_field(o.download_url, 1)
}

if o.has_app_id {
res << vproto.pack_int32_field(o.app_id, 2)
}

return res
}

pub fn cpartnerappsdownloadresponse_unpack(buf []byte) ?CPartnerAppsDownloadResponse {
mut res := CPartnerAppsDownloadResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_download_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.download_url = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpartnerappsdownloadresponse() CPartnerAppsDownloadResponse {
return CPartnerAppsDownloadResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpartnerappsdownloadresponse(o CPartnerAppsDownloadResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpartnerappsdownloadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPartnerAppsDownloadResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cpartnerappsdownloadresponse_unpack(v)?
return i, unpacked
}
