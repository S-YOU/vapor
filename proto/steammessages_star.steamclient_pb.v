// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum E_STAR_GlyphWriteResult {
	k_e_star_glyphwriteresult_success = 0
	k_e_star_glyphwriteresult_invalidmessage = 1
	k_e_star_glyphwriteresult_invalidjson = 2
	k_e_star_glyphwriteresult_sqlerror = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_e_star_glyphwriteresult(e E_STAR_GlyphWriteResult, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_e_star_glyphwriteresult_packed(e []E_STAR_GlyphWriteResult, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_e_star_glyphwriteresult(buf []byte, tag_wiretype vproto.WireType) ?(int, E_STAR_GlyphWriteResult) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, E_STAR_GlyphWriteResult(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_e_star_glyphwriteresult_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []E_STAR_GlyphWriteResult) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CSTAR_KeyValueQuery {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &CSTAR_KeyValueQuery) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn cstar_keyvaluequery_unpack(buf []byte) ?CSTAR_KeyValueQuery {
	mut res := CSTAR_KeyValueQuery{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstar_keyvaluequery() CSTAR_KeyValueQuery {
	return CSTAR_KeyValueQuery{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstar_keyvaluequery(o CSTAR_KeyValueQuery, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstar_keyvaluequery(buf []byte, tag_wiretype vproto.WireType) ?(int, CSTAR_KeyValueQuery) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstar_keyvaluequery_unpack(v)?
	return i, unpacked
}

pub struct CSTAR_GlyphQueryParams {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bundle_id      u64
	has_bundle_id  bool
	queries        []CSTAR_KeyValueQuery
}

pub fn (o &CSTAR_GlyphQueryParams) pack() []byte {
	mut res := []byte{}
	if o.has_bundle_id {
		res << vproto.pack_uint64_field(o.bundle_id, 1)
	}
	// [packed=false]
	for _, x in o.queries {
		res << zzz_vproto_internal_pack_cstar_keyvaluequery(x, 2)
	}
	return res
}

pub fn cstar_glyphqueryparams_unpack(buf []byte) ?CSTAR_GlyphQueryParams {
	mut res := CSTAR_GlyphQueryParams{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_bundle_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bundle_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstar_keyvaluequery(cur_buf, tag_wiretype.wire_type)?
				res.queries << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstar_glyphqueryparams() CSTAR_GlyphQueryParams {
	return CSTAR_GlyphQueryParams{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstar_glyphqueryparams(o CSTAR_GlyphQueryParams, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstar_glyphqueryparams(buf []byte, tag_wiretype vproto.WireType) ?(int, CSTAR_GlyphQueryParams) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstar_glyphqueryparams_unpack(v)?
	return i, unpacked
}

pub struct CSTAR_ReadGlyphData_Request {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	query_params                       CSTAR_GlyphQueryParams
	has_query_params                   bool
	last_modified_time_lower_limit     string
	has_last_modified_time_lower_limit bool
}

pub fn (o &CSTAR_ReadGlyphData_Request) pack() []byte {
	mut res := []byte{}
	if o.has_query_params {
		res << zzz_vproto_internal_pack_cstar_glyphqueryparams(o.query_params, 1)
	}
	if o.has_last_modified_time_lower_limit {
		res << vproto.pack_string_field(o.last_modified_time_lower_limit, 2)
	}
	return res
}

pub fn cstar_readglyphdata_request_unpack(buf []byte) ?CSTAR_ReadGlyphData_Request {
	mut res := CSTAR_ReadGlyphData_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_query_params = true
				ii, v := zzz_vproto_internal_unpack_cstar_glyphqueryparams(cur_buf, tag_wiretype.wire_type)?
				res.query_params = v
				i = ii
			}
			2 {
				res.has_last_modified_time_lower_limit = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.last_modified_time_lower_limit = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstar_readglyphdata_request() CSTAR_ReadGlyphData_Request {
	return CSTAR_ReadGlyphData_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstar_readglyphdata_request(o CSTAR_ReadGlyphData_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstar_readglyphdata_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CSTAR_ReadGlyphData_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstar_readglyphdata_request_unpack(v)?
	return i, unpacked
}

pub struct CSTAR_GlyphData {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	glyph_guid              []byte
	has_glyph_guid          bool
	glyph_last_modified     string
	has_glyph_last_modified bool
	glyph_json_data         string
	has_glyph_json_data     bool
}

pub fn (o &CSTAR_GlyphData) pack() []byte {
	mut res := []byte{}
	if o.has_glyph_guid {
		res << vproto.pack_bytes_field(o.glyph_guid, 1)
	}
	if o.has_glyph_last_modified {
		res << vproto.pack_string_field(o.glyph_last_modified, 2)
	}
	if o.has_glyph_json_data {
		res << vproto.pack_string_field(o.glyph_json_data, 3)
	}
	return res
}

pub fn cstar_glyphdata_unpack(buf []byte) ?CSTAR_GlyphData {
	mut res := CSTAR_GlyphData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_glyph_guid = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.glyph_guid = v
				i = ii
			}
			2 {
				res.has_glyph_last_modified = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.glyph_last_modified = v
				i = ii
			}
			3 {
				res.has_glyph_json_data = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.glyph_json_data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstar_glyphdata() CSTAR_GlyphData {
	return CSTAR_GlyphData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstar_glyphdata(o CSTAR_GlyphData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstar_glyphdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CSTAR_GlyphData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstar_glyphdata_unpack(v)?
	return i, unpacked
}

pub struct CSTAR_WriteGlyphData_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bundle_id      u64
	has_bundle_id  bool
	glyph_data     []CSTAR_GlyphData
}

pub fn (o &CSTAR_WriteGlyphData_Request) pack() []byte {
	mut res := []byte{}
	if o.has_bundle_id {
		res << vproto.pack_uint64_field(o.bundle_id, 1)
	}
	// [packed=false]
	for _, x in o.glyph_data {
		res << zzz_vproto_internal_pack_cstar_glyphdata(x, 2)
	}
	return res
}

pub fn cstar_writeglyphdata_request_unpack(buf []byte) ?CSTAR_WriteGlyphData_Request {
	mut res := CSTAR_WriteGlyphData_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_bundle_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bundle_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstar_glyphdata(cur_buf, tag_wiretype.wire_type)?
				res.glyph_data << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstar_writeglyphdata_request() CSTAR_WriteGlyphData_Request {
	return CSTAR_WriteGlyphData_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstar_writeglyphdata_request(o CSTAR_WriteGlyphData_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstar_writeglyphdata_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CSTAR_WriteGlyphData_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstar_writeglyphdata_request_unpack(v)?
	return i, unpacked
}

pub struct CSTAR_Request {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	read_glyph_data      CSTAR_ReadGlyphData_Request
	has_read_glyph_data  bool
	write_glyph_data     CSTAR_WriteGlyphData_Request
	has_write_glyph_data bool
}

pub fn (o &CSTAR_Request) pack() []byte {
	mut res := []byte{}
	if o.has_read_glyph_data {
		res << zzz_vproto_internal_pack_cstar_readglyphdata_request(o.read_glyph_data, 1)
	}
	if o.has_write_glyph_data {
		res << zzz_vproto_internal_pack_cstar_writeglyphdata_request(o.write_glyph_data, 2)
	}
	return res
}

pub fn cstar_request_unpack(buf []byte) ?CSTAR_Request {
	mut res := CSTAR_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_read_glyph_data = true
				ii, v := zzz_vproto_internal_unpack_cstar_readglyphdata_request(cur_buf,
					tag_wiretype.wire_type)?
				res.read_glyph_data = v
				i = ii
			}
			2 {
				res.has_write_glyph_data = true
				ii, v := zzz_vproto_internal_unpack_cstar_writeglyphdata_request(cur_buf,
					tag_wiretype.wire_type)?
				res.write_glyph_data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstar_request() CSTAR_Request {
	return CSTAR_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstar_request(o CSTAR_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstar_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CSTAR_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstar_request_unpack(v)?
	return i, unpacked
}

pub struct CSTAR_ReadGlyphData_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bundle_id      u64
	has_bundle_id  bool
	glyph_data     []CSTAR_GlyphData
}

pub fn (o &CSTAR_ReadGlyphData_Response) pack() []byte {
	mut res := []byte{}
	if o.has_bundle_id {
		res << vproto.pack_uint64_field(o.bundle_id, 1)
	}
	// [packed=false]
	for _, x in o.glyph_data {
		res << zzz_vproto_internal_pack_cstar_glyphdata(x, 2)
	}
	return res
}

pub fn cstar_readglyphdata_response_unpack(buf []byte) ?CSTAR_ReadGlyphData_Response {
	mut res := CSTAR_ReadGlyphData_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_bundle_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bundle_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstar_glyphdata(cur_buf, tag_wiretype.wire_type)?
				res.glyph_data << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstar_readglyphdata_response() CSTAR_ReadGlyphData_Response {
	return CSTAR_ReadGlyphData_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstar_readglyphdata_response(o CSTAR_ReadGlyphData_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstar_readglyphdata_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CSTAR_ReadGlyphData_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstar_readglyphdata_response_unpack(v)?
	return i, unpacked
}

pub struct CSTAR_WriteGlyphData_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         []E_STAR_GlyphWriteResult
}

pub fn (o &CSTAR_WriteGlyphData_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.result {
		res << zzz_vproto_internal_pack_e_star_glyphwriteresult(x, 1)
	}
	return res
}

pub fn cstar_writeglyphdata_response_unpack(buf []byte) ?CSTAR_WriteGlyphData_Response {
	mut res := CSTAR_WriteGlyphData_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_e_star_glyphwriteresult(cur_buf, tag_wiretype.wire_type)?
				res.result << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstar_writeglyphdata_response() CSTAR_WriteGlyphData_Response {
	return CSTAR_WriteGlyphData_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstar_writeglyphdata_response(o CSTAR_WriteGlyphData_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstar_writeglyphdata_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CSTAR_WriteGlyphData_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstar_writeglyphdata_response_unpack(v)?
	return i, unpacked
}

pub struct CSTAR_Response {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	read_glyph_data      CSTAR_ReadGlyphData_Response
	has_read_glyph_data  bool
	write_glyph_data     CSTAR_WriteGlyphData_Response
	has_write_glyph_data bool
}

pub fn (o &CSTAR_Response) pack() []byte {
	mut res := []byte{}
	if o.has_read_glyph_data {
		res << zzz_vproto_internal_pack_cstar_readglyphdata_response(o.read_glyph_data, 1)
	}
	if o.has_write_glyph_data {
		res << zzz_vproto_internal_pack_cstar_writeglyphdata_response(o.write_glyph_data, 2)
	}
	return res
}

pub fn cstar_response_unpack(buf []byte) ?CSTAR_Response {
	mut res := CSTAR_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_read_glyph_data = true
				ii, v := zzz_vproto_internal_unpack_cstar_readglyphdata_response(cur_buf,
					tag_wiretype.wire_type)?
				res.read_glyph_data = v
				i = ii
			}
			2 {
				res.has_write_glyph_data = true
				ii, v := zzz_vproto_internal_unpack_cstar_writeglyphdata_response(cur_buf,
					tag_wiretype.wire_type)?
				res.write_glyph_data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstar_response() CSTAR_Response {
	return CSTAR_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstar_response(o CSTAR_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstar_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CSTAR_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstar_response_unpack(v)?
	return i, unpacked
}
