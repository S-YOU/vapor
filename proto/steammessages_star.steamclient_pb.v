// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EStarglyphWriteResult {
	k_e_star_glyphwriteresult_success = 0
	k_e_star_glyphwriteresult_invalidmessage = 1
	k_e_star_glyphwriteresult_invalidjson = 2
	k_e_star_glyphwriteresult_sqlerror = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estarglyphwriteresult(e EStarglyphWriteResult, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estarglyphwriteresult(buf []byte, tag_wiretype vproto.WireType) ?(int, EStarglyphWriteResult) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStarglyphWriteResult(v)
}

pub struct CStarkeyValueQuery {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &CStarkeyValueQuery) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn cstarkeyvaluequery_unpack(buf []byte) ?CStarkeyValueQuery {
	mut res := CStarkeyValueQuery{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstarkeyvaluequery() CStarkeyValueQuery {
	return CStarkeyValueQuery{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstarkeyvaluequery(o CStarkeyValueQuery, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstarkeyvaluequery(buf []byte, tag_wiretype vproto.WireType) ?(int, CStarkeyValueQuery) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstarkeyvaluequery_unpack(v)?
	return i, unpacked
}

pub struct CStarglyphQueryParams {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bundle_id      u64
	has_bundle_id  bool
	queries        []CStarkeyValueQuery
}

pub fn (o &CStarglyphQueryParams) pack() []byte {
	mut res := []byte{}
	if o.has_bundle_id {
		res << vproto.pack_uint64_field(o.bundle_id, 1)
	}
	// [packed=false]
	for _, x in o.queries {
		res << zzz_vproto_internal_pack_cstarkeyvaluequery(x, 2)
	}
	return res
}

pub fn cstarglyphqueryparams_unpack(buf []byte) ?CStarglyphQueryParams {
	mut res := CStarglyphQueryParams{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_bundle_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bundle_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstarkeyvaluequery(cur_buf, tag_wiretype.wire_type)?
				res.queries << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstarglyphqueryparams() CStarglyphQueryParams {
	return CStarglyphQueryParams{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstarglyphqueryparams(o CStarglyphQueryParams, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstarglyphqueryparams(buf []byte, tag_wiretype vproto.WireType) ?(int, CStarglyphQueryParams) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstarglyphqueryparams_unpack(v)?
	return i, unpacked
}

pub struct CStarreadGlyphDataRequest {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	query_params                       CStarglyphQueryParams
	has_query_params                   bool
	last_modified_time_lower_limit     string
	has_last_modified_time_lower_limit bool
}

pub fn (o &CStarreadGlyphDataRequest) pack() []byte {
	mut res := []byte{}
	if o.has_query_params {
		res << zzz_vproto_internal_pack_cstarglyphqueryparams(o.query_params, 1)
	}
	if o.has_last_modified_time_lower_limit {
		res << vproto.pack_string_field(o.last_modified_time_lower_limit, 2)
	}
	return res
}

pub fn cstarreadglyphdatarequest_unpack(buf []byte) ?CStarreadGlyphDataRequest {
	mut res := CStarreadGlyphDataRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_query_params = true
				ii, v := zzz_vproto_internal_unpack_cstarglyphqueryparams(cur_buf, tag_wiretype.wire_type)?
				res.query_params = v
				i = ii
			}
			2 {
				res.has_last_modified_time_lower_limit = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.last_modified_time_lower_limit = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstarreadglyphdatarequest() CStarreadGlyphDataRequest {
	return CStarreadGlyphDataRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstarreadglyphdatarequest(o CStarreadGlyphDataRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstarreadglyphdatarequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CStarreadGlyphDataRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstarreadglyphdatarequest_unpack(v)?
	return i, unpacked
}

pub struct CStarglyphData {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	glyph_guid              []byte
	has_glyph_guid          bool
	glyph_last_modified     string
	has_glyph_last_modified bool
	glyph_json_data         string
	has_glyph_json_data     bool
}

pub fn (o &CStarglyphData) pack() []byte {
	mut res := []byte{}
	if o.has_glyph_guid {
		res << vproto.pack_bytes_field(o.glyph_guid, 1)
	}
	if o.has_glyph_last_modified {
		res << vproto.pack_string_field(o.glyph_last_modified, 2)
	}
	if o.has_glyph_json_data {
		res << vproto.pack_string_field(o.glyph_json_data, 3)
	}
	return res
}

pub fn cstarglyphdata_unpack(buf []byte) ?CStarglyphData {
	mut res := CStarglyphData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_glyph_guid = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.glyph_guid = v
				i = ii
			}
			2 {
				res.has_glyph_last_modified = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.glyph_last_modified = v
				i = ii
			}
			3 {
				res.has_glyph_json_data = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.glyph_json_data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstarglyphdata() CStarglyphData {
	return CStarglyphData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstarglyphdata(o CStarglyphData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstarglyphdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CStarglyphData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstarglyphdata_unpack(v)?
	return i, unpacked
}

pub struct CStarwriteGlyphDataRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bundle_id      u64
	has_bundle_id  bool
	glyph_data     []CStarglyphData
}

pub fn (o &CStarwriteGlyphDataRequest) pack() []byte {
	mut res := []byte{}
	if o.has_bundle_id {
		res << vproto.pack_uint64_field(o.bundle_id, 1)
	}
	// [packed=false]
	for _, x in o.glyph_data {
		res << zzz_vproto_internal_pack_cstarglyphdata(x, 2)
	}
	return res
}

pub fn cstarwriteglyphdatarequest_unpack(buf []byte) ?CStarwriteGlyphDataRequest {
	mut res := CStarwriteGlyphDataRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_bundle_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bundle_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstarglyphdata(cur_buf, tag_wiretype.wire_type)?
				res.glyph_data << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstarwriteglyphdatarequest() CStarwriteGlyphDataRequest {
	return CStarwriteGlyphDataRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstarwriteglyphdatarequest(o CStarwriteGlyphDataRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstarwriteglyphdatarequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CStarwriteGlyphDataRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstarwriteglyphdatarequest_unpack(v)?
	return i, unpacked
}

pub struct CStarrequest {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	read_glyph_data      CStarreadGlyphDataRequest
	has_read_glyph_data  bool
	write_glyph_data     CStarwriteGlyphDataRequest
	has_write_glyph_data bool
}

pub fn (o &CStarrequest) pack() []byte {
	mut res := []byte{}
	if o.has_read_glyph_data {
		res << zzz_vproto_internal_pack_cstarreadglyphdatarequest(o.read_glyph_data, 1)
	}
	if o.has_write_glyph_data {
		res << zzz_vproto_internal_pack_cstarwriteglyphdatarequest(o.write_glyph_data, 2)
	}
	return res
}

pub fn cstarrequest_unpack(buf []byte) ?CStarrequest {
	mut res := CStarrequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_read_glyph_data = true
				ii, v := zzz_vproto_internal_unpack_cstarreadglyphdatarequest(cur_buf,
					tag_wiretype.wire_type)?
				res.read_glyph_data = v
				i = ii
			}
			2 {
				res.has_write_glyph_data = true
				ii, v := zzz_vproto_internal_unpack_cstarwriteglyphdatarequest(cur_buf,
					tag_wiretype.wire_type)?
				res.write_glyph_data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstarrequest() CStarrequest {
	return CStarrequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstarrequest(o CStarrequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstarrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CStarrequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstarrequest_unpack(v)?
	return i, unpacked
}

pub struct CStarreadGlyphDataResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bundle_id      u64
	has_bundle_id  bool
	glyph_data     []CStarglyphData
}

pub fn (o &CStarreadGlyphDataResponse) pack() []byte {
	mut res := []byte{}
	if o.has_bundle_id {
		res << vproto.pack_uint64_field(o.bundle_id, 1)
	}
	// [packed=false]
	for _, x in o.glyph_data {
		res << zzz_vproto_internal_pack_cstarglyphdata(x, 2)
	}
	return res
}

pub fn cstarreadglyphdataresponse_unpack(buf []byte) ?CStarreadGlyphDataResponse {
	mut res := CStarreadGlyphDataResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_bundle_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bundle_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstarglyphdata(cur_buf, tag_wiretype.wire_type)?
				res.glyph_data << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstarreadglyphdataresponse() CStarreadGlyphDataResponse {
	return CStarreadGlyphDataResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstarreadglyphdataresponse(o CStarreadGlyphDataResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstarreadglyphdataresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CStarreadGlyphDataResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstarreadglyphdataresponse_unpack(v)?
	return i, unpacked
}

pub struct CStarwriteGlyphDataResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         []EStarglyphWriteResult
}

pub fn (o &CStarwriteGlyphDataResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.result {
		res << zzz_vproto_internal_pack_estarglyphwriteresult(x, 1)
	}
	return res
}

pub fn cstarwriteglyphdataresponse_unpack(buf []byte) ?CStarwriteGlyphDataResponse {
	mut res := CStarwriteGlyphDataResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_estarglyphwriteresult(cur_buf, tag_wiretype.wire_type)?
				res.result << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstarwriteglyphdataresponse() CStarwriteGlyphDataResponse {
	return CStarwriteGlyphDataResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstarwriteglyphdataresponse(o CStarwriteGlyphDataResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstarwriteglyphdataresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CStarwriteGlyphDataResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstarwriteglyphdataresponse_unpack(v)?
	return i, unpacked
}

pub struct CStarresponse {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	read_glyph_data      CStarreadGlyphDataResponse
	has_read_glyph_data  bool
	write_glyph_data     CStarwriteGlyphDataResponse
	has_write_glyph_data bool
}

pub fn (o &CStarresponse) pack() []byte {
	mut res := []byte{}
	if o.has_read_glyph_data {
		res << zzz_vproto_internal_pack_cstarreadglyphdataresponse(o.read_glyph_data, 1)
	}
	if o.has_write_glyph_data {
		res << zzz_vproto_internal_pack_cstarwriteglyphdataresponse(o.write_glyph_data, 2)
	}
	return res
}

pub fn cstarresponse_unpack(buf []byte) ?CStarresponse {
	mut res := CStarresponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_read_glyph_data = true
				ii, v := zzz_vproto_internal_unpack_cstarreadglyphdataresponse(cur_buf,
					tag_wiretype.wire_type)?
				res.read_glyph_data = v
				i = ii
			}
			2 {
				res.has_write_glyph_data = true
				ii, v := zzz_vproto_internal_unpack_cstarwriteglyphdataresponse(cur_buf,
					tag_wiretype.wire_type)?
				res.write_glyph_data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstarresponse() CStarresponse {
	return CStarresponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstarresponse(o CStarresponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstarresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CStarresponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstarresponse_unpack(v)?
	return i, unpacked
}
