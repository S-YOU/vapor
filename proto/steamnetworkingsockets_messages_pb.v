// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum ESteamNetworkingSocketsCipher {
	k_esteamnetworkingsocketscipher_invalid = 0
	k_esteamnetworkingsocketscipher_null = 1
	k_esteamnetworkingsocketscipher_aes_256_gcm = 2
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_esteamnetworkingsocketscipher(e ESteamNetworkingSocketsCipher, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_esteamnetworkingsocketscipher_packed(e []ESteamNetworkingSocketsCipher, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_esteamnetworkingsocketscipher(buf []byte, tag_wiretype vproto.WireType) ?(int, ESteamNetworkingSocketsCipher) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, ESteamNetworkingSocketsCipher(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_esteamnetworkingsocketscipher_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []ESteamNetworkingSocketsCipher) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum CMsgSteamDatagramSessionCryptInfo_EKeyType {
	invalid = 0
	curve25519 = 1
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfo_ekeytype(e CMsgSteamDatagramSessionCryptInfo_EKeyType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfo_ekeytype_packed(e []CMsgSteamDatagramSessionCryptInfo_EKeyType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfo_ekeytype(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramSessionCryptInfo_EKeyType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CMsgSteamDatagramSessionCryptInfo_EKeyType(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfo_ekeytype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CMsgSteamDatagramSessionCryptInfo_EKeyType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgSteamDatagramSessionCryptInfo {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	key_type             CMsgSteamDatagramSessionCryptInfo_EKeyType
	has_key_type         bool
	key_data             []byte
	has_key_data         bool
	nonce                u64
	has_nonce            bool
	protocol_version     u32
	has_protocol_version bool
	ciphers              []ESteamNetworkingSocketsCipher
}

pub fn (o &CMsgSteamDatagramSessionCryptInfo) pack() []byte {
	mut res := []byte{}
	if o.has_key_type {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfo_ekeytype(o.key_type, 1)
	}
	if o.has_key_data {
		res << vproto.pack_bytes_field(o.key_data, 2)
	}
	if o.has_nonce {
		res << vproto.pack_64bit_field(o.nonce, 3)
	}
	if o.has_protocol_version {
		res << vproto.pack_uint32_field(o.protocol_version, 4)
	}
	// [packed=false]
	for _, x in o.ciphers {
		res << zzz_vproto_internal_pack_esteamnetworkingsocketscipher(x, 5)
	}
	return res
}

pub fn cmsgsteamdatagramsessioncryptinfo_unpack(buf []byte) ?CMsgSteamDatagramSessionCryptInfo {
	mut res := CMsgSteamDatagramSessionCryptInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key_type = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfo_ekeytype(cur_buf,
					tag_wiretype.wire_type)?
				res.key_type = v
				i = ii
			}
			2 {
				res.has_key_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.key_data = v
				i = ii
			}
			3 {
				res.has_nonce = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.nonce = v
				i = ii
			}
			4 {
				res.has_protocol_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.protocol_version = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_esteamnetworkingsocketscipher(cur_buf,
					tag_wiretype.wire_type)?
				res.ciphers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramsessioncryptinfo() CMsgSteamDatagramSessionCryptInfo {
	return CMsgSteamDatagramSessionCryptInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfo(o CMsgSteamDatagramSessionCryptInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramSessionCryptInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramsessioncryptinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramSessionCryptInfoSigned {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	info           []byte
	has_info       bool
	signature      []byte
	has_signature  bool
}

pub fn (o &CMsgSteamDatagramSessionCryptInfoSigned) pack() []byte {
	mut res := []byte{}
	if o.has_info {
		res << vproto.pack_bytes_field(o.info, 1)
	}
	if o.has_signature {
		res << vproto.pack_bytes_field(o.signature, 2)
	}
	return res
}

pub fn cmsgsteamdatagramsessioncryptinfosigned_unpack(buf []byte) ?CMsgSteamDatagramSessionCryptInfoSigned {
	mut res := CMsgSteamDatagramSessionCryptInfoSigned{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_info = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.info = v
				i = ii
			}
			2 {
				res.has_signature = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.signature = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramsessioncryptinfosigned() CMsgSteamDatagramSessionCryptInfoSigned {
	return CMsgSteamDatagramSessionCryptInfoSigned{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfosigned(o CMsgSteamDatagramSessionCryptInfoSigned, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfosigned(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramSessionCryptInfoSigned) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramsessioncryptinfosigned_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramDiagnostic {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	severity       u32
	has_severity   bool
	text           string
	has_text       bool
}

pub fn (o &CMsgSteamDatagramDiagnostic) pack() []byte {
	mut res := []byte{}
	if o.has_severity {
		res << vproto.pack_uint32_field(o.severity, 1)
	}
	if o.has_text {
		res << vproto.pack_string_field(o.text, 2)
	}
	return res
}

pub fn cmsgsteamdatagramdiagnostic_unpack(buf []byte) ?CMsgSteamDatagramDiagnostic {
	mut res := CMsgSteamDatagramDiagnostic{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_severity = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.severity = v
				i = ii
			}
			2 {
				res.has_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramdiagnostic() CMsgSteamDatagramDiagnostic {
	return CMsgSteamDatagramDiagnostic{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramdiagnostic(o CMsgSteamDatagramDiagnostic, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramdiagnostic(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramDiagnostic) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramdiagnostic_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramLinkInstantaneousStats {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	out_packets_per_sec_x10        u32
	has_out_packets_per_sec_x10    bool
	out_bytes_per_sec              u32
	has_out_bytes_per_sec          bool
	in_packets_per_sec_x10         u32
	has_in_packets_per_sec_x10     bool
	in_bytes_per_sec               u32
	has_in_bytes_per_sec           bool
	ping_ms                        u32
	has_ping_ms                    bool
	packets_dropped_pct            u32
	has_packets_dropped_pct        bool
	packets_weird_sequence_pct     u32
	has_packets_weird_sequence_pct bool
	peak_jitter_usec               u32
	has_peak_jitter_usec           bool
}

pub fn (o &CMsgSteamDatagramLinkInstantaneousStats) pack() []byte {
	mut res := []byte{}
	if o.has_out_packets_per_sec_x10 {
		res << vproto.pack_uint32_field(o.out_packets_per_sec_x10, 1)
	}
	if o.has_out_bytes_per_sec {
		res << vproto.pack_uint32_field(o.out_bytes_per_sec, 2)
	}
	if o.has_in_packets_per_sec_x10 {
		res << vproto.pack_uint32_field(o.in_packets_per_sec_x10, 3)
	}
	if o.has_in_bytes_per_sec {
		res << vproto.pack_uint32_field(o.in_bytes_per_sec, 4)
	}
	if o.has_ping_ms {
		res << vproto.pack_uint32_field(o.ping_ms, 5)
	}
	if o.has_packets_dropped_pct {
		res << vproto.pack_uint32_field(o.packets_dropped_pct, 6)
	}
	if o.has_packets_weird_sequence_pct {
		res << vproto.pack_uint32_field(o.packets_weird_sequence_pct, 7)
	}
	if o.has_peak_jitter_usec {
		res << vproto.pack_uint32_field(o.peak_jitter_usec, 8)
	}
	return res
}

pub fn cmsgsteamdatagramlinkinstantaneousstats_unpack(buf []byte) ?CMsgSteamDatagramLinkInstantaneousStats {
	mut res := CMsgSteamDatagramLinkInstantaneousStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_out_packets_per_sec_x10 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.out_packets_per_sec_x10 = v
				i = ii
			}
			2 {
				res.has_out_bytes_per_sec = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.out_bytes_per_sec = v
				i = ii
			}
			3 {
				res.has_in_packets_per_sec_x10 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.in_packets_per_sec_x10 = v
				i = ii
			}
			4 {
				res.has_in_bytes_per_sec = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.in_bytes_per_sec = v
				i = ii
			}
			5 {
				res.has_ping_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_ms = v
				i = ii
			}
			6 {
				res.has_packets_dropped_pct = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.packets_dropped_pct = v
				i = ii
			}
			7 {
				res.has_packets_weird_sequence_pct = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.packets_weird_sequence_pct = v
				i = ii
			}
			8 {
				res.has_peak_jitter_usec = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.peak_jitter_usec = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramlinkinstantaneousstats() CMsgSteamDatagramLinkInstantaneousStats {
	return CMsgSteamDatagramLinkInstantaneousStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramlinkinstantaneousstats(o CMsgSteamDatagramLinkInstantaneousStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramlinkinstantaneousstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramLinkInstantaneousStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramlinkinstantaneousstats_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramLinkLifetimeStats {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	connected_seconds               u32
	has_connected_seconds           bool
	packets_sent                    u64
	has_packets_sent                bool
	kb_sent                         u64
	has_kb_sent                     bool
	packets_recv                    u64
	has_packets_recv                bool
	kb_recv                         u64
	has_kb_recv                     bool
	packets_recv_sequenced          u64
	has_packets_recv_sequenced      bool
	packets_recv_dropped            u64
	has_packets_recv_dropped        bool
	packets_recv_out_of_order       u64
	has_packets_recv_out_of_order   bool
	packets_recv_duplicate          u64
	has_packets_recv_duplicate      bool
	packets_recv_lurch              u64
	has_packets_recv_lurch          bool
	quality_histogram_100           u32
	has_quality_histogram_100       bool
	quality_histogram_99            u32
	has_quality_histogram_99        bool
	quality_histogram_97            u32
	has_quality_histogram_97        bool
	quality_histogram_95            u32
	has_quality_histogram_95        bool
	quality_histogram_90            u32
	has_quality_histogram_90        bool
	quality_histogram_75            u32
	has_quality_histogram_75        bool
	quality_histogram_50            u32
	has_quality_histogram_50        bool
	quality_histogram_1             u32
	has_quality_histogram_1         bool
	quality_histogram_dead          u32
	has_quality_histogram_dead      bool
	quality_ntile_2nd               u32
	has_quality_ntile_2nd           bool
	quality_ntile_5th               u32
	has_quality_ntile_5th           bool
	quality_ntile_25th              u32
	has_quality_ntile_25th          bool
	quality_ntile_50th              u32
	has_quality_ntile_50th          bool
	ping_histogram_25               u32
	has_ping_histogram_25           bool
	ping_histogram_50               u32
	has_ping_histogram_50           bool
	ping_histogram_75               u32
	has_ping_histogram_75           bool
	ping_histogram_100              u32
	has_ping_histogram_100          bool
	ping_histogram_125              u32
	has_ping_histogram_125          bool
	ping_histogram_150              u32
	has_ping_histogram_150          bool
	ping_histogram_200              u32
	has_ping_histogram_200          bool
	ping_histogram_300              u32
	has_ping_histogram_300          bool
	ping_histogram_max              u32
	has_ping_histogram_max          bool
	ping_ntile_5th                  u32
	has_ping_ntile_5th              bool
	ping_ntile_50th                 u32
	has_ping_ntile_50th             bool
	ping_ntile_75th                 u32
	has_ping_ntile_75th             bool
	ping_ntile_95th                 u32
	has_ping_ntile_95th             bool
	ping_ntile_98th                 u32
	has_ping_ntile_98th             bool
	jitter_histogram_negligible     u32
	has_jitter_histogram_negligible bool
	jitter_histogram_1              u32
	has_jitter_histogram_1          bool
	jitter_histogram_2              u32
	has_jitter_histogram_2          bool
	jitter_histogram_5              u32
	has_jitter_histogram_5          bool
	jitter_histogram_10             u32
	has_jitter_histogram_10         bool
	jitter_histogram_20             u32
	has_jitter_histogram_20         bool
	txspeed_max                     u32
	has_txspeed_max                 bool
	txspeed_histogram_16            u32
	has_txspeed_histogram_16        bool
	txspeed_histogram_32            u32
	has_txspeed_histogram_32        bool
	txspeed_histogram_64            u32
	has_txspeed_histogram_64        bool
	txspeed_histogram_128           u32
	has_txspeed_histogram_128       bool
	txspeed_histogram_256           u32
	has_txspeed_histogram_256       bool
	txspeed_histogram_512           u32
	has_txspeed_histogram_512       bool
	txspeed_histogram_1024          u32
	has_txspeed_histogram_1024      bool
	txspeed_histogram_max           u32
	has_txspeed_histogram_max       bool
	txspeed_ntile_5th               u32
	has_txspeed_ntile_5th           bool
	txspeed_ntile_50th              u32
	has_txspeed_ntile_50th          bool
	txspeed_ntile_75th              u32
	has_txspeed_ntile_75th          bool
	txspeed_ntile_95th              u32
	has_txspeed_ntile_95th          bool
	txspeed_ntile_98th              u32
	has_txspeed_ntile_98th          bool
	rxspeed_max                     u32
	has_rxspeed_max                 bool
	rxspeed_histogram_16            u32
	has_rxspeed_histogram_16        bool
	rxspeed_histogram_32            u32
	has_rxspeed_histogram_32        bool
	rxspeed_histogram_64            u32
	has_rxspeed_histogram_64        bool
	rxspeed_histogram_128           u32
	has_rxspeed_histogram_128       bool
	rxspeed_histogram_256           u32
	has_rxspeed_histogram_256       bool
	rxspeed_histogram_512           u32
	has_rxspeed_histogram_512       bool
	rxspeed_histogram_1024          u32
	has_rxspeed_histogram_1024      bool
	rxspeed_histogram_max           u32
	has_rxspeed_histogram_max       bool
	rxspeed_ntile_5th               u32
	has_rxspeed_ntile_5th           bool
	rxspeed_ntile_50th              u32
	has_rxspeed_ntile_50th          bool
	rxspeed_ntile_75th              u32
	has_rxspeed_ntile_75th          bool
	rxspeed_ntile_95th              u32
	has_rxspeed_ntile_95th          bool
	rxspeed_ntile_98th              u32
	has_rxspeed_ntile_98th          bool
}

pub fn (o &CMsgSteamDatagramLinkLifetimeStats) pack() []byte {
	mut res := []byte{}
	if o.has_connected_seconds {
		res << vproto.pack_uint32_field(o.connected_seconds, 2)
	}
	if o.has_packets_sent {
		res << vproto.pack_uint64_field(o.packets_sent, 3)
	}
	if o.has_kb_sent {
		res << vproto.pack_uint64_field(o.kb_sent, 4)
	}
	if o.has_packets_recv {
		res << vproto.pack_uint64_field(o.packets_recv, 5)
	}
	if o.has_kb_recv {
		res << vproto.pack_uint64_field(o.kb_recv, 6)
	}
	if o.has_packets_recv_sequenced {
		res << vproto.pack_uint64_field(o.packets_recv_sequenced, 7)
	}
	if o.has_packets_recv_dropped {
		res << vproto.pack_uint64_field(o.packets_recv_dropped, 8)
	}
	if o.has_packets_recv_out_of_order {
		res << vproto.pack_uint64_field(o.packets_recv_out_of_order, 9)
	}
	if o.has_packets_recv_duplicate {
		res << vproto.pack_uint64_field(o.packets_recv_duplicate, 10)
	}
	if o.has_packets_recv_lurch {
		res << vproto.pack_uint64_field(o.packets_recv_lurch, 11)
	}
	if o.has_quality_histogram_100 {
		res << vproto.pack_uint32_field(o.quality_histogram_100, 21)
	}
	if o.has_quality_histogram_99 {
		res << vproto.pack_uint32_field(o.quality_histogram_99, 22)
	}
	if o.has_quality_histogram_97 {
		res << vproto.pack_uint32_field(o.quality_histogram_97, 23)
	}
	if o.has_quality_histogram_95 {
		res << vproto.pack_uint32_field(o.quality_histogram_95, 24)
	}
	if o.has_quality_histogram_90 {
		res << vproto.pack_uint32_field(o.quality_histogram_90, 25)
	}
	if o.has_quality_histogram_75 {
		res << vproto.pack_uint32_field(o.quality_histogram_75, 26)
	}
	if o.has_quality_histogram_50 {
		res << vproto.pack_uint32_field(o.quality_histogram_50, 27)
	}
	if o.has_quality_histogram_1 {
		res << vproto.pack_uint32_field(o.quality_histogram_1, 28)
	}
	if o.has_quality_histogram_dead {
		res << vproto.pack_uint32_field(o.quality_histogram_dead, 29)
	}
	if o.has_quality_ntile_2nd {
		res << vproto.pack_uint32_field(o.quality_ntile_2nd, 30)
	}
	if o.has_quality_ntile_5th {
		res << vproto.pack_uint32_field(o.quality_ntile_5th, 31)
	}
	if o.has_quality_ntile_25th {
		res << vproto.pack_uint32_field(o.quality_ntile_25th, 32)
	}
	if o.has_quality_ntile_50th {
		res << vproto.pack_uint32_field(o.quality_ntile_50th, 33)
	}
	if o.has_ping_histogram_25 {
		res << vproto.pack_uint32_field(o.ping_histogram_25, 41)
	}
	if o.has_ping_histogram_50 {
		res << vproto.pack_uint32_field(o.ping_histogram_50, 42)
	}
	if o.has_ping_histogram_75 {
		res << vproto.pack_uint32_field(o.ping_histogram_75, 43)
	}
	if o.has_ping_histogram_100 {
		res << vproto.pack_uint32_field(o.ping_histogram_100, 44)
	}
	if o.has_ping_histogram_125 {
		res << vproto.pack_uint32_field(o.ping_histogram_125, 45)
	}
	if o.has_ping_histogram_150 {
		res << vproto.pack_uint32_field(o.ping_histogram_150, 46)
	}
	if o.has_ping_histogram_200 {
		res << vproto.pack_uint32_field(o.ping_histogram_200, 47)
	}
	if o.has_ping_histogram_300 {
		res << vproto.pack_uint32_field(o.ping_histogram_300, 48)
	}
	if o.has_ping_histogram_max {
		res << vproto.pack_uint32_field(o.ping_histogram_max, 49)
	}
	if o.has_ping_ntile_5th {
		res << vproto.pack_uint32_field(o.ping_ntile_5th, 50)
	}
	if o.has_ping_ntile_50th {
		res << vproto.pack_uint32_field(o.ping_ntile_50th, 51)
	}
	if o.has_ping_ntile_75th {
		res << vproto.pack_uint32_field(o.ping_ntile_75th, 52)
	}
	if o.has_ping_ntile_95th {
		res << vproto.pack_uint32_field(o.ping_ntile_95th, 53)
	}
	if o.has_ping_ntile_98th {
		res << vproto.pack_uint32_field(o.ping_ntile_98th, 54)
	}
	if o.has_jitter_histogram_negligible {
		res << vproto.pack_uint32_field(o.jitter_histogram_negligible, 61)
	}
	if o.has_jitter_histogram_1 {
		res << vproto.pack_uint32_field(o.jitter_histogram_1, 62)
	}
	if o.has_jitter_histogram_2 {
		res << vproto.pack_uint32_field(o.jitter_histogram_2, 63)
	}
	if o.has_jitter_histogram_5 {
		res << vproto.pack_uint32_field(o.jitter_histogram_5, 64)
	}
	if o.has_jitter_histogram_10 {
		res << vproto.pack_uint32_field(o.jitter_histogram_10, 65)
	}
	if o.has_jitter_histogram_20 {
		res << vproto.pack_uint32_field(o.jitter_histogram_20, 66)
	}
	if o.has_txspeed_max {
		res << vproto.pack_uint32_field(o.txspeed_max, 67)
	}
	if o.has_txspeed_histogram_16 {
		res << vproto.pack_uint32_field(o.txspeed_histogram_16, 68)
	}
	if o.has_txspeed_histogram_32 {
		res << vproto.pack_uint32_field(o.txspeed_histogram_32, 69)
	}
	if o.has_txspeed_histogram_64 {
		res << vproto.pack_uint32_field(o.txspeed_histogram_64, 70)
	}
	if o.has_txspeed_histogram_128 {
		res << vproto.pack_uint32_field(o.txspeed_histogram_128, 71)
	}
	if o.has_txspeed_histogram_256 {
		res << vproto.pack_uint32_field(o.txspeed_histogram_256, 72)
	}
	if o.has_txspeed_histogram_512 {
		res << vproto.pack_uint32_field(o.txspeed_histogram_512, 73)
	}
	if o.has_txspeed_histogram_1024 {
		res << vproto.pack_uint32_field(o.txspeed_histogram_1024, 74)
	}
	if o.has_txspeed_histogram_max {
		res << vproto.pack_uint32_field(o.txspeed_histogram_max, 75)
	}
	if o.has_txspeed_ntile_5th {
		res << vproto.pack_uint32_field(o.txspeed_ntile_5th, 76)
	}
	if o.has_txspeed_ntile_50th {
		res << vproto.pack_uint32_field(o.txspeed_ntile_50th, 77)
	}
	if o.has_txspeed_ntile_75th {
		res << vproto.pack_uint32_field(o.txspeed_ntile_75th, 78)
	}
	if o.has_txspeed_ntile_95th {
		res << vproto.pack_uint32_field(o.txspeed_ntile_95th, 79)
	}
	if o.has_txspeed_ntile_98th {
		res << vproto.pack_uint32_field(o.txspeed_ntile_98th, 80)
	}
	if o.has_rxspeed_max {
		res << vproto.pack_uint32_field(o.rxspeed_max, 81)
	}
	if o.has_rxspeed_histogram_16 {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_16, 82)
	}
	if o.has_rxspeed_histogram_32 {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_32, 83)
	}
	if o.has_rxspeed_histogram_64 {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_64, 84)
	}
	if o.has_rxspeed_histogram_128 {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_128, 85)
	}
	if o.has_rxspeed_histogram_256 {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_256, 86)
	}
	if o.has_rxspeed_histogram_512 {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_512, 87)
	}
	if o.has_rxspeed_histogram_1024 {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_1024, 88)
	}
	if o.has_rxspeed_histogram_max {
		res << vproto.pack_uint32_field(o.rxspeed_histogram_max, 89)
	}
	if o.has_rxspeed_ntile_5th {
		res << vproto.pack_uint32_field(o.rxspeed_ntile_5th, 90)
	}
	if o.has_rxspeed_ntile_50th {
		res << vproto.pack_uint32_field(o.rxspeed_ntile_50th, 91)
	}
	if o.has_rxspeed_ntile_75th {
		res << vproto.pack_uint32_field(o.rxspeed_ntile_75th, 92)
	}
	if o.has_rxspeed_ntile_95th {
		res << vproto.pack_uint32_field(o.rxspeed_ntile_95th, 93)
	}
	if o.has_rxspeed_ntile_98th {
		res << vproto.pack_uint32_field(o.rxspeed_ntile_98th, 94)
	}
	return res
}

pub fn cmsgsteamdatagramlinklifetimestats_unpack(buf []byte) ?CMsgSteamDatagramLinkLifetimeStats {
	mut res := CMsgSteamDatagramLinkLifetimeStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				res.has_connected_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.connected_seconds = v
				i = ii
			}
			3 {
				res.has_packets_sent = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.packets_sent = v
				i = ii
			}
			4 {
				res.has_kb_sent = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.kb_sent = v
				i = ii
			}
			5 {
				res.has_packets_recv = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.packets_recv = v
				i = ii
			}
			6 {
				res.has_kb_recv = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.kb_recv = v
				i = ii
			}
			7 {
				res.has_packets_recv_sequenced = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.packets_recv_sequenced = v
				i = ii
			}
			8 {
				res.has_packets_recv_dropped = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.packets_recv_dropped = v
				i = ii
			}
			9 {
				res.has_packets_recv_out_of_order = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.packets_recv_out_of_order = v
				i = ii
			}
			10 {
				res.has_packets_recv_duplicate = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.packets_recv_duplicate = v
				i = ii
			}
			11 {
				res.has_packets_recv_lurch = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.packets_recv_lurch = v
				i = ii
			}
			21 {
				res.has_quality_histogram_100 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quality_histogram_100 = v
				i = ii
			}
			22 {
				res.has_quality_histogram_99 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quality_histogram_99 = v
				i = ii
			}
			23 {
				res.has_quality_histogram_97 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quality_histogram_97 = v
				i = ii
			}
			24 {
				res.has_quality_histogram_95 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quality_histogram_95 = v
				i = ii
			}
			25 {
				res.has_quality_histogram_90 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quality_histogram_90 = v
				i = ii
			}
			26 {
				res.has_quality_histogram_75 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quality_histogram_75 = v
				i = ii
			}
			27 {
				res.has_quality_histogram_50 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quality_histogram_50 = v
				i = ii
			}
			28 {
				res.has_quality_histogram_1 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quality_histogram_1 = v
				i = ii
			}
			29 {
				res.has_quality_histogram_dead = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quality_histogram_dead = v
				i = ii
			}
			30 {
				res.has_quality_ntile_2nd = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quality_ntile_2nd = v
				i = ii
			}
			31 {
				res.has_quality_ntile_5th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quality_ntile_5th = v
				i = ii
			}
			32 {
				res.has_quality_ntile_25th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quality_ntile_25th = v
				i = ii
			}
			33 {
				res.has_quality_ntile_50th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.quality_ntile_50th = v
				i = ii
			}
			41 {
				res.has_ping_histogram_25 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_histogram_25 = v
				i = ii
			}
			42 {
				res.has_ping_histogram_50 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_histogram_50 = v
				i = ii
			}
			43 {
				res.has_ping_histogram_75 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_histogram_75 = v
				i = ii
			}
			44 {
				res.has_ping_histogram_100 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_histogram_100 = v
				i = ii
			}
			45 {
				res.has_ping_histogram_125 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_histogram_125 = v
				i = ii
			}
			46 {
				res.has_ping_histogram_150 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_histogram_150 = v
				i = ii
			}
			47 {
				res.has_ping_histogram_200 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_histogram_200 = v
				i = ii
			}
			48 {
				res.has_ping_histogram_300 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_histogram_300 = v
				i = ii
			}
			49 {
				res.has_ping_histogram_max = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_histogram_max = v
				i = ii
			}
			50 {
				res.has_ping_ntile_5th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_ntile_5th = v
				i = ii
			}
			51 {
				res.has_ping_ntile_50th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_ntile_50th = v
				i = ii
			}
			52 {
				res.has_ping_ntile_75th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_ntile_75th = v
				i = ii
			}
			53 {
				res.has_ping_ntile_95th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_ntile_95th = v
				i = ii
			}
			54 {
				res.has_ping_ntile_98th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_ntile_98th = v
				i = ii
			}
			61 {
				res.has_jitter_histogram_negligible = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.jitter_histogram_negligible = v
				i = ii
			}
			62 {
				res.has_jitter_histogram_1 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.jitter_histogram_1 = v
				i = ii
			}
			63 {
				res.has_jitter_histogram_2 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.jitter_histogram_2 = v
				i = ii
			}
			64 {
				res.has_jitter_histogram_5 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.jitter_histogram_5 = v
				i = ii
			}
			65 {
				res.has_jitter_histogram_10 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.jitter_histogram_10 = v
				i = ii
			}
			66 {
				res.has_jitter_histogram_20 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.jitter_histogram_20 = v
				i = ii
			}
			67 {
				res.has_txspeed_max = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_max = v
				i = ii
			}
			68 {
				res.has_txspeed_histogram_16 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_histogram_16 = v
				i = ii
			}
			69 {
				res.has_txspeed_histogram_32 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_histogram_32 = v
				i = ii
			}
			70 {
				res.has_txspeed_histogram_64 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_histogram_64 = v
				i = ii
			}
			71 {
				res.has_txspeed_histogram_128 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_histogram_128 = v
				i = ii
			}
			72 {
				res.has_txspeed_histogram_256 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_histogram_256 = v
				i = ii
			}
			73 {
				res.has_txspeed_histogram_512 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_histogram_512 = v
				i = ii
			}
			74 {
				res.has_txspeed_histogram_1024 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_histogram_1024 = v
				i = ii
			}
			75 {
				res.has_txspeed_histogram_max = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_histogram_max = v
				i = ii
			}
			76 {
				res.has_txspeed_ntile_5th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_ntile_5th = v
				i = ii
			}
			77 {
				res.has_txspeed_ntile_50th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_ntile_50th = v
				i = ii
			}
			78 {
				res.has_txspeed_ntile_75th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_ntile_75th = v
				i = ii
			}
			79 {
				res.has_txspeed_ntile_95th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_ntile_95th = v
				i = ii
			}
			80 {
				res.has_txspeed_ntile_98th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.txspeed_ntile_98th = v
				i = ii
			}
			81 {
				res.has_rxspeed_max = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_max = v
				i = ii
			}
			82 {
				res.has_rxspeed_histogram_16 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_histogram_16 = v
				i = ii
			}
			83 {
				res.has_rxspeed_histogram_32 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_histogram_32 = v
				i = ii
			}
			84 {
				res.has_rxspeed_histogram_64 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_histogram_64 = v
				i = ii
			}
			85 {
				res.has_rxspeed_histogram_128 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_histogram_128 = v
				i = ii
			}
			86 {
				res.has_rxspeed_histogram_256 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_histogram_256 = v
				i = ii
			}
			87 {
				res.has_rxspeed_histogram_512 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_histogram_512 = v
				i = ii
			}
			88 {
				res.has_rxspeed_histogram_1024 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_histogram_1024 = v
				i = ii
			}
			89 {
				res.has_rxspeed_histogram_max = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_histogram_max = v
				i = ii
			}
			90 {
				res.has_rxspeed_ntile_5th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_ntile_5th = v
				i = ii
			}
			91 {
				res.has_rxspeed_ntile_50th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_ntile_50th = v
				i = ii
			}
			92 {
				res.has_rxspeed_ntile_75th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_ntile_75th = v
				i = ii
			}
			93 {
				res.has_rxspeed_ntile_95th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_ntile_95th = v
				i = ii
			}
			94 {
				res.has_rxspeed_ntile_98th = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.rxspeed_ntile_98th = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramlinklifetimestats() CMsgSteamDatagramLinkLifetimeStats {
	return CMsgSteamDatagramLinkLifetimeStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramlinklifetimestats(o CMsgSteamDatagramLinkLifetimeStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramlinklifetimestats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramLinkLifetimeStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramlinklifetimestats_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamDatagramConnectionQuality {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	instantaneous     CMsgSteamDatagramLinkInstantaneousStats
	has_instantaneous bool
	lifetime          CMsgSteamDatagramLinkLifetimeStats
	has_lifetime      bool
}

pub fn (o &CMsgSteamDatagramConnectionQuality) pack() []byte {
	mut res := []byte{}
	if o.has_instantaneous {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramlinkinstantaneousstats(o.instantaneous, 1)
	}
	if o.has_lifetime {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramlinklifetimestats(o.lifetime, 2)
	}
	return res
}

pub fn cmsgsteamdatagramconnectionquality_unpack(buf []byte) ?CMsgSteamDatagramConnectionQuality {
	mut res := CMsgSteamDatagramConnectionQuality{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_instantaneous = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramlinkinstantaneousstats(cur_buf,
					tag_wiretype.wire_type)?
				res.instantaneous = v
				i = ii
			}
			2 {
				res.has_lifetime = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramlinklifetimestats(cur_buf,
					tag_wiretype.wire_type)?
				res.lifetime = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamdatagramconnectionquality() CMsgSteamDatagramConnectionQuality {
	return CMsgSteamDatagramConnectionQuality{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamdatagramconnectionquality(o CMsgSteamDatagramConnectionQuality, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamdatagramconnectionquality(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamDatagramConnectionQuality) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamdatagramconnectionquality_unpack(v)?
	return i, unpacked
}

pub struct CMsgICERendezvous_Auth {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	pwd_frag       string
	has_pwd_frag   bool
}

pub fn (o &CMsgICERendezvous_Auth) pack() []byte {
	mut res := []byte{}
	if o.has_pwd_frag {
		res << vproto.pack_string_field(o.pwd_frag, 1)
	}
	return res
}

pub fn cmsgicerendezvous_auth_unpack(buf []byte) ?CMsgICERendezvous_Auth {
	mut res := CMsgICERendezvous_Auth{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_pwd_frag = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.pwd_frag = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgicerendezvous_auth() CMsgICERendezvous_Auth {
	return CMsgICERendezvous_Auth{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgicerendezvous_auth(o CMsgICERendezvous_Auth, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgicerendezvous_auth(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgICERendezvous_Auth) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgicerendezvous_auth_unpack(v)?
	return i, unpacked
}

pub struct CMsgICERendezvous_Candidate {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	candidate      string
	has_candidate  bool
}

pub fn (o &CMsgICERendezvous_Candidate) pack() []byte {
	mut res := []byte{}
	if o.has_candidate {
		res << vproto.pack_string_field(o.candidate, 3)
	}
	return res
}

pub fn cmsgicerendezvous_candidate_unpack(buf []byte) ?CMsgICERendezvous_Candidate {
	mut res := CMsgICERendezvous_Candidate{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			3 {
				res.has_candidate = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.candidate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgicerendezvous_candidate() CMsgICERendezvous_Candidate {
	return CMsgICERendezvous_Candidate{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgicerendezvous_candidate(o CMsgICERendezvous_Candidate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgicerendezvous_candidate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgICERendezvous_Candidate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgicerendezvous_candidate_unpack(v)?
	return i, unpacked
}

pub struct CMsgICERendezvous {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	auth              CMsgICERendezvous_Auth
	has_auth          bool
	add_candidate     CMsgICERendezvous_Candidate
	has_add_candidate bool
}

pub fn (o &CMsgICERendezvous) pack() []byte {
	mut res := []byte{}
	if o.has_auth {
		res << zzz_vproto_internal_pack_cmsgicerendezvous_auth(o.auth, 2)
	}
	if o.has_add_candidate {
		res << zzz_vproto_internal_pack_cmsgicerendezvous_candidate(o.add_candidate, 1)
	}
	return res
}

pub fn cmsgicerendezvous_unpack(buf []byte) ?CMsgICERendezvous {
	mut res := CMsgICERendezvous{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				res.has_auth = true
				ii, v := zzz_vproto_internal_unpack_cmsgicerendezvous_auth(cur_buf, tag_wiretype.wire_type)?
				res.auth = v
				i = ii
			}
			1 {
				res.has_add_candidate = true
				ii, v := zzz_vproto_internal_unpack_cmsgicerendezvous_candidate(cur_buf,
					tag_wiretype.wire_type)?
				res.add_candidate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgicerendezvous() CMsgICERendezvous {
	return CMsgICERendezvous{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgicerendezvous(o CMsgICERendezvous, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgicerendezvous(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgICERendezvous) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgicerendezvous_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	crypt            CMsgSteamDatagramSessionCryptInfoSigned
	has_crypt        bool
	cert             CMsgSteamDatagramCertificateSigned
	has_cert         bool
	virtual_port     u32
	has_virtual_port bool
}

pub fn (o &CMsgSteamNetworkingP2PRendezvous_ConnectRequest) pack() []byte {
	mut res := []byte{}
	if o.has_crypt {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfosigned(o.crypt, 6)
	}
	if o.has_cert {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 7)
	}
	if o.has_virtual_port {
		res << vproto.pack_uint32_field(o.virtual_port, 9)
	}
	return res
}

pub fn cmsgsteamnetworkingp2prendezvous_connectrequest_unpack(buf []byte) ?CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
	mut res := CMsgSteamNetworkingP2PRendezvous_ConnectRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			6 {
				res.has_crypt = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfosigned(cur_buf,
					tag_wiretype.wire_type)?
				res.crypt = v
				i = ii
			}
			7 {
				res.has_cert = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf,
					tag_wiretype.wire_type)?
				res.cert = v
				i = ii
			}
			9 {
				res.has_virtual_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.virtual_port = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_connectrequest() CMsgSteamNetworkingP2PRendezvous_ConnectRequest {
	return CMsgSteamNetworkingP2PRendezvous_ConnectRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_connectrequest(o CMsgSteamNetworkingP2PRendezvous_ConnectRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_connectrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingP2PRendezvous_ConnectRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamnetworkingp2prendezvous_connectrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamNetworkingP2PRendezvous_ConnectOK {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	crypt          CMsgSteamDatagramSessionCryptInfoSigned
	has_crypt      bool
	cert           CMsgSteamDatagramCertificateSigned
	has_cert       bool
}

pub fn (o &CMsgSteamNetworkingP2PRendezvous_ConnectOK) pack() []byte {
	mut res := []byte{}
	if o.has_crypt {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramsessioncryptinfosigned(o.crypt, 5)
	}
	if o.has_cert {
		res << zzz_vproto_internal_pack_cmsgsteamdatagramcertificatesigned(o.cert, 6)
	}
	return res
}

pub fn cmsgsteamnetworkingp2prendezvous_connectok_unpack(buf []byte) ?CMsgSteamNetworkingP2PRendezvous_ConnectOK {
	mut res := CMsgSteamNetworkingP2PRendezvous_ConnectOK{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			5 {
				res.has_crypt = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramsessioncryptinfosigned(cur_buf,
					tag_wiretype.wire_type)?
				res.crypt = v
				i = ii
			}
			6 {
				res.has_cert = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamdatagramcertificatesigned(cur_buf,
					tag_wiretype.wire_type)?
				res.cert = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_connectok() CMsgSteamNetworkingP2PRendezvous_ConnectOK {
	return CMsgSteamNetworkingP2PRendezvous_ConnectOK{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_connectok(o CMsgSteamNetworkingP2PRendezvous_ConnectOK, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_connectok(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingP2PRendezvous_ConnectOK) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamnetworkingp2prendezvous_connectok_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	debug           string
	has_debug       bool
	reason_code     u32
	has_reason_code bool
}

pub fn (o &CMsgSteamNetworkingP2PRendezvous_ConnectionClosed) pack() []byte {
	mut res := []byte{}
	if o.has_debug {
		res << vproto.pack_string_field(o.debug, 5)
	}
	if o.has_reason_code {
		res << vproto.pack_uint32_field(o.reason_code, 6)
	}
	return res
}

pub fn cmsgsteamnetworkingp2prendezvous_connectionclosed_unpack(buf []byte) ?CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
	mut res := CMsgSteamNetworkingP2PRendezvous_ConnectionClosed{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			5 {
				res.has_debug = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.debug = v
				i = ii
			}
			6 {
				res.has_reason_code = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.reason_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_connectionclosed() CMsgSteamNetworkingP2PRendezvous_ConnectionClosed {
	return CMsgSteamNetworkingP2PRendezvous_ConnectionClosed{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_connectionclosed(o CMsgSteamNetworkingP2PRendezvous_ConnectionClosed, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_connectionclosed(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingP2PRendezvous_ConnectionClosed) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamnetworkingp2prendezvous_connectionclosed_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ice            CMsgICERendezvous
	has_ice        bool
}

pub fn (o &CMsgSteamNetworkingP2PRendezvous_ReliableMessage) pack() []byte {
	mut res := []byte{}
	if o.has_ice {
		res << zzz_vproto_internal_pack_cmsgicerendezvous(o.ice, 1)
	}
	return res
}

pub fn cmsgsteamnetworkingp2prendezvous_reliablemessage_unpack(buf []byte) ?CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
	mut res := CMsgSteamNetworkingP2PRendezvous_ReliableMessage{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ice = true
				ii, v := zzz_vproto_internal_unpack_cmsgicerendezvous(cur_buf, tag_wiretype.wire_type)?
				res.ice = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous_reliablemessage() CMsgSteamNetworkingP2PRendezvous_ReliableMessage {
	return CMsgSteamNetworkingP2PRendezvous_ReliableMessage{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_reliablemessage(o CMsgSteamNetworkingP2PRendezvous_ReliableMessage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_reliablemessage(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingP2PRendezvous_ReliableMessage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamnetworkingp2prendezvous_reliablemessage_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamNetworkingP2PRendezvous {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	from_identity                string
	has_from_identity            bool
	from_connection_id           u32
	has_from_connection_id       bool
	to_identity                  string
	has_to_identity              bool
	to_connection_id             u32
	has_to_connection_id         bool
	sdr_routes                   []byte
	has_sdr_routes               bool
	ack_peer_routes_revision     u32
	has_ack_peer_routes_revision bool
	ice_enabled                  bool
	has_ice_enabled              bool
	connect_request              CMsgSteamNetworkingP2PRendezvous_ConnectRequest
	has_connect_request          bool
	connect_ok                   CMsgSteamNetworkingP2PRendezvous_ConnectOK
	has_connect_ok               bool
	connection_closed            CMsgSteamNetworkingP2PRendezvous_ConnectionClosed
	has_connection_closed        bool
	ack_reliable_msg             u32
	has_ack_reliable_msg         bool
	first_reliable_msg           u32
	has_first_reliable_msg       bool
	reliable_messages            []CMsgSteamNetworkingP2PRendezvous_ReliableMessage
}

pub fn (o &CMsgSteamNetworkingP2PRendezvous) pack() []byte {
	mut res := []byte{}
	if o.has_from_identity {
		res << vproto.pack_string_field(o.from_identity, 8)
	}
	if o.has_from_connection_id {
		res << vproto.pack_32bit_field(o.from_connection_id, 9)
	}
	if o.has_to_identity {
		res << vproto.pack_string_field(o.to_identity, 10)
	}
	if o.has_to_connection_id {
		res << vproto.pack_32bit_field(o.to_connection_id, 1)
	}
	if o.has_sdr_routes {
		res << vproto.pack_bytes_field(o.sdr_routes, 2)
	}
	if o.has_ack_peer_routes_revision {
		res << vproto.pack_uint32_field(o.ack_peer_routes_revision, 3)
	}
	if o.has_ice_enabled {
		res << vproto.pack_bool_field(o.ice_enabled, 7)
	}
	if o.has_connect_request {
		res <<
			zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_connectrequest(o.connect_request, 4)
	}
	if o.has_connect_ok {
		res << zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_connectok(o.connect_ok, 5)
	}
	if o.has_connection_closed {
		res <<
			zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_connectionclosed(o.connection_closed, 6)
	}
	if o.has_ack_reliable_msg {
		res << vproto.pack_uint32_field(o.ack_reliable_msg, 11)
	}
	if o.has_first_reliable_msg {
		res << vproto.pack_uint32_field(o.first_reliable_msg, 12)
	}
	// [packed=false]
	for _, x in o.reliable_messages {
		res << zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous_reliablemessage(x, 13)
	}
	return res
}

pub fn cmsgsteamnetworkingp2prendezvous_unpack(buf []byte) ?CMsgSteamNetworkingP2PRendezvous {
	mut res := CMsgSteamNetworkingP2PRendezvous{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			8 {
				res.has_from_identity = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.from_identity = v
				i = ii
			}
			9 {
				res.has_from_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.from_connection_id = v
				i = ii
			}
			10 {
				res.has_to_identity = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.to_identity = v
				i = ii
			}
			1 {
				res.has_to_connection_id = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.to_connection_id = v
				i = ii
			}
			2 {
				res.has_sdr_routes = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sdr_routes = v
				i = ii
			}
			3 {
				res.has_ack_peer_routes_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_peer_routes_revision = v
				i = ii
			}
			7 {
				res.has_ice_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ice_enabled = v
				i = ii
			}
			4 {
				res.has_connect_request = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_connectrequest(cur_buf,
					tag_wiretype.wire_type)?
				res.connect_request = v
				i = ii
			}
			5 {
				res.has_connect_ok = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_connectok(cur_buf,
					tag_wiretype.wire_type)?
				res.connect_ok = v
				i = ii
			}
			6 {
				res.has_connection_closed = true
				ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_connectionclosed(cur_buf,
					tag_wiretype.wire_type)?
				res.connection_closed = v
				i = ii
			}
			11 {
				res.has_ack_reliable_msg = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ack_reliable_msg = v
				i = ii
			}
			12 {
				res.has_first_reliable_msg = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.first_reliable_msg = v
				i = ii
			}
			13 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous_reliablemessage(cur_buf,
					tag_wiretype.wire_type)?
				res.reliable_messages << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingp2prendezvous() CMsgSteamNetworkingP2PRendezvous {
	return CMsgSteamNetworkingP2PRendezvous{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingp2prendezvous(o CMsgSteamNetworkingP2PRendezvous, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingp2prendezvous(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingP2PRendezvous) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamnetworkingp2prendezvous_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamNetworkingICESessionSummary {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	failure_reason_code        u32
	has_failure_reason_code    bool
	local_candidate_types      u32
	has_local_candidate_types  bool
	remote_candidate_types     u32
	has_remote_candidate_types bool
	initial_route_kind         u32
	has_initial_route_kind     bool
	initial_ping               u32
	has_initial_ping           bool
	initial_score              u32
	has_initial_score          bool
	negotiation_ms             u32
	has_negotiation_ms         bool
	selected_seconds           u32
	has_selected_seconds       bool
}

pub fn (o &CMsgSteamNetworkingICESessionSummary) pack() []byte {
	mut res := []byte{}
	if o.has_failure_reason_code {
		res << vproto.pack_uint32_field(o.failure_reason_code, 7)
	}
	if o.has_local_candidate_types {
		res << vproto.pack_uint32_field(o.local_candidate_types, 1)
	}
	if o.has_remote_candidate_types {
		res << vproto.pack_uint32_field(o.remote_candidate_types, 2)
	}
	if o.has_initial_route_kind {
		res << vproto.pack_uint32_field(o.initial_route_kind, 3)
	}
	if o.has_initial_ping {
		res << vproto.pack_uint32_field(o.initial_ping, 4)
	}
	if o.has_initial_score {
		res << vproto.pack_uint32_field(o.initial_score, 6)
	}
	if o.has_negotiation_ms {
		res << vproto.pack_uint32_field(o.negotiation_ms, 5)
	}
	if o.has_selected_seconds {
		res << vproto.pack_uint32_field(o.selected_seconds, 12)
	}
	return res
}

pub fn cmsgsteamnetworkingicesessionsummary_unpack(buf []byte) ?CMsgSteamNetworkingICESessionSummary {
	mut res := CMsgSteamNetworkingICESessionSummary{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			7 {
				res.has_failure_reason_code = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.failure_reason_code = v
				i = ii
			}
			1 {
				res.has_local_candidate_types = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.local_candidate_types = v
				i = ii
			}
			2 {
				res.has_remote_candidate_types = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.remote_candidate_types = v
				i = ii
			}
			3 {
				res.has_initial_route_kind = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_route_kind = v
				i = ii
			}
			4 {
				res.has_initial_ping = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_ping = v
				i = ii
			}
			6 {
				res.has_initial_score = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_score = v
				i = ii
			}
			5 {
				res.has_negotiation_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.negotiation_ms = v
				i = ii
			}
			12 {
				res.has_selected_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.selected_seconds = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamnetworkingicesessionsummary() CMsgSteamNetworkingICESessionSummary {
	return CMsgSteamNetworkingICESessionSummary{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamnetworkingicesessionsummary(o CMsgSteamNetworkingICESessionSummary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamnetworkingicesessionsummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamNetworkingICESessionSummary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamnetworkingicesessionsummary_unpack(v)?
	return i, unpacked
}
