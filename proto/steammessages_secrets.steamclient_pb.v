
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


[_allow_multiple_values]
enum EKeyEscrowUsage {
k_ekeyescrowusagestreamingdevice = 0
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_ekeyescrowusage(e EKeyEscrowUsage, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_ekeyescrowusage(buf []byte, tag_wiretype vproto.WireType) ?(int, EKeyEscrowUsage) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, EKeyEscrowUsage(v)
}
pub struct CKeyEscrowRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
rsa_oaep_sha_ticket []byte
has_rsa_oaep_sha_ticket bool
password []byte
has_password bool
usage EKeyEscrowUsage
has_usage bool
device_name string
has_device_name bool
}
pub fn (o &CKeyEscrowRequest) pack() []byte {
mut res := []byte{}
if o.has_rsa_oaep_sha_ticket {
res << vproto.pack_bytes_field(o.rsa_oaep_sha_ticket, 1)
}

if o.has_password {
res << vproto.pack_bytes_field(o.password, 2)
}

if o.has_usage {
res << zzz_vproto_internal_pack_ekeyescrowusage(o.usage, 3)
}

if o.has_device_name {
res << vproto.pack_string_field(o.device_name, 4)
}

return res
}

pub fn ckeyescrowrequest_unpack(buf []byte) ?CKeyEscrowRequest {
mut res := CKeyEscrowRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_rsa_oaep_sha_ticket = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.rsa_oaep_sha_ticket = v
i = ii
}

2 {
res.has_password = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.password = v
i = ii
}

3 {
res.has_usage = true
ii, v := zzz_vproto_internal_unpack_ekeyescrowusage(cur_buf, tag_wiretype.wire_type)?
res.usage = v
i = ii
}

4 {
res.has_device_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.device_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ckeyescrowrequest() CKeyEscrowRequest {
return CKeyEscrowRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ckeyescrowrequest(o CKeyEscrowRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ckeyescrowrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CKeyEscrowRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ckeyescrowrequest_unpack(v)?
return i, unpacked
}
pub struct CKeyEscrowTicket {
mut:
unknown_fields []vproto.UnknownField
pub mut:
password []byte
has_password bool
identifier u64
has_identifier bool
payload []byte
has_payload bool
timestamp u32
has_timestamp bool
usage EKeyEscrowUsage
has_usage bool
device_name string
has_device_name bool
device_model string
has_device_model bool
device_serial string
has_device_serial bool
device_provisioning_id u32
has_device_provisioning_id bool
}
pub fn (o &CKeyEscrowTicket) pack() []byte {
mut res := []byte{}
if o.has_password {
res << vproto.pack_bytes_field(o.password, 1)
}

if o.has_identifier {
res << vproto.pack_uint64_field(o.identifier, 2)
}

if o.has_payload {
res << vproto.pack_bytes_field(o.payload, 3)
}

if o.has_timestamp {
res << vproto.pack_uint32_field(o.timestamp, 4)
}

if o.has_usage {
res << zzz_vproto_internal_pack_ekeyescrowusage(o.usage, 5)
}

if o.has_device_name {
res << vproto.pack_string_field(o.device_name, 6)
}

if o.has_device_model {
res << vproto.pack_string_field(o.device_model, 7)
}

if o.has_device_serial {
res << vproto.pack_string_field(o.device_serial, 8)
}

if o.has_device_provisioning_id {
res << vproto.pack_uint32_field(o.device_provisioning_id, 9)
}

return res
}

pub fn ckeyescrowticket_unpack(buf []byte) ?CKeyEscrowTicket {
mut res := CKeyEscrowTicket{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_password = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.password = v
i = ii
}

2 {
res.has_identifier = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.identifier = v
i = ii
}

3 {
res.has_payload = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.payload = v
i = ii
}

4 {
res.has_timestamp = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp = v
i = ii
}

5 {
res.has_usage = true
ii, v := zzz_vproto_internal_unpack_ekeyescrowusage(cur_buf, tag_wiretype.wire_type)?
res.usage = v
i = ii
}

6 {
res.has_device_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.device_name = v
i = ii
}

7 {
res.has_device_model = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.device_model = v
i = ii
}

8 {
res.has_device_serial = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.device_serial = v
i = ii
}

9 {
res.has_device_provisioning_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.device_provisioning_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ckeyescrowticket() CKeyEscrowTicket {
return CKeyEscrowTicket{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ckeyescrowticket(o CKeyEscrowTicket, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ckeyescrowticket(buf []byte, tag_wiretype vproto.WireType) ?(int, CKeyEscrowTicket) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ckeyescrowticket_unpack(v)?
return i, unpacked
}
pub struct CKeyEscrowResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
ticket CKeyEscrowTicket
has_ticket bool
}
pub fn (o &CKeyEscrowResponse) pack() []byte {
mut res := []byte{}
if o.has_ticket {
res << zzz_vproto_internal_pack_ckeyescrowticket(o.ticket, 1)
}

return res
}

pub fn ckeyescrowresponse_unpack(buf []byte) ?CKeyEscrowResponse {
mut res := CKeyEscrowResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_ticket = true
ii, v := zzz_vproto_internal_unpack_ckeyescrowticket(cur_buf, tag_wiretype.wire_type)?
res.ticket = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ckeyescrowresponse() CKeyEscrowResponse {
return CKeyEscrowResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ckeyescrowresponse(o CKeyEscrowResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ckeyescrowresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CKeyEscrowResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := ckeyescrowresponse_unpack(v)?
return i, unpacked
}
