// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EHiddeviceLocation {
	k_edevicelocationlocal = 0
	k_edevicelocationremote = 2
	k_edevicelocationany = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_ehiddevicelocation(e EHiddeviceLocation, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_ehiddevicelocation(buf []byte, tag_wiretype vproto.WireType) ?(int, EHiddeviceLocation) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EHiddeviceLocation(v)
}

[_allow_multiple_values]
enum EHiddeviceDisconnectMethod {
	k_edevicedisconnectmethodunknown = 0
	k_edevicedisconnectmethodbluetooth = 1
	k_edevicedisconnectmethodfeaturereport = 2
	k_edevicedisconnectmethodoutputreport = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_ehiddevicedisconnectmethod(e EHiddeviceDisconnectMethod, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_ehiddevicedisconnectmethod(buf []byte, tag_wiretype vproto.WireType) ?(int, EHiddeviceDisconnectMethod) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EHiddeviceDisconnectMethod(v)
}

pub struct CHiddeviceInfo {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	location                EHiddeviceLocation
	has_location            bool
	path                    string
	has_path                bool
	vendor_id               u32
	has_vendor_id           bool
	product_id              u32
	has_product_id          bool
	serial_number           string
	has_serial_number       bool
	release_number          u32
	has_release_number      bool
	manufacturer_string     string
	has_manufacturer_string bool
	product_string          string
	has_product_string      bool
	usage_page              u32
	has_usage_page          bool
	usage                   u32
	has_usage               bool
	interface_number        int
	has_interface_number    bool
	ostype                  int
	has_ostype              bool
	is_generic_gamepad      bool
	has_is_generic_gamepad  bool
	is_generic_joystick     bool
	has_is_generic_joystick bool
	caps_bits               u32
	has_caps_bits           bool
	session_id              u32
	has_session_id          bool
	econtrollertype         u32
	has_econtrollertype     bool
	is_xinput_device        bool
	has_is_xinput_device    bool
}

pub fn (o &CHiddeviceInfo) pack() []byte {
	mut res := []byte{}
	if o.has_location {
		res << zzz_vproto_internal_pack_ehiddevicelocation(o.location, 1)
	}
	if o.has_path {
		res << vproto.pack_string_field(o.path, 2)
	}
	if o.has_vendor_id {
		res << vproto.pack_uint32_field(o.vendor_id, 3)
	}
	if o.has_product_id {
		res << vproto.pack_uint32_field(o.product_id, 4)
	}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 5)
	}
	if o.has_release_number {
		res << vproto.pack_uint32_field(o.release_number, 6)
	}
	if o.has_manufacturer_string {
		res << vproto.pack_string_field(o.manufacturer_string, 7)
	}
	if o.has_product_string {
		res << vproto.pack_string_field(o.product_string, 8)
	}
	if o.has_usage_page {
		res << vproto.pack_uint32_field(o.usage_page, 9)
	}
	if o.has_usage {
		res << vproto.pack_uint32_field(o.usage, 10)
	}
	if o.has_interface_number {
		res << vproto.pack_int32_field(o.interface_number, 11)
	}
	if o.has_ostype {
		res << vproto.pack_int32_field(o.ostype, 12)
	}
	if o.has_is_generic_gamepad {
		res << vproto.pack_bool_field(o.is_generic_gamepad, 13)
	}
	if o.has_is_generic_joystick {
		res << vproto.pack_bool_field(o.is_generic_joystick, 14)
	}
	if o.has_caps_bits {
		res << vproto.pack_uint32_field(o.caps_bits, 15)
	}
	if o.has_session_id {
		res << vproto.pack_uint32_field(o.session_id, 16)
	}
	if o.has_econtrollertype {
		res << vproto.pack_uint32_field(o.econtrollertype, 17)
	}
	if o.has_is_xinput_device {
		res << vproto.pack_bool_field(o.is_xinput_device, 18)
	}
	return res
}

pub fn chiddeviceinfo_unpack(buf []byte) ?CHiddeviceInfo {
	mut res := CHiddeviceInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_location = true
				ii, v := zzz_vproto_internal_unpack_ehiddevicelocation(cur_buf, tag_wiretype.wire_type)?
				res.location = v
				i = ii
			}
			2 {
				res.has_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.path = v
				i = ii
			}
			3 {
				res.has_vendor_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.vendor_id = v
				i = ii
			}
			4 {
				res.has_product_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.product_id = v
				i = ii
			}
			5 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			6 {
				res.has_release_number = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.release_number = v
				i = ii
			}
			7 {
				res.has_manufacturer_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.manufacturer_string = v
				i = ii
			}
			8 {
				res.has_product_string = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.product_string = v
				i = ii
			}
			9 {
				res.has_usage_page = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.usage_page = v
				i = ii
			}
			10 {
				res.has_usage = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.usage = v
				i = ii
			}
			11 {
				res.has_interface_number = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.interface_number = v
				i = ii
			}
			12 {
				res.has_ostype = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ostype = v
				i = ii
			}
			13 {
				res.has_is_generic_gamepad = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_generic_gamepad = v
				i = ii
			}
			14 {
				res.has_is_generic_joystick = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_generic_joystick = v
				i = ii
			}
			15 {
				res.has_caps_bits = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.caps_bits = v
				i = ii
			}
			16 {
				res.has_session_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			17 {
				res.has_econtrollertype = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.econtrollertype = v
				i = ii
			}
			18 {
				res.has_is_xinput_device = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_xinput_device = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chiddeviceinfo() CHiddeviceInfo {
	return CHiddeviceInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chiddeviceinfo(o CHiddeviceInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chiddeviceinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CHiddeviceInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chiddeviceinfo_unpack(v)?
	return i, unpacked
}

pub struct CHiddeviceInputReport {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	full_report           []byte
	has_full_report       bool
	delta_report          []byte
	has_delta_report      bool
	delta_report_size     u32
	has_delta_report_size bool
	delta_report_crc      u32
	has_delta_report_crc  bool
}

pub fn (o &CHiddeviceInputReport) pack() []byte {
	mut res := []byte{}
	if o.has_full_report {
		res << vproto.pack_bytes_field(o.full_report, 1)
	}
	if o.has_delta_report {
		res << vproto.pack_bytes_field(o.delta_report, 2)
	}
	if o.has_delta_report_size {
		res << vproto.pack_uint32_field(o.delta_report_size, 3)
	}
	if o.has_delta_report_crc {
		res << vproto.pack_uint32_field(o.delta_report_crc, 4)
	}
	return res
}

pub fn chiddeviceinputreport_unpack(buf []byte) ?CHiddeviceInputReport {
	mut res := CHiddeviceInputReport{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_full_report = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.full_report = v
				i = ii
			}
			2 {
				res.has_delta_report = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.delta_report = v
				i = ii
			}
			3 {
				res.has_delta_report_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.delta_report_size = v
				i = ii
			}
			4 {
				res.has_delta_report_crc = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.delta_report_crc = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chiddeviceinputreport() CHiddeviceInputReport {
	return CHiddeviceInputReport{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chiddeviceinputreport(o CHiddeviceInputReport, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chiddeviceinputreport(buf []byte, tag_wiretype vproto.WireType) ?(int, CHiddeviceInputReport) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chiddeviceinputreport_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageToRemoteDeviceOpen {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	info           CHiddeviceInfo
	has_info       bool
}

pub fn (o &CHidmessageToRemoteDeviceOpen) pack() []byte {
	mut res := []byte{}
	if o.has_info {
		res << zzz_vproto_internal_pack_chiddeviceinfo(o.info, 1)
	}
	return res
}

pub fn chidmessagetoremotedeviceopen_unpack(buf []byte) ?CHidmessageToRemoteDeviceOpen {
	mut res := CHidmessageToRemoteDeviceOpen{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_info = true
				ii, v := zzz_vproto_internal_unpack_chiddeviceinfo(cur_buf, tag_wiretype.wire_type)?
				res.info = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagetoremotedeviceopen() CHidmessageToRemoteDeviceOpen {
	return CHidmessageToRemoteDeviceOpen{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagetoremotedeviceopen(o CHidmessageToRemoteDeviceOpen, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagetoremotedeviceopen(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageToRemoteDeviceOpen) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagetoremotedeviceopen_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageToRemoteDeviceClose {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	device         u32
	has_device     bool
}

pub fn (o &CHidmessageToRemoteDeviceClose) pack() []byte {
	mut res := []byte{}
	if o.has_device {
		res << vproto.pack_uint32_field(o.device, 1)
	}
	return res
}

pub fn chidmessagetoremotedeviceclose_unpack(buf []byte) ?CHidmessageToRemoteDeviceClose {
	mut res := CHidmessageToRemoteDeviceClose{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagetoremotedeviceclose() CHidmessageToRemoteDeviceClose {
	return CHidmessageToRemoteDeviceClose{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagetoremotedeviceclose(o CHidmessageToRemoteDeviceClose, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagetoremotedeviceclose(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageToRemoteDeviceClose) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagetoremotedeviceclose_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageToRemoteDeviceWrite {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	device         u32
	has_device     bool
	data           []byte
	has_data       bool
}

pub fn (o &CHidmessageToRemoteDeviceWrite) pack() []byte {
	mut res := []byte{}
	if o.has_device {
		res << vproto.pack_uint32_field(o.device, 1)
	}
	if o.has_data {
		res << vproto.pack_bytes_field(o.data, 2)
	}
	return res
}

pub fn chidmessagetoremotedevicewrite_unpack(buf []byte) ?CHidmessageToRemoteDeviceWrite {
	mut res := CHidmessageToRemoteDeviceWrite{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device = v
				i = ii
			}
			2 {
				res.has_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagetoremotedevicewrite() CHidmessageToRemoteDeviceWrite {
	return CHidmessageToRemoteDeviceWrite{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagetoremotedevicewrite(o CHidmessageToRemoteDeviceWrite, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagetoremotedevicewrite(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageToRemoteDeviceWrite) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagetoremotedevicewrite_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageToRemoteDeviceRead {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	device         u32
	has_device     bool
	length         u32
	has_length     bool
	timeout_ms     int
	has_timeout_ms bool
}

pub fn (o &CHidmessageToRemoteDeviceRead) pack() []byte {
	mut res := []byte{}
	if o.has_device {
		res << vproto.pack_uint32_field(o.device, 1)
	}
	if o.has_length {
		res << vproto.pack_uint32_field(o.length, 2)
	}
	if o.has_timeout_ms {
		res << vproto.pack_int32_field(o.timeout_ms, 3)
	}
	return res
}

pub fn chidmessagetoremotedeviceread_unpack(buf []byte) ?CHidmessageToRemoteDeviceRead {
	mut res := CHidmessageToRemoteDeviceRead{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device = v
				i = ii
			}
			2 {
				res.has_length = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.length = v
				i = ii
			}
			3 {
				res.has_timeout_ms = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.timeout_ms = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagetoremotedeviceread() CHidmessageToRemoteDeviceRead {
	return CHidmessageToRemoteDeviceRead{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagetoremotedeviceread(o CHidmessageToRemoteDeviceRead, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagetoremotedeviceread(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageToRemoteDeviceRead) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagetoremotedeviceread_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageToRemoteDeviceSendFeatureReport {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	device         u32
	has_device     bool
	data           []byte
	has_data       bool
}

pub fn (o &CHidmessageToRemoteDeviceSendFeatureReport) pack() []byte {
	mut res := []byte{}
	if o.has_device {
		res << vproto.pack_uint32_field(o.device, 1)
	}
	if o.has_data {
		res << vproto.pack_bytes_field(o.data, 2)
	}
	return res
}

pub fn chidmessagetoremotedevicesendfeaturereport_unpack(buf []byte) ?CHidmessageToRemoteDeviceSendFeatureReport {
	mut res := CHidmessageToRemoteDeviceSendFeatureReport{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device = v
				i = ii
			}
			2 {
				res.has_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagetoremotedevicesendfeaturereport() CHidmessageToRemoteDeviceSendFeatureReport {
	return CHidmessageToRemoteDeviceSendFeatureReport{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagetoremotedevicesendfeaturereport(o CHidmessageToRemoteDeviceSendFeatureReport, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagetoremotedevicesendfeaturereport(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageToRemoteDeviceSendFeatureReport) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagetoremotedevicesendfeaturereport_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageToRemoteDeviceGetFeatureReport {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	device            u32
	has_device        bool
	report_number     []byte
	has_report_number bool
	length            u32
	has_length        bool
}

pub fn (o &CHidmessageToRemoteDeviceGetFeatureReport) pack() []byte {
	mut res := []byte{}
	if o.has_device {
		res << vproto.pack_uint32_field(o.device, 1)
	}
	if o.has_report_number {
		res << vproto.pack_bytes_field(o.report_number, 2)
	}
	if o.has_length {
		res << vproto.pack_uint32_field(o.length, 3)
	}
	return res
}

pub fn chidmessagetoremotedevicegetfeaturereport_unpack(buf []byte) ?CHidmessageToRemoteDeviceGetFeatureReport {
	mut res := CHidmessageToRemoteDeviceGetFeatureReport{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device = v
				i = ii
			}
			2 {
				res.has_report_number = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.report_number = v
				i = ii
			}
			3 {
				res.has_length = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.length = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagetoremotedevicegetfeaturereport() CHidmessageToRemoteDeviceGetFeatureReport {
	return CHidmessageToRemoteDeviceGetFeatureReport{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagetoremotedevicegetfeaturereport(o CHidmessageToRemoteDeviceGetFeatureReport, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagetoremotedevicegetfeaturereport(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageToRemoteDeviceGetFeatureReport) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagetoremotedevicegetfeaturereport_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageToRemoteDeviceGetVendorString {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	device         u32
	has_device     bool
}

pub fn (o &CHidmessageToRemoteDeviceGetVendorString) pack() []byte {
	mut res := []byte{}
	if o.has_device {
		res << vproto.pack_uint32_field(o.device, 1)
	}
	return res
}

pub fn chidmessagetoremotedevicegetvendorstring_unpack(buf []byte) ?CHidmessageToRemoteDeviceGetVendorString {
	mut res := CHidmessageToRemoteDeviceGetVendorString{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagetoremotedevicegetvendorstring() CHidmessageToRemoteDeviceGetVendorString {
	return CHidmessageToRemoteDeviceGetVendorString{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagetoremotedevicegetvendorstring(o CHidmessageToRemoteDeviceGetVendorString, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagetoremotedevicegetvendorstring(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageToRemoteDeviceGetVendorString) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagetoremotedevicegetvendorstring_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageToRemoteDeviceGetProductString {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	device         u32
	has_device     bool
}

pub fn (o &CHidmessageToRemoteDeviceGetProductString) pack() []byte {
	mut res := []byte{}
	if o.has_device {
		res << vproto.pack_uint32_field(o.device, 1)
	}
	return res
}

pub fn chidmessagetoremotedevicegetproductstring_unpack(buf []byte) ?CHidmessageToRemoteDeviceGetProductString {
	mut res := CHidmessageToRemoteDeviceGetProductString{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagetoremotedevicegetproductstring() CHidmessageToRemoteDeviceGetProductString {
	return CHidmessageToRemoteDeviceGetProductString{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagetoremotedevicegetproductstring(o CHidmessageToRemoteDeviceGetProductString, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagetoremotedevicegetproductstring(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageToRemoteDeviceGetProductString) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagetoremotedevicegetproductstring_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageToRemoteDeviceGetSerialNumberString {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	device         u32
	has_device     bool
}

pub fn (o &CHidmessageToRemoteDeviceGetSerialNumberString) pack() []byte {
	mut res := []byte{}
	if o.has_device {
		res << vproto.pack_uint32_field(o.device, 1)
	}
	return res
}

pub fn chidmessagetoremotedevicegetserialnumberstring_unpack(buf []byte) ?CHidmessageToRemoteDeviceGetSerialNumberString {
	mut res := CHidmessageToRemoteDeviceGetSerialNumberString{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagetoremotedevicegetserialnumberstring() CHidmessageToRemoteDeviceGetSerialNumberString {
	return CHidmessageToRemoteDeviceGetSerialNumberString{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagetoremotedevicegetserialnumberstring(o CHidmessageToRemoteDeviceGetSerialNumberString, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagetoremotedevicegetserialnumberstring(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageToRemoteDeviceGetSerialNumberString) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagetoremotedevicegetserialnumberstring_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageToRemoteDeviceStartInputReports {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	device         u32
	has_device     bool
	length         u32
	has_length     bool
}

pub fn (o &CHidmessageToRemoteDeviceStartInputReports) pack() []byte {
	mut res := []byte{}
	if o.has_device {
		res << vproto.pack_uint32_field(o.device, 1)
	}
	if o.has_length {
		res << vproto.pack_uint32_field(o.length, 2)
	}
	return res
}

pub fn chidmessagetoremotedevicestartinputreports_unpack(buf []byte) ?CHidmessageToRemoteDeviceStartInputReports {
	mut res := CHidmessageToRemoteDeviceStartInputReports{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device = v
				i = ii
			}
			2 {
				res.has_length = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.length = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagetoremotedevicestartinputreports() CHidmessageToRemoteDeviceStartInputReports {
	return CHidmessageToRemoteDeviceStartInputReports{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagetoremotedevicestartinputreports(o CHidmessageToRemoteDeviceStartInputReports, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagetoremotedevicestartinputreports(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageToRemoteDeviceStartInputReports) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagetoremotedevicestartinputreports_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageToRemoteDeviceRequestFullReport {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	device         u32
	has_device     bool
}

pub fn (o &CHidmessageToRemoteDeviceRequestFullReport) pack() []byte {
	mut res := []byte{}
	if o.has_device {
		res << vproto.pack_uint32_field(o.device, 1)
	}
	return res
}

pub fn chidmessagetoremotedevicerequestfullreport_unpack(buf []byte) ?CHidmessageToRemoteDeviceRequestFullReport {
	mut res := CHidmessageToRemoteDeviceRequestFullReport{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagetoremotedevicerequestfullreport() CHidmessageToRemoteDeviceRequestFullReport {
	return CHidmessageToRemoteDeviceRequestFullReport{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagetoremotedevicerequestfullreport(o CHidmessageToRemoteDeviceRequestFullReport, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagetoremotedevicerequestfullreport(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageToRemoteDeviceRequestFullReport) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagetoremotedevicerequestfullreport_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageToRemoteDeviceDisconnect {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	device               u32
	has_device           bool
	disconnectmethod     EHiddeviceDisconnectMethod
	has_disconnectmethod bool
	data                 []byte
	has_data             bool
}

pub fn (o &CHidmessageToRemoteDeviceDisconnect) pack() []byte {
	mut res := []byte{}
	if o.has_device {
		res << vproto.pack_uint32_field(o.device, 1)
	}
	if o.has_disconnectmethod {
		res << zzz_vproto_internal_pack_ehiddevicedisconnectmethod(o.disconnectmethod, 2)
	}
	if o.has_data {
		res << vproto.pack_bytes_field(o.data, 3)
	}
	return res
}

pub fn chidmessagetoremotedevicedisconnect_unpack(buf []byte) ?CHidmessageToRemoteDeviceDisconnect {
	mut res := CHidmessageToRemoteDeviceDisconnect{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device = v
				i = ii
			}
			2 {
				res.has_disconnectmethod = true
				ii, v := zzz_vproto_internal_unpack_ehiddevicedisconnectmethod(cur_buf,
					tag_wiretype.wire_type)?
				res.disconnectmethod = v
				i = ii
			}
			3 {
				res.has_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagetoremotedevicedisconnect() CHidmessageToRemoteDeviceDisconnect {
	return CHidmessageToRemoteDeviceDisconnect{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagetoremotedevicedisconnect(o CHidmessageToRemoteDeviceDisconnect, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagetoremotedevicedisconnect(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageToRemoteDeviceDisconnect) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagetoremotedevicedisconnect_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageToRemote {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	request_id     u32
	has_request_id bool
}

pub fn (o &CHidmessageToRemote) pack() []byte {
	mut res := []byte{}
	if o.has_request_id {
		res << vproto.pack_uint32_field(o.request_id, 1)
	}
	return res
}

pub fn chidmessagetoremote_unpack(buf []byte) ?CHidmessageToRemote {
	mut res := CHidmessageToRemote{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_request_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.request_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagetoremote() CHidmessageToRemote {
	return CHidmessageToRemote{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagetoremote(o CHidmessageToRemote, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagetoremote(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageToRemote) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagetoremote_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageFromRemoteUpdateDeviceList {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	devices        []CHiddeviceInfo
}

pub fn (o &CHidmessageFromRemoteUpdateDeviceList) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.devices {
		res << zzz_vproto_internal_pack_chiddeviceinfo(x, 1)
	}
	return res
}

pub fn chidmessagefromremoteupdatedevicelist_unpack(buf []byte) ?CHidmessageFromRemoteUpdateDeviceList {
	mut res := CHidmessageFromRemoteUpdateDeviceList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_chiddeviceinfo(cur_buf, tag_wiretype.wire_type)?
				res.devices << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagefromremoteupdatedevicelist() CHidmessageFromRemoteUpdateDeviceList {
	return CHidmessageFromRemoteUpdateDeviceList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagefromremoteupdatedevicelist(o CHidmessageFromRemoteUpdateDeviceList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagefromremoteupdatedevicelist(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageFromRemoteUpdateDeviceList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagefromremoteupdatedevicelist_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageFromRemoteRequestResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	request_id     u32
	has_request_id bool
	result         int
	has_result     bool
	data           []byte
	has_data       bool
}

pub fn (o &CHidmessageFromRemoteRequestResponse) pack() []byte {
	mut res := []byte{}
	if o.has_request_id {
		res << vproto.pack_uint32_field(o.request_id, 1)
	}
	if o.has_result {
		res << vproto.pack_int32_field(o.result, 2)
	}
	if o.has_data {
		res << vproto.pack_bytes_field(o.data, 3)
	}
	return res
}

pub fn chidmessagefromremoterequestresponse_unpack(buf []byte) ?CHidmessageFromRemoteRequestResponse {
	mut res := CHidmessageFromRemoteRequestResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_request_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.request_id = v
				i = ii
			}
			2 {
				res.has_result = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			3 {
				res.has_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagefromremoterequestresponse() CHidmessageFromRemoteRequestResponse {
	return CHidmessageFromRemoteRequestResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagefromremoterequestresponse(o CHidmessageFromRemoteRequestResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagefromremoterequestresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageFromRemoteRequestResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagefromremoterequestresponse_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageFromRemoteDeviceInputReportsDeviceInputReport {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	device         u32
	has_device     bool
	reports        []CHiddeviceInputReport
}

pub fn (o &CHidmessageFromRemoteDeviceInputReportsDeviceInputReport) pack() []byte {
	mut res := []byte{}
	if o.has_device {
		res << vproto.pack_uint32_field(o.device, 1)
	}
	// [packed=false]
	for _, x in o.reports {
		res << zzz_vproto_internal_pack_chiddeviceinputreport(x, 2)
	}
	return res
}

pub fn chidmessagefromremotedeviceinputreportsdeviceinputreport_unpack(buf []byte) ?CHidmessageFromRemoteDeviceInputReportsDeviceInputReport {
	mut res := CHidmessageFromRemoteDeviceInputReportsDeviceInputReport{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_chiddeviceinputreport(cur_buf, tag_wiretype.wire_type)?
				res.reports << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagefromremotedeviceinputreportsdeviceinputreport() CHidmessageFromRemoteDeviceInputReportsDeviceInputReport {
	return CHidmessageFromRemoteDeviceInputReportsDeviceInputReport{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagefromremotedeviceinputreportsdeviceinputreport(o CHidmessageFromRemoteDeviceInputReportsDeviceInputReport, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagefromremotedeviceinputreportsdeviceinputreport(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageFromRemoteDeviceInputReportsDeviceInputReport) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagefromremotedeviceinputreportsdeviceinputreport_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageFromRemoteDeviceInputReports {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	device_reports []CHidmessageFromRemoteDeviceInputReportsDeviceInputReport
}

pub fn (o &CHidmessageFromRemoteDeviceInputReports) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.device_reports {
		res <<
			zzz_vproto_internal_pack_chidmessagefromremotedeviceinputreportsdeviceinputreport(x, 1)
	}
	return res
}

pub fn chidmessagefromremotedeviceinputreports_unpack(buf []byte) ?CHidmessageFromRemoteDeviceInputReports {
	mut res := CHidmessageFromRemoteDeviceInputReports{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_chidmessagefromremotedeviceinputreportsdeviceinputreport(cur_buf,
					tag_wiretype.wire_type)?
				res.device_reports << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagefromremotedeviceinputreports() CHidmessageFromRemoteDeviceInputReports {
	return CHidmessageFromRemoteDeviceInputReports{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagefromremotedeviceinputreports(o CHidmessageFromRemoteDeviceInputReports, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagefromremotedeviceinputreports(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageFromRemoteDeviceInputReports) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagefromremotedeviceinputreports_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageFromRemoteCloseDevice {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	device         u32
	has_device     bool
}

pub fn (o &CHidmessageFromRemoteCloseDevice) pack() []byte {
	mut res := []byte{}
	if o.has_device {
		res << vproto.pack_uint32_field(o.device, 1)
	}
	return res
}

pub fn chidmessagefromremoteclosedevice_unpack(buf []byte) ?CHidmessageFromRemoteCloseDevice {
	mut res := CHidmessageFromRemoteCloseDevice{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.device = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagefromremoteclosedevice() CHidmessageFromRemoteCloseDevice {
	return CHidmessageFromRemoteCloseDevice{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagefromremoteclosedevice(o CHidmessageFromRemoteCloseDevice, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagefromremoteclosedevice(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageFromRemoteCloseDevice) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagefromremoteclosedevice_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageFromRemoteCloseAllDevices {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CHidmessageFromRemoteCloseAllDevices) pack() []byte {
	res := []byte{}
	return res
}

pub fn chidmessagefromremoteclosealldevices_unpack(buf []byte) ?CHidmessageFromRemoteCloseAllDevices {
	res := CHidmessageFromRemoteCloseAllDevices{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagefromremoteclosealldevices() CHidmessageFromRemoteCloseAllDevices {
	return CHidmessageFromRemoteCloseAllDevices{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagefromremoteclosealldevices(o CHidmessageFromRemoteCloseAllDevices, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagefromremoteclosealldevices(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageFromRemoteCloseAllDevices) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagefromremoteclosealldevices_unpack(v)?
	return i, unpacked
}

pub struct CHidmessageFromRemote {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CHidmessageFromRemote) pack() []byte {
	res := []byte{}
	return res
}

pub fn chidmessagefromremote_unpack(buf []byte) ?CHidmessageFromRemote {
	res := CHidmessageFromRemote{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidmessagefromremote() CHidmessageFromRemote {
	return CHidmessageFromRemote{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidmessagefromremote(o CHidmessageFromRemote, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidmessagefromremote(buf []byte, tag_wiretype vproto.WireType) ?(int, CHidmessageFromRemote) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidmessagefromremote_unpack(v)?
	return i, unpacked
}
