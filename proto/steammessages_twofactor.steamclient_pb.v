// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CTwoFactor_Status_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CTwoFactor_Status_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn ctwofactor_status_request_unpack(buf []byte) ?CTwoFactor_Status_Request {
	mut res := CTwoFactor_Status_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_status_request() CTwoFactor_Status_Request {
	return CTwoFactor_Status_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_status_request(o CTwoFactor_Status_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_status_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_Status_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_status_request_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_Status_Response {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	state                             u32
	has_state                         bool
	inactivation_reason               u32
	has_inactivation_reason           bool
	authenticator_type                u32
	has_authenticator_type            bool
	authenticator_allowed             bool
	has_authenticator_allowed         bool
	steamguard_scheme                 u32
	has_steamguard_scheme             bool
	token_gid                         string
	has_token_gid                     bool
	email_validated                   bool
	has_email_validated               bool
	device_identifier                 string
	has_device_identifier             bool
	time_created                      u32
	has_time_created                  bool
	revocation_attempts_remaining     u32
	has_revocation_attempts_remaining bool
	classified_agent                  string
	has_classified_agent              bool
	allow_external_authenticator      bool
	has_allow_external_authenticator  bool
	time_transferred                  u32
	has_time_transferred              bool
}

pub fn (o &CTwoFactor_Status_Response) pack() []byte {
	mut res := []byte{}
	if o.has_state {
		res << vproto.pack_uint32_field(o.state, 1)
	}
	if o.has_inactivation_reason {
		res << vproto.pack_uint32_field(o.inactivation_reason, 2)
	}
	if o.has_authenticator_type {
		res << vproto.pack_uint32_field(o.authenticator_type, 3)
	}
	if o.has_authenticator_allowed {
		res << vproto.pack_bool_field(o.authenticator_allowed, 4)
	}
	if o.has_steamguard_scheme {
		res << vproto.pack_uint32_field(o.steamguard_scheme, 5)
	}
	if o.has_token_gid {
		res << vproto.pack_string_field(o.token_gid, 6)
	}
	if o.has_email_validated {
		res << vproto.pack_bool_field(o.email_validated, 7)
	}
	if o.has_device_identifier {
		res << vproto.pack_string_field(o.device_identifier, 8)
	}
	if o.has_time_created {
		res << vproto.pack_uint32_field(o.time_created, 9)
	}
	if o.has_revocation_attempts_remaining {
		res << vproto.pack_uint32_field(o.revocation_attempts_remaining, 10)
	}
	if o.has_classified_agent {
		res << vproto.pack_string_field(o.classified_agent, 11)
	}
	if o.has_allow_external_authenticator {
		res << vproto.pack_bool_field(o.allow_external_authenticator, 12)
	}
	if o.has_time_transferred {
		res << vproto.pack_uint32_field(o.time_transferred, 13)
	}
	return res
}

pub fn ctwofactor_status_response_unpack(buf []byte) ?CTwoFactor_Status_Response {
	mut res := CTwoFactor_Status_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_state = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			2 {
				res.has_inactivation_reason = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.inactivation_reason = v
				i = ii
			}
			3 {
				res.has_authenticator_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.authenticator_type = v
				i = ii
			}
			4 {
				res.has_authenticator_allowed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.authenticator_allowed = v
				i = ii
			}
			5 {
				res.has_steamguard_scheme = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.steamguard_scheme = v
				i = ii
			}
			6 {
				res.has_token_gid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.token_gid = v
				i = ii
			}
			7 {
				res.has_email_validated = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.email_validated = v
				i = ii
			}
			8 {
				res.has_device_identifier = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_identifier = v
				i = ii
			}
			9 {
				res.has_time_created = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			10 {
				res.has_revocation_attempts_remaining = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.revocation_attempts_remaining = v
				i = ii
			}
			11 {
				res.has_classified_agent = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.classified_agent = v
				i = ii
			}
			12 {
				res.has_allow_external_authenticator = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.allow_external_authenticator = v
				i = ii
			}
			13 {
				res.has_time_transferred = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_transferred = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_status_response() CTwoFactor_Status_Response {
	return CTwoFactor_Status_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_status_response(o CTwoFactor_Status_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_status_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_Status_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_status_response_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_AddAuthenticator_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	steamid                u64
	has_steamid            bool
	authenticator_time     u64
	has_authenticator_time bool
	serial_number          u64
	has_serial_number      bool
	authenticator_type     u32
	has_authenticator_type bool
	device_identifier      string
	has_device_identifier  bool
	sms_phone_id           string
	has_sms_phone_id       bool
	http_headers           []string
}

pub fn (o &CTwoFactor_AddAuthenticator_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_authenticator_time {
		res << vproto.pack_uint64_field(o.authenticator_time, 2)
	}
	if o.has_serial_number {
		res << vproto.pack_64bit_field(o.serial_number, 3)
	}
	if o.has_authenticator_type {
		res << vproto.pack_uint32_field(o.authenticator_type, 4)
	}
	if o.has_device_identifier {
		res << vproto.pack_string_field(o.device_identifier, 5)
	}
	if o.has_sms_phone_id {
		res << vproto.pack_string_field(o.sms_phone_id, 6)
	}
	// [packed=false]
	for _, x in o.http_headers {
		res << vproto.pack_string_field(x, 7)
	}
	return res
}

pub fn ctwofactor_addauthenticator_request_unpack(buf []byte) ?CTwoFactor_AddAuthenticator_Request {
	mut res := CTwoFactor_AddAuthenticator_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_authenticator_time = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.authenticator_time = v
				i = ii
			}
			3 {
				res.has_serial_number = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			4 {
				res.has_authenticator_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.authenticator_type = v
				i = ii
			}
			5 {
				res.has_device_identifier = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_identifier = v
				i = ii
			}
			6 {
				res.has_sms_phone_id = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sms_phone_id = v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.http_headers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_addauthenticator_request() CTwoFactor_AddAuthenticator_Request {
	return CTwoFactor_AddAuthenticator_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_addauthenticator_request(o CTwoFactor_AddAuthenticator_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_addauthenticator_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_AddAuthenticator_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_addauthenticator_request_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_AddAuthenticator_Response {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	shared_secret       []byte
	has_shared_secret   bool
	serial_number       u64
	has_serial_number   bool
	revocation_code     string
	has_revocation_code bool
	uri                 string
	has_uri             bool
	server_time         u64
	has_server_time     bool
	account_name        string
	has_account_name    bool
	token_gid           string
	has_token_gid       bool
	identity_secret     []byte
	has_identity_secret bool
	secret_1            []byte
	has_secret_1        bool
	status              int
	has_status          bool
}

pub fn (o &CTwoFactor_AddAuthenticator_Response) pack() []byte {
	mut res := []byte{}
	if o.has_shared_secret {
		res << vproto.pack_bytes_field(o.shared_secret, 1)
	}
	if o.has_serial_number {
		res << vproto.pack_64bit_field(o.serial_number, 2)
	}
	if o.has_revocation_code {
		res << vproto.pack_string_field(o.revocation_code, 3)
	}
	if o.has_uri {
		res << vproto.pack_string_field(o.uri, 4)
	}
	if o.has_server_time {
		res << vproto.pack_uint64_field(o.server_time, 5)
	}
	if o.has_account_name {
		res << vproto.pack_string_field(o.account_name, 6)
	}
	if o.has_token_gid {
		res << vproto.pack_string_field(o.token_gid, 7)
	}
	if o.has_identity_secret {
		res << vproto.pack_bytes_field(o.identity_secret, 8)
	}
	if o.has_secret_1 {
		res << vproto.pack_bytes_field(o.secret_1, 9)
	}
	if o.has_status {
		res << vproto.pack_int32_field(o.status, 10)
	}
	return res
}

pub fn ctwofactor_addauthenticator_response_unpack(buf []byte) ?CTwoFactor_AddAuthenticator_Response {
	mut res := CTwoFactor_AddAuthenticator_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_shared_secret = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.shared_secret = v
				i = ii
			}
			2 {
				res.has_serial_number = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			3 {
				res.has_revocation_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.revocation_code = v
				i = ii
			}
			4 {
				res.has_uri = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.uri = v
				i = ii
			}
			5 {
				res.has_server_time = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.server_time = v
				i = ii
			}
			6 {
				res.has_account_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.account_name = v
				i = ii
			}
			7 {
				res.has_token_gid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.token_gid = v
				i = ii
			}
			8 {
				res.has_identity_secret = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.identity_secret = v
				i = ii
			}
			9 {
				res.has_secret_1 = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.secret_1 = v
				i = ii
			}
			10 {
				res.has_status = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.status = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_addauthenticator_response() CTwoFactor_AddAuthenticator_Response {
	return CTwoFactor_AddAuthenticator_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_addauthenticator_response(o CTwoFactor_AddAuthenticator_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_addauthenticator_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_AddAuthenticator_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_addauthenticator_response_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_SendEmail_Request {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	steamid                     u64
	has_steamid                 bool
	email_type                  u32
	has_email_type              bool
	include_activation_code     bool
	has_include_activation_code bool
}

pub fn (o &CTwoFactor_SendEmail_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_email_type {
		res << vproto.pack_uint32_field(o.email_type, 2)
	}
	if o.has_include_activation_code {
		res << vproto.pack_bool_field(o.include_activation_code, 3)
	}
	return res
}

pub fn ctwofactor_sendemail_request_unpack(buf []byte) ?CTwoFactor_SendEmail_Request {
	mut res := CTwoFactor_SendEmail_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_email_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.email_type = v
				i = ii
			}
			3 {
				res.has_include_activation_code = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_activation_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_sendemail_request() CTwoFactor_SendEmail_Request {
	return CTwoFactor_SendEmail_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_sendemail_request(o CTwoFactor_SendEmail_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_sendemail_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_SendEmail_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_sendemail_request_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_SendEmail_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CTwoFactor_SendEmail_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn ctwofactor_sendemail_response_unpack(buf []byte) ?CTwoFactor_SendEmail_Response {
	res := CTwoFactor_SendEmail_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_sendemail_response() CTwoFactor_SendEmail_Response {
	return CTwoFactor_SendEmail_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_sendemail_response(o CTwoFactor_SendEmail_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_sendemail_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_SendEmail_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_sendemail_response_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_FinalizeAddAuthenticator_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	steamid                u64
	has_steamid            bool
	authenticator_code     string
	has_authenticator_code bool
	authenticator_time     u64
	has_authenticator_time bool
	activation_code        string
	has_activation_code    bool
	http_headers           []string
}

pub fn (o &CTwoFactor_FinalizeAddAuthenticator_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_authenticator_code {
		res << vproto.pack_string_field(o.authenticator_code, 2)
	}
	if o.has_authenticator_time {
		res << vproto.pack_uint64_field(o.authenticator_time, 3)
	}
	if o.has_activation_code {
		res << vproto.pack_string_field(o.activation_code, 4)
	}
	// [packed=false]
	for _, x in o.http_headers {
		res << vproto.pack_string_field(x, 5)
	}
	return res
}

pub fn ctwofactor_finalizeaddauthenticator_request_unpack(buf []byte) ?CTwoFactor_FinalizeAddAuthenticator_Request {
	mut res := CTwoFactor_FinalizeAddAuthenticator_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_authenticator_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.authenticator_code = v
				i = ii
			}
			3 {
				res.has_authenticator_time = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.authenticator_time = v
				i = ii
			}
			4 {
				res.has_activation_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.activation_code = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.http_headers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_finalizeaddauthenticator_request() CTwoFactor_FinalizeAddAuthenticator_Request {
	return CTwoFactor_FinalizeAddAuthenticator_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_finalizeaddauthenticator_request(o CTwoFactor_FinalizeAddAuthenticator_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_finalizeaddauthenticator_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_FinalizeAddAuthenticator_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_finalizeaddauthenticator_request_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_FinalizeAddAuthenticator_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	success         bool
	has_success     bool
	want_more       bool
	has_want_more   bool
	server_time     u64
	has_server_time bool
	status          int
	has_status      bool
}

pub fn (o &CTwoFactor_FinalizeAddAuthenticator_Response) pack() []byte {
	mut res := []byte{}
	if o.has_success {
		res << vproto.pack_bool_field(o.success, 1)
	}
	if o.has_want_more {
		res << vproto.pack_bool_field(o.want_more, 2)
	}
	if o.has_server_time {
		res << vproto.pack_uint64_field(o.server_time, 3)
	}
	if o.has_status {
		res << vproto.pack_int32_field(o.status, 4)
	}
	return res
}

pub fn ctwofactor_finalizeaddauthenticator_response_unpack(buf []byte) ?CTwoFactor_FinalizeAddAuthenticator_Response {
	mut res := CTwoFactor_FinalizeAddAuthenticator_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_success = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.success = v
				i = ii
			}
			2 {
				res.has_want_more = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.want_more = v
				i = ii
			}
			3 {
				res.has_server_time = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.server_time = v
				i = ii
			}
			4 {
				res.has_status = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.status = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_finalizeaddauthenticator_response() CTwoFactor_FinalizeAddAuthenticator_Response {
	return CTwoFactor_FinalizeAddAuthenticator_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_finalizeaddauthenticator_response(o CTwoFactor_FinalizeAddAuthenticator_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_finalizeaddauthenticator_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_FinalizeAddAuthenticator_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_finalizeaddauthenticator_response_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_RemoveAuthenticator_Request {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	revocation_code                   string
	has_revocation_code               bool
	revocation_reason                 u32
	has_revocation_reason             bool
	steamguard_scheme                 u32
	has_steamguard_scheme             bool
	remove_all_steamguard_cookies     bool
	has_remove_all_steamguard_cookies bool
}

pub fn (o &CTwoFactor_RemoveAuthenticator_Request) pack() []byte {
	mut res := []byte{}
	if o.has_revocation_code {
		res << vproto.pack_string_field(o.revocation_code, 2)
	}
	if o.has_revocation_reason {
		res << vproto.pack_uint32_field(o.revocation_reason, 5)
	}
	if o.has_steamguard_scheme {
		res << vproto.pack_uint32_field(o.steamguard_scheme, 6)
	}
	if o.has_remove_all_steamguard_cookies {
		res << vproto.pack_bool_field(o.remove_all_steamguard_cookies, 7)
	}
	return res
}

pub fn ctwofactor_removeauthenticator_request_unpack(buf []byte) ?CTwoFactor_RemoveAuthenticator_Request {
	mut res := CTwoFactor_RemoveAuthenticator_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				res.has_revocation_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.revocation_code = v
				i = ii
			}
			5 {
				res.has_revocation_reason = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.revocation_reason = v
				i = ii
			}
			6 {
				res.has_steamguard_scheme = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.steamguard_scheme = v
				i = ii
			}
			7 {
				res.has_remove_all_steamguard_cookies = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.remove_all_steamguard_cookies = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_removeauthenticator_request() CTwoFactor_RemoveAuthenticator_Request {
	return CTwoFactor_RemoveAuthenticator_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_removeauthenticator_request(o CTwoFactor_RemoveAuthenticator_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_removeauthenticator_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_RemoveAuthenticator_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_removeauthenticator_request_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_RemoveAuthenticator_Response {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	success                           bool
	has_success                       bool
	server_time                       u64
	has_server_time                   bool
	revocation_attempts_remaining     u32
	has_revocation_attempts_remaining bool
}

pub fn (o &CTwoFactor_RemoveAuthenticator_Response) pack() []byte {
	mut res := []byte{}
	if o.has_success {
		res << vproto.pack_bool_field(o.success, 1)
	}
	if o.has_server_time {
		res << vproto.pack_uint64_field(o.server_time, 3)
	}
	if o.has_revocation_attempts_remaining {
		res << vproto.pack_uint32_field(o.revocation_attempts_remaining, 5)
	}
	return res
}

pub fn ctwofactor_removeauthenticator_response_unpack(buf []byte) ?CTwoFactor_RemoveAuthenticator_Response {
	mut res := CTwoFactor_RemoveAuthenticator_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_success = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.success = v
				i = ii
			}
			3 {
				res.has_server_time = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.server_time = v
				i = ii
			}
			5 {
				res.has_revocation_attempts_remaining = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.revocation_attempts_remaining = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_removeauthenticator_response() CTwoFactor_RemoveAuthenticator_Response {
	return CTwoFactor_RemoveAuthenticator_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_removeauthenticator_response(o CTwoFactor_RemoveAuthenticator_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_removeauthenticator_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_RemoveAuthenticator_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_removeauthenticator_response_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_CreateEmergencyCodes_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	code           string
	has_code       bool
}

pub fn (o &CTwoFactor_CreateEmergencyCodes_Request) pack() []byte {
	mut res := []byte{}
	if o.has_code {
		res << vproto.pack_string_field(o.code, 1)
	}
	return res
}

pub fn ctwofactor_createemergencycodes_request_unpack(buf []byte) ?CTwoFactor_CreateEmergencyCodes_Request {
	mut res := CTwoFactor_CreateEmergencyCodes_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_createemergencycodes_request() CTwoFactor_CreateEmergencyCodes_Request {
	return CTwoFactor_CreateEmergencyCodes_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_createemergencycodes_request(o CTwoFactor_CreateEmergencyCodes_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_createemergencycodes_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_CreateEmergencyCodes_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_createemergencycodes_request_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_CreateEmergencyCodes_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	codes          []string
}

pub fn (o &CTwoFactor_CreateEmergencyCodes_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.codes {
		res << vproto.pack_string_field(x, 1)
	}
	return res
}

pub fn ctwofactor_createemergencycodes_response_unpack(buf []byte) ?CTwoFactor_CreateEmergencyCodes_Response {
	mut res := CTwoFactor_CreateEmergencyCodes_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.codes << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_createemergencycodes_response() CTwoFactor_CreateEmergencyCodes_Response {
	return CTwoFactor_CreateEmergencyCodes_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_createemergencycodes_response(o CTwoFactor_CreateEmergencyCodes_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_createemergencycodes_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_CreateEmergencyCodes_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_createemergencycodes_response_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_DestroyEmergencyCodes_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CTwoFactor_DestroyEmergencyCodes_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn ctwofactor_destroyemergencycodes_request_unpack(buf []byte) ?CTwoFactor_DestroyEmergencyCodes_Request {
	mut res := CTwoFactor_DestroyEmergencyCodes_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_destroyemergencycodes_request() CTwoFactor_DestroyEmergencyCodes_Request {
	return CTwoFactor_DestroyEmergencyCodes_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_destroyemergencycodes_request(o CTwoFactor_DestroyEmergencyCodes_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_destroyemergencycodes_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_DestroyEmergencyCodes_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_destroyemergencycodes_request_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_DestroyEmergencyCodes_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CTwoFactor_DestroyEmergencyCodes_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn ctwofactor_destroyemergencycodes_response_unpack(buf []byte) ?CTwoFactor_DestroyEmergencyCodes_Response {
	res := CTwoFactor_DestroyEmergencyCodes_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_destroyemergencycodes_response() CTwoFactor_DestroyEmergencyCodes_Response {
	return CTwoFactor_DestroyEmergencyCodes_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_destroyemergencycodes_response(o CTwoFactor_DestroyEmergencyCodes_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_destroyemergencycodes_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_DestroyEmergencyCodes_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_destroyemergencycodes_response_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_ValidateToken_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	code           string
	has_code       bool
}

pub fn (o &CTwoFactor_ValidateToken_Request) pack() []byte {
	mut res := []byte{}
	if o.has_code {
		res << vproto.pack_string_field(o.code, 1)
	}
	return res
}

pub fn ctwofactor_validatetoken_request_unpack(buf []byte) ?CTwoFactor_ValidateToken_Request {
	mut res := CTwoFactor_ValidateToken_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_validatetoken_request() CTwoFactor_ValidateToken_Request {
	return CTwoFactor_ValidateToken_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_validatetoken_request(o CTwoFactor_ValidateToken_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_validatetoken_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_ValidateToken_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_validatetoken_request_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactor_ValidateToken_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	valid          bool
	has_valid      bool
}

pub fn (o &CTwoFactor_ValidateToken_Response) pack() []byte {
	mut res := []byte{}
	if o.has_valid {
		res << vproto.pack_bool_field(o.valid, 1)
	}
	return res
}

pub fn ctwofactor_validatetoken_response_unpack(buf []byte) ?CTwoFactor_ValidateToken_Response {
	mut res := CTwoFactor_ValidateToken_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_valid = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.valid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactor_validatetoken_response() CTwoFactor_ValidateToken_Response {
	return CTwoFactor_ValidateToken_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactor_validatetoken_response(o CTwoFactor_ValidateToken_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactor_validatetoken_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactor_ValidateToken_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactor_validatetoken_response_unpack(v)?
	return i, unpacked
}
