// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CTwoFactorStatusRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CTwoFactorStatusRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn ctwofactorstatusrequest_unpack(buf []byte) ?CTwoFactorStatusRequest {
	mut res := CTwoFactorStatusRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactorstatusrequest() CTwoFactorStatusRequest {
	return CTwoFactorStatusRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactorstatusrequest(o CTwoFactorStatusRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactorstatusrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorStatusRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactorstatusrequest_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorStatusResponse {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	state                             u32
	has_state                         bool
	inactivation_reason               u32
	has_inactivation_reason           bool
	authenticator_type                u32
	has_authenticator_type            bool
	authenticator_allowed             bool
	has_authenticator_allowed         bool
	steamguard_scheme                 u32
	has_steamguard_scheme             bool
	token_gid                         string
	has_token_gid                     bool
	email_validated                   bool
	has_email_validated               bool
	device_identifier                 string
	has_device_identifier             bool
	time_created                      u32
	has_time_created                  bool
	revocation_attempts_remaining     u32
	has_revocation_attempts_remaining bool
	classified_agent                  string
	has_classified_agent              bool
	allow_external_authenticator      bool
	has_allow_external_authenticator  bool
	time_transferred                  u32
	has_time_transferred              bool
}

pub fn (o &CTwoFactorStatusResponse) pack() []byte {
	mut res := []byte{}
	if o.has_state {
		res << vproto.pack_uint32_field(o.state, 1)
	}
	if o.has_inactivation_reason {
		res << vproto.pack_uint32_field(o.inactivation_reason, 2)
	}
	if o.has_authenticator_type {
		res << vproto.pack_uint32_field(o.authenticator_type, 3)
	}
	if o.has_authenticator_allowed {
		res << vproto.pack_bool_field(o.authenticator_allowed, 4)
	}
	if o.has_steamguard_scheme {
		res << vproto.pack_uint32_field(o.steamguard_scheme, 5)
	}
	if o.has_token_gid {
		res << vproto.pack_string_field(o.token_gid, 6)
	}
	if o.has_email_validated {
		res << vproto.pack_bool_field(o.email_validated, 7)
	}
	if o.has_device_identifier {
		res << vproto.pack_string_field(o.device_identifier, 8)
	}
	if o.has_time_created {
		res << vproto.pack_uint32_field(o.time_created, 9)
	}
	if o.has_revocation_attempts_remaining {
		res << vproto.pack_uint32_field(o.revocation_attempts_remaining, 10)
	}
	if o.has_classified_agent {
		res << vproto.pack_string_field(o.classified_agent, 11)
	}
	if o.has_allow_external_authenticator {
		res << vproto.pack_bool_field(o.allow_external_authenticator, 12)
	}
	if o.has_time_transferred {
		res << vproto.pack_uint32_field(o.time_transferred, 13)
	}
	return res
}

pub fn ctwofactorstatusresponse_unpack(buf []byte) ?CTwoFactorStatusResponse {
	mut res := CTwoFactorStatusResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_state = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			2 {
				res.has_inactivation_reason = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.inactivation_reason = v
				i = ii
			}
			3 {
				res.has_authenticator_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.authenticator_type = v
				i = ii
			}
			4 {
				res.has_authenticator_allowed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.authenticator_allowed = v
				i = ii
			}
			5 {
				res.has_steamguard_scheme = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.steamguard_scheme = v
				i = ii
			}
			6 {
				res.has_token_gid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.token_gid = v
				i = ii
			}
			7 {
				res.has_email_validated = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.email_validated = v
				i = ii
			}
			8 {
				res.has_device_identifier = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_identifier = v
				i = ii
			}
			9 {
				res.has_time_created = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			10 {
				res.has_revocation_attempts_remaining = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.revocation_attempts_remaining = v
				i = ii
			}
			11 {
				res.has_classified_agent = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.classified_agent = v
				i = ii
			}
			12 {
				res.has_allow_external_authenticator = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.allow_external_authenticator = v
				i = ii
			}
			13 {
				res.has_time_transferred = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_transferred = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactorstatusresponse() CTwoFactorStatusResponse {
	return CTwoFactorStatusResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactorstatusresponse(o CTwoFactorStatusResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactorstatusresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorStatusResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactorstatusresponse_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorAddAuthenticatorRequest {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	steamid                u64
	has_steamid            bool
	authenticator_time     u64
	has_authenticator_time bool
	serial_number          u64
	has_serial_number      bool
	authenticator_type     u32
	has_authenticator_type bool
	device_identifier      string
	has_device_identifier  bool
	sms_phone_id           string
	has_sms_phone_id       bool
	http_headers           []string
}

pub fn (o &CTwoFactorAddAuthenticatorRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_authenticator_time {
		res << vproto.pack_uint64_field(o.authenticator_time, 2)
	}
	if o.has_serial_number {
		res << vproto.pack_64bit_field(o.serial_number, 3)
	}
	if o.has_authenticator_type {
		res << vproto.pack_uint32_field(o.authenticator_type, 4)
	}
	if o.has_device_identifier {
		res << vproto.pack_string_field(o.device_identifier, 5)
	}
	if o.has_sms_phone_id {
		res << vproto.pack_string_field(o.sms_phone_id, 6)
	}
	// [packed=false]
	for _, x in o.http_headers {
		res << vproto.pack_string_field(x, 7)
	}
	return res
}

pub fn ctwofactoraddauthenticatorrequest_unpack(buf []byte) ?CTwoFactorAddAuthenticatorRequest {
	mut res := CTwoFactorAddAuthenticatorRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_authenticator_time = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.authenticator_time = v
				i = ii
			}
			3 {
				res.has_serial_number = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			4 {
				res.has_authenticator_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.authenticator_type = v
				i = ii
			}
			5 {
				res.has_device_identifier = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_identifier = v
				i = ii
			}
			6 {
				res.has_sms_phone_id = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sms_phone_id = v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.http_headers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactoraddauthenticatorrequest() CTwoFactorAddAuthenticatorRequest {
	return CTwoFactorAddAuthenticatorRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactoraddauthenticatorrequest(o CTwoFactorAddAuthenticatorRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactoraddauthenticatorrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorAddAuthenticatorRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactoraddauthenticatorrequest_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorAddAuthenticatorResponse {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	shared_secret       []byte
	has_shared_secret   bool
	serial_number       u64
	has_serial_number   bool
	revocation_code     string
	has_revocation_code bool
	uri                 string
	has_uri             bool
	server_time         u64
	has_server_time     bool
	account_name        string
	has_account_name    bool
	token_gid           string
	has_token_gid       bool
	identity_secret     []byte
	has_identity_secret bool
	secret_1            []byte
	has_secret_1        bool
	status              int
	has_status          bool
}

pub fn (o &CTwoFactorAddAuthenticatorResponse) pack() []byte {
	mut res := []byte{}
	if o.has_shared_secret {
		res << vproto.pack_bytes_field(o.shared_secret, 1)
	}
	if o.has_serial_number {
		res << vproto.pack_64bit_field(o.serial_number, 2)
	}
	if o.has_revocation_code {
		res << vproto.pack_string_field(o.revocation_code, 3)
	}
	if o.has_uri {
		res << vproto.pack_string_field(o.uri, 4)
	}
	if o.has_server_time {
		res << vproto.pack_uint64_field(o.server_time, 5)
	}
	if o.has_account_name {
		res << vproto.pack_string_field(o.account_name, 6)
	}
	if o.has_token_gid {
		res << vproto.pack_string_field(o.token_gid, 7)
	}
	if o.has_identity_secret {
		res << vproto.pack_bytes_field(o.identity_secret, 8)
	}
	if o.has_secret_1 {
		res << vproto.pack_bytes_field(o.secret_1, 9)
	}
	if o.has_status {
		res << vproto.pack_int32_field(o.status, 10)
	}
	return res
}

pub fn ctwofactoraddauthenticatorresponse_unpack(buf []byte) ?CTwoFactorAddAuthenticatorResponse {
	mut res := CTwoFactorAddAuthenticatorResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_shared_secret = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.shared_secret = v
				i = ii
			}
			2 {
				res.has_serial_number = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			3 {
				res.has_revocation_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.revocation_code = v
				i = ii
			}
			4 {
				res.has_uri = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.uri = v
				i = ii
			}
			5 {
				res.has_server_time = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.server_time = v
				i = ii
			}
			6 {
				res.has_account_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.account_name = v
				i = ii
			}
			7 {
				res.has_token_gid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.token_gid = v
				i = ii
			}
			8 {
				res.has_identity_secret = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.identity_secret = v
				i = ii
			}
			9 {
				res.has_secret_1 = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.secret_1 = v
				i = ii
			}
			10 {
				res.has_status = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.status = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactoraddauthenticatorresponse() CTwoFactorAddAuthenticatorResponse {
	return CTwoFactorAddAuthenticatorResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactoraddauthenticatorresponse(o CTwoFactorAddAuthenticatorResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactoraddauthenticatorresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorAddAuthenticatorResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactoraddauthenticatorresponse_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorSendEmailRequest {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	steamid                     u64
	has_steamid                 bool
	email_type                  u32
	has_email_type              bool
	include_activation_code     bool
	has_include_activation_code bool
}

pub fn (o &CTwoFactorSendEmailRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_email_type {
		res << vproto.pack_uint32_field(o.email_type, 2)
	}
	if o.has_include_activation_code {
		res << vproto.pack_bool_field(o.include_activation_code, 3)
	}
	return res
}

pub fn ctwofactorsendemailrequest_unpack(buf []byte) ?CTwoFactorSendEmailRequest {
	mut res := CTwoFactorSendEmailRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_email_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.email_type = v
				i = ii
			}
			3 {
				res.has_include_activation_code = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_activation_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactorsendemailrequest() CTwoFactorSendEmailRequest {
	return CTwoFactorSendEmailRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactorsendemailrequest(o CTwoFactorSendEmailRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactorsendemailrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorSendEmailRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactorsendemailrequest_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorSendEmailResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CTwoFactorSendEmailResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn ctwofactorsendemailresponse_unpack(buf []byte) ?CTwoFactorSendEmailResponse {
	res := CTwoFactorSendEmailResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactorsendemailresponse() CTwoFactorSendEmailResponse {
	return CTwoFactorSendEmailResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactorsendemailresponse(o CTwoFactorSendEmailResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactorsendemailresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorSendEmailResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactorsendemailresponse_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorFinalizeAddAuthenticatorRequest {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	steamid                u64
	has_steamid            bool
	authenticator_code     string
	has_authenticator_code bool
	authenticator_time     u64
	has_authenticator_time bool
	activation_code        string
	has_activation_code    bool
	http_headers           []string
}

pub fn (o &CTwoFactorFinalizeAddAuthenticatorRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_authenticator_code {
		res << vproto.pack_string_field(o.authenticator_code, 2)
	}
	if o.has_authenticator_time {
		res << vproto.pack_uint64_field(o.authenticator_time, 3)
	}
	if o.has_activation_code {
		res << vproto.pack_string_field(o.activation_code, 4)
	}
	// [packed=false]
	for _, x in o.http_headers {
		res << vproto.pack_string_field(x, 5)
	}
	return res
}

pub fn ctwofactorfinalizeaddauthenticatorrequest_unpack(buf []byte) ?CTwoFactorFinalizeAddAuthenticatorRequest {
	mut res := CTwoFactorFinalizeAddAuthenticatorRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_authenticator_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.authenticator_code = v
				i = ii
			}
			3 {
				res.has_authenticator_time = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.authenticator_time = v
				i = ii
			}
			4 {
				res.has_activation_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.activation_code = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.http_headers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactorfinalizeaddauthenticatorrequest() CTwoFactorFinalizeAddAuthenticatorRequest {
	return CTwoFactorFinalizeAddAuthenticatorRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactorfinalizeaddauthenticatorrequest(o CTwoFactorFinalizeAddAuthenticatorRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactorfinalizeaddauthenticatorrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorFinalizeAddAuthenticatorRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactorfinalizeaddauthenticatorrequest_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorFinalizeAddAuthenticatorResponse {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	success         bool
	has_success     bool
	want_more       bool
	has_want_more   bool
	server_time     u64
	has_server_time bool
	status          int
	has_status      bool
}

pub fn (o &CTwoFactorFinalizeAddAuthenticatorResponse) pack() []byte {
	mut res := []byte{}
	if o.has_success {
		res << vproto.pack_bool_field(o.success, 1)
	}
	if o.has_want_more {
		res << vproto.pack_bool_field(o.want_more, 2)
	}
	if o.has_server_time {
		res << vproto.pack_uint64_field(o.server_time, 3)
	}
	if o.has_status {
		res << vproto.pack_int32_field(o.status, 4)
	}
	return res
}

pub fn ctwofactorfinalizeaddauthenticatorresponse_unpack(buf []byte) ?CTwoFactorFinalizeAddAuthenticatorResponse {
	mut res := CTwoFactorFinalizeAddAuthenticatorResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_success = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.success = v
				i = ii
			}
			2 {
				res.has_want_more = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.want_more = v
				i = ii
			}
			3 {
				res.has_server_time = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.server_time = v
				i = ii
			}
			4 {
				res.has_status = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.status = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactorfinalizeaddauthenticatorresponse() CTwoFactorFinalizeAddAuthenticatorResponse {
	return CTwoFactorFinalizeAddAuthenticatorResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactorfinalizeaddauthenticatorresponse(o CTwoFactorFinalizeAddAuthenticatorResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactorfinalizeaddauthenticatorresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorFinalizeAddAuthenticatorResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactorfinalizeaddauthenticatorresponse_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorRemoveAuthenticatorRequest {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	revocation_code                   string
	has_revocation_code               bool
	revocation_reason                 u32
	has_revocation_reason             bool
	steamguard_scheme                 u32
	has_steamguard_scheme             bool
	remove_all_steamguard_cookies     bool
	has_remove_all_steamguard_cookies bool
}

pub fn (o &CTwoFactorRemoveAuthenticatorRequest) pack() []byte {
	mut res := []byte{}
	if o.has_revocation_code {
		res << vproto.pack_string_field(o.revocation_code, 2)
	}
	if o.has_revocation_reason {
		res << vproto.pack_uint32_field(o.revocation_reason, 5)
	}
	if o.has_steamguard_scheme {
		res << vproto.pack_uint32_field(o.steamguard_scheme, 6)
	}
	if o.has_remove_all_steamguard_cookies {
		res << vproto.pack_bool_field(o.remove_all_steamguard_cookies, 7)
	}
	return res
}

pub fn ctwofactorremoveauthenticatorrequest_unpack(buf []byte) ?CTwoFactorRemoveAuthenticatorRequest {
	mut res := CTwoFactorRemoveAuthenticatorRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				res.has_revocation_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.revocation_code = v
				i = ii
			}
			5 {
				res.has_revocation_reason = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.revocation_reason = v
				i = ii
			}
			6 {
				res.has_steamguard_scheme = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.steamguard_scheme = v
				i = ii
			}
			7 {
				res.has_remove_all_steamguard_cookies = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.remove_all_steamguard_cookies = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactorremoveauthenticatorrequest() CTwoFactorRemoveAuthenticatorRequest {
	return CTwoFactorRemoveAuthenticatorRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactorremoveauthenticatorrequest(o CTwoFactorRemoveAuthenticatorRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactorremoveauthenticatorrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorRemoveAuthenticatorRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactorremoveauthenticatorrequest_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorRemoveAuthenticatorResponse {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	success                           bool
	has_success                       bool
	server_time                       u64
	has_server_time                   bool
	revocation_attempts_remaining     u32
	has_revocation_attempts_remaining bool
}

pub fn (o &CTwoFactorRemoveAuthenticatorResponse) pack() []byte {
	mut res := []byte{}
	if o.has_success {
		res << vproto.pack_bool_field(o.success, 1)
	}
	if o.has_server_time {
		res << vproto.pack_uint64_field(o.server_time, 3)
	}
	if o.has_revocation_attempts_remaining {
		res << vproto.pack_uint32_field(o.revocation_attempts_remaining, 5)
	}
	return res
}

pub fn ctwofactorremoveauthenticatorresponse_unpack(buf []byte) ?CTwoFactorRemoveAuthenticatorResponse {
	mut res := CTwoFactorRemoveAuthenticatorResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_success = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.success = v
				i = ii
			}
			3 {
				res.has_server_time = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.server_time = v
				i = ii
			}
			5 {
				res.has_revocation_attempts_remaining = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.revocation_attempts_remaining = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactorremoveauthenticatorresponse() CTwoFactorRemoveAuthenticatorResponse {
	return CTwoFactorRemoveAuthenticatorResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactorremoveauthenticatorresponse(o CTwoFactorRemoveAuthenticatorResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactorremoveauthenticatorresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorRemoveAuthenticatorResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactorremoveauthenticatorresponse_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorCreateEmergencyCodesRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	code           string
	has_code       bool
}

pub fn (o &CTwoFactorCreateEmergencyCodesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_code {
		res << vproto.pack_string_field(o.code, 1)
	}
	return res
}

pub fn ctwofactorcreateemergencycodesrequest_unpack(buf []byte) ?CTwoFactorCreateEmergencyCodesRequest {
	mut res := CTwoFactorCreateEmergencyCodesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactorcreateemergencycodesrequest() CTwoFactorCreateEmergencyCodesRequest {
	return CTwoFactorCreateEmergencyCodesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactorcreateemergencycodesrequest(o CTwoFactorCreateEmergencyCodesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactorcreateemergencycodesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorCreateEmergencyCodesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactorcreateemergencycodesrequest_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorCreateEmergencyCodesResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	codes          []string
}

pub fn (o &CTwoFactorCreateEmergencyCodesResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.codes {
		res << vproto.pack_string_field(x, 1)
	}
	return res
}

pub fn ctwofactorcreateemergencycodesresponse_unpack(buf []byte) ?CTwoFactorCreateEmergencyCodesResponse {
	mut res := CTwoFactorCreateEmergencyCodesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.codes << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactorcreateemergencycodesresponse() CTwoFactorCreateEmergencyCodesResponse {
	return CTwoFactorCreateEmergencyCodesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactorcreateemergencycodesresponse(o CTwoFactorCreateEmergencyCodesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactorcreateemergencycodesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorCreateEmergencyCodesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactorcreateemergencycodesresponse_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorDestroyEmergencyCodesRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CTwoFactorDestroyEmergencyCodesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn ctwofactordestroyemergencycodesrequest_unpack(buf []byte) ?CTwoFactorDestroyEmergencyCodesRequest {
	mut res := CTwoFactorDestroyEmergencyCodesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactordestroyemergencycodesrequest() CTwoFactorDestroyEmergencyCodesRequest {
	return CTwoFactorDestroyEmergencyCodesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactordestroyemergencycodesrequest(o CTwoFactorDestroyEmergencyCodesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactordestroyemergencycodesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorDestroyEmergencyCodesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactordestroyemergencycodesrequest_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorDestroyEmergencyCodesResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CTwoFactorDestroyEmergencyCodesResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn ctwofactordestroyemergencycodesresponse_unpack(buf []byte) ?CTwoFactorDestroyEmergencyCodesResponse {
	res := CTwoFactorDestroyEmergencyCodesResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactordestroyemergencycodesresponse() CTwoFactorDestroyEmergencyCodesResponse {
	return CTwoFactorDestroyEmergencyCodesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactordestroyemergencycodesresponse(o CTwoFactorDestroyEmergencyCodesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactordestroyemergencycodesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorDestroyEmergencyCodesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactordestroyemergencycodesresponse_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorValidateTokenRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	code           string
	has_code       bool
}

pub fn (o &CTwoFactorValidateTokenRequest) pack() []byte {
	mut res := []byte{}
	if o.has_code {
		res << vproto.pack_string_field(o.code, 1)
	}
	return res
}

pub fn ctwofactorvalidatetokenrequest_unpack(buf []byte) ?CTwoFactorValidateTokenRequest {
	mut res := CTwoFactorValidateTokenRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactorvalidatetokenrequest() CTwoFactorValidateTokenRequest {
	return CTwoFactorValidateTokenRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactorvalidatetokenrequest(o CTwoFactorValidateTokenRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactorvalidatetokenrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorValidateTokenRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactorvalidatetokenrequest_unpack(v)?
	return i, unpacked
}

pub struct CTwoFactorValidateTokenResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	valid          bool
	has_valid      bool
}

pub fn (o &CTwoFactorValidateTokenResponse) pack() []byte {
	mut res := []byte{}
	if o.has_valid {
		res << vproto.pack_bool_field(o.valid, 1)
	}
	return res
}

pub fn ctwofactorvalidatetokenresponse_unpack(buf []byte) ?CTwoFactorValidateTokenResponse {
	mut res := CTwoFactorValidateTokenResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_valid = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.valid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctwofactorvalidatetokenresponse() CTwoFactorValidateTokenResponse {
	return CTwoFactorValidateTokenResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctwofactorvalidatetokenresponse(o CTwoFactorValidateTokenResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctwofactorvalidatetokenresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CTwoFactorValidateTokenResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctwofactorvalidatetokenresponse_unpack(v)?
	return i, unpacked
}
