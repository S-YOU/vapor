// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CFriendMessagesGetRecentMessagesRequest {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	steamid1                     u64
	has_steamid1                 bool
	steamid2                     u64
	has_steamid2                 bool
	count                        u32
	has_count                    bool
	most_recent_conversation     bool
	has_most_recent_conversation bool
	rtime32_start_time           u32
	has_rtime32_start_time       bool
	bbcode_format                bool
	has_bbcode_format            bool
	start_ordinal                u32
	has_start_ordinal            bool
	time_last                    u32
	has_time_last                bool
	ordinal_last                 u32
	has_ordinal_last             bool
}

pub fn (o &CFriendMessagesGetRecentMessagesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid1 {
		res << vproto.pack_64bit_field(o.steamid1, 1)
	}
	if o.has_steamid2 {
		res << vproto.pack_64bit_field(o.steamid2, 2)
	}
	if o.has_count {
		res << vproto.pack_uint32_field(o.count, 3)
	}
	if o.has_most_recent_conversation {
		res << vproto.pack_bool_field(o.most_recent_conversation, 4)
	}
	if o.has_rtime32_start_time {
		res << vproto.pack_32bit_field(o.rtime32_start_time, 5)
	}
	if o.has_bbcode_format {
		res << vproto.pack_bool_field(o.bbcode_format, 6)
	}
	if o.has_start_ordinal {
		res << vproto.pack_uint32_field(o.start_ordinal, 7)
	}
	if o.has_time_last {
		res << vproto.pack_uint32_field(o.time_last, 8)
	}
	if o.has_ordinal_last {
		res << vproto.pack_uint32_field(o.ordinal_last, 9)
	}
	return res
}

pub fn cfriendmessagesgetrecentmessagesrequest_unpack(buf []byte) ?CFriendMessagesGetRecentMessagesRequest {
	mut res := CFriendMessagesGetRecentMessagesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid1 = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid1 = v
				i = ii
			}
			2 {
				res.has_steamid2 = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid2 = v
				i = ii
			}
			3 {
				res.has_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			4 {
				res.has_most_recent_conversation = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.most_recent_conversation = v
				i = ii
			}
			5 {
				res.has_rtime32_start_time = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_start_time = v
				i = ii
			}
			6 {
				res.has_bbcode_format = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bbcode_format = v
				i = ii
			}
			7 {
				res.has_start_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_ordinal = v
				i = ii
			}
			8 {
				res.has_time_last = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last = v
				i = ii
			}
			9 {
				res.has_ordinal_last = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal_last = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfriendmessagesgetrecentmessagesrequest() CFriendMessagesGetRecentMessagesRequest {
	return CFriendMessagesGetRecentMessagesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfriendmessagesgetrecentmessagesrequest(o CFriendMessagesGetRecentMessagesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfriendmessagesgetrecentmessagesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CFriendMessagesGetRecentMessagesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfriendmessagesgetrecentmessagesrequest_unpack(v)?
	return i, unpacked
}

pub struct CFriendMessagesGetRecentMessagesResponseFriendMessage {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	accountid      u32
	has_accountid  bool
	timestamp      u32
	has_timestamp  bool
	message        string
	has_message    bool
	ordinal        u32
	has_ordinal    bool
}

pub fn (o &CFriendMessagesGetRecentMessagesResponseFriendMessage) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 1)
	}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 2)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 3)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 4)
	}
	return res
}

pub fn cfriendmessagesgetrecentmessagesresponsefriendmessage_unpack(buf []byte) ?CFriendMessagesGetRecentMessagesResponseFriendMessage {
	mut res := CFriendMessagesGetRecentMessagesResponseFriendMessage{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			3 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			4 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfriendmessagesgetrecentmessagesresponsefriendmessage() CFriendMessagesGetRecentMessagesResponseFriendMessage {
	return CFriendMessagesGetRecentMessagesResponseFriendMessage{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfriendmessagesgetrecentmessagesresponsefriendmessage(o CFriendMessagesGetRecentMessagesResponseFriendMessage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfriendmessagesgetrecentmessagesresponsefriendmessage(buf []byte, tag_wiretype vproto.WireType) ?(int, CFriendMessagesGetRecentMessagesResponseFriendMessage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfriendmessagesgetrecentmessagesresponsefriendmessage_unpack(v)?
	return i, unpacked
}

pub struct CFriendMessagesGetRecentMessagesResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	messages           []CFriendMessagesGetRecentMessagesResponseFriendMessage
	more_available     bool
	has_more_available bool
}

pub fn (o &CFriendMessagesGetRecentMessagesResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.messages {
		res << zzz_vproto_internal_pack_cfriendmessagesgetrecentmessagesresponsefriendmessage(x, 1)
	}
	if o.has_more_available {
		res << vproto.pack_bool_field(o.more_available, 4)
	}
	return res
}

pub fn cfriendmessagesgetrecentmessagesresponse_unpack(buf []byte) ?CFriendMessagesGetRecentMessagesResponse {
	mut res := CFriendMessagesGetRecentMessagesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cfriendmessagesgetrecentmessagesresponsefriendmessage(cur_buf,
					tag_wiretype.wire_type)?
				res.messages << v
				i = ii
			}
			4 {
				res.has_more_available = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.more_available = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfriendmessagesgetrecentmessagesresponse() CFriendMessagesGetRecentMessagesResponse {
	return CFriendMessagesGetRecentMessagesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfriendmessagesgetrecentmessagesresponse(o CFriendMessagesGetRecentMessagesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfriendmessagesgetrecentmessagesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CFriendMessagesGetRecentMessagesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfriendmessagesgetrecentmessagesresponse_unpack(v)?
	return i, unpacked
}

pub struct CFriendsMessagesGetActiveMessageSessionsRequest {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	lastmessage_since               u32
	has_lastmessage_since           bool
	only_sessions_with_messages     bool
	has_only_sessions_with_messages bool
}

pub fn (o &CFriendsMessagesGetActiveMessageSessionsRequest) pack() []byte {
	mut res := []byte{}
	if o.has_lastmessage_since {
		res << vproto.pack_uint32_field(o.lastmessage_since, 1)
	}
	if o.has_only_sessions_with_messages {
		res << vproto.pack_bool_field(o.only_sessions_with_messages, 2)
	}
	return res
}

pub fn cfriendsmessagesgetactivemessagesessionsrequest_unpack(buf []byte) ?CFriendsMessagesGetActiveMessageSessionsRequest {
	mut res := CFriendsMessagesGetActiveMessageSessionsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_lastmessage_since = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.lastmessage_since = v
				i = ii
			}
			2 {
				res.has_only_sessions_with_messages = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.only_sessions_with_messages = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfriendsmessagesgetactivemessagesessionsrequest() CFriendsMessagesGetActiveMessageSessionsRequest {
	return CFriendsMessagesGetActiveMessageSessionsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfriendsmessagesgetactivemessagesessionsrequest(o CFriendsMessagesGetActiveMessageSessionsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfriendsmessagesgetactivemessagesessionsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CFriendsMessagesGetActiveMessageSessionsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfriendsmessagesgetactivemessagesessionsrequest_unpack(v)?
	return i, unpacked
}

pub struct CFriendsMessagesGetActiveMessageSessionsResponseFriendMessageSession {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	accountid_friend         u32
	has_accountid_friend     bool
	last_message             u32
	has_last_message         bool
	last_view                u32
	has_last_view            bool
	unread_message_count     u32
	has_unread_message_count bool
}

pub fn (o &CFriendsMessagesGetActiveMessageSessionsResponseFriendMessageSession) pack() []byte {
	mut res := []byte{}
	if o.has_accountid_friend {
		res << vproto.pack_uint32_field(o.accountid_friend, 1)
	}
	if o.has_last_message {
		res << vproto.pack_uint32_field(o.last_message, 2)
	}
	if o.has_last_view {
		res << vproto.pack_uint32_field(o.last_view, 3)
	}
	if o.has_unread_message_count {
		res << vproto.pack_uint32_field(o.unread_message_count, 4)
	}
	return res
}

pub fn cfriendsmessagesgetactivemessagesessionsresponsefriendmessagesession_unpack(buf []byte) ?CFriendsMessagesGetActiveMessageSessionsResponseFriendMessageSession {
	mut res := CFriendsMessagesGetActiveMessageSessionsResponseFriendMessageSession{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid_friend = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_friend = v
				i = ii
			}
			2 {
				res.has_last_message = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_message = v
				i = ii
			}
			3 {
				res.has_last_view = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_view = v
				i = ii
			}
			4 {
				res.has_unread_message_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.unread_message_count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfriendsmessagesgetactivemessagesessionsresponsefriendmessagesession() CFriendsMessagesGetActiveMessageSessionsResponseFriendMessageSession {
	return CFriendsMessagesGetActiveMessageSessionsResponseFriendMessageSession{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfriendsmessagesgetactivemessagesessionsresponsefriendmessagesession(o CFriendsMessagesGetActiveMessageSessionsResponseFriendMessageSession, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfriendsmessagesgetactivemessagesessionsresponsefriendmessagesession(buf []byte, tag_wiretype vproto.WireType) ?(int, CFriendsMessagesGetActiveMessageSessionsResponseFriendMessageSession) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfriendsmessagesgetactivemessagesessionsresponsefriendmessagesession_unpack(v)?
	return i, unpacked
}

pub struct CFriendsMessagesGetActiveMessageSessionsResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	message_sessions []CFriendsMessagesGetActiveMessageSessionsResponseFriendMessageSession
	timestamp        u32
	has_timestamp    bool
}

pub fn (o &CFriendsMessagesGetActiveMessageSessionsResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.message_sessions {
		res <<
			zzz_vproto_internal_pack_cfriendsmessagesgetactivemessagesessionsresponsefriendmessagesession(x, 1)
	}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 2)
	}
	return res
}

pub fn cfriendsmessagesgetactivemessagesessionsresponse_unpack(buf []byte) ?CFriendsMessagesGetActiveMessageSessionsResponse {
	mut res := CFriendsMessagesGetActiveMessageSessionsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cfriendsmessagesgetactivemessagesessionsresponsefriendmessagesession(cur_buf,
					tag_wiretype.wire_type)?
				res.message_sessions << v
				i = ii
			}
			2 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfriendsmessagesgetactivemessagesessionsresponse() CFriendsMessagesGetActiveMessageSessionsResponse {
	return CFriendsMessagesGetActiveMessageSessionsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfriendsmessagesgetactivemessagesessionsresponse(o CFriendsMessagesGetActiveMessageSessionsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfriendsmessagesgetactivemessagesessionsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CFriendsMessagesGetActiveMessageSessionsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfriendsmessagesgetactivemessagesessionsresponse_unpack(v)?
	return i, unpacked
}

pub struct CFriendMessagesSendMessageRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steamid               u64
	has_steamid           bool
	chat_entry_type       int
	has_chat_entry_type   bool
	message               string
	has_message           bool
	contains_bbcode       bool
	has_contains_bbcode   bool
	echo_to_sender        bool
	has_echo_to_sender    bool
	low_priority          bool
	has_low_priority      bool
	client_message_id     string
	has_client_message_id bool
}

pub fn (o &CFriendMessagesSendMessageRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_chat_entry_type {
		res << vproto.pack_int32_field(o.chat_entry_type, 2)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 3)
	}
	if o.has_contains_bbcode {
		res << vproto.pack_bool_field(o.contains_bbcode, 4)
	}
	if o.has_echo_to_sender {
		res << vproto.pack_bool_field(o.echo_to_sender, 5)
	}
	if o.has_low_priority {
		res << vproto.pack_bool_field(o.low_priority, 6)
	}
	if o.has_client_message_id {
		res << vproto.pack_string_field(o.client_message_id, 8)
	}
	return res
}

pub fn cfriendmessagessendmessagerequest_unpack(buf []byte) ?CFriendMessagesSendMessageRequest {
	mut res := CFriendMessagesSendMessageRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_chat_entry_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_entry_type = v
				i = ii
			}
			3 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			4 {
				res.has_contains_bbcode = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.contains_bbcode = v
				i = ii
			}
			5 {
				res.has_echo_to_sender = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.echo_to_sender = v
				i = ii
			}
			6 {
				res.has_low_priority = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.low_priority = v
				i = ii
			}
			8 {
				res.has_client_message_id = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.client_message_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfriendmessagessendmessagerequest() CFriendMessagesSendMessageRequest {
	return CFriendMessagesSendMessageRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfriendmessagessendmessagerequest(o CFriendMessagesSendMessageRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfriendmessagessendmessagerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CFriendMessagesSendMessageRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfriendmessagessendmessagerequest_unpack(v)?
	return i, unpacked
}

pub struct CFriendMessagesSendMessageResponse {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	modified_message            string
	has_modified_message        bool
	server_timestamp            u32
	has_server_timestamp        bool
	ordinal                     u32
	has_ordinal                 bool
	message_without_bb_code     string
	has_message_without_bb_code bool
}

pub fn (o &CFriendMessagesSendMessageResponse) pack() []byte {
	mut res := []byte{}
	if o.has_modified_message {
		res << vproto.pack_string_field(o.modified_message, 1)
	}
	if o.has_server_timestamp {
		res << vproto.pack_uint32_field(o.server_timestamp, 2)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 3)
	}
	if o.has_message_without_bb_code {
		res << vproto.pack_string_field(o.message_without_bb_code, 4)
	}
	return res
}

pub fn cfriendmessagessendmessageresponse_unpack(buf []byte) ?CFriendMessagesSendMessageResponse {
	mut res := CFriendMessagesSendMessageResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_modified_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.modified_message = v
				i = ii
			}
			2 {
				res.has_server_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.server_timestamp = v
				i = ii
			}
			3 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			4 {
				res.has_message_without_bb_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message_without_bb_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfriendmessagessendmessageresponse() CFriendMessagesSendMessageResponse {
	return CFriendMessagesSendMessageResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfriendmessagessendmessageresponse(o CFriendMessagesSendMessageResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfriendmessagessendmessageresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CFriendMessagesSendMessageResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfriendmessagessendmessageresponse_unpack(v)?
	return i, unpacked
}

pub struct CFriendMessagesAckMessageNotification {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	steamid_partner     u64
	has_steamid_partner bool
	timestamp           u32
	has_timestamp       bool
}

pub fn (o &CFriendMessagesAckMessageNotification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_partner {
		res << vproto.pack_64bit_field(o.steamid_partner, 1)
	}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 2)
	}
	return res
}

pub fn cfriendmessagesackmessagenotification_unpack(buf []byte) ?CFriendMessagesAckMessageNotification {
	mut res := CFriendMessagesAckMessageNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_partner = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_partner = v
				i = ii
			}
			2 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfriendmessagesackmessagenotification() CFriendMessagesAckMessageNotification {
	return CFriendMessagesAckMessageNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfriendmessagesackmessagenotification(o CFriendMessagesAckMessageNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfriendmessagesackmessagenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CFriendMessagesAckMessageNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfriendmessagesackmessagenotification_unpack(v)?
	return i, unpacked
}

pub struct CFriendMessagesIsInFriendsUIbetaRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CFriendMessagesIsInFriendsUIbetaRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cfriendmessagesisinfriendsuibetarequest_unpack(buf []byte) ?CFriendMessagesIsInFriendsUIbetaRequest {
	mut res := CFriendMessagesIsInFriendsUIbetaRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfriendmessagesisinfriendsuibetarequest() CFriendMessagesIsInFriendsUIbetaRequest {
	return CFriendMessagesIsInFriendsUIbetaRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfriendmessagesisinfriendsuibetarequest(o CFriendMessagesIsInFriendsUIbetaRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfriendmessagesisinfriendsuibetarequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CFriendMessagesIsInFriendsUIbetaRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfriendmessagesisinfriendsuibetarequest_unpack(v)?
	return i, unpacked
}

pub struct CFriendMessagesIsInFriendsUIbetaResponse {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	online_in_friendsui     bool
	has_online_in_friendsui bool
	has_used_friendsui      bool
	has_has_used_friendsui  bool
}

pub fn (o &CFriendMessagesIsInFriendsUIbetaResponse) pack() []byte {
	mut res := []byte{}
	if o.has_online_in_friendsui {
		res << vproto.pack_bool_field(o.online_in_friendsui, 1)
	}
	if o.has_has_used_friendsui {
		res << vproto.pack_bool_field(o.has_used_friendsui, 2)
	}
	return res
}

pub fn cfriendmessagesisinfriendsuibetaresponse_unpack(buf []byte) ?CFriendMessagesIsInFriendsUIbetaResponse {
	mut res := CFriendMessagesIsInFriendsUIbetaResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_online_in_friendsui = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.online_in_friendsui = v
				i = ii
			}
			2 {
				res.has_has_used_friendsui = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.has_used_friendsui = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfriendmessagesisinfriendsuibetaresponse() CFriendMessagesIsInFriendsUIbetaResponse {
	return CFriendMessagesIsInFriendsUIbetaResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfriendmessagesisinfriendsuibetaresponse(o CFriendMessagesIsInFriendsUIbetaResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfriendmessagesisinfriendsuibetaresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CFriendMessagesIsInFriendsUIbetaResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfriendmessagesisinfriendsuibetaresponse_unpack(v)?
	return i, unpacked
}

pub struct CFriendMessagesIncomingMessageNotification {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	steamid_friend               u64
	has_steamid_friend           bool
	chat_entry_type              int
	has_chat_entry_type          bool
	from_limited_account         bool
	has_from_limited_account     bool
	message                      string
	has_message                  bool
	rtime32_server_timestamp     u32
	has_rtime32_server_timestamp bool
	ordinal                      u32
	has_ordinal                  bool
	local_echo                   bool
	has_local_echo               bool
	message_no_bbcode            string
	has_message_no_bbcode        bool
	low_priority                 bool
	has_low_priority             bool
}

pub fn (o &CFriendMessagesIncomingMessageNotification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_friend {
		res << vproto.pack_64bit_field(o.steamid_friend, 1)
	}
	if o.has_chat_entry_type {
		res << vproto.pack_int32_field(o.chat_entry_type, 2)
	}
	if o.has_from_limited_account {
		res << vproto.pack_bool_field(o.from_limited_account, 3)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 4)
	}
	if o.has_rtime32_server_timestamp {
		res << vproto.pack_32bit_field(o.rtime32_server_timestamp, 5)
	}
	if o.has_ordinal {
		res << vproto.pack_uint32_field(o.ordinal, 6)
	}
	if o.has_local_echo {
		res << vproto.pack_bool_field(o.local_echo, 7)
	}
	if o.has_message_no_bbcode {
		res << vproto.pack_string_field(o.message_no_bbcode, 8)
	}
	if o.has_low_priority {
		res << vproto.pack_bool_field(o.low_priority, 9)
	}
	return res
}

pub fn cfriendmessagesincomingmessagenotification_unpack(buf []byte) ?CFriendMessagesIncomingMessageNotification {
	mut res := CFriendMessagesIncomingMessageNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_friend = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_friend = v
				i = ii
			}
			2 {
				res.has_chat_entry_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_entry_type = v
				i = ii
			}
			3 {
				res.has_from_limited_account = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.from_limited_account = v
				i = ii
			}
			4 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			5 {
				res.has_rtime32_server_timestamp = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_server_timestamp = v
				i = ii
			}
			6 {
				res.has_ordinal = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ordinal = v
				i = ii
			}
			7 {
				res.has_local_echo = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.local_echo = v
				i = ii
			}
			8 {
				res.has_message_no_bbcode = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message_no_bbcode = v
				i = ii
			}
			9 {
				res.has_low_priority = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.low_priority = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cfriendmessagesincomingmessagenotification() CFriendMessagesIncomingMessageNotification {
	return CFriendMessagesIncomingMessageNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cfriendmessagesincomingmessagenotification(o CFriendMessagesIncomingMessageNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cfriendmessagesincomingmessagenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CFriendMessagesIncomingMessageNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cfriendmessagesincomingmessagenotification_unpack(v)?
	return i, unpacked
}
