// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EBroadcastWatchLocation {
	k_ebroadcastwatchlocation_invalid = 0
	k_ebroadcastwatchlocation_steamtv_tab = 1
	k_ebroadcastwatchlocation_steamtv_watchparty = 2
	k_ebroadcastwatchlocation_chat_tab = 3
	k_ebroadcastwatchlocation_chat_watchparty = 4
	k_ebroadcastwatchlocation_communitypage = 5
	k_ebroadcastwatchlocation_storeapppage = 6
	k_ebroadcastwatchlocation_ingame = 7
	k_ebroadcastwatchlocation_bigpicture = 8
	k_ebroadcastwatchlocation_salespage = 9
	k_ebroadcastwatchlocation_curatorpage = 10
	k_ebroadcastwatchlocation_developerpage = 11
	k_ebroadcastwatchlocation_chat_friends = 12
	k_ebroadcastwatchlocation_steamtv_web = 13
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_ebroadcastwatchlocation(e EBroadcastWatchLocation, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_ebroadcastwatchlocation_packed(e []EBroadcastWatchLocation, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_ebroadcastwatchlocation(buf []byte, tag_wiretype vproto.WireType) ?(int, EBroadcastWatchLocation) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EBroadcastWatchLocation(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_ebroadcastwatchlocation_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EBroadcastWatchLocation) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EBroadcastChatPermission {
	k_ebroadcastchatpermissionpublic = 0
	k_ebroadcastchatpermissionownsapp = 1
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_ebroadcastchatpermission(e EBroadcastChatPermission, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_ebroadcastchatpermission_packed(e []EBroadcastChatPermission, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_ebroadcastchatpermission(buf []byte, tag_wiretype vproto.WireType) ?(int, EBroadcastChatPermission) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EBroadcastChatPermission(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_ebroadcastchatpermission_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EBroadcastChatPermission) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CBroadcast_BeginBroadcastSession_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	permission             int
	has_permission         bool
	gameid                 u64
	has_gameid             bool
	client_instance_id     u64
	has_client_instance_id bool
	title                  string
	has_title              bool
	cellid                 u32
	has_cellid             bool
	rtmp_token             u64
	has_rtmp_token         bool
	thumbnail_upload       bool
	has_thumbnail_upload   bool
	client_beta            string
	has_client_beta        bool
	sysid                  u32
	has_sysid              bool
	allow_webrtc           bool
	has_allow_webrtc       bool
}

pub fn (o &CBroadcast_BeginBroadcastSession_Request) pack() []byte {
	mut res := []byte{}
	if o.has_permission {
		res << vproto.pack_int32_field(o.permission, 1)
	}
	if o.has_gameid {
		res << vproto.pack_uint64_field(o.gameid, 2)
	}
	if o.has_client_instance_id {
		res << vproto.pack_uint64_field(o.client_instance_id, 3)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 4)
	}
	if o.has_cellid {
		res << vproto.pack_uint32_field(o.cellid, 5)
	}
	if o.has_rtmp_token {
		res << vproto.pack_uint64_field(o.rtmp_token, 6)
	}
	if o.has_thumbnail_upload {
		res << vproto.pack_bool_field(o.thumbnail_upload, 7)
	}
	if o.has_client_beta {
		res << vproto.pack_string_field(o.client_beta, 8)
	}
	if o.has_sysid {
		res << vproto.pack_uint32_field(o.sysid, 9)
	}
	if o.has_allow_webrtc {
		res << vproto.pack_bool_field(o.allow_webrtc, 10)
	}
	return res
}

pub fn cbroadcast_beginbroadcastsession_request_unpack(buf []byte) ?CBroadcast_BeginBroadcastSession_Request {
	mut res := CBroadcast_BeginBroadcastSession_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_permission = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.permission = v
				i = ii
			}
			2 {
				res.has_gameid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			3 {
				res.has_client_instance_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.client_instance_id = v
				i = ii
			}
			4 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			5 {
				res.has_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cellid = v
				i = ii
			}
			6 {
				res.has_rtmp_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.rtmp_token = v
				i = ii
			}
			7 {
				res.has_thumbnail_upload = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_upload = v
				i = ii
			}
			8 {
				res.has_client_beta = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.client_beta = v
				i = ii
			}
			9 {
				res.has_sysid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sysid = v
				i = ii
			}
			10 {
				res.has_allow_webrtc = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.allow_webrtc = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_beginbroadcastsession_request() CBroadcast_BeginBroadcastSession_Request {
	return CBroadcast_BeginBroadcastSession_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_beginbroadcastsession_request(o CBroadcast_BeginBroadcastSession_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_beginbroadcastsession_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_BeginBroadcastSession_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_beginbroadcastsession_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_BeginBroadcastSession_Response {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	broadcast_id                   u64
	has_broadcast_id               bool
	thumbnail_upload_address       string
	has_thumbnail_upload_address   bool
	thumbnail_upload_token         string
	has_thumbnail_upload_token     bool
	thumbnail_interval_seconds     u32
	has_thumbnail_interval_seconds bool
	heartbeat_interval_seconds     u32
	has_heartbeat_interval_seconds bool
}

pub fn (o &CBroadcast_BeginBroadcastSession_Response) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	if o.has_thumbnail_upload_address {
		res << vproto.pack_string_field(o.thumbnail_upload_address, 2)
	}
	if o.has_thumbnail_upload_token {
		res << vproto.pack_string_field(o.thumbnail_upload_token, 3)
	}
	if o.has_thumbnail_interval_seconds {
		res << vproto.pack_uint32_field(o.thumbnail_interval_seconds, 4)
	}
	if o.has_heartbeat_interval_seconds {
		res << vproto.pack_uint32_field(o.heartbeat_interval_seconds, 5)
	}
	return res
}

pub fn cbroadcast_beginbroadcastsession_response_unpack(buf []byte) ?CBroadcast_BeginBroadcastSession_Response {
	mut res := CBroadcast_BeginBroadcastSession_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			2 {
				res.has_thumbnail_upload_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_upload_address = v
				i = ii
			}
			3 {
				res.has_thumbnail_upload_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_upload_token = v
				i = ii
			}
			4 {
				res.has_thumbnail_interval_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_interval_seconds = v
				i = ii
			}
			5 {
				res.has_heartbeat_interval_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.heartbeat_interval_seconds = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_beginbroadcastsession_response() CBroadcast_BeginBroadcastSession_Response {
	return CBroadcast_BeginBroadcastSession_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_beginbroadcastsession_response(o CBroadcast_BeginBroadcastSession_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_beginbroadcastsession_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_BeginBroadcastSession_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_beginbroadcastsession_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_EndBroadcastSession_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	broadcast_id     u64
	has_broadcast_id bool
}

pub fn (o &CBroadcast_EndBroadcastSession_Request) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	return res
}

pub fn cbroadcast_endbroadcastsession_request_unpack(buf []byte) ?CBroadcast_EndBroadcastSession_Request {
	mut res := CBroadcast_EndBroadcastSession_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_endbroadcastsession_request() CBroadcast_EndBroadcastSession_Request {
	return CBroadcast_EndBroadcastSession_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_endbroadcastsession_request(o CBroadcast_EndBroadcastSession_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_endbroadcastsession_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_EndBroadcastSession_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_endbroadcastsession_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_EndBroadcastSession_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcast_EndBroadcastSession_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcast_endbroadcastsession_response_unpack(buf []byte) ?CBroadcast_EndBroadcastSession_Response {
	res := CBroadcast_EndBroadcastSession_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_endbroadcastsession_response() CBroadcast_EndBroadcastSession_Response {
	return CBroadcast_EndBroadcastSession_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_endbroadcastsession_response(o CBroadcast_EndBroadcastSession_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_endbroadcastsession_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_EndBroadcastSession_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_endbroadcastsession_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_StartBroadcastUpload_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	broadcast_id          u64
	has_broadcast_id      bool
	cellid                u32
	has_cellid            bool
	as_rtmp               bool
	has_as_rtmp           bool
	delay_seconds         u32
	has_delay_seconds     bool
	rtmp_token            u64
	has_rtmp_token        bool
	upload_ip_address     u32
	has_upload_ip_address bool
	is_replay             bool
	has_is_replay         bool
	sysid                 u32
	has_sysid             bool
}

pub fn (o &CBroadcast_StartBroadcastUpload_Request) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	if o.has_cellid {
		res << vproto.pack_uint32_field(o.cellid, 2)
	}
	if o.has_as_rtmp {
		res << vproto.pack_bool_field(o.as_rtmp, 3)
	}
	if o.has_delay_seconds {
		res << vproto.pack_uint32_field(o.delay_seconds, 4)
	}
	if o.has_rtmp_token {
		res << vproto.pack_uint64_field(o.rtmp_token, 5)
	}
	if o.has_upload_ip_address {
		res << vproto.pack_uint32_field(o.upload_ip_address, 6)
	}
	if o.has_is_replay {
		res << vproto.pack_bool_field(o.is_replay, 7)
	}
	if o.has_sysid {
		res << vproto.pack_uint32_field(o.sysid, 8)
	}
	return res
}

pub fn cbroadcast_startbroadcastupload_request_unpack(buf []byte) ?CBroadcast_StartBroadcastUpload_Request {
	mut res := CBroadcast_StartBroadcastUpload_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			2 {
				res.has_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cellid = v
				i = ii
			}
			3 {
				res.has_as_rtmp = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.as_rtmp = v
				i = ii
			}
			4 {
				res.has_delay_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.delay_seconds = v
				i = ii
			}
			5 {
				res.has_rtmp_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.rtmp_token = v
				i = ii
			}
			6 {
				res.has_upload_ip_address = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_ip_address = v
				i = ii
			}
			7 {
				res.has_is_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_replay = v
				i = ii
			}
			8 {
				res.has_sysid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sysid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_startbroadcastupload_request() CBroadcast_StartBroadcastUpload_Request {
	return CBroadcast_StartBroadcastUpload_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_startbroadcastupload_request(o CBroadcast_StartBroadcastUpload_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_startbroadcastupload_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_StartBroadcastUpload_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_startbroadcastupload_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_StartBroadcastUpload_Response {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	upload_token            string
	has_upload_token        bool
	upload_address          string
	has_upload_address      bool
	broadcast_upload_id     u64
	has_broadcast_upload_id bool
	enable_replay           bool
	has_enable_replay       bool
	http_address            string
	has_http_address        bool
}

pub fn (o &CBroadcast_StartBroadcastUpload_Response) pack() []byte {
	mut res := []byte{}
	if o.has_upload_token {
		res << vproto.pack_string_field(o.upload_token, 1)
	}
	if o.has_upload_address {
		res << vproto.pack_string_field(o.upload_address, 2)
	}
	if o.has_broadcast_upload_id {
		res << vproto.pack_64bit_field(o.broadcast_upload_id, 3)
	}
	if o.has_enable_replay {
		res << vproto.pack_bool_field(o.enable_replay, 6)
	}
	if o.has_http_address {
		res << vproto.pack_string_field(o.http_address, 7)
	}
	return res
}

pub fn cbroadcast_startbroadcastupload_response_unpack(buf []byte) ?CBroadcast_StartBroadcastUpload_Response {
	mut res := CBroadcast_StartBroadcastUpload_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_upload_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_token = v
				i = ii
			}
			2 {
				res.has_upload_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_address = v
				i = ii
			}
			3 {
				res.has_broadcast_upload_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_upload_id = v
				i = ii
			}
			6 {
				res.has_enable_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_replay = v
				i = ii
			}
			7 {
				res.has_http_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.http_address = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_startbroadcastupload_response() CBroadcast_StartBroadcastUpload_Response {
	return CBroadcast_StartBroadcastUpload_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_startbroadcastupload_response(o CBroadcast_StartBroadcastUpload_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_startbroadcastupload_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_StartBroadcastUpload_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_startbroadcastupload_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_NotifyBroadcastUploadStop_Notification {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	broadcast_upload_id     u64
	has_broadcast_upload_id bool
	upload_result           u32
	has_upload_result       bool
}

pub fn (o &CBroadcast_NotifyBroadcastUploadStop_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_upload_id {
		res << vproto.pack_64bit_field(o.broadcast_upload_id, 1)
	}
	if o.has_upload_result {
		res << vproto.pack_uint32_field(o.upload_result, 2)
	}
	return res
}

pub fn cbroadcast_notifybroadcastuploadstop_notification_unpack(buf []byte) ?CBroadcast_NotifyBroadcastUploadStop_Notification {
	mut res := CBroadcast_NotifyBroadcastUploadStop_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_upload_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_upload_id = v
				i = ii
			}
			2 {
				res.has_upload_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_result = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_notifybroadcastuploadstop_notification() CBroadcast_NotifyBroadcastUploadStop_Notification {
	return CBroadcast_NotifyBroadcastUploadStop_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_notifybroadcastuploadstop_notification(o CBroadcast_NotifyBroadcastUploadStop_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_notifybroadcastuploadstop_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_NotifyBroadcastUploadStop_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_notifybroadcastuploadstop_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WatchBroadcast_Request {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	steamid                   u64
	has_steamid               bool
	existing_broadcast_id     u64
	has_existing_broadcast_id bool
	viewer_token              u64
	has_viewer_token          bool
	client_ip                 u32
	has_client_ip             bool
	client_cell               u32
	has_client_cell           bool
	watch_location            EBroadcastWatchLocation
	has_watch_location        bool
	is_webrtc                 bool
	has_is_webrtc             bool
}

pub fn (o &CBroadcast_WatchBroadcast_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_existing_broadcast_id {
		res << vproto.pack_64bit_field(o.existing_broadcast_id, 2)
	}
	if o.has_viewer_token {
		res << vproto.pack_64bit_field(o.viewer_token, 3)
	}
	if o.has_client_ip {
		res << vproto.pack_uint32_field(o.client_ip, 4)
	}
	if o.has_client_cell {
		res << vproto.pack_uint32_field(o.client_cell, 5)
	}
	if o.has_watch_location {
		res << zzz_vproto_internal_pack_ebroadcastwatchlocation(o.watch_location, 6)
	}
	if o.has_is_webrtc {
		res << vproto.pack_bool_field(o.is_webrtc, 7)
	}
	return res
}

pub fn cbroadcast_watchbroadcast_request_unpack(buf []byte) ?CBroadcast_WatchBroadcast_Request {
	mut res := CBroadcast_WatchBroadcast_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_existing_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.existing_broadcast_id = v
				i = ii
			}
			3 {
				res.has_viewer_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.viewer_token = v
				i = ii
			}
			4 {
				res.has_client_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_ip = v
				i = ii
			}
			5 {
				res.has_client_cell = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_cell = v
				i = ii
			}
			6 {
				res.has_watch_location = true
				ii, v := zzz_vproto_internal_unpack_ebroadcastwatchlocation(cur_buf, tag_wiretype.wire_type)?
				res.watch_location = v
				i = ii
			}
			7 {
				res.has_is_webrtc = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_webrtc = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_watchbroadcast_request() CBroadcast_WatchBroadcast_Request {
	return CBroadcast_WatchBroadcast_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_watchbroadcast_request(o CBroadcast_WatchBroadcast_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_watchbroadcast_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WatchBroadcast_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_watchbroadcast_request_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CBroadcast_WatchBroadcast_Response_EWatchResponse {
	k_ewatchresponseready = 1
	k_ewatchresponsenotavailable = 2
	k_ewatchresponsewaitingforapproval = 3
	k_ewatchresponsewaitingforstart = 4
	k_ewatchresponseinvalidsession = 5
	k_ewatchresponsetoomanybroadcasts = 6
	k_ewatchresponsewaitingforreconnect = 7
	k_ewatchresponsesystemnotsupported = 8
	k_ewatchresponseuserrestricted = 9
	k_ewatchresponseclientoutofdate = 10
	k_ewatchresponsepooruploadquality = 11
	k_ewatchresponsemissingsubscription = 12
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cbroadcast_watchbroadcast_response_ewatchresponse(e CBroadcast_WatchBroadcast_Response_EWatchResponse, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cbroadcast_watchbroadcast_response_ewatchresponse_packed(e []CBroadcast_WatchBroadcast_Response_EWatchResponse, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cbroadcast_watchbroadcast_response_ewatchresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WatchBroadcast_Response_EWatchResponse) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CBroadcast_WatchBroadcast_Response_EWatchResponse(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cbroadcast_watchbroadcast_response_ewatchresponse_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CBroadcast_WatchBroadcast_Response_EWatchResponse) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CBroadcast_WatchBroadcast_Response {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	response                CBroadcast_WatchBroadcast_Response_EWatchResponse
	has_response            bool
	mpd_url                 string
	has_mpd_url             bool
	broadcast_id            u64
	has_broadcast_id        bool
	gameid                  u64
	has_gameid              bool
	title                   string
	has_title               bool
	num_viewers             u32
	has_num_viewers         bool
	permission              int
	has_permission          bool
	is_rtmp                 bool
	has_is_rtmp             bool
	seconds_delay           int
	has_seconds_delay       bool
	viewer_token            u64
	has_viewer_token        bool
	hls_m3u8_master_url     string
	has_hls_m3u8_master_url bool
	heartbeat_interval      int
	has_heartbeat_interval  bool
	thumbnail_url           string
	has_thumbnail_url       bool
	is_webrtc               bool
	has_is_webrtc           bool
	webrtc_session_id       u64
	has_webrtc_session_id   bool
	webrtc_offer_sdp        string
	has_webrtc_offer_sdp    bool
	webrtc_turn_server      string
	has_webrtc_turn_server  bool
	is_replay               bool
	has_is_replay           bool
	duration                int
	has_duration            bool
}

pub fn (o &CBroadcast_WatchBroadcast_Response) pack() []byte {
	mut res := []byte{}
	if o.has_response {
		res <<
			zzz_vproto_internal_pack_cbroadcast_watchbroadcast_response_ewatchresponse(o.response, 1)
	}
	if o.has_mpd_url {
		res << vproto.pack_string_field(o.mpd_url, 2)
	}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 3)
	}
	if o.has_gameid {
		res << vproto.pack_uint64_field(o.gameid, 4)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 5)
	}
	if o.has_num_viewers {
		res << vproto.pack_uint32_field(o.num_viewers, 6)
	}
	if o.has_permission {
		res << vproto.pack_int32_field(o.permission, 7)
	}
	if o.has_is_rtmp {
		res << vproto.pack_bool_field(o.is_rtmp, 8)
	}
	if o.has_seconds_delay {
		res << vproto.pack_int32_field(o.seconds_delay, 9)
	}
	if o.has_viewer_token {
		res << vproto.pack_64bit_field(o.viewer_token, 10)
	}
	if o.has_hls_m3u8_master_url {
		res << vproto.pack_string_field(o.hls_m3u8_master_url, 11)
	}
	if o.has_heartbeat_interval {
		res << vproto.pack_int32_field(o.heartbeat_interval, 12)
	}
	if o.has_thumbnail_url {
		res << vproto.pack_string_field(o.thumbnail_url, 13)
	}
	if o.has_is_webrtc {
		res << vproto.pack_bool_field(o.is_webrtc, 14)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 15)
	}
	if o.has_webrtc_offer_sdp {
		res << vproto.pack_string_field(o.webrtc_offer_sdp, 16)
	}
	if o.has_webrtc_turn_server {
		res << vproto.pack_string_field(o.webrtc_turn_server, 17)
	}
	if o.has_is_replay {
		res << vproto.pack_bool_field(o.is_replay, 18)
	}
	if o.has_duration {
		res << vproto.pack_int32_field(o.duration, 19)
	}
	return res
}

pub fn cbroadcast_watchbroadcast_response_unpack(buf []byte) ?CBroadcast_WatchBroadcast_Response {
	mut res := CBroadcast_WatchBroadcast_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_response = true
				ii, v := zzz_vproto_internal_unpack_cbroadcast_watchbroadcast_response_ewatchresponse(cur_buf,
					tag_wiretype.wire_type)?
				res.response = v
				i = ii
			}
			2 {
				res.has_mpd_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.mpd_url = v
				i = ii
			}
			3 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			4 {
				res.has_gameid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			5 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			6 {
				res.has_num_viewers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_viewers = v
				i = ii
			}
			7 {
				res.has_permission = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.permission = v
				i = ii
			}
			8 {
				res.has_is_rtmp = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_rtmp = v
				i = ii
			}
			9 {
				res.has_seconds_delay = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_delay = v
				i = ii
			}
			10 {
				res.has_viewer_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.viewer_token = v
				i = ii
			}
			11 {
				res.has_hls_m3u8_master_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.hls_m3u8_master_url = v
				i = ii
			}
			12 {
				res.has_heartbeat_interval = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.heartbeat_interval = v
				i = ii
			}
			13 {
				res.has_thumbnail_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_url = v
				i = ii
			}
			14 {
				res.has_is_webrtc = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_webrtc = v
				i = ii
			}
			15 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			16 {
				res.has_webrtc_offer_sdp = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_offer_sdp = v
				i = ii
			}
			17 {
				res.has_webrtc_turn_server = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_turn_server = v
				i = ii
			}
			18 {
				res.has_is_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_replay = v
				i = ii
			}
			19 {
				res.has_duration = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.duration = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_watchbroadcast_response() CBroadcast_WatchBroadcast_Response {
	return CBroadcast_WatchBroadcast_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_watchbroadcast_response(o CBroadcast_WatchBroadcast_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_watchbroadcast_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WatchBroadcast_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_watchbroadcast_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_HeartbeatBroadcast_Notification {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	steamid            u64
	has_steamid        bool
	broadcast_id       u64
	has_broadcast_id   bool
	viewer_token       u64
	has_viewer_token   bool
	representation     u32
	has_representation bool
}

pub fn (o &CBroadcast_HeartbeatBroadcast_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 2)
	}
	if o.has_viewer_token {
		res << vproto.pack_64bit_field(o.viewer_token, 3)
	}
	if o.has_representation {
		res << vproto.pack_uint32_field(o.representation, 4)
	}
	return res
}

pub fn cbroadcast_heartbeatbroadcast_notification_unpack(buf []byte) ?CBroadcast_HeartbeatBroadcast_Notification {
	mut res := CBroadcast_HeartbeatBroadcast_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			3 {
				res.has_viewer_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.viewer_token = v
				i = ii
			}
			4 {
				res.has_representation = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.representation = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_heartbeatbroadcast_notification() CBroadcast_HeartbeatBroadcast_Notification {
	return CBroadcast_HeartbeatBroadcast_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_heartbeatbroadcast_notification(o CBroadcast_HeartbeatBroadcast_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_heartbeatbroadcast_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_HeartbeatBroadcast_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_heartbeatbroadcast_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_StopWatchingBroadcast_Notification {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	broadcast_id     u64
	has_broadcast_id bool
	viewer_token     u64
	has_viewer_token bool
}

pub fn (o &CBroadcast_StopWatchingBroadcast_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 2)
	}
	if o.has_viewer_token {
		res << vproto.pack_64bit_field(o.viewer_token, 3)
	}
	return res
}

pub fn cbroadcast_stopwatchingbroadcast_notification_unpack(buf []byte) ?CBroadcast_StopWatchingBroadcast_Notification {
	mut res := CBroadcast_StopWatchingBroadcast_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			3 {
				res.has_viewer_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.viewer_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_stopwatchingbroadcast_notification() CBroadcast_StopWatchingBroadcast_Notification {
	return CBroadcast_StopWatchingBroadcast_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_stopwatchingbroadcast_notification(o CBroadcast_StopWatchingBroadcast_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_stopwatchingbroadcast_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_StopWatchingBroadcast_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_stopwatchingbroadcast_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastStatus_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	broadcast_id     u64
	has_broadcast_id bool
}

pub fn (o &CBroadcast_GetBroadcastStatus_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 2)
	}
	return res
}

pub fn cbroadcast_getbroadcaststatus_request_unpack(buf []byte) ?CBroadcast_GetBroadcastStatus_Request {
	mut res := CBroadcast_GetBroadcastStatus_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcaststatus_request() CBroadcast_GetBroadcastStatus_Request {
	return CBroadcast_GetBroadcastStatus_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcaststatus_request(o CBroadcast_GetBroadcastStatus_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcaststatus_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastStatus_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcaststatus_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastStatus_Response {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	gameid                   u64
	has_gameid               bool
	title                    string
	has_title                bool
	num_viewers              u32
	has_num_viewers          bool
	permission               int
	has_permission           bool
	is_rtmp                  bool
	has_is_rtmp              bool
	seconds_delay            int
	has_seconds_delay        bool
	is_publisher             bool
	has_is_publisher         bool
	thumbnail_url            string
	has_thumbnail_url        bool
	update_interval          int
	has_update_interval      bool
	is_uploading             bool
	has_is_uploading         bool
	duration                 u32
	has_duration             bool
	is_replay                bool
	has_is_replay            bool
	is_capturing_vod         bool
	has_is_capturing_vod     bool
	is_store_whitelisted     bool
	has_is_store_whitelisted bool
}

pub fn (o &CBroadcast_GetBroadcastStatus_Response) pack() []byte {
	mut res := []byte{}
	if o.has_gameid {
		res << vproto.pack_uint64_field(o.gameid, 1)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 2)
	}
	if o.has_num_viewers {
		res << vproto.pack_uint32_field(o.num_viewers, 3)
	}
	if o.has_permission {
		res << vproto.pack_int32_field(o.permission, 4)
	}
	if o.has_is_rtmp {
		res << vproto.pack_bool_field(o.is_rtmp, 5)
	}
	if o.has_seconds_delay {
		res << vproto.pack_int32_field(o.seconds_delay, 6)
	}
	if o.has_is_publisher {
		res << vproto.pack_bool_field(o.is_publisher, 7)
	}
	if o.has_thumbnail_url {
		res << vproto.pack_string_field(o.thumbnail_url, 8)
	}
	if o.has_update_interval {
		res << vproto.pack_int32_field(o.update_interval, 9)
	}
	if o.has_is_uploading {
		res << vproto.pack_bool_field(o.is_uploading, 10)
	}
	if o.has_duration {
		res << vproto.pack_uint32_field(o.duration, 11)
	}
	if o.has_is_replay {
		res << vproto.pack_bool_field(o.is_replay, 12)
	}
	if o.has_is_capturing_vod {
		res << vproto.pack_bool_field(o.is_capturing_vod, 13)
	}
	if o.has_is_store_whitelisted {
		res << vproto.pack_bool_field(o.is_store_whitelisted, 14)
	}
	return res
}

pub fn cbroadcast_getbroadcaststatus_response_unpack(buf []byte) ?CBroadcast_GetBroadcastStatus_Response {
	mut res := CBroadcast_GetBroadcastStatus_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_gameid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			2 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			3 {
				res.has_num_viewers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_viewers = v
				i = ii
			}
			4 {
				res.has_permission = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.permission = v
				i = ii
			}
			5 {
				res.has_is_rtmp = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_rtmp = v
				i = ii
			}
			6 {
				res.has_seconds_delay = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_delay = v
				i = ii
			}
			7 {
				res.has_is_publisher = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_publisher = v
				i = ii
			}
			8 {
				res.has_thumbnail_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_url = v
				i = ii
			}
			9 {
				res.has_update_interval = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.update_interval = v
				i = ii
			}
			10 {
				res.has_is_uploading = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_uploading = v
				i = ii
			}
			11 {
				res.has_duration = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.duration = v
				i = ii
			}
			12 {
				res.has_is_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_replay = v
				i = ii
			}
			13 {
				res.has_is_capturing_vod = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_capturing_vod = v
				i = ii
			}
			14 {
				res.has_is_store_whitelisted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_store_whitelisted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcaststatus_response() CBroadcast_GetBroadcastStatus_Response {
	return CBroadcast_GetBroadcastStatus_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcaststatus_response(o CBroadcast_GetBroadcastStatus_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcaststatus_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastStatus_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcaststatus_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastThumbnail_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	broadcast_id     u64
	has_broadcast_id bool
}

pub fn (o &CBroadcast_GetBroadcastThumbnail_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 2)
	}
	return res
}

pub fn cbroadcast_getbroadcastthumbnail_request_unpack(buf []byte) ?CBroadcast_GetBroadcastThumbnail_Request {
	mut res := CBroadcast_GetBroadcastThumbnail_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastthumbnail_request() CBroadcast_GetBroadcastThumbnail_Request {
	return CBroadcast_GetBroadcastThumbnail_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastthumbnail_request(o CBroadcast_GetBroadcastThumbnail_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastthumbnail_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastThumbnail_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastthumbnail_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastThumbnail_Response {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	thumbnail_url       string
	has_thumbnail_url   bool
	update_interval     int
	has_update_interval bool
	num_viewers         int
	has_num_viewers     bool
	duration            int
	has_duration        bool
}

pub fn (o &CBroadcast_GetBroadcastThumbnail_Response) pack() []byte {
	mut res := []byte{}
	if o.has_thumbnail_url {
		res << vproto.pack_string_field(o.thumbnail_url, 1)
	}
	if o.has_update_interval {
		res << vproto.pack_int32_field(o.update_interval, 2)
	}
	if o.has_num_viewers {
		res << vproto.pack_int32_field(o.num_viewers, 3)
	}
	if o.has_duration {
		res << vproto.pack_int32_field(o.duration, 4)
	}
	return res
}

pub fn cbroadcast_getbroadcastthumbnail_response_unpack(buf []byte) ?CBroadcast_GetBroadcastThumbnail_Response {
	mut res := CBroadcast_GetBroadcastThumbnail_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_thumbnail_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_url = v
				i = ii
			}
			2 {
				res.has_update_interval = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.update_interval = v
				i = ii
			}
			3 {
				res.has_num_viewers = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_viewers = v
				i = ii
			}
			4 {
				res.has_duration = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.duration = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastthumbnail_response() CBroadcast_GetBroadcastThumbnail_Response {
	return CBroadcast_GetBroadcastThumbnail_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastthumbnail_response(o CBroadcast_GetBroadcastThumbnail_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastthumbnail_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastThumbnail_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastthumbnail_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_InviteToBroadcast_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steamid               u64
	has_steamid           bool
	approval_response     bool
	has_approval_response bool
}

pub fn (o &CBroadcast_InviteToBroadcast_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_approval_response {
		res << vproto.pack_bool_field(o.approval_response, 2)
	}
	return res
}

pub fn cbroadcast_invitetobroadcast_request_unpack(buf []byte) ?CBroadcast_InviteToBroadcast_Request {
	mut res := CBroadcast_InviteToBroadcast_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_approval_response = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.approval_response = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_invitetobroadcast_request() CBroadcast_InviteToBroadcast_Request {
	return CBroadcast_InviteToBroadcast_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_invitetobroadcast_request(o CBroadcast_InviteToBroadcast_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_invitetobroadcast_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_InviteToBroadcast_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_invitetobroadcast_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_InviteToBroadcast_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	success        bool
	has_success    bool
}

pub fn (o &CBroadcast_InviteToBroadcast_Response) pack() []byte {
	mut res := []byte{}
	if o.has_success {
		res << vproto.pack_bool_field(o.success, 1)
	}
	return res
}

pub fn cbroadcast_invitetobroadcast_response_unpack(buf []byte) ?CBroadcast_InviteToBroadcast_Response {
	mut res := CBroadcast_InviteToBroadcast_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_success = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.success = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_invitetobroadcast_response() CBroadcast_InviteToBroadcast_Response {
	return CBroadcast_InviteToBroadcast_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_invitetobroadcast_response(o CBroadcast_InviteToBroadcast_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_invitetobroadcast_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_InviteToBroadcast_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_invitetobroadcast_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_SendBroadcastStateToServer_Request {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	permission           int
	has_permission       bool
	gameid               u64
	has_gameid           bool
	title                string
	has_title            bool
	game_data_config     string
	has_game_data_config bool
}

pub fn (o &CBroadcast_SendBroadcastStateToServer_Request) pack() []byte {
	mut res := []byte{}
	if o.has_permission {
		res << vproto.pack_int32_field(o.permission, 1)
	}
	if o.has_gameid {
		res << vproto.pack_uint64_field(o.gameid, 2)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 3)
	}
	if o.has_game_data_config {
		res << vproto.pack_string_field(o.game_data_config, 4)
	}
	return res
}

pub fn cbroadcast_sendbroadcaststatetoserver_request_unpack(buf []byte) ?CBroadcast_SendBroadcastStateToServer_Request {
	mut res := CBroadcast_SendBroadcastStateToServer_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_permission = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.permission = v
				i = ii
			}
			2 {
				res.has_gameid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			3 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			4 {
				res.has_game_data_config = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_data_config = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_sendbroadcaststatetoserver_request() CBroadcast_SendBroadcastStateToServer_Request {
	return CBroadcast_SendBroadcastStateToServer_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_sendbroadcaststatetoserver_request(o CBroadcast_SendBroadcastStateToServer_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_sendbroadcaststatetoserver_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_SendBroadcastStateToServer_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_sendbroadcaststatetoserver_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_SendBroadcastStateToServer_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcast_SendBroadcastStateToServer_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcast_sendbroadcaststatetoserver_response_unpack(buf []byte) ?CBroadcast_SendBroadcastStateToServer_Response {
	res := CBroadcast_SendBroadcastStateToServer_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_sendbroadcaststatetoserver_response() CBroadcast_SendBroadcastStateToServer_Response {
	return CBroadcast_SendBroadcastStateToServer_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_sendbroadcaststatetoserver_response(o CBroadcast_SendBroadcastStateToServer_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_sendbroadcaststatetoserver_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_SendBroadcastStateToServer_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_sendbroadcaststatetoserver_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	broadcast_id     u64
	has_broadcast_id bool
}

pub fn (o &CBroadcast_NotifyBroadcastSessionHeartbeat_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	return res
}

pub fn cbroadcast_notifybroadcastsessionheartbeat_notification_unpack(buf []byte) ?CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
	mut res := CBroadcast_NotifyBroadcastSessionHeartbeat_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_notifybroadcastsessionheartbeat_notification() CBroadcast_NotifyBroadcastSessionHeartbeat_Notification {
	return CBroadcast_NotifyBroadcastSessionHeartbeat_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_notifybroadcastsessionheartbeat_notification(o CBroadcast_NotifyBroadcastSessionHeartbeat_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_notifybroadcastsessionheartbeat_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_NotifyBroadcastSessionHeartbeat_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_notifybroadcastsessionheartbeat_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastChatInfo_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	broadcast_id     u64
	has_broadcast_id bool
	client_ip        u32
	has_client_ip    bool
	client_cell      u32
	has_client_cell  bool
}

pub fn (o &CBroadcast_GetBroadcastChatInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 2)
	}
	if o.has_client_ip {
		res << vproto.pack_uint32_field(o.client_ip, 3)
	}
	if o.has_client_cell {
		res << vproto.pack_uint32_field(o.client_cell, 4)
	}
	return res
}

pub fn cbroadcast_getbroadcastchatinfo_request_unpack(buf []byte) ?CBroadcast_GetBroadcastChatInfo_Request {
	mut res := CBroadcast_GetBroadcastChatInfo_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			3 {
				res.has_client_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_ip = v
				i = ii
			}
			4 {
				res.has_client_cell = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_cell = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastchatinfo_request() CBroadcast_GetBroadcastChatInfo_Request {
	return CBroadcast_GetBroadcastChatInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastchatinfo_request(o CBroadcast_GetBroadcastChatInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastchatinfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastChatInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastchatinfo_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastChatInfo_Response {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	chat_id               u64
	has_chat_id           bool
	view_url_template     string
	has_view_url_template bool
	flair_group_ids       []u32
}

pub fn (o &CBroadcast_GetBroadcastChatInfo_Response) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 1)
	}
	if o.has_view_url_template {
		res << vproto.pack_string_field(o.view_url_template, 3)
	}
	// [packed=false]
	for _, x in o.flair_group_ids {
		res << vproto.pack_uint32_field(x, 4)
	}
	return res
}

pub fn cbroadcast_getbroadcastchatinfo_response_unpack(buf []byte) ?CBroadcast_GetBroadcastChatInfo_Response {
	mut res := CBroadcast_GetBroadcastChatInfo_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_view_url_template = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.view_url_template = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flair_group_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastchatinfo_response() CBroadcast_GetBroadcastChatInfo_Response {
	return CBroadcast_GetBroadcastChatInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastchatinfo_response(o CBroadcast_GetBroadcastChatInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastchatinfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastChatInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastchatinfo_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_PostChatMessage_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	chat_id          u64
	has_chat_id      bool
	message          string
	has_message      bool
	instance_id      u32
	has_instance_id  bool
	language         u32
	has_language     bool
	country_code     string
	has_country_code bool
}

pub fn (o &CBroadcast_PostChatMessage_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 1)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 2)
	}
	if o.has_instance_id {
		res << vproto.pack_uint32_field(o.instance_id, 3)
	}
	if o.has_language {
		res << vproto.pack_uint32_field(o.language, 4)
	}
	if o.has_country_code {
		res << vproto.pack_string_field(o.country_code, 5)
	}
	return res
}

pub fn cbroadcast_postchatmessage_request_unpack(buf []byte) ?CBroadcast_PostChatMessage_Request {
	mut res := CBroadcast_PostChatMessage_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			3 {
				res.has_instance_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.instance_id = v
				i = ii
			}
			4 {
				res.has_language = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			5 {
				res.has_country_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.country_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_postchatmessage_request() CBroadcast_PostChatMessage_Request {
	return CBroadcast_PostChatMessage_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_postchatmessage_request(o CBroadcast_PostChatMessage_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_postchatmessage_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_PostChatMessage_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_postchatmessage_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_PostChatMessage_Response {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	persona_name              string
	has_persona_name          bool
	in_game                   bool
	has_in_game               bool
	result                    int
	has_result                bool
	cooldown_time_seconds     int
	has_cooldown_time_seconds bool
}

pub fn (o &CBroadcast_PostChatMessage_Response) pack() []byte {
	mut res := []byte{}
	if o.has_persona_name {
		res << vproto.pack_string_field(o.persona_name, 1)
	}
	if o.has_in_game {
		res << vproto.pack_bool_field(o.in_game, 2)
	}
	if o.has_result {
		res << vproto.pack_int32_field(o.result, 3)
	}
	if o.has_cooldown_time_seconds {
		res << vproto.pack_int32_field(o.cooldown_time_seconds, 4)
	}
	return res
}

pub fn cbroadcast_postchatmessage_response_unpack(buf []byte) ?CBroadcast_PostChatMessage_Response {
	mut res := CBroadcast_PostChatMessage_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_persona_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_name = v
				i = ii
			}
			2 {
				res.has_in_game = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.in_game = v
				i = ii
			}
			3 {
				res.has_result = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			4 {
				res.has_cooldown_time_seconds = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.cooldown_time_seconds = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_postchatmessage_response() CBroadcast_PostChatMessage_Response {
	return CBroadcast_PostChatMessage_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_postchatmessage_response(o CBroadcast_PostChatMessage_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_postchatmessage_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_PostChatMessage_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_postchatmessage_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_UpdateChatMessageFlair_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	chat_id        u64
	has_chat_id    bool
	flair          string
	has_flair      bool
}

pub fn (o &CBroadcast_UpdateChatMessageFlair_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 1)
	}
	if o.has_flair {
		res << vproto.pack_string_field(o.flair, 2)
	}
	return res
}

pub fn cbroadcast_updatechatmessageflair_request_unpack(buf []byte) ?CBroadcast_UpdateChatMessageFlair_Request {
	mut res := CBroadcast_UpdateChatMessageFlair_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_flair = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.flair = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_updatechatmessageflair_request() CBroadcast_UpdateChatMessageFlair_Request {
	return CBroadcast_UpdateChatMessageFlair_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_updatechatmessageflair_request(o CBroadcast_UpdateChatMessageFlair_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_updatechatmessageflair_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_UpdateChatMessageFlair_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_updatechatmessageflair_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_UpdateChatMessageFlair_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         int
	has_result     bool
	chat_id        u64
	has_chat_id    bool
	flair          string
	has_flair      bool
}

pub fn (o &CBroadcast_UpdateChatMessageFlair_Response) pack() []byte {
	mut res := []byte{}
	if o.has_result {
		res << vproto.pack_int32_field(o.result, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 2)
	}
	if o.has_flair {
		res << vproto.pack_string_field(o.flair, 3)
	}
	return res
}

pub fn cbroadcast_updatechatmessageflair_response_unpack(buf []byte) ?CBroadcast_UpdateChatMessageFlair_Response {
	mut res := CBroadcast_UpdateChatMessageFlair_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_result = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_flair = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.flair = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_updatechatmessageflair_response() CBroadcast_UpdateChatMessageFlair_Response {
	return CBroadcast_UpdateChatMessageFlair_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_updatechatmessageflair_response(o CBroadcast_UpdateChatMessageFlair_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_updatechatmessageflair_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_UpdateChatMessageFlair_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_updatechatmessageflair_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_MuteBroadcastChatUser_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	chat_id          u64
	has_chat_id      bool
	user_steamid     u64
	has_user_steamid bool
	muted            bool
	has_muted        bool
}

pub fn (o &CBroadcast_MuteBroadcastChatUser_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 1)
	}
	if o.has_user_steamid {
		res << vproto.pack_64bit_field(o.user_steamid, 2)
	}
	if o.has_muted {
		res << vproto.pack_bool_field(o.muted, 3)
	}
	return res
}

pub fn cbroadcast_mutebroadcastchatuser_request_unpack(buf []byte) ?CBroadcast_MuteBroadcastChatUser_Request {
	mut res := CBroadcast_MuteBroadcastChatUser_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_user_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.user_steamid = v
				i = ii
			}
			3 {
				res.has_muted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.muted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_mutebroadcastchatuser_request() CBroadcast_MuteBroadcastChatUser_Request {
	return CBroadcast_MuteBroadcastChatUser_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_mutebroadcastchatuser_request(o CBroadcast_MuteBroadcastChatUser_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_mutebroadcastchatuser_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_MuteBroadcastChatUser_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_mutebroadcastchatuser_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_MuteBroadcastChatUser_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcast_MuteBroadcastChatUser_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcast_mutebroadcastchatuser_response_unpack(buf []byte) ?CBroadcast_MuteBroadcastChatUser_Response {
	res := CBroadcast_MuteBroadcastChatUser_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_mutebroadcastchatuser_response() CBroadcast_MuteBroadcastChatUser_Response {
	return CBroadcast_MuteBroadcastChatUser_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_mutebroadcastchatuser_response(o CBroadcast_MuteBroadcastChatUser_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_mutebroadcastchatuser_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_MuteBroadcastChatUser_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_mutebroadcastchatuser_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_RemoveUserChatText_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	chat_id          u64
	has_chat_id      bool
	user_steamid     u64
	has_user_steamid bool
}

pub fn (o &CBroadcast_RemoveUserChatText_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 1)
	}
	if o.has_user_steamid {
		res << vproto.pack_64bit_field(o.user_steamid, 2)
	}
	return res
}

pub fn cbroadcast_removeuserchattext_request_unpack(buf []byte) ?CBroadcast_RemoveUserChatText_Request {
	mut res := CBroadcast_RemoveUserChatText_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_user_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.user_steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_removeuserchattext_request() CBroadcast_RemoveUserChatText_Request {
	return CBroadcast_RemoveUserChatText_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_removeuserchattext_request(o CBroadcast_RemoveUserChatText_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_removeuserchattext_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_RemoveUserChatText_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_removeuserchattext_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_RemoveUserChatText_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcast_RemoveUserChatText_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcast_removeuserchattext_response_unpack(buf []byte) ?CBroadcast_RemoveUserChatText_Response {
	res := CBroadcast_RemoveUserChatText_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_removeuserchattext_response() CBroadcast_RemoveUserChatText_Response {
	return CBroadcast_RemoveUserChatText_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_removeuserchattext_response(o CBroadcast_RemoveUserChatText_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_removeuserchattext_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_RemoveUserChatText_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_removeuserchattext_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastChatUserNames_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	chat_id        u64
	has_chat_id    bool
	user_steamid   []u64
}

pub fn (o &CBroadcast_GetBroadcastChatUserNames_Request) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 1)
	}
	// [packed=false]
	for _, x in o.user_steamid {
		res << vproto.pack_64bit_field(x, 2)
	}
	return res
}

pub fn cbroadcast_getbroadcastchatusernames_request_unpack(buf []byte) ?CBroadcast_GetBroadcastChatUserNames_Request {
	mut res := CBroadcast_GetBroadcastChatUserNames_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.user_steamid << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastchatusernames_request() CBroadcast_GetBroadcastChatUserNames_Request {
	return CBroadcast_GetBroadcastChatUserNames_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastchatusernames_request(o CBroadcast_GetBroadcastChatUserNames_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastchatusernames_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastChatUserNames_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastchatusernames_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	has_steam_id   bool
	persona        string
	has_persona    bool
}

pub fn (o &CBroadcast_GetBroadcastChatUserNames_Response_PersonaName) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.has_persona {
		res << vproto.pack_string_field(o.persona, 2)
	}
	return res
}

pub fn cbroadcast_getbroadcastchatusernames_response_personaname_unpack(buf []byte) ?CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
	mut res := CBroadcast_GetBroadcastChatUserNames_Response_PersonaName{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			2 {
				res.has_persona = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastchatusernames_response_personaname() CBroadcast_GetBroadcastChatUserNames_Response_PersonaName {
	return CBroadcast_GetBroadcastChatUserNames_Response_PersonaName{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastchatusernames_response_personaname(o CBroadcast_GetBroadcastChatUserNames_Response_PersonaName, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastchatusernames_response_personaname(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastChatUserNames_Response_PersonaName) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastchatusernames_response_personaname_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastChatUserNames_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	persona_names  []CBroadcast_GetBroadcastChatUserNames_Response_PersonaName
}

pub fn (o &CBroadcast_GetBroadcastChatUserNames_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.persona_names {
		res <<
			zzz_vproto_internal_pack_cbroadcast_getbroadcastchatusernames_response_personaname(x, 1)
	}
	return res
}

pub fn cbroadcast_getbroadcastchatusernames_response_unpack(buf []byte) ?CBroadcast_GetBroadcastChatUserNames_Response {
	mut res := CBroadcast_GetBroadcastChatUserNames_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cbroadcast_getbroadcastchatusernames_response_personaname(cur_buf,
					tag_wiretype.wire_type)?
				res.persona_names << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastchatusernames_response() CBroadcast_GetBroadcastChatUserNames_Response {
	return CBroadcast_GetBroadcastChatUserNames_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastchatusernames_response(o CBroadcast_GetBroadcastChatUserNames_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastchatusernames_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastChatUserNames_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastchatusernames_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_StartBuildClip_Request {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	steamid                  u64
	has_steamid              bool
	broadcast_session_id     u64
	has_broadcast_session_id bool
	first_segment            int
	has_first_segment        bool
	num_segments             int
	has_num_segments         bool
	clip_description         string
	has_clip_description     bool
}

pub fn (o &CBroadcast_StartBuildClip_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_broadcast_session_id {
		res << vproto.pack_64bit_field(o.broadcast_session_id, 2)
	}
	if o.has_first_segment {
		res << vproto.pack_int32_field(o.first_segment, 3)
	}
	if o.has_num_segments {
		res << vproto.pack_int32_field(o.num_segments, 4)
	}
	if o.has_clip_description {
		res << vproto.pack_string_field(o.clip_description, 5)
	}
	return res
}

pub fn cbroadcast_startbuildclip_request_unpack(buf []byte) ?CBroadcast_StartBuildClip_Request {
	mut res := CBroadcast_StartBuildClip_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_session_id = v
				i = ii
			}
			3 {
				res.has_first_segment = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.first_segment = v
				i = ii
			}
			4 {
				res.has_num_segments = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_segments = v
				i = ii
			}
			5 {
				res.has_clip_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.clip_description = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_startbuildclip_request() CBroadcast_StartBuildClip_Request {
	return CBroadcast_StartBuildClip_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_startbuildclip_request(o CBroadcast_StartBuildClip_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_startbuildclip_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_StartBuildClip_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_startbuildclip_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_StartBuildClip_Response {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	broadcast_clip_id     u64
	has_broadcast_clip_id bool
}

pub fn (o &CBroadcast_StartBuildClip_Response) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_clip_id {
		res << vproto.pack_64bit_field(o.broadcast_clip_id, 1)
	}
	return res
}

pub fn cbroadcast_startbuildclip_response_unpack(buf []byte) ?CBroadcast_StartBuildClip_Response {
	mut res := CBroadcast_StartBuildClip_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_clip_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_clip_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_startbuildclip_response() CBroadcast_StartBuildClip_Response {
	return CBroadcast_StartBuildClip_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_startbuildclip_response(o CBroadcast_StartBuildClip_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_startbuildclip_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_StartBuildClip_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_startbuildclip_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBuildClipStatus_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	broadcast_clip_id     u64
	has_broadcast_clip_id bool
}

pub fn (o &CBroadcast_GetBuildClipStatus_Request) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_clip_id {
		res << vproto.pack_64bit_field(o.broadcast_clip_id, 1)
	}
	return res
}

pub fn cbroadcast_getbuildclipstatus_request_unpack(buf []byte) ?CBroadcast_GetBuildClipStatus_Request {
	mut res := CBroadcast_GetBuildClipStatus_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_clip_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_clip_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbuildclipstatus_request() CBroadcast_GetBuildClipStatus_Request {
	return CBroadcast_GetBuildClipStatus_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbuildclipstatus_request(o CBroadcast_GetBuildClipStatus_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbuildclipstatus_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBuildClipStatus_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbuildclipstatus_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBuildClipStatus_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcast_GetBuildClipStatus_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcast_getbuildclipstatus_response_unpack(buf []byte) ?CBroadcast_GetBuildClipStatus_Response {
	res := CBroadcast_GetBuildClipStatus_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbuildclipstatus_response() CBroadcast_GetBuildClipStatus_Response {
	return CBroadcast_GetBuildClipStatus_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbuildclipstatus_response(o CBroadcast_GetBuildClipStatus_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbuildclipstatus_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBuildClipStatus_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbuildclipstatus_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_SetClipDetails_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	broadcast_clip_id     u64
	has_broadcast_clip_id bool
	start_time            u32
	has_start_time        bool
	end_time              u32
	has_end_time          bool
	video_description     string
	has_video_description bool
}

pub fn (o &CBroadcast_SetClipDetails_Request) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_clip_id {
		res << vproto.pack_uint64_field(o.broadcast_clip_id, 1)
	}
	if o.has_start_time {
		res << vproto.pack_uint32_field(o.start_time, 2)
	}
	if o.has_end_time {
		res << vproto.pack_uint32_field(o.end_time, 3)
	}
	if o.has_video_description {
		res << vproto.pack_string_field(o.video_description, 4)
	}
	return res
}

pub fn cbroadcast_setclipdetails_request_unpack(buf []byte) ?CBroadcast_SetClipDetails_Request {
	mut res := CBroadcast_SetClipDetails_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_clip_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_clip_id = v
				i = ii
			}
			2 {
				res.has_start_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_time = v
				i = ii
			}
			3 {
				res.has_end_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.end_time = v
				i = ii
			}
			4 {
				res.has_video_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.video_description = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_setclipdetails_request() CBroadcast_SetClipDetails_Request {
	return CBroadcast_SetClipDetails_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_setclipdetails_request(o CBroadcast_SetClipDetails_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_setclipdetails_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_SetClipDetails_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_setclipdetails_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_SetClipDetails_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcast_SetClipDetails_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcast_setclipdetails_response_unpack(buf []byte) ?CBroadcast_SetClipDetails_Response {
	res := CBroadcast_SetClipDetails_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_setclipdetails_response() CBroadcast_SetClipDetails_Response {
	return CBroadcast_SetClipDetails_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_setclipdetails_response(o CBroadcast_SetClipDetails_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_setclipdetails_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_SetClipDetails_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_setclipdetails_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetClipDetails_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	broadcast_clip_id     u64
	has_broadcast_clip_id bool
}

pub fn (o &CBroadcast_GetClipDetails_Request) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_clip_id {
		res << vproto.pack_uint64_field(o.broadcast_clip_id, 1)
	}
	return res
}

pub fn cbroadcast_getclipdetails_request_unpack(buf []byte) ?CBroadcast_GetClipDetails_Request {
	mut res := CBroadcast_GetClipDetails_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_clip_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_clip_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getclipdetails_request() CBroadcast_GetClipDetails_Request {
	return CBroadcast_GetClipDetails_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getclipdetails_request(o CBroadcast_GetClipDetails_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getclipdetails_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetClipDetails_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getclipdetails_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetClipDetails_Response {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	broadcast_clip_id         u64
	has_broadcast_clip_id     bool
	video_id                  u64
	has_video_id              bool
	channel_id                u64
	has_channel_id            bool
	app_id                    u32
	has_app_id                bool
	accountid_broadcaster     u32
	has_accountid_broadcaster bool
	accountid_clipmaker       u32
	has_accountid_clipmaker   bool
	video_description         string
	has_video_description     bool
	start_time                u32
	has_start_time            bool
	length_milliseconds       u32
	has_length_milliseconds   bool
	thumbnail_path            string
	has_thumbnail_path        bool
}

pub fn (o &CBroadcast_GetClipDetails_Response) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_clip_id {
		res << vproto.pack_uint64_field(o.broadcast_clip_id, 1)
	}
	if o.has_video_id {
		res << vproto.pack_uint64_field(o.video_id, 2)
	}
	if o.has_channel_id {
		res << vproto.pack_uint64_field(o.channel_id, 3)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 4)
	}
	if o.has_accountid_broadcaster {
		res << vproto.pack_uint32_field(o.accountid_broadcaster, 5)
	}
	if o.has_accountid_clipmaker {
		res << vproto.pack_uint32_field(o.accountid_clipmaker, 6)
	}
	if o.has_video_description {
		res << vproto.pack_string_field(o.video_description, 7)
	}
	if o.has_start_time {
		res << vproto.pack_uint32_field(o.start_time, 8)
	}
	if o.has_length_milliseconds {
		res << vproto.pack_uint32_field(o.length_milliseconds, 9)
	}
	if o.has_thumbnail_path {
		res << vproto.pack_string_field(o.thumbnail_path, 10)
	}
	return res
}

pub fn cbroadcast_getclipdetails_response_unpack(buf []byte) ?CBroadcast_GetClipDetails_Response {
	mut res := CBroadcast_GetClipDetails_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_clip_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_clip_id = v
				i = ii
			}
			2 {
				res.has_video_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.video_id = v
				i = ii
			}
			3 {
				res.has_channel_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.channel_id = v
				i = ii
			}
			4 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			5 {
				res.has_accountid_broadcaster = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_broadcaster = v
				i = ii
			}
			6 {
				res.has_accountid_clipmaker = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_clipmaker = v
				i = ii
			}
			7 {
				res.has_video_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.video_description = v
				i = ii
			}
			8 {
				res.has_start_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_time = v
				i = ii
			}
			9 {
				res.has_length_milliseconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.length_milliseconds = v
				i = ii
			}
			10 {
				res.has_thumbnail_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_path = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getclipdetails_response() CBroadcast_GetClipDetails_Response {
	return CBroadcast_GetClipDetails_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getclipdetails_response(o CBroadcast_GetClipDetails_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getclipdetails_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetClipDetails_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getclipdetails_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_SetRTMPInfo_Request {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	broadcast_permission          int
	has_broadcast_permission      bool
	update_token                  bool
	has_update_token              bool
	broadcast_delay               int
	has_broadcast_delay           bool
	app_id                        u32
	has_app_id                    bool
	required_app_id               u32
	has_required_app_id           bool
	broadcast_chat_permission     EBroadcastChatPermission
	has_broadcast_chat_permission bool
	broadcast_buffer              int
	has_broadcast_buffer          bool
	steamid                       u64
	has_steamid                   bool
	chat_rate_limit               u32
	has_chat_rate_limit           bool
	enable_replay                 bool
	has_enable_replay             bool
}

pub fn (o &CBroadcast_SetRTMPInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_permission {
		res << vproto.pack_int32_field(o.broadcast_permission, 1)
	}
	if o.has_update_token {
		res << vproto.pack_bool_field(o.update_token, 2)
	}
	if o.has_broadcast_delay {
		res << vproto.pack_int32_field(o.broadcast_delay, 3)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 4)
	}
	if o.has_required_app_id {
		res << vproto.pack_uint32_field(o.required_app_id, 5)
	}
	if o.has_broadcast_chat_permission {
		res << zzz_vproto_internal_pack_ebroadcastchatpermission(o.broadcast_chat_permission, 6)
	}
	if o.has_broadcast_buffer {
		res << vproto.pack_int32_field(o.broadcast_buffer, 7)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 8)
	}
	if o.has_chat_rate_limit {
		res << vproto.pack_uint32_field(o.chat_rate_limit, 9)
	}
	if o.has_enable_replay {
		res << vproto.pack_bool_field(o.enable_replay, 10)
	}
	return res
}

pub fn cbroadcast_setrtmpinfo_request_unpack(buf []byte) ?CBroadcast_SetRTMPInfo_Request {
	mut res := CBroadcast_SetRTMPInfo_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_permission = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_permission = v
				i = ii
			}
			2 {
				res.has_update_token = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.update_token = v
				i = ii
			}
			3 {
				res.has_broadcast_delay = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_delay = v
				i = ii
			}
			4 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			5 {
				res.has_required_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.required_app_id = v
				i = ii
			}
			6 {
				res.has_broadcast_chat_permission = true
				ii, v := zzz_vproto_internal_unpack_ebroadcastchatpermission(cur_buf,
					tag_wiretype.wire_type)?
				res.broadcast_chat_permission = v
				i = ii
			}
			7 {
				res.has_broadcast_buffer = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_buffer = v
				i = ii
			}
			8 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			9 {
				res.has_chat_rate_limit = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_rate_limit = v
				i = ii
			}
			10 {
				res.has_enable_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_replay = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_setrtmpinfo_request() CBroadcast_SetRTMPInfo_Request {
	return CBroadcast_SetRTMPInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_setrtmpinfo_request(o CBroadcast_SetRTMPInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_setrtmpinfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_SetRTMPInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_setrtmpinfo_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_SetRTMPInfo_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcast_SetRTMPInfo_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcast_setrtmpinfo_response_unpack(buf []byte) ?CBroadcast_SetRTMPInfo_Response {
	res := CBroadcast_SetRTMPInfo_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_setrtmpinfo_response() CBroadcast_SetRTMPInfo_Response {
	return CBroadcast_SetRTMPInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_setrtmpinfo_response(o CBroadcast_SetRTMPInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_setrtmpinfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_SetRTMPInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_setrtmpinfo_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetRTMPInfo_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ip             u32
	has_ip         bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CBroadcast_GetRTMPInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.has_ip {
		res << vproto.pack_uint32_field(o.ip, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	return res
}

pub fn cbroadcast_getrtmpinfo_request_unpack(buf []byte) ?CBroadcast_GetRTMPInfo_Request {
	mut res := CBroadcast_GetRTMPInfo_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ip = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getrtmpinfo_request() CBroadcast_GetRTMPInfo_Request {
	return CBroadcast_GetRTMPInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getrtmpinfo_request(o CBroadcast_GetRTMPInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getrtmpinfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetRTMPInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getrtmpinfo_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetRTMPInfo_Response {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	broadcast_permission          int
	has_broadcast_permission      bool
	rtmp_host                     string
	has_rtmp_host                 bool
	rtmp_token                    string
	has_rtmp_token                bool
	broadcast_delay               int
	has_broadcast_delay           bool
	app_id                        u32
	has_app_id                    bool
	required_app_id               u32
	has_required_app_id           bool
	broadcast_chat_permission     EBroadcastChatPermission
	has_broadcast_chat_permission bool
	broadcast_buffer              int
	has_broadcast_buffer          bool
	steamid                       u64
	has_steamid                   bool
	chat_rate_limit               u32
	has_chat_rate_limit           bool
	enable_replay                 bool
	has_enable_replay             bool
}

pub fn (o &CBroadcast_GetRTMPInfo_Response) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_permission {
		res << vproto.pack_int32_field(o.broadcast_permission, 1)
	}
	if o.has_rtmp_host {
		res << vproto.pack_string_field(o.rtmp_host, 2)
	}
	if o.has_rtmp_token {
		res << vproto.pack_string_field(o.rtmp_token, 3)
	}
	if o.has_broadcast_delay {
		res << vproto.pack_int32_field(o.broadcast_delay, 4)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 5)
	}
	if o.has_required_app_id {
		res << vproto.pack_uint32_field(o.required_app_id, 6)
	}
	if o.has_broadcast_chat_permission {
		res << zzz_vproto_internal_pack_ebroadcastchatpermission(o.broadcast_chat_permission, 7)
	}
	if o.has_broadcast_buffer {
		res << vproto.pack_int32_field(o.broadcast_buffer, 8)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 9)
	}
	if o.has_chat_rate_limit {
		res << vproto.pack_uint32_field(o.chat_rate_limit, 10)
	}
	if o.has_enable_replay {
		res << vproto.pack_bool_field(o.enable_replay, 11)
	}
	return res
}

pub fn cbroadcast_getrtmpinfo_response_unpack(buf []byte) ?CBroadcast_GetRTMPInfo_Response {
	mut res := CBroadcast_GetRTMPInfo_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_permission = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_permission = v
				i = ii
			}
			2 {
				res.has_rtmp_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.rtmp_host = v
				i = ii
			}
			3 {
				res.has_rtmp_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.rtmp_token = v
				i = ii
			}
			4 {
				res.has_broadcast_delay = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_delay = v
				i = ii
			}
			5 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			6 {
				res.has_required_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.required_app_id = v
				i = ii
			}
			7 {
				res.has_broadcast_chat_permission = true
				ii, v := zzz_vproto_internal_unpack_ebroadcastchatpermission(cur_buf,
					tag_wiretype.wire_type)?
				res.broadcast_chat_permission = v
				i = ii
			}
			8 {
				res.has_broadcast_buffer = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_buffer = v
				i = ii
			}
			9 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			10 {
				res.has_chat_rate_limit = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_rate_limit = v
				i = ii
			}
			11 {
				res.has_enable_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_replay = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getrtmpinfo_response() CBroadcast_GetRTMPInfo_Response {
	return CBroadcast_GetRTMPInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getrtmpinfo_response(o CBroadcast_GetRTMPInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getrtmpinfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetRTMPInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getrtmpinfo_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCHaveTURNServer_Notification {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	broadcast_session_id     u64
	has_broadcast_session_id bool
	turn_server              string
	has_turn_server          bool
}

pub fn (o &CBroadcast_WebRTCHaveTURNServer_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_session_id {
		res << vproto.pack_64bit_field(o.broadcast_session_id, 1)
	}
	if o.has_turn_server {
		res << vproto.pack_string_field(o.turn_server, 2)
	}
	return res
}

pub fn cbroadcast_webrtchaveturnserver_notification_unpack(buf []byte) ?CBroadcast_WebRTCHaveTURNServer_Notification {
	mut res := CBroadcast_WebRTCHaveTURNServer_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_session_id = v
				i = ii
			}
			2 {
				res.has_turn_server = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.turn_server = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtchaveturnserver_notification() CBroadcast_WebRTCHaveTURNServer_Notification {
	return CBroadcast_WebRTCHaveTURNServer_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtchaveturnserver_notification(o CBroadcast_WebRTCHaveTURNServer_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtchaveturnserver_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCHaveTURNServer_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtchaveturnserver_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCStartResult_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	webrtc_session_id     u64
	has_webrtc_session_id bool
	started               bool
	has_started           bool
	offer                 string
	has_offer             bool
	resolution_x          u32
	has_resolution_x      bool
	resolution_y          u32
	has_resolution_y      bool
	fps                   u32
	has_fps               bool
}

pub fn (o &CBroadcast_WebRTCStartResult_Request) pack() []byte {
	mut res := []byte{}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 1)
	}
	if o.has_started {
		res << vproto.pack_bool_field(o.started, 2)
	}
	if o.has_offer {
		res << vproto.pack_string_field(o.offer, 3)
	}
	if o.has_resolution_x {
		res << vproto.pack_uint32_field(o.resolution_x, 4)
	}
	if o.has_resolution_y {
		res << vproto.pack_uint32_field(o.resolution_y, 5)
	}
	if o.has_fps {
		res << vproto.pack_uint32_field(o.fps, 6)
	}
	return res
}

pub fn cbroadcast_webrtcstartresult_request_unpack(buf []byte) ?CBroadcast_WebRTCStartResult_Request {
	mut res := CBroadcast_WebRTCStartResult_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			2 {
				res.has_started = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.started = v
				i = ii
			}
			3 {
				res.has_offer = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.offer = v
				i = ii
			}
			4 {
				res.has_resolution_x = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.resolution_x = v
				i = ii
			}
			5 {
				res.has_resolution_y = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.resolution_y = v
				i = ii
			}
			6 {
				res.has_fps = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.fps = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcstartresult_request() CBroadcast_WebRTCStartResult_Request {
	return CBroadcast_WebRTCStartResult_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcstartresult_request(o CBroadcast_WebRTCStartResult_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcstartresult_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCStartResult_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcstartresult_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCStartResult_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcast_WebRTCStartResult_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcast_webrtcstartresult_response_unpack(buf []byte) ?CBroadcast_WebRTCStartResult_Response {
	res := CBroadcast_WebRTCStartResult_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcstartresult_response() CBroadcast_WebRTCStartResult_Response {
	return CBroadcast_WebRTCStartResult_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcstartresult_response(o CBroadcast_WebRTCStartResult_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcstartresult_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCStartResult_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcstartresult_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCStopped_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	webrtc_session_id     u64
	has_webrtc_session_id bool
}

pub fn (o &CBroadcast_WebRTCStopped_Request) pack() []byte {
	mut res := []byte{}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 1)
	}
	return res
}

pub fn cbroadcast_webrtcstopped_request_unpack(buf []byte) ?CBroadcast_WebRTCStopped_Request {
	mut res := CBroadcast_WebRTCStopped_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcstopped_request() CBroadcast_WebRTCStopped_Request {
	return CBroadcast_WebRTCStopped_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcstopped_request(o CBroadcast_WebRTCStopped_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcstopped_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCStopped_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcstopped_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCStopped_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcast_WebRTCStopped_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcast_webrtcstopped_response_unpack(buf []byte) ?CBroadcast_WebRTCStopped_Response {
	res := CBroadcast_WebRTCStopped_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcstopped_response() CBroadcast_WebRTCStopped_Response {
	return CBroadcast_WebRTCStopped_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcstopped_response(o CBroadcast_WebRTCStopped_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcstopped_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCStopped_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcstopped_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCSetAnswer_Request {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	broadcaster_steamid     u64
	has_broadcaster_steamid bool
	webrtc_session_id       u64
	has_webrtc_session_id   bool
	answer                  string
	has_answer              bool
}

pub fn (o &CBroadcast_WebRTCSetAnswer_Request) pack() []byte {
	mut res := []byte{}
	if o.has_broadcaster_steamid {
		res << vproto.pack_64bit_field(o.broadcaster_steamid, 1)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 2)
	}
	if o.has_answer {
		res << vproto.pack_string_field(o.answer, 3)
	}
	return res
}

pub fn cbroadcast_webrtcsetanswer_request_unpack(buf []byte) ?CBroadcast_WebRTCSetAnswer_Request {
	mut res := CBroadcast_WebRTCSetAnswer_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcaster_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcaster_steamid = v
				i = ii
			}
			2 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			3 {
				res.has_answer = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.answer = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcsetanswer_request() CBroadcast_WebRTCSetAnswer_Request {
	return CBroadcast_WebRTCSetAnswer_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcsetanswer_request(o CBroadcast_WebRTCSetAnswer_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcsetanswer_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCSetAnswer_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcsetanswer_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCSetAnswer_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcast_WebRTCSetAnswer_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcast_webrtcsetanswer_response_unpack(buf []byte) ?CBroadcast_WebRTCSetAnswer_Response {
	res := CBroadcast_WebRTCSetAnswer_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcsetanswer_response() CBroadcast_WebRTCSetAnswer_Response {
	return CBroadcast_WebRTCSetAnswer_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcsetanswer_response(o CBroadcast_WebRTCSetAnswer_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcsetanswer_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCSetAnswer_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcsetanswer_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCLookupTURNServer_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	cellid         u32
	has_cellid     bool
}

pub fn (o &CBroadcast_WebRTCLookupTURNServer_Request) pack() []byte {
	mut res := []byte{}
	if o.has_cellid {
		res << vproto.pack_uint32_field(o.cellid, 1)
	}
	return res
}

pub fn cbroadcast_webrtclookupturnserver_request_unpack(buf []byte) ?CBroadcast_WebRTCLookupTURNServer_Request {
	mut res := CBroadcast_WebRTCLookupTURNServer_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cellid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtclookupturnserver_request() CBroadcast_WebRTCLookupTURNServer_Request {
	return CBroadcast_WebRTCLookupTURNServer_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtclookupturnserver_request(o CBroadcast_WebRTCLookupTURNServer_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtclookupturnserver_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCLookupTURNServer_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtclookupturnserver_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCLookupTURNServer_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	turn_server     string
	has_turn_server bool
}

pub fn (o &CBroadcast_WebRTCLookupTURNServer_Response) pack() []byte {
	mut res := []byte{}
	if o.has_turn_server {
		res << vproto.pack_string_field(o.turn_server, 1)
	}
	return res
}

pub fn cbroadcast_webrtclookupturnserver_response_unpack(buf []byte) ?CBroadcast_WebRTCLookupTURNServer_Response {
	mut res := CBroadcast_WebRTCLookupTURNServer_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_turn_server = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.turn_server = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtclookupturnserver_response() CBroadcast_WebRTCLookupTURNServer_Response {
	return CBroadcast_WebRTCLookupTURNServer_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtclookupturnserver_response(o CBroadcast_WebRTCLookupTURNServer_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtclookupturnserver_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCLookupTURNServer_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtclookupturnserver_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTC_Candidate {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	sdp_mid             string
	has_sdp_mid         bool
	sdp_mline_index     int
	has_sdp_mline_index bool
	candidate           string
	has_candidate       bool
}

pub fn (o &CBroadcast_WebRTC_Candidate) pack() []byte {
	mut res := []byte{}
	if o.has_sdp_mid {
		res << vproto.pack_string_field(o.sdp_mid, 1)
	}
	if o.has_sdp_mline_index {
		res << vproto.pack_int32_field(o.sdp_mline_index, 2)
	}
	if o.has_candidate {
		res << vproto.pack_string_field(o.candidate, 3)
	}
	return res
}

pub fn cbroadcast_webrtc_candidate_unpack(buf []byte) ?CBroadcast_WebRTC_Candidate {
	mut res := CBroadcast_WebRTC_Candidate{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sdp_mid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sdp_mid = v
				i = ii
			}
			2 {
				res.has_sdp_mline_index = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.sdp_mline_index = v
				i = ii
			}
			3 {
				res.has_candidate = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.candidate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtc_candidate() CBroadcast_WebRTC_Candidate {
	return CBroadcast_WebRTC_Candidate{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtc_candidate(o CBroadcast_WebRTC_Candidate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtc_candidate(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTC_Candidate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtc_candidate_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCAddHostCandidate_Request {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	webrtc_session_id     u64
	has_webrtc_session_id bool
	candidate             CBroadcast_WebRTC_Candidate
	has_candidate         bool
}

pub fn (o &CBroadcast_WebRTCAddHostCandidate_Request) pack() []byte {
	mut res := []byte{}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 1)
	}
	if o.has_candidate {
		res << zzz_vproto_internal_pack_cbroadcast_webrtc_candidate(o.candidate, 2)
	}
	return res
}

pub fn cbroadcast_webrtcaddhostcandidate_request_unpack(buf []byte) ?CBroadcast_WebRTCAddHostCandidate_Request {
	mut res := CBroadcast_WebRTCAddHostCandidate_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			2 {
				res.has_candidate = true
				ii, v := zzz_vproto_internal_unpack_cbroadcast_webrtc_candidate(cur_buf,
					tag_wiretype.wire_type)?
				res.candidate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcaddhostcandidate_request() CBroadcast_WebRTCAddHostCandidate_Request {
	return CBroadcast_WebRTCAddHostCandidate_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcaddhostcandidate_request(o CBroadcast_WebRTCAddHostCandidate_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcaddhostcandidate_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCAddHostCandidate_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcaddhostcandidate_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCAddHostCandidate_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcast_WebRTCAddHostCandidate_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcast_webrtcaddhostcandidate_response_unpack(buf []byte) ?CBroadcast_WebRTCAddHostCandidate_Response {
	res := CBroadcast_WebRTCAddHostCandidate_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcaddhostcandidate_response() CBroadcast_WebRTCAddHostCandidate_Response {
	return CBroadcast_WebRTCAddHostCandidate_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcaddhostcandidate_response(o CBroadcast_WebRTCAddHostCandidate_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcaddhostcandidate_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCAddHostCandidate_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcaddhostcandidate_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCAddViewerCandidate_Request {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	broadcaster_steamid     u64
	has_broadcaster_steamid bool
	webrtc_session_id       u64
	has_webrtc_session_id   bool
	candidate               CBroadcast_WebRTC_Candidate
	has_candidate           bool
}

pub fn (o &CBroadcast_WebRTCAddViewerCandidate_Request) pack() []byte {
	mut res := []byte{}
	if o.has_broadcaster_steamid {
		res << vproto.pack_64bit_field(o.broadcaster_steamid, 1)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 2)
	}
	if o.has_candidate {
		res << zzz_vproto_internal_pack_cbroadcast_webrtc_candidate(o.candidate, 3)
	}
	return res
}

pub fn cbroadcast_webrtcaddviewercandidate_request_unpack(buf []byte) ?CBroadcast_WebRTCAddViewerCandidate_Request {
	mut res := CBroadcast_WebRTCAddViewerCandidate_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcaster_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcaster_steamid = v
				i = ii
			}
			2 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			3 {
				res.has_candidate = true
				ii, v := zzz_vproto_internal_unpack_cbroadcast_webrtc_candidate(cur_buf,
					tag_wiretype.wire_type)?
				res.candidate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcaddviewercandidate_request() CBroadcast_WebRTCAddViewerCandidate_Request {
	return CBroadcast_WebRTCAddViewerCandidate_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcaddviewercandidate_request(o CBroadcast_WebRTCAddViewerCandidate_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcaddviewercandidate_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCAddViewerCandidate_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcaddviewercandidate_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCAddViewerCandidate_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcast_WebRTCAddViewerCandidate_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcast_webrtcaddviewercandidate_response_unpack(buf []byte) ?CBroadcast_WebRTCAddViewerCandidate_Response {
	res := CBroadcast_WebRTCAddViewerCandidate_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcaddviewercandidate_response() CBroadcast_WebRTCAddViewerCandidate_Response {
	return CBroadcast_WebRTCAddViewerCandidate_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcaddviewercandidate_response(o CBroadcast_WebRTCAddViewerCandidate_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcaddviewercandidate_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCAddViewerCandidate_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcaddviewercandidate_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCGetHostCandidates_Request {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	broadcaster_steamid      u64
	has_broadcaster_steamid  bool
	webrtc_session_id        u64
	has_webrtc_session_id    bool
	candidate_generation     u32
	has_candidate_generation bool
}

pub fn (o &CBroadcast_WebRTCGetHostCandidates_Request) pack() []byte {
	mut res := []byte{}
	if o.has_broadcaster_steamid {
		res << vproto.pack_64bit_field(o.broadcaster_steamid, 1)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 2)
	}
	if o.has_candidate_generation {
		res << vproto.pack_uint32_field(o.candidate_generation, 3)
	}
	return res
}

pub fn cbroadcast_webrtcgethostcandidates_request_unpack(buf []byte) ?CBroadcast_WebRTCGetHostCandidates_Request {
	mut res := CBroadcast_WebRTCGetHostCandidates_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcaster_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcaster_steamid = v
				i = ii
			}
			2 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			3 {
				res.has_candidate_generation = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.candidate_generation = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcgethostcandidates_request() CBroadcast_WebRTCGetHostCandidates_Request {
	return CBroadcast_WebRTCGetHostCandidates_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcgethostcandidates_request(o CBroadcast_WebRTCGetHostCandidates_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcgethostcandidates_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCGetHostCandidates_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcgethostcandidates_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCGetHostCandidates_Response {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	candidate_generation     u32
	has_candidate_generation bool
	candidates               []CBroadcast_WebRTC_Candidate
}

pub fn (o &CBroadcast_WebRTCGetHostCandidates_Response) pack() []byte {
	mut res := []byte{}
	if o.has_candidate_generation {
		res << vproto.pack_uint32_field(o.candidate_generation, 1)
	}
	// [packed=false]
	for _, x in o.candidates {
		res << zzz_vproto_internal_pack_cbroadcast_webrtc_candidate(x, 2)
	}
	return res
}

pub fn cbroadcast_webrtcgethostcandidates_response_unpack(buf []byte) ?CBroadcast_WebRTCGetHostCandidates_Response {
	mut res := CBroadcast_WebRTCGetHostCandidates_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_candidate_generation = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.candidate_generation = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cbroadcast_webrtc_candidate(cur_buf,
					tag_wiretype.wire_type)?
				res.candidates << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcgethostcandidates_response() CBroadcast_WebRTCGetHostCandidates_Response {
	return CBroadcast_WebRTCGetHostCandidates_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcgethostcandidates_response(o CBroadcast_WebRTCGetHostCandidates_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcgethostcandidates_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCGetHostCandidates_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcgethostcandidates_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastUploadStats_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	row_limit      u32
	has_row_limit  bool
	start_time     u32
	has_start_time bool
	upload_id      u64
	has_upload_id  bool
	steamid        u64
	has_steamid    bool
	session_id     u64
	has_session_id bool
}

pub fn (o &CBroadcast_GetBroadcastUploadStats_Request) pack() []byte {
	mut res := []byte{}
	if o.has_row_limit {
		res << vproto.pack_uint32_field(o.row_limit, 1)
	}
	if o.has_start_time {
		res << vproto.pack_uint32_field(o.start_time, 2)
	}
	if o.has_upload_id {
		res << vproto.pack_uint64_field(o.upload_id, 3)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 4)
	}
	if o.has_session_id {
		res << vproto.pack_uint64_field(o.session_id, 5)
	}
	return res
}

pub fn cbroadcast_getbroadcastuploadstats_request_unpack(buf []byte) ?CBroadcast_GetBroadcastUploadStats_Request {
	mut res := CBroadcast_GetBroadcastUploadStats_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_row_limit = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.row_limit = v
				i = ii
			}
			2 {
				res.has_start_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_time = v
				i = ii
			}
			3 {
				res.has_upload_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_id = v
				i = ii
			}
			4 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			5 {
				res.has_session_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastuploadstats_request() CBroadcast_GetBroadcastUploadStats_Request {
	return CBroadcast_GetBroadcastUploadStats_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastuploadstats_request(o CBroadcast_GetBroadcastUploadStats_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastuploadstats_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastUploadStats_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastuploadstats_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	upload_result             u32
	has_upload_result         bool
	time_stopped              u32
	has_time_stopped          bool
	seconds_uploaded          u32
	has_seconds_uploaded      bool
	max_viewers               u32
	has_max_viewers           bool
	resolution_x              u32
	has_resolution_x          bool
	resolution_y              u32
	has_resolution_y          bool
	avg_bandwidth             u32
	has_avg_bandwidth         bool
	total_bytes               u64
	has_total_bytes           bool
	app_id                    u32
	has_app_id                bool
	total_unique_viewers      u32
	has_total_unique_viewers  bool
	total_seconds_watched     u64
	has_total_seconds_watched bool
	time_started              u32
	has_time_started          bool
	upload_id                 u64
	has_upload_id             bool
	local_address             string
	has_local_address         bool
	remote_address            string
	has_remote_address        bool
	frames_per_second         u32
	has_frames_per_second     bool
	num_representations       u32
	has_num_representations   bool
	app_name                  string
	has_app_name              bool
	is_replay                 bool
	has_is_replay             bool
	session_id                u64
	has_session_id            bool
}

pub fn (o &CBroadcast_GetBroadcastUploadStats_Response_UploadStats) pack() []byte {
	mut res := []byte{}
	if o.has_upload_result {
		res << vproto.pack_uint32_field(o.upload_result, 1)
	}
	if o.has_time_stopped {
		res << vproto.pack_uint32_field(o.time_stopped, 2)
	}
	if o.has_seconds_uploaded {
		res << vproto.pack_uint32_field(o.seconds_uploaded, 3)
	}
	if o.has_max_viewers {
		res << vproto.pack_uint32_field(o.max_viewers, 4)
	}
	if o.has_resolution_x {
		res << vproto.pack_uint32_field(o.resolution_x, 5)
	}
	if o.has_resolution_y {
		res << vproto.pack_uint32_field(o.resolution_y, 6)
	}
	if o.has_avg_bandwidth {
		res << vproto.pack_uint32_field(o.avg_bandwidth, 7)
	}
	if o.has_total_bytes {
		res << vproto.pack_uint64_field(o.total_bytes, 8)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 9)
	}
	if o.has_total_unique_viewers {
		res << vproto.pack_uint32_field(o.total_unique_viewers, 10)
	}
	if o.has_total_seconds_watched {
		res << vproto.pack_uint64_field(o.total_seconds_watched, 11)
	}
	if o.has_time_started {
		res << vproto.pack_uint32_field(o.time_started, 12)
	}
	if o.has_upload_id {
		res << vproto.pack_uint64_field(o.upload_id, 13)
	}
	if o.has_local_address {
		res << vproto.pack_string_field(o.local_address, 14)
	}
	if o.has_remote_address {
		res << vproto.pack_string_field(o.remote_address, 15)
	}
	if o.has_frames_per_second {
		res << vproto.pack_uint32_field(o.frames_per_second, 16)
	}
	if o.has_num_representations {
		res << vproto.pack_uint32_field(o.num_representations, 17)
	}
	if o.has_app_name {
		res << vproto.pack_string_field(o.app_name, 18)
	}
	if o.has_is_replay {
		res << vproto.pack_bool_field(o.is_replay, 19)
	}
	if o.has_session_id {
		res << vproto.pack_uint64_field(o.session_id, 20)
	}
	return res
}

pub fn cbroadcast_getbroadcastuploadstats_response_uploadstats_unpack(buf []byte) ?CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
	mut res := CBroadcast_GetBroadcastUploadStats_Response_UploadStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_upload_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_result = v
				i = ii
			}
			2 {
				res.has_time_stopped = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_stopped = v
				i = ii
			}
			3 {
				res.has_seconds_uploaded = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_uploaded = v
				i = ii
			}
			4 {
				res.has_max_viewers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_viewers = v
				i = ii
			}
			5 {
				res.has_resolution_x = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.resolution_x = v
				i = ii
			}
			6 {
				res.has_resolution_y = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.resolution_y = v
				i = ii
			}
			7 {
				res.has_avg_bandwidth = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.avg_bandwidth = v
				i = ii
			}
			8 {
				res.has_total_bytes = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.total_bytes = v
				i = ii
			}
			9 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			10 {
				res.has_total_unique_viewers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_unique_viewers = v
				i = ii
			}
			11 {
				res.has_total_seconds_watched = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.total_seconds_watched = v
				i = ii
			}
			12 {
				res.has_time_started = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_started = v
				i = ii
			}
			13 {
				res.has_upload_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_id = v
				i = ii
			}
			14 {
				res.has_local_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.local_address = v
				i = ii
			}
			15 {
				res.has_remote_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.remote_address = v
				i = ii
			}
			16 {
				res.has_frames_per_second = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.frames_per_second = v
				i = ii
			}
			17 {
				res.has_num_representations = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_representations = v
				i = ii
			}
			18 {
				res.has_app_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.app_name = v
				i = ii
			}
			19 {
				res.has_is_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_replay = v
				i = ii
			}
			20 {
				res.has_session_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastuploadstats_response_uploadstats() CBroadcast_GetBroadcastUploadStats_Response_UploadStats {
	return CBroadcast_GetBroadcastUploadStats_Response_UploadStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastuploadstats_response_uploadstats(o CBroadcast_GetBroadcastUploadStats_Response_UploadStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastuploadstats_response_uploadstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastUploadStats_Response_UploadStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastuploadstats_response_uploadstats_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastUploadStats_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	upload_stats   []CBroadcast_GetBroadcastUploadStats_Response_UploadStats
}

pub fn (o &CBroadcast_GetBroadcastUploadStats_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.upload_stats {
		res <<
			zzz_vproto_internal_pack_cbroadcast_getbroadcastuploadstats_response_uploadstats(x, 1)
	}
	return res
}

pub fn cbroadcast_getbroadcastuploadstats_response_unpack(buf []byte) ?CBroadcast_GetBroadcastUploadStats_Response {
	mut res := CBroadcast_GetBroadcastUploadStats_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cbroadcast_getbroadcastuploadstats_response_uploadstats(cur_buf,
					tag_wiretype.wire_type)?
				res.upload_stats << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastuploadstats_response() CBroadcast_GetBroadcastUploadStats_Response {
	return CBroadcast_GetBroadcastUploadStats_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastuploadstats_response(o CBroadcast_GetBroadcastUploadStats_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastuploadstats_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastUploadStats_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastuploadstats_response_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastViewerStats_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	upload_id      u64
	has_upload_id  bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CBroadcast_GetBroadcastViewerStats_Request) pack() []byte {
	mut res := []byte{}
	if o.has_upload_id {
		res << vproto.pack_uint64_field(o.upload_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	return res
}

pub fn cbroadcast_getbroadcastviewerstats_request_unpack(buf []byte) ?CBroadcast_GetBroadcastViewerStats_Request {
	mut res := CBroadcast_GetBroadcastViewerStats_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_upload_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastviewerstats_request() CBroadcast_GetBroadcastViewerStats_Request {
	return CBroadcast_GetBroadcastViewerStats_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastviewerstats_request(o CBroadcast_GetBroadcastViewerStats_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastviewerstats_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastViewerStats_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastviewerstats_request_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	time            u32
	has_time        bool
	num_viewers     u32
	has_num_viewers bool
}

pub fn (o &CBroadcast_GetBroadcastViewerStats_Response_ViewerStats) pack() []byte {
	mut res := []byte{}
	if o.has_time {
		res << vproto.pack_uint32_field(o.time, 1)
	}
	if o.has_num_viewers {
		res << vproto.pack_uint32_field(o.num_viewers, 2)
	}
	return res
}

pub fn cbroadcast_getbroadcastviewerstats_response_viewerstats_unpack(buf []byte) ?CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
	mut res := CBroadcast_GetBroadcastViewerStats_Response_ViewerStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time = v
				i = ii
			}
			2 {
				res.has_num_viewers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_viewers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastviewerstats_response_viewerstats() CBroadcast_GetBroadcastViewerStats_Response_ViewerStats {
	return CBroadcast_GetBroadcastViewerStats_Response_ViewerStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastviewerstats_response_viewerstats(o CBroadcast_GetBroadcastViewerStats_Response_ViewerStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastviewerstats_response_viewerstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastViewerStats_Response_ViewerStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastviewerstats_response_viewerstats_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	country_code     string
	has_country_code bool
	num_viewers      u32
	has_num_viewers  bool
}

pub fn (o &CBroadcast_GetBroadcastViewerStats_Response_CountryStats) pack() []byte {
	mut res := []byte{}
	if o.has_country_code {
		res << vproto.pack_string_field(o.country_code, 1)
	}
	if o.has_num_viewers {
		res << vproto.pack_uint32_field(o.num_viewers, 2)
	}
	return res
}

pub fn cbroadcast_getbroadcastviewerstats_response_countrystats_unpack(buf []byte) ?CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
	mut res := CBroadcast_GetBroadcastViewerStats_Response_CountryStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_country_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.country_code = v
				i = ii
			}
			2 {
				res.has_num_viewers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_viewers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastviewerstats_response_countrystats() CBroadcast_GetBroadcastViewerStats_Response_CountryStats {
	return CBroadcast_GetBroadcastViewerStats_Response_CountryStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastviewerstats_response_countrystats(o CBroadcast_GetBroadcastViewerStats_Response_CountryStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastviewerstats_response_countrystats(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastViewerStats_Response_CountryStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastviewerstats_response_countrystats_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_GetBroadcastViewerStats_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	viewer_stats   []CBroadcast_GetBroadcastViewerStats_Response_ViewerStats
	country_stats  []CBroadcast_GetBroadcastViewerStats_Response_CountryStats
}

pub fn (o &CBroadcast_GetBroadcastViewerStats_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.viewer_stats {
		res <<
			zzz_vproto_internal_pack_cbroadcast_getbroadcastviewerstats_response_viewerstats(x, 1)
	}
	// [packed=false]
	for _, x in o.country_stats {
		res <<
			zzz_vproto_internal_pack_cbroadcast_getbroadcastviewerstats_response_countrystats(x, 2)
	}
	return res
}

pub fn cbroadcast_getbroadcastviewerstats_response_unpack(buf []byte) ?CBroadcast_GetBroadcastViewerStats_Response {
	mut res := CBroadcast_GetBroadcastViewerStats_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cbroadcast_getbroadcastviewerstats_response_viewerstats(cur_buf,
					tag_wiretype.wire_type)?
				res.viewer_stats << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cbroadcast_getbroadcastviewerstats_response_countrystats(cur_buf,
					tag_wiretype.wire_type)?
				res.country_stats << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_getbroadcastviewerstats_response() CBroadcast_GetBroadcastViewerStats_Response {
	return CBroadcast_GetBroadcastViewerStats_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_getbroadcastviewerstats_response(o CBroadcast_GetBroadcastViewerStats_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_getbroadcastviewerstats_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_GetBroadcastViewerStats_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_getbroadcastviewerstats_response_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CBroadcast_BroadcastViewerState_Notification_EViewerState {
	k_eviewerneedsapproval = 1
	k_eviewerwatching = 2
	k_eviewerleft = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cbroadcast_broadcastviewerstate_notification_eviewerstate(e CBroadcast_BroadcastViewerState_Notification_EViewerState, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cbroadcast_broadcastviewerstate_notification_eviewerstate_packed(e []CBroadcast_BroadcastViewerState_Notification_EViewerState, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cbroadcast_broadcastviewerstate_notification_eviewerstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_BroadcastViewerState_Notification_EViewerState) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CBroadcast_BroadcastViewerState_Notification_EViewerState(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cbroadcast_broadcastviewerstate_notification_eviewerstate_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CBroadcast_BroadcastViewerState_Notification_EViewerState) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CBroadcast_BroadcastViewerState_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	state          CBroadcast_BroadcastViewerState_Notification_EViewerState
	has_state      bool
}

pub fn (o &CBroadcast_BroadcastViewerState_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_state {
		res <<
			zzz_vproto_internal_pack_cbroadcast_broadcastviewerstate_notification_eviewerstate(o.state, 2)
	}
	return res
}

pub fn cbroadcast_broadcastviewerstate_notification_unpack(buf []byte) ?CBroadcast_BroadcastViewerState_Notification {
	mut res := CBroadcast_BroadcastViewerState_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_state = true
				ii, v := zzz_vproto_internal_unpack_cbroadcast_broadcastviewerstate_notification_eviewerstate(cur_buf,
					tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_broadcastviewerstate_notification() CBroadcast_BroadcastViewerState_Notification {
	return CBroadcast_BroadcastViewerState_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_broadcastviewerstate_notification(o CBroadcast_BroadcastViewerState_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_broadcastviewerstate_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_BroadcastViewerState_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_broadcastviewerstate_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WaitingBroadcastViewer_Notification {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	broadcast_id     u64
	has_broadcast_id bool
}

pub fn (o &CBroadcast_WaitingBroadcastViewer_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	return res
}

pub fn cbroadcast_waitingbroadcastviewer_notification_unpack(buf []byte) ?CBroadcast_WaitingBroadcastViewer_Notification {
	mut res := CBroadcast_WaitingBroadcastViewer_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_waitingbroadcastviewer_notification() CBroadcast_WaitingBroadcastViewer_Notification {
	return CBroadcast_WaitingBroadcastViewer_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_waitingbroadcastviewer_notification(o CBroadcast_WaitingBroadcastViewer_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_waitingbroadcastviewer_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WaitingBroadcastViewer_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_waitingbroadcastviewer_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_BroadcastUploadStarted_Notification {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	broadcast_id                   u64
	has_broadcast_id               bool
	upload_token                   string
	has_upload_token               bool
	upload_address                 string
	has_upload_address             bool
	http_address                   string
	has_http_address               bool
	broadcast_upload_id            u64
	has_broadcast_upload_id        bool
	heartbeat_interval_seconds     u32
	has_heartbeat_interval_seconds bool
	is_rtmp                        bool
	has_is_rtmp                    bool
}

pub fn (o &CBroadcast_BroadcastUploadStarted_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	if o.has_upload_token {
		res << vproto.pack_string_field(o.upload_token, 2)
	}
	if o.has_upload_address {
		res << vproto.pack_string_field(o.upload_address, 3)
	}
	if o.has_http_address {
		res << vproto.pack_string_field(o.http_address, 4)
	}
	if o.has_broadcast_upload_id {
		res << vproto.pack_64bit_field(o.broadcast_upload_id, 5)
	}
	if o.has_heartbeat_interval_seconds {
		res << vproto.pack_uint32_field(o.heartbeat_interval_seconds, 6)
	}
	if o.has_is_rtmp {
		res << vproto.pack_bool_field(o.is_rtmp, 7)
	}
	return res
}

pub fn cbroadcast_broadcastuploadstarted_notification_unpack(buf []byte) ?CBroadcast_BroadcastUploadStarted_Notification {
	mut res := CBroadcast_BroadcastUploadStarted_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			2 {
				res.has_upload_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_token = v
				i = ii
			}
			3 {
				res.has_upload_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_address = v
				i = ii
			}
			4 {
				res.has_http_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.http_address = v
				i = ii
			}
			5 {
				res.has_broadcast_upload_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_upload_id = v
				i = ii
			}
			6 {
				res.has_heartbeat_interval_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.heartbeat_interval_seconds = v
				i = ii
			}
			7 {
				res.has_is_rtmp = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_rtmp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_broadcastuploadstarted_notification() CBroadcast_BroadcastUploadStarted_Notification {
	return CBroadcast_BroadcastUploadStarted_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_broadcastuploadstarted_notification(o CBroadcast_BroadcastUploadStarted_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_broadcastuploadstarted_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_BroadcastUploadStarted_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_broadcastuploadstarted_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_StopBroadcastUpload_Notification {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	broadcast_id              u64
	has_broadcast_id          bool
	broadcast_relay_id        u64
	has_broadcast_relay_id    bool
	upload_result             u32
	has_upload_result         bool
	too_many_poor_uploads     bool
	has_too_many_poor_uploads bool
}

pub fn (o &CBroadcast_StopBroadcastUpload_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	if o.has_broadcast_relay_id {
		res << vproto.pack_64bit_field(o.broadcast_relay_id, 2)
	}
	if o.has_upload_result {
		res << vproto.pack_uint32_field(o.upload_result, 3)
	}
	if o.has_too_many_poor_uploads {
		res << vproto.pack_bool_field(o.too_many_poor_uploads, 4)
	}
	return res
}

pub fn cbroadcast_stopbroadcastupload_notification_unpack(buf []byte) ?CBroadcast_StopBroadcastUpload_Notification {
	mut res := CBroadcast_StopBroadcastUpload_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			2 {
				res.has_broadcast_relay_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_relay_id = v
				i = ii
			}
			3 {
				res.has_upload_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_result = v
				i = ii
			}
			4 {
				res.has_too_many_poor_uploads = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.too_many_poor_uploads = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_stopbroadcastupload_notification() CBroadcast_StopBroadcastUpload_Notification {
	return CBroadcast_StopBroadcastUpload_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_stopbroadcastupload_notification(o CBroadcast_StopBroadcastUpload_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_stopbroadcastupload_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_StopBroadcastUpload_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_stopbroadcastupload_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_SessionClosed_Notification {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	broadcast_id     u64
	has_broadcast_id bool
}

pub fn (o &CBroadcast_SessionClosed_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	return res
}

pub fn cbroadcast_sessionclosed_notification_unpack(buf []byte) ?CBroadcast_SessionClosed_Notification {
	mut res := CBroadcast_SessionClosed_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_sessionclosed_notification() CBroadcast_SessionClosed_Notification {
	return CBroadcast_SessionClosed_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_sessionclosed_notification(o CBroadcast_SessionClosed_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_sessionclosed_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_SessionClosed_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_sessionclosed_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_ViewerBroadcastInvite_Notification {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	broadcaster_steamid     u64
	has_broadcaster_steamid bool
}

pub fn (o &CBroadcast_ViewerBroadcastInvite_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcaster_steamid {
		res << vproto.pack_64bit_field(o.broadcaster_steamid, 1)
	}
	return res
}

pub fn cbroadcast_viewerbroadcastinvite_notification_unpack(buf []byte) ?CBroadcast_ViewerBroadcastInvite_Notification {
	mut res := CBroadcast_ViewerBroadcastInvite_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcaster_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcaster_steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_viewerbroadcastinvite_notification() CBroadcast_ViewerBroadcastInvite_Notification {
	return CBroadcast_ViewerBroadcastInvite_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_viewerbroadcastinvite_notification(o CBroadcast_ViewerBroadcastInvite_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_viewerbroadcastinvite_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_ViewerBroadcastInvite_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_viewerbroadcastinvite_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_BroadcastStatus_Notification {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	broadcast_id     u64
	has_broadcast_id bool
	num_viewers      int
	has_num_viewers  bool
}

pub fn (o &CBroadcast_BroadcastStatus_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	if o.has_num_viewers {
		res << vproto.pack_int32_field(o.num_viewers, 2)
	}
	return res
}

pub fn cbroadcast_broadcaststatus_notification_unpack(buf []byte) ?CBroadcast_BroadcastStatus_Notification {
	mut res := CBroadcast_BroadcastStatus_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			2 {
				res.has_num_viewers = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_viewers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_broadcaststatus_notification() CBroadcast_BroadcastStatus_Notification {
	return CBroadcast_BroadcastStatus_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_broadcaststatus_notification(o CBroadcast_BroadcastStatus_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_broadcaststatus_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_BroadcastStatus_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_broadcaststatus_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_BroadcastChannelLive_Notification {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	broadcast_channel_id         u64
	has_broadcast_channel_id     bool
	broadcast_channel_name       string
	has_broadcast_channel_name   bool
	broadcast_channel_avatar     string
	has_broadcast_channel_avatar bool
}

pub fn (o &CBroadcast_BroadcastChannelLive_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_channel_id {
		res << vproto.pack_64bit_field(o.broadcast_channel_id, 1)
	}
	if o.has_broadcast_channel_name {
		res << vproto.pack_string_field(o.broadcast_channel_name, 2)
	}
	if o.has_broadcast_channel_avatar {
		res << vproto.pack_string_field(o.broadcast_channel_avatar, 3)
	}
	return res
}

pub fn cbroadcast_broadcastchannellive_notification_unpack(buf []byte) ?CBroadcast_BroadcastChannelLive_Notification {
	mut res := CBroadcast_BroadcastChannelLive_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_channel_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_channel_id = v
				i = ii
			}
			2 {
				res.has_broadcast_channel_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_channel_name = v
				i = ii
			}
			3 {
				res.has_broadcast_channel_avatar = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_channel_avatar = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_broadcastchannellive_notification() CBroadcast_BroadcastChannelLive_Notification {
	return CBroadcast_BroadcastChannelLive_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_broadcastchannellive_notification(o CBroadcast_BroadcastChannelLive_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_broadcastchannellive_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_BroadcastChannelLive_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_broadcastchannellive_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_SendThumbnailToRelay_Notification {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	thumbnail_upload_token             string
	has_thumbnail_upload_token         bool
	thumbnail_broadcast_session_id     u64
	has_thumbnail_broadcast_session_id bool
	thumbnail_data                     []byte
	has_thumbnail_data                 bool
	thumbnail_width                    u32
	has_thumbnail_width                bool
	thumbnail_height                   u32
	has_thumbnail_height               bool
}

pub fn (o &CBroadcast_SendThumbnailToRelay_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_thumbnail_upload_token {
		res << vproto.pack_string_field(o.thumbnail_upload_token, 1)
	}
	if o.has_thumbnail_broadcast_session_id {
		res << vproto.pack_64bit_field(o.thumbnail_broadcast_session_id, 2)
	}
	if o.has_thumbnail_data {
		res << vproto.pack_bytes_field(o.thumbnail_data, 3)
	}
	if o.has_thumbnail_width {
		res << vproto.pack_uint32_field(o.thumbnail_width, 4)
	}
	if o.has_thumbnail_height {
		res << vproto.pack_uint32_field(o.thumbnail_height, 5)
	}
	return res
}

pub fn cbroadcast_sendthumbnailtorelay_notification_unpack(buf []byte) ?CBroadcast_SendThumbnailToRelay_Notification {
	mut res := CBroadcast_SendThumbnailToRelay_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_thumbnail_upload_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_upload_token = v
				i = ii
			}
			2 {
				res.has_thumbnail_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_broadcast_session_id = v
				i = ii
			}
			3 {
				res.has_thumbnail_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_data = v
				i = ii
			}
			4 {
				res.has_thumbnail_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_width = v
				i = ii
			}
			5 {
				res.has_thumbnail_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_sendthumbnailtorelay_notification() CBroadcast_SendThumbnailToRelay_Notification {
	return CBroadcast_SendThumbnailToRelay_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_sendthumbnailtorelay_notification(o CBroadcast_SendThumbnailToRelay_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_sendthumbnailtorelay_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_SendThumbnailToRelay_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_sendthumbnailtorelay_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCNeedTURNServer_Notification {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	broadcast_session_id     u64
	has_broadcast_session_id bool
}

pub fn (o &CBroadcast_WebRTCNeedTURNServer_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_session_id {
		res << vproto.pack_64bit_field(o.broadcast_session_id, 1)
	}
	return res
}

pub fn cbroadcast_webrtcneedturnserver_notification_unpack(buf []byte) ?CBroadcast_WebRTCNeedTURNServer_Notification {
	mut res := CBroadcast_WebRTCNeedTURNServer_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_session_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcneedturnserver_notification() CBroadcast_WebRTCNeedTURNServer_Notification {
	return CBroadcast_WebRTCNeedTURNServer_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcneedturnserver_notification(o CBroadcast_WebRTCNeedTURNServer_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcneedturnserver_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCNeedTURNServer_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcneedturnserver_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCStart_Notification {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	broadcast_session_id     u64
	has_broadcast_session_id bool
	webrtc_session_id        u64
	has_webrtc_session_id    bool
	viewer_steamid           u64
	has_viewer_steamid       bool
	viewer_token             u64
	has_viewer_token         bool
}

pub fn (o &CBroadcast_WebRTCStart_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_session_id {
		res << vproto.pack_64bit_field(o.broadcast_session_id, 1)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 2)
	}
	if o.has_viewer_steamid {
		res << vproto.pack_64bit_field(o.viewer_steamid, 3)
	}
	if o.has_viewer_token {
		res << vproto.pack_64bit_field(o.viewer_token, 4)
	}
	return res
}

pub fn cbroadcast_webrtcstart_notification_unpack(buf []byte) ?CBroadcast_WebRTCStart_Notification {
	mut res := CBroadcast_WebRTCStart_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_session_id = v
				i = ii
			}
			2 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			3 {
				res.has_viewer_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.viewer_steamid = v
				i = ii
			}
			4 {
				res.has_viewer_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.viewer_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcstart_notification() CBroadcast_WebRTCStart_Notification {
	return CBroadcast_WebRTCStart_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcstart_notification(o CBroadcast_WebRTCStart_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcstart_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCStart_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcstart_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCSetAnswer_Notification {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	broadcast_session_id     u64
	has_broadcast_session_id bool
	webrtc_session_id        u64
	has_webrtc_session_id    bool
	answer                   string
	has_answer               bool
}

pub fn (o &CBroadcast_WebRTCSetAnswer_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_session_id {
		res << vproto.pack_64bit_field(o.broadcast_session_id, 1)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 2)
	}
	if o.has_answer {
		res << vproto.pack_string_field(o.answer, 3)
	}
	return res
}

pub fn cbroadcast_webrtcsetanswer_notification_unpack(buf []byte) ?CBroadcast_WebRTCSetAnswer_Notification {
	mut res := CBroadcast_WebRTCSetAnswer_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_session_id = v
				i = ii
			}
			2 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			3 {
				res.has_answer = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.answer = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcsetanswer_notification() CBroadcast_WebRTCSetAnswer_Notification {
	return CBroadcast_WebRTCSetAnswer_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcsetanswer_notification(o CBroadcast_WebRTCSetAnswer_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcsetanswer_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCSetAnswer_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcsetanswer_notification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcast_WebRTCAddViewerCandidate_Notification {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	broadcast_session_id     u64
	has_broadcast_session_id bool
	webrtc_session_id        u64
	has_webrtc_session_id    bool
	candidate                CBroadcast_WebRTC_Candidate
	has_candidate            bool
}

pub fn (o &CBroadcast_WebRTCAddViewerCandidate_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_session_id {
		res << vproto.pack_64bit_field(o.broadcast_session_id, 1)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 2)
	}
	if o.has_candidate {
		res << zzz_vproto_internal_pack_cbroadcast_webrtc_candidate(o.candidate, 3)
	}
	return res
}

pub fn cbroadcast_webrtcaddviewercandidate_notification_unpack(buf []byte) ?CBroadcast_WebRTCAddViewerCandidate_Notification {
	mut res := CBroadcast_WebRTCAddViewerCandidate_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_session_id = v
				i = ii
			}
			2 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			3 {
				res.has_candidate = true
				ii, v := zzz_vproto_internal_unpack_cbroadcast_webrtc_candidate(cur_buf,
					tag_wiretype.wire_type)?
				res.candidate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcast_webrtcaddviewercandidate_notification() CBroadcast_WebRTCAddViewerCandidate_Notification {
	return CBroadcast_WebRTCAddViewerCandidate_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcast_webrtcaddviewercandidate_notification(o CBroadcast_WebRTCAddViewerCandidate_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcast_webrtcaddviewercandidate_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcast_WebRTCAddViewerCandidate_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcast_webrtcaddviewercandidate_notification_unpack(v)?
	return i, unpacked
}
