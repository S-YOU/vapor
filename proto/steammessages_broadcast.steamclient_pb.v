// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EBroadcastWatchLocation {
	k_ebroadcastwatchlocation_invalid = 0
	k_ebroadcastwatchlocation_steamtv_tab = 1
	k_ebroadcastwatchlocation_steamtv_watchparty = 2
	k_ebroadcastwatchlocation_chat_tab = 3
	k_ebroadcastwatchlocation_chat_watchparty = 4
	k_ebroadcastwatchlocation_communitypage = 5
	k_ebroadcastwatchlocation_storeapppage = 6
	k_ebroadcastwatchlocation_ingame = 7
	k_ebroadcastwatchlocation_bigpicture = 8
	k_ebroadcastwatchlocation_salespage = 9
	k_ebroadcastwatchlocation_curatorpage = 10
	k_ebroadcastwatchlocation_developerpage = 11
	k_ebroadcastwatchlocation_chat_friends = 12
	k_ebroadcastwatchlocation_steamtv_web = 13
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_ebroadcastwatchlocation(e EBroadcastWatchLocation, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_ebroadcastwatchlocation(buf []byte, tag_wiretype vproto.WireType) ?(int, EBroadcastWatchLocation) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EBroadcastWatchLocation(v)
}

[_allow_multiple_values]
enum EBroadcastChatPermission {
	k_ebroadcastchatpermissionpublic = 0
	k_ebroadcastchatpermissionownsapp = 1
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_ebroadcastchatpermission(e EBroadcastChatPermission, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_ebroadcastchatpermission(buf []byte, tag_wiretype vproto.WireType) ?(int, EBroadcastChatPermission) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EBroadcastChatPermission(v)
}

pub struct CBroadcastBeginBroadcastSessionRequest {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	permission             int
	has_permission         bool
	gameid                 u64
	has_gameid             bool
	client_instance_id     u64
	has_client_instance_id bool
	title                  string
	has_title              bool
	cellid                 u32
	has_cellid             bool
	rtmp_token             u64
	has_rtmp_token         bool
	thumbnail_upload       bool
	has_thumbnail_upload   bool
	client_beta            string
	has_client_beta        bool
	sysid                  u32
	has_sysid              bool
	allow_webrtc           bool
	has_allow_webrtc       bool
}

pub fn (o &CBroadcastBeginBroadcastSessionRequest) pack() []byte {
	mut res := []byte{}
	if o.has_permission {
		res << vproto.pack_int32_field(o.permission, 1)
	}
	if o.has_gameid {
		res << vproto.pack_uint64_field(o.gameid, 2)
	}
	if o.has_client_instance_id {
		res << vproto.pack_uint64_field(o.client_instance_id, 3)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 4)
	}
	if o.has_cellid {
		res << vproto.pack_uint32_field(o.cellid, 5)
	}
	if o.has_rtmp_token {
		res << vproto.pack_uint64_field(o.rtmp_token, 6)
	}
	if o.has_thumbnail_upload {
		res << vproto.pack_bool_field(o.thumbnail_upload, 7)
	}
	if o.has_client_beta {
		res << vproto.pack_string_field(o.client_beta, 8)
	}
	if o.has_sysid {
		res << vproto.pack_uint32_field(o.sysid, 9)
	}
	if o.has_allow_webrtc {
		res << vproto.pack_bool_field(o.allow_webrtc, 10)
	}
	return res
}

pub fn cbroadcastbeginbroadcastsessionrequest_unpack(buf []byte) ?CBroadcastBeginBroadcastSessionRequest {
	mut res := CBroadcastBeginBroadcastSessionRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_permission = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.permission = v
				i = ii
			}
			2 {
				res.has_gameid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			3 {
				res.has_client_instance_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.client_instance_id = v
				i = ii
			}
			4 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			5 {
				res.has_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cellid = v
				i = ii
			}
			6 {
				res.has_rtmp_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.rtmp_token = v
				i = ii
			}
			7 {
				res.has_thumbnail_upload = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_upload = v
				i = ii
			}
			8 {
				res.has_client_beta = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.client_beta = v
				i = ii
			}
			9 {
				res.has_sysid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sysid = v
				i = ii
			}
			10 {
				res.has_allow_webrtc = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.allow_webrtc = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastbeginbroadcastsessionrequest() CBroadcastBeginBroadcastSessionRequest {
	return CBroadcastBeginBroadcastSessionRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastbeginbroadcastsessionrequest(o CBroadcastBeginBroadcastSessionRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastbeginbroadcastsessionrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastBeginBroadcastSessionRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastbeginbroadcastsessionrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastBeginBroadcastSessionResponse {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	broadcast_id                   u64
	has_broadcast_id               bool
	thumbnail_upload_address       string
	has_thumbnail_upload_address   bool
	thumbnail_upload_token         string
	has_thumbnail_upload_token     bool
	thumbnail_interval_seconds     u32
	has_thumbnail_interval_seconds bool
	heartbeat_interval_seconds     u32
	has_heartbeat_interval_seconds bool
}

pub fn (o &CBroadcastBeginBroadcastSessionResponse) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	if o.has_thumbnail_upload_address {
		res << vproto.pack_string_field(o.thumbnail_upload_address, 2)
	}
	if o.has_thumbnail_upload_token {
		res << vproto.pack_string_field(o.thumbnail_upload_token, 3)
	}
	if o.has_thumbnail_interval_seconds {
		res << vproto.pack_uint32_field(o.thumbnail_interval_seconds, 4)
	}
	if o.has_heartbeat_interval_seconds {
		res << vproto.pack_uint32_field(o.heartbeat_interval_seconds, 5)
	}
	return res
}

pub fn cbroadcastbeginbroadcastsessionresponse_unpack(buf []byte) ?CBroadcastBeginBroadcastSessionResponse {
	mut res := CBroadcastBeginBroadcastSessionResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			2 {
				res.has_thumbnail_upload_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_upload_address = v
				i = ii
			}
			3 {
				res.has_thumbnail_upload_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_upload_token = v
				i = ii
			}
			4 {
				res.has_thumbnail_interval_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_interval_seconds = v
				i = ii
			}
			5 {
				res.has_heartbeat_interval_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.heartbeat_interval_seconds = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastbeginbroadcastsessionresponse() CBroadcastBeginBroadcastSessionResponse {
	return CBroadcastBeginBroadcastSessionResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastbeginbroadcastsessionresponse(o CBroadcastBeginBroadcastSessionResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastbeginbroadcastsessionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastBeginBroadcastSessionResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastbeginbroadcastsessionresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastEndBroadcastSessionRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	broadcast_id     u64
	has_broadcast_id bool
}

pub fn (o &CBroadcastEndBroadcastSessionRequest) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	return res
}

pub fn cbroadcastendbroadcastsessionrequest_unpack(buf []byte) ?CBroadcastEndBroadcastSessionRequest {
	mut res := CBroadcastEndBroadcastSessionRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastendbroadcastsessionrequest() CBroadcastEndBroadcastSessionRequest {
	return CBroadcastEndBroadcastSessionRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastendbroadcastsessionrequest(o CBroadcastEndBroadcastSessionRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastendbroadcastsessionrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastEndBroadcastSessionRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastendbroadcastsessionrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastEndBroadcastSessionResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcastEndBroadcastSessionResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcastendbroadcastsessionresponse_unpack(buf []byte) ?CBroadcastEndBroadcastSessionResponse {
	res := CBroadcastEndBroadcastSessionResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastendbroadcastsessionresponse() CBroadcastEndBroadcastSessionResponse {
	return CBroadcastEndBroadcastSessionResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastendbroadcastsessionresponse(o CBroadcastEndBroadcastSessionResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastendbroadcastsessionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastEndBroadcastSessionResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastendbroadcastsessionresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastStartBroadcastUploadRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	broadcast_id          u64
	has_broadcast_id      bool
	cellid                u32
	has_cellid            bool
	as_rtmp               bool
	has_as_rtmp           bool
	delay_seconds         u32
	has_delay_seconds     bool
	rtmp_token            u64
	has_rtmp_token        bool
	upload_ip_address     u32
	has_upload_ip_address bool
	is_replay             bool
	has_is_replay         bool
	sysid                 u32
	has_sysid             bool
}

pub fn (o &CBroadcastStartBroadcastUploadRequest) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	if o.has_cellid {
		res << vproto.pack_uint32_field(o.cellid, 2)
	}
	if o.has_as_rtmp {
		res << vproto.pack_bool_field(o.as_rtmp, 3)
	}
	if o.has_delay_seconds {
		res << vproto.pack_uint32_field(o.delay_seconds, 4)
	}
	if o.has_rtmp_token {
		res << vproto.pack_uint64_field(o.rtmp_token, 5)
	}
	if o.has_upload_ip_address {
		res << vproto.pack_uint32_field(o.upload_ip_address, 6)
	}
	if o.has_is_replay {
		res << vproto.pack_bool_field(o.is_replay, 7)
	}
	if o.has_sysid {
		res << vproto.pack_uint32_field(o.sysid, 8)
	}
	return res
}

pub fn cbroadcaststartbroadcastuploadrequest_unpack(buf []byte) ?CBroadcastStartBroadcastUploadRequest {
	mut res := CBroadcastStartBroadcastUploadRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			2 {
				res.has_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cellid = v
				i = ii
			}
			3 {
				res.has_as_rtmp = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.as_rtmp = v
				i = ii
			}
			4 {
				res.has_delay_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.delay_seconds = v
				i = ii
			}
			5 {
				res.has_rtmp_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.rtmp_token = v
				i = ii
			}
			6 {
				res.has_upload_ip_address = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_ip_address = v
				i = ii
			}
			7 {
				res.has_is_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_replay = v
				i = ii
			}
			8 {
				res.has_sysid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sysid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcaststartbroadcastuploadrequest() CBroadcastStartBroadcastUploadRequest {
	return CBroadcastStartBroadcastUploadRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcaststartbroadcastuploadrequest(o CBroadcastStartBroadcastUploadRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcaststartbroadcastuploadrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastStartBroadcastUploadRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcaststartbroadcastuploadrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastStartBroadcastUploadResponse {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	upload_token            string
	has_upload_token        bool
	upload_address          string
	has_upload_address      bool
	broadcast_upload_id     u64
	has_broadcast_upload_id bool
	enable_replay           bool
	has_enable_replay       bool
	http_address            string
	has_http_address        bool
}

pub fn (o &CBroadcastStartBroadcastUploadResponse) pack() []byte {
	mut res := []byte{}
	if o.has_upload_token {
		res << vproto.pack_string_field(o.upload_token, 1)
	}
	if o.has_upload_address {
		res << vproto.pack_string_field(o.upload_address, 2)
	}
	if o.has_broadcast_upload_id {
		res << vproto.pack_64bit_field(o.broadcast_upload_id, 3)
	}
	if o.has_enable_replay {
		res << vproto.pack_bool_field(o.enable_replay, 6)
	}
	if o.has_http_address {
		res << vproto.pack_string_field(o.http_address, 7)
	}
	return res
}

pub fn cbroadcaststartbroadcastuploadresponse_unpack(buf []byte) ?CBroadcastStartBroadcastUploadResponse {
	mut res := CBroadcastStartBroadcastUploadResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_upload_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_token = v
				i = ii
			}
			2 {
				res.has_upload_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_address = v
				i = ii
			}
			3 {
				res.has_broadcast_upload_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_upload_id = v
				i = ii
			}
			6 {
				res.has_enable_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_replay = v
				i = ii
			}
			7 {
				res.has_http_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.http_address = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcaststartbroadcastuploadresponse() CBroadcastStartBroadcastUploadResponse {
	return CBroadcastStartBroadcastUploadResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcaststartbroadcastuploadresponse(o CBroadcastStartBroadcastUploadResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcaststartbroadcastuploadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastStartBroadcastUploadResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcaststartbroadcastuploadresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastNotifyBroadcastUploadStopNotification {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	broadcast_upload_id     u64
	has_broadcast_upload_id bool
	upload_result           u32
	has_upload_result       bool
}

pub fn (o &CBroadcastNotifyBroadcastUploadStopNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_upload_id {
		res << vproto.pack_64bit_field(o.broadcast_upload_id, 1)
	}
	if o.has_upload_result {
		res << vproto.pack_uint32_field(o.upload_result, 2)
	}
	return res
}

pub fn cbroadcastnotifybroadcastuploadstopnotification_unpack(buf []byte) ?CBroadcastNotifyBroadcastUploadStopNotification {
	mut res := CBroadcastNotifyBroadcastUploadStopNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_upload_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_upload_id = v
				i = ii
			}
			2 {
				res.has_upload_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_result = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastnotifybroadcastuploadstopnotification() CBroadcastNotifyBroadcastUploadStopNotification {
	return CBroadcastNotifyBroadcastUploadStopNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastnotifybroadcastuploadstopnotification(o CBroadcastNotifyBroadcastUploadStopNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastnotifybroadcastuploadstopnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastNotifyBroadcastUploadStopNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastnotifybroadcastuploadstopnotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWatchBroadcastRequest {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	steamid                   u64
	has_steamid               bool
	existing_broadcast_id     u64
	has_existing_broadcast_id bool
	viewer_token              u64
	has_viewer_token          bool
	client_ip                 u32
	has_client_ip             bool
	client_cell               u32
	has_client_cell           bool
	watch_location            EBroadcastWatchLocation
	has_watch_location        bool
	is_webrtc                 bool
	has_is_webrtc             bool
}

pub fn (o &CBroadcastWatchBroadcastRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_existing_broadcast_id {
		res << vproto.pack_64bit_field(o.existing_broadcast_id, 2)
	}
	if o.has_viewer_token {
		res << vproto.pack_64bit_field(o.viewer_token, 3)
	}
	if o.has_client_ip {
		res << vproto.pack_uint32_field(o.client_ip, 4)
	}
	if o.has_client_cell {
		res << vproto.pack_uint32_field(o.client_cell, 5)
	}
	if o.has_watch_location {
		res << zzz_vproto_internal_pack_ebroadcastwatchlocation(o.watch_location, 6)
	}
	if o.has_is_webrtc {
		res << vproto.pack_bool_field(o.is_webrtc, 7)
	}
	return res
}

pub fn cbroadcastwatchbroadcastrequest_unpack(buf []byte) ?CBroadcastWatchBroadcastRequest {
	mut res := CBroadcastWatchBroadcastRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_existing_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.existing_broadcast_id = v
				i = ii
			}
			3 {
				res.has_viewer_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.viewer_token = v
				i = ii
			}
			4 {
				res.has_client_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_ip = v
				i = ii
			}
			5 {
				res.has_client_cell = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_cell = v
				i = ii
			}
			6 {
				res.has_watch_location = true
				ii, v := zzz_vproto_internal_unpack_ebroadcastwatchlocation(cur_buf, tag_wiretype.wire_type)?
				res.watch_location = v
				i = ii
			}
			7 {
				res.has_is_webrtc = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_webrtc = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwatchbroadcastrequest() CBroadcastWatchBroadcastRequest {
	return CBroadcastWatchBroadcastRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwatchbroadcastrequest(o CBroadcastWatchBroadcastRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwatchbroadcastrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWatchBroadcastRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwatchbroadcastrequest_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CBroadcastWatchBroadcastResponseEWatchResponse {
	k_ewatchresponseready = 1
	k_ewatchresponsenotavailable = 2
	k_ewatchresponsewaitingforapproval = 3
	k_ewatchresponsewaitingforstart = 4
	k_ewatchresponseinvalidsession = 5
	k_ewatchresponsetoomanybroadcasts = 6
	k_ewatchresponsewaitingforreconnect = 7
	k_ewatchresponsesystemnotsupported = 8
	k_ewatchresponseuserrestricted = 9
	k_ewatchresponseclientoutofdate = 10
	k_ewatchresponsepooruploadquality = 11
	k_ewatchresponsemissingsubscription = 12
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cbroadcastwatchbroadcastresponseewatchresponse(e CBroadcastWatchBroadcastResponseEWatchResponse, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cbroadcastwatchbroadcastresponseewatchresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWatchBroadcastResponseEWatchResponse) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CBroadcastWatchBroadcastResponseEWatchResponse(v)
}

pub struct CBroadcastWatchBroadcastResponse {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	response                CBroadcastWatchBroadcastResponseEWatchResponse
	has_response            bool
	mpd_url                 string
	has_mpd_url             bool
	broadcast_id            u64
	has_broadcast_id        bool
	gameid                  u64
	has_gameid              bool
	title                   string
	has_title               bool
	num_viewers             u32
	has_num_viewers         bool
	permission              int
	has_permission          bool
	is_rtmp                 bool
	has_is_rtmp             bool
	seconds_delay           int
	has_seconds_delay       bool
	viewer_token            u64
	has_viewer_token        bool
	hls_m3u8_master_url     string
	has_hls_m3u8_master_url bool
	heartbeat_interval      int
	has_heartbeat_interval  bool
	thumbnail_url           string
	has_thumbnail_url       bool
	is_webrtc               bool
	has_is_webrtc           bool
	webrtc_session_id       u64
	has_webrtc_session_id   bool
	webrtc_offer_sdp        string
	has_webrtc_offer_sdp    bool
	webrtc_turn_server      string
	has_webrtc_turn_server  bool
	is_replay               bool
	has_is_replay           bool
	duration                int
	has_duration            bool
}

pub fn (o &CBroadcastWatchBroadcastResponse) pack() []byte {
	mut res := []byte{}
	if o.has_response {
		res <<
			zzz_vproto_internal_pack_cbroadcastwatchbroadcastresponseewatchresponse(o.response, 1)
	}
	if o.has_mpd_url {
		res << vproto.pack_string_field(o.mpd_url, 2)
	}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 3)
	}
	if o.has_gameid {
		res << vproto.pack_uint64_field(o.gameid, 4)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 5)
	}
	if o.has_num_viewers {
		res << vproto.pack_uint32_field(o.num_viewers, 6)
	}
	if o.has_permission {
		res << vproto.pack_int32_field(o.permission, 7)
	}
	if o.has_is_rtmp {
		res << vproto.pack_bool_field(o.is_rtmp, 8)
	}
	if o.has_seconds_delay {
		res << vproto.pack_int32_field(o.seconds_delay, 9)
	}
	if o.has_viewer_token {
		res << vproto.pack_64bit_field(o.viewer_token, 10)
	}
	if o.has_hls_m3u8_master_url {
		res << vproto.pack_string_field(o.hls_m3u8_master_url, 11)
	}
	if o.has_heartbeat_interval {
		res << vproto.pack_int32_field(o.heartbeat_interval, 12)
	}
	if o.has_thumbnail_url {
		res << vproto.pack_string_field(o.thumbnail_url, 13)
	}
	if o.has_is_webrtc {
		res << vproto.pack_bool_field(o.is_webrtc, 14)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 15)
	}
	if o.has_webrtc_offer_sdp {
		res << vproto.pack_string_field(o.webrtc_offer_sdp, 16)
	}
	if o.has_webrtc_turn_server {
		res << vproto.pack_string_field(o.webrtc_turn_server, 17)
	}
	if o.has_is_replay {
		res << vproto.pack_bool_field(o.is_replay, 18)
	}
	if o.has_duration {
		res << vproto.pack_int32_field(o.duration, 19)
	}
	return res
}

pub fn cbroadcastwatchbroadcastresponse_unpack(buf []byte) ?CBroadcastWatchBroadcastResponse {
	mut res := CBroadcastWatchBroadcastResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_response = true
				ii, v := zzz_vproto_internal_unpack_cbroadcastwatchbroadcastresponseewatchresponse(cur_buf,
					tag_wiretype.wire_type)?
				res.response = v
				i = ii
			}
			2 {
				res.has_mpd_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.mpd_url = v
				i = ii
			}
			3 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			4 {
				res.has_gameid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			5 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			6 {
				res.has_num_viewers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_viewers = v
				i = ii
			}
			7 {
				res.has_permission = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.permission = v
				i = ii
			}
			8 {
				res.has_is_rtmp = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_rtmp = v
				i = ii
			}
			9 {
				res.has_seconds_delay = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_delay = v
				i = ii
			}
			10 {
				res.has_viewer_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.viewer_token = v
				i = ii
			}
			11 {
				res.has_hls_m3u8_master_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.hls_m3u8_master_url = v
				i = ii
			}
			12 {
				res.has_heartbeat_interval = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.heartbeat_interval = v
				i = ii
			}
			13 {
				res.has_thumbnail_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_url = v
				i = ii
			}
			14 {
				res.has_is_webrtc = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_webrtc = v
				i = ii
			}
			15 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			16 {
				res.has_webrtc_offer_sdp = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_offer_sdp = v
				i = ii
			}
			17 {
				res.has_webrtc_turn_server = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_turn_server = v
				i = ii
			}
			18 {
				res.has_is_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_replay = v
				i = ii
			}
			19 {
				res.has_duration = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.duration = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwatchbroadcastresponse() CBroadcastWatchBroadcastResponse {
	return CBroadcastWatchBroadcastResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwatchbroadcastresponse(o CBroadcastWatchBroadcastResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwatchbroadcastresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWatchBroadcastResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwatchbroadcastresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastHeartbeatBroadcastNotification {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	steamid            u64
	has_steamid        bool
	broadcast_id       u64
	has_broadcast_id   bool
	viewer_token       u64
	has_viewer_token   bool
	representation     u32
	has_representation bool
}

pub fn (o &CBroadcastHeartbeatBroadcastNotification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 2)
	}
	if o.has_viewer_token {
		res << vproto.pack_64bit_field(o.viewer_token, 3)
	}
	if o.has_representation {
		res << vproto.pack_uint32_field(o.representation, 4)
	}
	return res
}

pub fn cbroadcastheartbeatbroadcastnotification_unpack(buf []byte) ?CBroadcastHeartbeatBroadcastNotification {
	mut res := CBroadcastHeartbeatBroadcastNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			3 {
				res.has_viewer_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.viewer_token = v
				i = ii
			}
			4 {
				res.has_representation = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.representation = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastheartbeatbroadcastnotification() CBroadcastHeartbeatBroadcastNotification {
	return CBroadcastHeartbeatBroadcastNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastheartbeatbroadcastnotification(o CBroadcastHeartbeatBroadcastNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastheartbeatbroadcastnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastHeartbeatBroadcastNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastheartbeatbroadcastnotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastStopWatchingBroadcastNotification {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	broadcast_id     u64
	has_broadcast_id bool
	viewer_token     u64
	has_viewer_token bool
}

pub fn (o &CBroadcastStopWatchingBroadcastNotification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 2)
	}
	if o.has_viewer_token {
		res << vproto.pack_64bit_field(o.viewer_token, 3)
	}
	return res
}

pub fn cbroadcaststopwatchingbroadcastnotification_unpack(buf []byte) ?CBroadcastStopWatchingBroadcastNotification {
	mut res := CBroadcastStopWatchingBroadcastNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			3 {
				res.has_viewer_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.viewer_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcaststopwatchingbroadcastnotification() CBroadcastStopWatchingBroadcastNotification {
	return CBroadcastStopWatchingBroadcastNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcaststopwatchingbroadcastnotification(o CBroadcastStopWatchingBroadcastNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcaststopwatchingbroadcastnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastStopWatchingBroadcastNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcaststopwatchingbroadcastnotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastStatusRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	broadcast_id     u64
	has_broadcast_id bool
}

pub fn (o &CBroadcastGetBroadcastStatusRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 2)
	}
	return res
}

pub fn cbroadcastgetbroadcaststatusrequest_unpack(buf []byte) ?CBroadcastGetBroadcastStatusRequest {
	mut res := CBroadcastGetBroadcastStatusRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcaststatusrequest() CBroadcastGetBroadcastStatusRequest {
	return CBroadcastGetBroadcastStatusRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcaststatusrequest(o CBroadcastGetBroadcastStatusRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcaststatusrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastStatusRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcaststatusrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastStatusResponse {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	gameid                   u64
	has_gameid               bool
	title                    string
	has_title                bool
	num_viewers              u32
	has_num_viewers          bool
	permission               int
	has_permission           bool
	is_rtmp                  bool
	has_is_rtmp              bool
	seconds_delay            int
	has_seconds_delay        bool
	is_publisher             bool
	has_is_publisher         bool
	thumbnail_url            string
	has_thumbnail_url        bool
	update_interval          int
	has_update_interval      bool
	is_uploading             bool
	has_is_uploading         bool
	duration                 u32
	has_duration             bool
	is_replay                bool
	has_is_replay            bool
	is_capturing_vod         bool
	has_is_capturing_vod     bool
	is_store_whitelisted     bool
	has_is_store_whitelisted bool
}

pub fn (o &CBroadcastGetBroadcastStatusResponse) pack() []byte {
	mut res := []byte{}
	if o.has_gameid {
		res << vproto.pack_uint64_field(o.gameid, 1)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 2)
	}
	if o.has_num_viewers {
		res << vproto.pack_uint32_field(o.num_viewers, 3)
	}
	if o.has_permission {
		res << vproto.pack_int32_field(o.permission, 4)
	}
	if o.has_is_rtmp {
		res << vproto.pack_bool_field(o.is_rtmp, 5)
	}
	if o.has_seconds_delay {
		res << vproto.pack_int32_field(o.seconds_delay, 6)
	}
	if o.has_is_publisher {
		res << vproto.pack_bool_field(o.is_publisher, 7)
	}
	if o.has_thumbnail_url {
		res << vproto.pack_string_field(o.thumbnail_url, 8)
	}
	if o.has_update_interval {
		res << vproto.pack_int32_field(o.update_interval, 9)
	}
	if o.has_is_uploading {
		res << vproto.pack_bool_field(o.is_uploading, 10)
	}
	if o.has_duration {
		res << vproto.pack_uint32_field(o.duration, 11)
	}
	if o.has_is_replay {
		res << vproto.pack_bool_field(o.is_replay, 12)
	}
	if o.has_is_capturing_vod {
		res << vproto.pack_bool_field(o.is_capturing_vod, 13)
	}
	if o.has_is_store_whitelisted {
		res << vproto.pack_bool_field(o.is_store_whitelisted, 14)
	}
	return res
}

pub fn cbroadcastgetbroadcaststatusresponse_unpack(buf []byte) ?CBroadcastGetBroadcastStatusResponse {
	mut res := CBroadcastGetBroadcastStatusResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_gameid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			2 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			3 {
				res.has_num_viewers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_viewers = v
				i = ii
			}
			4 {
				res.has_permission = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.permission = v
				i = ii
			}
			5 {
				res.has_is_rtmp = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_rtmp = v
				i = ii
			}
			6 {
				res.has_seconds_delay = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_delay = v
				i = ii
			}
			7 {
				res.has_is_publisher = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_publisher = v
				i = ii
			}
			8 {
				res.has_thumbnail_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_url = v
				i = ii
			}
			9 {
				res.has_update_interval = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.update_interval = v
				i = ii
			}
			10 {
				res.has_is_uploading = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_uploading = v
				i = ii
			}
			11 {
				res.has_duration = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.duration = v
				i = ii
			}
			12 {
				res.has_is_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_replay = v
				i = ii
			}
			13 {
				res.has_is_capturing_vod = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_capturing_vod = v
				i = ii
			}
			14 {
				res.has_is_store_whitelisted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_store_whitelisted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcaststatusresponse() CBroadcastGetBroadcastStatusResponse {
	return CBroadcastGetBroadcastStatusResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcaststatusresponse(o CBroadcastGetBroadcastStatusResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcaststatusresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastStatusResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcaststatusresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastThumbnailRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	broadcast_id     u64
	has_broadcast_id bool
}

pub fn (o &CBroadcastGetBroadcastThumbnailRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 2)
	}
	return res
}

pub fn cbroadcastgetbroadcastthumbnailrequest_unpack(buf []byte) ?CBroadcastGetBroadcastThumbnailRequest {
	mut res := CBroadcastGetBroadcastThumbnailRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastthumbnailrequest() CBroadcastGetBroadcastThumbnailRequest {
	return CBroadcastGetBroadcastThumbnailRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastthumbnailrequest(o CBroadcastGetBroadcastThumbnailRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastthumbnailrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastThumbnailRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastthumbnailrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastThumbnailResponse {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	thumbnail_url       string
	has_thumbnail_url   bool
	update_interval     int
	has_update_interval bool
	num_viewers         int
	has_num_viewers     bool
	duration            int
	has_duration        bool
}

pub fn (o &CBroadcastGetBroadcastThumbnailResponse) pack() []byte {
	mut res := []byte{}
	if o.has_thumbnail_url {
		res << vproto.pack_string_field(o.thumbnail_url, 1)
	}
	if o.has_update_interval {
		res << vproto.pack_int32_field(o.update_interval, 2)
	}
	if o.has_num_viewers {
		res << vproto.pack_int32_field(o.num_viewers, 3)
	}
	if o.has_duration {
		res << vproto.pack_int32_field(o.duration, 4)
	}
	return res
}

pub fn cbroadcastgetbroadcastthumbnailresponse_unpack(buf []byte) ?CBroadcastGetBroadcastThumbnailResponse {
	mut res := CBroadcastGetBroadcastThumbnailResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_thumbnail_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_url = v
				i = ii
			}
			2 {
				res.has_update_interval = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.update_interval = v
				i = ii
			}
			3 {
				res.has_num_viewers = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_viewers = v
				i = ii
			}
			4 {
				res.has_duration = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.duration = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastthumbnailresponse() CBroadcastGetBroadcastThumbnailResponse {
	return CBroadcastGetBroadcastThumbnailResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastthumbnailresponse(o CBroadcastGetBroadcastThumbnailResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastthumbnailresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastThumbnailResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastthumbnailresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastInviteToBroadcastRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steamid               u64
	has_steamid           bool
	approval_response     bool
	has_approval_response bool
}

pub fn (o &CBroadcastInviteToBroadcastRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_approval_response {
		res << vproto.pack_bool_field(o.approval_response, 2)
	}
	return res
}

pub fn cbroadcastinvitetobroadcastrequest_unpack(buf []byte) ?CBroadcastInviteToBroadcastRequest {
	mut res := CBroadcastInviteToBroadcastRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_approval_response = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.approval_response = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastinvitetobroadcastrequest() CBroadcastInviteToBroadcastRequest {
	return CBroadcastInviteToBroadcastRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastinvitetobroadcastrequest(o CBroadcastInviteToBroadcastRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastinvitetobroadcastrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastInviteToBroadcastRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastinvitetobroadcastrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastInviteToBroadcastResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	success        bool
	has_success    bool
}

pub fn (o &CBroadcastInviteToBroadcastResponse) pack() []byte {
	mut res := []byte{}
	if o.has_success {
		res << vproto.pack_bool_field(o.success, 1)
	}
	return res
}

pub fn cbroadcastinvitetobroadcastresponse_unpack(buf []byte) ?CBroadcastInviteToBroadcastResponse {
	mut res := CBroadcastInviteToBroadcastResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_success = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.success = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastinvitetobroadcastresponse() CBroadcastInviteToBroadcastResponse {
	return CBroadcastInviteToBroadcastResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastinvitetobroadcastresponse(o CBroadcastInviteToBroadcastResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastinvitetobroadcastresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastInviteToBroadcastResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastinvitetobroadcastresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastSendBroadcastStateToServerRequest {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	permission           int
	has_permission       bool
	gameid               u64
	has_gameid           bool
	title                string
	has_title            bool
	game_data_config     string
	has_game_data_config bool
}

pub fn (o &CBroadcastSendBroadcastStateToServerRequest) pack() []byte {
	mut res := []byte{}
	if o.has_permission {
		res << vproto.pack_int32_field(o.permission, 1)
	}
	if o.has_gameid {
		res << vproto.pack_uint64_field(o.gameid, 2)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 3)
	}
	if o.has_game_data_config {
		res << vproto.pack_string_field(o.game_data_config, 4)
	}
	return res
}

pub fn cbroadcastsendbroadcaststatetoserverrequest_unpack(buf []byte) ?CBroadcastSendBroadcastStateToServerRequest {
	mut res := CBroadcastSendBroadcastStateToServerRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_permission = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.permission = v
				i = ii
			}
			2 {
				res.has_gameid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			3 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			4 {
				res.has_game_data_config = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_data_config = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastsendbroadcaststatetoserverrequest() CBroadcastSendBroadcastStateToServerRequest {
	return CBroadcastSendBroadcastStateToServerRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastsendbroadcaststatetoserverrequest(o CBroadcastSendBroadcastStateToServerRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastsendbroadcaststatetoserverrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastSendBroadcastStateToServerRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastsendbroadcaststatetoserverrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastSendBroadcastStateToServerResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcastSendBroadcastStateToServerResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcastsendbroadcaststatetoserverresponse_unpack(buf []byte) ?CBroadcastSendBroadcastStateToServerResponse {
	res := CBroadcastSendBroadcastStateToServerResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastsendbroadcaststatetoserverresponse() CBroadcastSendBroadcastStateToServerResponse {
	return CBroadcastSendBroadcastStateToServerResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastsendbroadcaststatetoserverresponse(o CBroadcastSendBroadcastStateToServerResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastsendbroadcaststatetoserverresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastSendBroadcastStateToServerResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastsendbroadcaststatetoserverresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastNotifyBroadcastSessionHeartbeatNotification {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	broadcast_id     u64
	has_broadcast_id bool
}

pub fn (o &CBroadcastNotifyBroadcastSessionHeartbeatNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	return res
}

pub fn cbroadcastnotifybroadcastsessionheartbeatnotification_unpack(buf []byte) ?CBroadcastNotifyBroadcastSessionHeartbeatNotification {
	mut res := CBroadcastNotifyBroadcastSessionHeartbeatNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastnotifybroadcastsessionheartbeatnotification() CBroadcastNotifyBroadcastSessionHeartbeatNotification {
	return CBroadcastNotifyBroadcastSessionHeartbeatNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastnotifybroadcastsessionheartbeatnotification(o CBroadcastNotifyBroadcastSessionHeartbeatNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastnotifybroadcastsessionheartbeatnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastNotifyBroadcastSessionHeartbeatNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastnotifybroadcastsessionheartbeatnotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastChatInfoRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	broadcast_id     u64
	has_broadcast_id bool
	client_ip        u32
	has_client_ip    bool
	client_cell      u32
	has_client_cell  bool
}

pub fn (o &CBroadcastGetBroadcastChatInfoRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 2)
	}
	if o.has_client_ip {
		res << vproto.pack_uint32_field(o.client_ip, 3)
	}
	if o.has_client_cell {
		res << vproto.pack_uint32_field(o.client_cell, 4)
	}
	return res
}

pub fn cbroadcastgetbroadcastchatinforequest_unpack(buf []byte) ?CBroadcastGetBroadcastChatInfoRequest {
	mut res := CBroadcastGetBroadcastChatInfoRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			3 {
				res.has_client_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_ip = v
				i = ii
			}
			4 {
				res.has_client_cell = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_cell = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastchatinforequest() CBroadcastGetBroadcastChatInfoRequest {
	return CBroadcastGetBroadcastChatInfoRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastchatinforequest(o CBroadcastGetBroadcastChatInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastchatinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastChatInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastchatinforequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastChatInfoResponse {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	chat_id               u64
	has_chat_id           bool
	view_url_template     string
	has_view_url_template bool
	flair_group_ids       []u32
}

pub fn (o &CBroadcastGetBroadcastChatInfoResponse) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 1)
	}
	if o.has_view_url_template {
		res << vproto.pack_string_field(o.view_url_template, 3)
	}
	// [packed=false]
	for _, x in o.flair_group_ids {
		res << vproto.pack_uint32_field(x, 4)
	}
	return res
}

pub fn cbroadcastgetbroadcastchatinforesponse_unpack(buf []byte) ?CBroadcastGetBroadcastChatInfoResponse {
	mut res := CBroadcastGetBroadcastChatInfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_view_url_template = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.view_url_template = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flair_group_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastchatinforesponse() CBroadcastGetBroadcastChatInfoResponse {
	return CBroadcastGetBroadcastChatInfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastchatinforesponse(o CBroadcastGetBroadcastChatInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastchatinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastChatInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastchatinforesponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastPostChatMessageRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	chat_id          u64
	has_chat_id      bool
	message          string
	has_message      bool
	instance_id      u32
	has_instance_id  bool
	language         u32
	has_language     bool
	country_code     string
	has_country_code bool
}

pub fn (o &CBroadcastPostChatMessageRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 1)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 2)
	}
	if o.has_instance_id {
		res << vproto.pack_uint32_field(o.instance_id, 3)
	}
	if o.has_language {
		res << vproto.pack_uint32_field(o.language, 4)
	}
	if o.has_country_code {
		res << vproto.pack_string_field(o.country_code, 5)
	}
	return res
}

pub fn cbroadcastpostchatmessagerequest_unpack(buf []byte) ?CBroadcastPostChatMessageRequest {
	mut res := CBroadcastPostChatMessageRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			3 {
				res.has_instance_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.instance_id = v
				i = ii
			}
			4 {
				res.has_language = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			5 {
				res.has_country_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.country_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastpostchatmessagerequest() CBroadcastPostChatMessageRequest {
	return CBroadcastPostChatMessageRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastpostchatmessagerequest(o CBroadcastPostChatMessageRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastpostchatmessagerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastPostChatMessageRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastpostchatmessagerequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastPostChatMessageResponse {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	persona_name              string
	has_persona_name          bool
	in_game                   bool
	has_in_game               bool
	result                    int
	has_result                bool
	cooldown_time_seconds     int
	has_cooldown_time_seconds bool
}

pub fn (o &CBroadcastPostChatMessageResponse) pack() []byte {
	mut res := []byte{}
	if o.has_persona_name {
		res << vproto.pack_string_field(o.persona_name, 1)
	}
	if o.has_in_game {
		res << vproto.pack_bool_field(o.in_game, 2)
	}
	if o.has_result {
		res << vproto.pack_int32_field(o.result, 3)
	}
	if o.has_cooldown_time_seconds {
		res << vproto.pack_int32_field(o.cooldown_time_seconds, 4)
	}
	return res
}

pub fn cbroadcastpostchatmessageresponse_unpack(buf []byte) ?CBroadcastPostChatMessageResponse {
	mut res := CBroadcastPostChatMessageResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_persona_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_name = v
				i = ii
			}
			2 {
				res.has_in_game = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.in_game = v
				i = ii
			}
			3 {
				res.has_result = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			4 {
				res.has_cooldown_time_seconds = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.cooldown_time_seconds = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastpostchatmessageresponse() CBroadcastPostChatMessageResponse {
	return CBroadcastPostChatMessageResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastpostchatmessageresponse(o CBroadcastPostChatMessageResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastpostchatmessageresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastPostChatMessageResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastpostchatmessageresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastUpdateChatMessageFlairRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	chat_id        u64
	has_chat_id    bool
	flair          string
	has_flair      bool
}

pub fn (o &CBroadcastUpdateChatMessageFlairRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 1)
	}
	if o.has_flair {
		res << vproto.pack_string_field(o.flair, 2)
	}
	return res
}

pub fn cbroadcastupdatechatmessageflairrequest_unpack(buf []byte) ?CBroadcastUpdateChatMessageFlairRequest {
	mut res := CBroadcastUpdateChatMessageFlairRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_flair = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.flair = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastupdatechatmessageflairrequest() CBroadcastUpdateChatMessageFlairRequest {
	return CBroadcastUpdateChatMessageFlairRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastupdatechatmessageflairrequest(o CBroadcastUpdateChatMessageFlairRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastupdatechatmessageflairrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastUpdateChatMessageFlairRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastupdatechatmessageflairrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastUpdateChatMessageFlairResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         int
	has_result     bool
	chat_id        u64
	has_chat_id    bool
	flair          string
	has_flair      bool
}

pub fn (o &CBroadcastUpdateChatMessageFlairResponse) pack() []byte {
	mut res := []byte{}
	if o.has_result {
		res << vproto.pack_int32_field(o.result, 1)
	}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 2)
	}
	if o.has_flair {
		res << vproto.pack_string_field(o.flair, 3)
	}
	return res
}

pub fn cbroadcastupdatechatmessageflairresponse_unpack(buf []byte) ?CBroadcastUpdateChatMessageFlairResponse {
	mut res := CBroadcastUpdateChatMessageFlairResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_result = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			2 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			3 {
				res.has_flair = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.flair = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastupdatechatmessageflairresponse() CBroadcastUpdateChatMessageFlairResponse {
	return CBroadcastUpdateChatMessageFlairResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastupdatechatmessageflairresponse(o CBroadcastUpdateChatMessageFlairResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastupdatechatmessageflairresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastUpdateChatMessageFlairResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastupdatechatmessageflairresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastMuteBroadcastChatUserRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	chat_id          u64
	has_chat_id      bool
	user_steamid     u64
	has_user_steamid bool
	muted            bool
	has_muted        bool
}

pub fn (o &CBroadcastMuteBroadcastChatUserRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 1)
	}
	if o.has_user_steamid {
		res << vproto.pack_64bit_field(o.user_steamid, 2)
	}
	if o.has_muted {
		res << vproto.pack_bool_field(o.muted, 3)
	}
	return res
}

pub fn cbroadcastmutebroadcastchatuserrequest_unpack(buf []byte) ?CBroadcastMuteBroadcastChatUserRequest {
	mut res := CBroadcastMuteBroadcastChatUserRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_user_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.user_steamid = v
				i = ii
			}
			3 {
				res.has_muted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.muted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastmutebroadcastchatuserrequest() CBroadcastMuteBroadcastChatUserRequest {
	return CBroadcastMuteBroadcastChatUserRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastmutebroadcastchatuserrequest(o CBroadcastMuteBroadcastChatUserRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastmutebroadcastchatuserrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastMuteBroadcastChatUserRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastmutebroadcastchatuserrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastMuteBroadcastChatUserResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcastMuteBroadcastChatUserResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcastmutebroadcastchatuserresponse_unpack(buf []byte) ?CBroadcastMuteBroadcastChatUserResponse {
	res := CBroadcastMuteBroadcastChatUserResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastmutebroadcastchatuserresponse() CBroadcastMuteBroadcastChatUserResponse {
	return CBroadcastMuteBroadcastChatUserResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastmutebroadcastchatuserresponse(o CBroadcastMuteBroadcastChatUserResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastmutebroadcastchatuserresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastMuteBroadcastChatUserResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastmutebroadcastchatuserresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastRemoveUserChatTextRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	chat_id          u64
	has_chat_id      bool
	user_steamid     u64
	has_user_steamid bool
}

pub fn (o &CBroadcastRemoveUserChatTextRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 1)
	}
	if o.has_user_steamid {
		res << vproto.pack_64bit_field(o.user_steamid, 2)
	}
	return res
}

pub fn cbroadcastremoveuserchattextrequest_unpack(buf []byte) ?CBroadcastRemoveUserChatTextRequest {
	mut res := CBroadcastRemoveUserChatTextRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				res.has_user_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.user_steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastremoveuserchattextrequest() CBroadcastRemoveUserChatTextRequest {
	return CBroadcastRemoveUserChatTextRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastremoveuserchattextrequest(o CBroadcastRemoveUserChatTextRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastremoveuserchattextrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastRemoveUserChatTextRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastremoveuserchattextrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastRemoveUserChatTextResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcastRemoveUserChatTextResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcastremoveuserchattextresponse_unpack(buf []byte) ?CBroadcastRemoveUserChatTextResponse {
	res := CBroadcastRemoveUserChatTextResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastremoveuserchattextresponse() CBroadcastRemoveUserChatTextResponse {
	return CBroadcastRemoveUserChatTextResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastremoveuserchattextresponse(o CBroadcastRemoveUserChatTextResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastremoveuserchattextresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastRemoveUserChatTextResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastremoveuserchattextresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastChatUserNamesRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	chat_id        u64
	has_chat_id    bool
	user_steamid   []u64
}

pub fn (o &CBroadcastGetBroadcastChatUserNamesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_chat_id {
		res << vproto.pack_64bit_field(o.chat_id, 1)
	}
	// [packed=false]
	for _, x in o.user_steamid {
		res << vproto.pack_64bit_field(x, 2)
	}
	return res
}

pub fn cbroadcastgetbroadcastchatusernamesrequest_unpack(buf []byte) ?CBroadcastGetBroadcastChatUserNamesRequest {
	mut res := CBroadcastGetBroadcastChatUserNamesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_chat_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.user_steamid << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastchatusernamesrequest() CBroadcastGetBroadcastChatUserNamesRequest {
	return CBroadcastGetBroadcastChatUserNamesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastchatusernamesrequest(o CBroadcastGetBroadcastChatUserNamesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastchatusernamesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastChatUserNamesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastchatusernamesrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastChatUserNamesResponsePersonaName {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	has_steam_id   bool
	persona        string
	has_persona    bool
}

pub fn (o &CBroadcastGetBroadcastChatUserNamesResponsePersonaName) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.has_persona {
		res << vproto.pack_string_field(o.persona, 2)
	}
	return res
}

pub fn cbroadcastgetbroadcastchatusernamesresponsepersonaname_unpack(buf []byte) ?CBroadcastGetBroadcastChatUserNamesResponsePersonaName {
	mut res := CBroadcastGetBroadcastChatUserNamesResponsePersonaName{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			2 {
				res.has_persona = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastchatusernamesresponsepersonaname() CBroadcastGetBroadcastChatUserNamesResponsePersonaName {
	return CBroadcastGetBroadcastChatUserNamesResponsePersonaName{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastchatusernamesresponsepersonaname(o CBroadcastGetBroadcastChatUserNamesResponsePersonaName, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastchatusernamesresponsepersonaname(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastChatUserNamesResponsePersonaName) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastchatusernamesresponsepersonaname_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastChatUserNamesResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	persona_names  []CBroadcastGetBroadcastChatUserNamesResponsePersonaName
}

pub fn (o &CBroadcastGetBroadcastChatUserNamesResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.persona_names {
		res <<
			zzz_vproto_internal_pack_cbroadcastgetbroadcastchatusernamesresponsepersonaname(x, 1)
	}
	return res
}

pub fn cbroadcastgetbroadcastchatusernamesresponse_unpack(buf []byte) ?CBroadcastGetBroadcastChatUserNamesResponse {
	mut res := CBroadcastGetBroadcastChatUserNamesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cbroadcastgetbroadcastchatusernamesresponsepersonaname(cur_buf,
					tag_wiretype.wire_type)?
				res.persona_names << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastchatusernamesresponse() CBroadcastGetBroadcastChatUserNamesResponse {
	return CBroadcastGetBroadcastChatUserNamesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastchatusernamesresponse(o CBroadcastGetBroadcastChatUserNamesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastchatusernamesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastChatUserNamesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastchatusernamesresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastStartBuildClipRequest {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	steamid                  u64
	has_steamid              bool
	broadcast_session_id     u64
	has_broadcast_session_id bool
	first_segment            int
	has_first_segment        bool
	num_segments             int
	has_num_segments         bool
	clip_description         string
	has_clip_description     bool
}

pub fn (o &CBroadcastStartBuildClipRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_broadcast_session_id {
		res << vproto.pack_64bit_field(o.broadcast_session_id, 2)
	}
	if o.has_first_segment {
		res << vproto.pack_int32_field(o.first_segment, 3)
	}
	if o.has_num_segments {
		res << vproto.pack_int32_field(o.num_segments, 4)
	}
	if o.has_clip_description {
		res << vproto.pack_string_field(o.clip_description, 5)
	}
	return res
}

pub fn cbroadcaststartbuildcliprequest_unpack(buf []byte) ?CBroadcastStartBuildClipRequest {
	mut res := CBroadcastStartBuildClipRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_session_id = v
				i = ii
			}
			3 {
				res.has_first_segment = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.first_segment = v
				i = ii
			}
			4 {
				res.has_num_segments = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_segments = v
				i = ii
			}
			5 {
				res.has_clip_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.clip_description = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcaststartbuildcliprequest() CBroadcastStartBuildClipRequest {
	return CBroadcastStartBuildClipRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcaststartbuildcliprequest(o CBroadcastStartBuildClipRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcaststartbuildcliprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastStartBuildClipRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcaststartbuildcliprequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastStartBuildClipResponse {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	broadcast_clip_id     u64
	has_broadcast_clip_id bool
}

pub fn (o &CBroadcastStartBuildClipResponse) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_clip_id {
		res << vproto.pack_64bit_field(o.broadcast_clip_id, 1)
	}
	return res
}

pub fn cbroadcaststartbuildclipresponse_unpack(buf []byte) ?CBroadcastStartBuildClipResponse {
	mut res := CBroadcastStartBuildClipResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_clip_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_clip_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcaststartbuildclipresponse() CBroadcastStartBuildClipResponse {
	return CBroadcastStartBuildClipResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcaststartbuildclipresponse(o CBroadcastStartBuildClipResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcaststartbuildclipresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastStartBuildClipResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcaststartbuildclipresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBuildClipStatusRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	broadcast_clip_id     u64
	has_broadcast_clip_id bool
}

pub fn (o &CBroadcastGetBuildClipStatusRequest) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_clip_id {
		res << vproto.pack_64bit_field(o.broadcast_clip_id, 1)
	}
	return res
}

pub fn cbroadcastgetbuildclipstatusrequest_unpack(buf []byte) ?CBroadcastGetBuildClipStatusRequest {
	mut res := CBroadcastGetBuildClipStatusRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_clip_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_clip_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbuildclipstatusrequest() CBroadcastGetBuildClipStatusRequest {
	return CBroadcastGetBuildClipStatusRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbuildclipstatusrequest(o CBroadcastGetBuildClipStatusRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbuildclipstatusrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBuildClipStatusRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbuildclipstatusrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBuildClipStatusResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcastGetBuildClipStatusResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcastgetbuildclipstatusresponse_unpack(buf []byte) ?CBroadcastGetBuildClipStatusResponse {
	res := CBroadcastGetBuildClipStatusResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbuildclipstatusresponse() CBroadcastGetBuildClipStatusResponse {
	return CBroadcastGetBuildClipStatusResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbuildclipstatusresponse(o CBroadcastGetBuildClipStatusResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbuildclipstatusresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBuildClipStatusResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbuildclipstatusresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastSetClipDetailsRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	broadcast_clip_id     u64
	has_broadcast_clip_id bool
	start_time            u32
	has_start_time        bool
	end_time              u32
	has_end_time          bool
	video_description     string
	has_video_description bool
}

pub fn (o &CBroadcastSetClipDetailsRequest) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_clip_id {
		res << vproto.pack_uint64_field(o.broadcast_clip_id, 1)
	}
	if o.has_start_time {
		res << vproto.pack_uint32_field(o.start_time, 2)
	}
	if o.has_end_time {
		res << vproto.pack_uint32_field(o.end_time, 3)
	}
	if o.has_video_description {
		res << vproto.pack_string_field(o.video_description, 4)
	}
	return res
}

pub fn cbroadcastsetclipdetailsrequest_unpack(buf []byte) ?CBroadcastSetClipDetailsRequest {
	mut res := CBroadcastSetClipDetailsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_clip_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_clip_id = v
				i = ii
			}
			2 {
				res.has_start_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_time = v
				i = ii
			}
			3 {
				res.has_end_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.end_time = v
				i = ii
			}
			4 {
				res.has_video_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.video_description = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastsetclipdetailsrequest() CBroadcastSetClipDetailsRequest {
	return CBroadcastSetClipDetailsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastsetclipdetailsrequest(o CBroadcastSetClipDetailsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastsetclipdetailsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastSetClipDetailsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastsetclipdetailsrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastSetClipDetailsResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcastSetClipDetailsResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcastsetclipdetailsresponse_unpack(buf []byte) ?CBroadcastSetClipDetailsResponse {
	res := CBroadcastSetClipDetailsResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastsetclipdetailsresponse() CBroadcastSetClipDetailsResponse {
	return CBroadcastSetClipDetailsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastsetclipdetailsresponse(o CBroadcastSetClipDetailsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastsetclipdetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastSetClipDetailsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastsetclipdetailsresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetClipDetailsRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	broadcast_clip_id     u64
	has_broadcast_clip_id bool
}

pub fn (o &CBroadcastGetClipDetailsRequest) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_clip_id {
		res << vproto.pack_uint64_field(o.broadcast_clip_id, 1)
	}
	return res
}

pub fn cbroadcastgetclipdetailsrequest_unpack(buf []byte) ?CBroadcastGetClipDetailsRequest {
	mut res := CBroadcastGetClipDetailsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_clip_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_clip_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetclipdetailsrequest() CBroadcastGetClipDetailsRequest {
	return CBroadcastGetClipDetailsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetclipdetailsrequest(o CBroadcastGetClipDetailsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetclipdetailsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetClipDetailsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetclipdetailsrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetClipDetailsResponse {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	broadcast_clip_id         u64
	has_broadcast_clip_id     bool
	video_id                  u64
	has_video_id              bool
	channel_id                u64
	has_channel_id            bool
	app_id                    u32
	has_app_id                bool
	accountid_broadcaster     u32
	has_accountid_broadcaster bool
	accountid_clipmaker       u32
	has_accountid_clipmaker   bool
	video_description         string
	has_video_description     bool
	start_time                u32
	has_start_time            bool
	length_milliseconds       u32
	has_length_milliseconds   bool
	thumbnail_path            string
	has_thumbnail_path        bool
}

pub fn (o &CBroadcastGetClipDetailsResponse) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_clip_id {
		res << vproto.pack_uint64_field(o.broadcast_clip_id, 1)
	}
	if o.has_video_id {
		res << vproto.pack_uint64_field(o.video_id, 2)
	}
	if o.has_channel_id {
		res << vproto.pack_uint64_field(o.channel_id, 3)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 4)
	}
	if o.has_accountid_broadcaster {
		res << vproto.pack_uint32_field(o.accountid_broadcaster, 5)
	}
	if o.has_accountid_clipmaker {
		res << vproto.pack_uint32_field(o.accountid_clipmaker, 6)
	}
	if o.has_video_description {
		res << vproto.pack_string_field(o.video_description, 7)
	}
	if o.has_start_time {
		res << vproto.pack_uint32_field(o.start_time, 8)
	}
	if o.has_length_milliseconds {
		res << vproto.pack_uint32_field(o.length_milliseconds, 9)
	}
	if o.has_thumbnail_path {
		res << vproto.pack_string_field(o.thumbnail_path, 10)
	}
	return res
}

pub fn cbroadcastgetclipdetailsresponse_unpack(buf []byte) ?CBroadcastGetClipDetailsResponse {
	mut res := CBroadcastGetClipDetailsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_clip_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_clip_id = v
				i = ii
			}
			2 {
				res.has_video_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.video_id = v
				i = ii
			}
			3 {
				res.has_channel_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.channel_id = v
				i = ii
			}
			4 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			5 {
				res.has_accountid_broadcaster = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_broadcaster = v
				i = ii
			}
			6 {
				res.has_accountid_clipmaker = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid_clipmaker = v
				i = ii
			}
			7 {
				res.has_video_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.video_description = v
				i = ii
			}
			8 {
				res.has_start_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_time = v
				i = ii
			}
			9 {
				res.has_length_milliseconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.length_milliseconds = v
				i = ii
			}
			10 {
				res.has_thumbnail_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_path = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetclipdetailsresponse() CBroadcastGetClipDetailsResponse {
	return CBroadcastGetClipDetailsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetclipdetailsresponse(o CBroadcastGetClipDetailsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetclipdetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetClipDetailsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetclipdetailsresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastSetRTmpinfoRequest {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	broadcast_permission          int
	has_broadcast_permission      bool
	update_token                  bool
	has_update_token              bool
	broadcast_delay               int
	has_broadcast_delay           bool
	app_id                        u32
	has_app_id                    bool
	required_app_id               u32
	has_required_app_id           bool
	broadcast_chat_permission     EBroadcastChatPermission
	has_broadcast_chat_permission bool
	broadcast_buffer              int
	has_broadcast_buffer          bool
	steamid                       u64
	has_steamid                   bool
	chat_rate_limit               u32
	has_chat_rate_limit           bool
	enable_replay                 bool
	has_enable_replay             bool
}

pub fn (o &CBroadcastSetRTmpinfoRequest) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_permission {
		res << vproto.pack_int32_field(o.broadcast_permission, 1)
	}
	if o.has_update_token {
		res << vproto.pack_bool_field(o.update_token, 2)
	}
	if o.has_broadcast_delay {
		res << vproto.pack_int32_field(o.broadcast_delay, 3)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 4)
	}
	if o.has_required_app_id {
		res << vproto.pack_uint32_field(o.required_app_id, 5)
	}
	if o.has_broadcast_chat_permission {
		res << zzz_vproto_internal_pack_ebroadcastchatpermission(o.broadcast_chat_permission, 6)
	}
	if o.has_broadcast_buffer {
		res << vproto.pack_int32_field(o.broadcast_buffer, 7)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 8)
	}
	if o.has_chat_rate_limit {
		res << vproto.pack_uint32_field(o.chat_rate_limit, 9)
	}
	if o.has_enable_replay {
		res << vproto.pack_bool_field(o.enable_replay, 10)
	}
	return res
}

pub fn cbroadcastsetrtmpinforequest_unpack(buf []byte) ?CBroadcastSetRTmpinfoRequest {
	mut res := CBroadcastSetRTmpinfoRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_permission = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_permission = v
				i = ii
			}
			2 {
				res.has_update_token = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.update_token = v
				i = ii
			}
			3 {
				res.has_broadcast_delay = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_delay = v
				i = ii
			}
			4 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			5 {
				res.has_required_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.required_app_id = v
				i = ii
			}
			6 {
				res.has_broadcast_chat_permission = true
				ii, v := zzz_vproto_internal_unpack_ebroadcastchatpermission(cur_buf,
					tag_wiretype.wire_type)?
				res.broadcast_chat_permission = v
				i = ii
			}
			7 {
				res.has_broadcast_buffer = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_buffer = v
				i = ii
			}
			8 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			9 {
				res.has_chat_rate_limit = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_rate_limit = v
				i = ii
			}
			10 {
				res.has_enable_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_replay = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastsetrtmpinforequest() CBroadcastSetRTmpinfoRequest {
	return CBroadcastSetRTmpinfoRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastsetrtmpinforequest(o CBroadcastSetRTmpinfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastsetrtmpinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastSetRTmpinfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastsetrtmpinforequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastSetRTmpinfoResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcastSetRTmpinfoResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcastsetrtmpinforesponse_unpack(buf []byte) ?CBroadcastSetRTmpinfoResponse {
	res := CBroadcastSetRTmpinfoResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastsetrtmpinforesponse() CBroadcastSetRTmpinfoResponse {
	return CBroadcastSetRTmpinfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastsetrtmpinforesponse(o CBroadcastSetRTmpinfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastsetrtmpinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastSetRTmpinfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastsetrtmpinforesponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetRTmpinfoRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ip             u32
	has_ip         bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CBroadcastGetRTmpinfoRequest) pack() []byte {
	mut res := []byte{}
	if o.has_ip {
		res << vproto.pack_uint32_field(o.ip, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	return res
}

pub fn cbroadcastgetrtmpinforequest_unpack(buf []byte) ?CBroadcastGetRTmpinfoRequest {
	mut res := CBroadcastGetRTmpinfoRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ip = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetrtmpinforequest() CBroadcastGetRTmpinfoRequest {
	return CBroadcastGetRTmpinfoRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetrtmpinforequest(o CBroadcastGetRTmpinfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetrtmpinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetRTmpinfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetrtmpinforequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetRTmpinfoResponse {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	broadcast_permission          int
	has_broadcast_permission      bool
	rtmp_host                     string
	has_rtmp_host                 bool
	rtmp_token                    string
	has_rtmp_token                bool
	broadcast_delay               int
	has_broadcast_delay           bool
	app_id                        u32
	has_app_id                    bool
	required_app_id               u32
	has_required_app_id           bool
	broadcast_chat_permission     EBroadcastChatPermission
	has_broadcast_chat_permission bool
	broadcast_buffer              int
	has_broadcast_buffer          bool
	steamid                       u64
	has_steamid                   bool
	chat_rate_limit               u32
	has_chat_rate_limit           bool
	enable_replay                 bool
	has_enable_replay             bool
}

pub fn (o &CBroadcastGetRTmpinfoResponse) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_permission {
		res << vproto.pack_int32_field(o.broadcast_permission, 1)
	}
	if o.has_rtmp_host {
		res << vproto.pack_string_field(o.rtmp_host, 2)
	}
	if o.has_rtmp_token {
		res << vproto.pack_string_field(o.rtmp_token, 3)
	}
	if o.has_broadcast_delay {
		res << vproto.pack_int32_field(o.broadcast_delay, 4)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 5)
	}
	if o.has_required_app_id {
		res << vproto.pack_uint32_field(o.required_app_id, 6)
	}
	if o.has_broadcast_chat_permission {
		res << zzz_vproto_internal_pack_ebroadcastchatpermission(o.broadcast_chat_permission, 7)
	}
	if o.has_broadcast_buffer {
		res << vproto.pack_int32_field(o.broadcast_buffer, 8)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 9)
	}
	if o.has_chat_rate_limit {
		res << vproto.pack_uint32_field(o.chat_rate_limit, 10)
	}
	if o.has_enable_replay {
		res << vproto.pack_bool_field(o.enable_replay, 11)
	}
	return res
}

pub fn cbroadcastgetrtmpinforesponse_unpack(buf []byte) ?CBroadcastGetRTmpinfoResponse {
	mut res := CBroadcastGetRTmpinfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_permission = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_permission = v
				i = ii
			}
			2 {
				res.has_rtmp_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.rtmp_host = v
				i = ii
			}
			3 {
				res.has_rtmp_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.rtmp_token = v
				i = ii
			}
			4 {
				res.has_broadcast_delay = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_delay = v
				i = ii
			}
			5 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			6 {
				res.has_required_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.required_app_id = v
				i = ii
			}
			7 {
				res.has_broadcast_chat_permission = true
				ii, v := zzz_vproto_internal_unpack_ebroadcastchatpermission(cur_buf,
					tag_wiretype.wire_type)?
				res.broadcast_chat_permission = v
				i = ii
			}
			8 {
				res.has_broadcast_buffer = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_buffer = v
				i = ii
			}
			9 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			10 {
				res.has_chat_rate_limit = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_rate_limit = v
				i = ii
			}
			11 {
				res.has_enable_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_replay = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetrtmpinforesponse() CBroadcastGetRTmpinfoResponse {
	return CBroadcastGetRTmpinfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetrtmpinforesponse(o CBroadcastGetRTmpinfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetrtmpinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetRTmpinfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetrtmpinforesponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTchaveTUrnserverNotification {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	broadcast_session_id     u64
	has_broadcast_session_id bool
	turn_server              string
	has_turn_server          bool
}

pub fn (o &CBroadcastWebRTchaveTUrnserverNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_session_id {
		res << vproto.pack_64bit_field(o.broadcast_session_id, 1)
	}
	if o.has_turn_server {
		res << vproto.pack_string_field(o.turn_server, 2)
	}
	return res
}

pub fn cbroadcastwebrtchaveturnservernotification_unpack(buf []byte) ?CBroadcastWebRTchaveTUrnserverNotification {
	mut res := CBroadcastWebRTchaveTUrnserverNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_session_id = v
				i = ii
			}
			2 {
				res.has_turn_server = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.turn_server = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtchaveturnservernotification() CBroadcastWebRTchaveTUrnserverNotification {
	return CBroadcastWebRTchaveTUrnserverNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtchaveturnservernotification(o CBroadcastWebRTchaveTUrnserverNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtchaveturnservernotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTchaveTUrnserverNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtchaveturnservernotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcstartResultRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	webrtc_session_id     u64
	has_webrtc_session_id bool
	started               bool
	has_started           bool
	offer                 string
	has_offer             bool
	resolution_x          u32
	has_resolution_x      bool
	resolution_y          u32
	has_resolution_y      bool
	fps                   u32
	has_fps               bool
}

pub fn (o &CBroadcastWebRTcstartResultRequest) pack() []byte {
	mut res := []byte{}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 1)
	}
	if o.has_started {
		res << vproto.pack_bool_field(o.started, 2)
	}
	if o.has_offer {
		res << vproto.pack_string_field(o.offer, 3)
	}
	if o.has_resolution_x {
		res << vproto.pack_uint32_field(o.resolution_x, 4)
	}
	if o.has_resolution_y {
		res << vproto.pack_uint32_field(o.resolution_y, 5)
	}
	if o.has_fps {
		res << vproto.pack_uint32_field(o.fps, 6)
	}
	return res
}

pub fn cbroadcastwebrtcstartresultrequest_unpack(buf []byte) ?CBroadcastWebRTcstartResultRequest {
	mut res := CBroadcastWebRTcstartResultRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			2 {
				res.has_started = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.started = v
				i = ii
			}
			3 {
				res.has_offer = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.offer = v
				i = ii
			}
			4 {
				res.has_resolution_x = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.resolution_x = v
				i = ii
			}
			5 {
				res.has_resolution_y = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.resolution_y = v
				i = ii
			}
			6 {
				res.has_fps = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.fps = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcstartresultrequest() CBroadcastWebRTcstartResultRequest {
	return CBroadcastWebRTcstartResultRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcstartresultrequest(o CBroadcastWebRTcstartResultRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcstartresultrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcstartResultRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcstartresultrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcstartResultResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcastWebRTcstartResultResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcastwebrtcstartresultresponse_unpack(buf []byte) ?CBroadcastWebRTcstartResultResponse {
	res := CBroadcastWebRTcstartResultResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcstartresultresponse() CBroadcastWebRTcstartResultResponse {
	return CBroadcastWebRTcstartResultResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcstartresultresponse(o CBroadcastWebRTcstartResultResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcstartresultresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcstartResultResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcstartresultresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcstoppedRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	webrtc_session_id     u64
	has_webrtc_session_id bool
}

pub fn (o &CBroadcastWebRTcstoppedRequest) pack() []byte {
	mut res := []byte{}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 1)
	}
	return res
}

pub fn cbroadcastwebrtcstoppedrequest_unpack(buf []byte) ?CBroadcastWebRTcstoppedRequest {
	mut res := CBroadcastWebRTcstoppedRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcstoppedrequest() CBroadcastWebRTcstoppedRequest {
	return CBroadcastWebRTcstoppedRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcstoppedrequest(o CBroadcastWebRTcstoppedRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcstoppedrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcstoppedRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcstoppedrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcstoppedResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcastWebRTcstoppedResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcastwebrtcstoppedresponse_unpack(buf []byte) ?CBroadcastWebRTcstoppedResponse {
	res := CBroadcastWebRTcstoppedResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcstoppedresponse() CBroadcastWebRTcstoppedResponse {
	return CBroadcastWebRTcstoppedResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcstoppedresponse(o CBroadcastWebRTcstoppedResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcstoppedresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcstoppedResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcstoppedresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcsetAnswerRequest {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	broadcaster_steamid     u64
	has_broadcaster_steamid bool
	webrtc_session_id       u64
	has_webrtc_session_id   bool
	answer                  string
	has_answer              bool
}

pub fn (o &CBroadcastWebRTcsetAnswerRequest) pack() []byte {
	mut res := []byte{}
	if o.has_broadcaster_steamid {
		res << vproto.pack_64bit_field(o.broadcaster_steamid, 1)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 2)
	}
	if o.has_answer {
		res << vproto.pack_string_field(o.answer, 3)
	}
	return res
}

pub fn cbroadcastwebrtcsetanswerrequest_unpack(buf []byte) ?CBroadcastWebRTcsetAnswerRequest {
	mut res := CBroadcastWebRTcsetAnswerRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcaster_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcaster_steamid = v
				i = ii
			}
			2 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			3 {
				res.has_answer = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.answer = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcsetanswerrequest() CBroadcastWebRTcsetAnswerRequest {
	return CBroadcastWebRTcsetAnswerRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcsetanswerrequest(o CBroadcastWebRTcsetAnswerRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcsetanswerrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcsetAnswerRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcsetanswerrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcsetAnswerResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcastWebRTcsetAnswerResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcastwebrtcsetanswerresponse_unpack(buf []byte) ?CBroadcastWebRTcsetAnswerResponse {
	res := CBroadcastWebRTcsetAnswerResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcsetanswerresponse() CBroadcastWebRTcsetAnswerResponse {
	return CBroadcastWebRTcsetAnswerResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcsetanswerresponse(o CBroadcastWebRTcsetAnswerResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcsetanswerresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcsetAnswerResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcsetanswerresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTclookupTUrnserverRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	cellid         u32
	has_cellid     bool
}

pub fn (o &CBroadcastWebRTclookupTUrnserverRequest) pack() []byte {
	mut res := []byte{}
	if o.has_cellid {
		res << vproto.pack_uint32_field(o.cellid, 1)
	}
	return res
}

pub fn cbroadcastwebrtclookupturnserverrequest_unpack(buf []byte) ?CBroadcastWebRTclookupTUrnserverRequest {
	mut res := CBroadcastWebRTclookupTUrnserverRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cellid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtclookupturnserverrequest() CBroadcastWebRTclookupTUrnserverRequest {
	return CBroadcastWebRTclookupTUrnserverRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtclookupturnserverrequest(o CBroadcastWebRTclookupTUrnserverRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtclookupturnserverrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTclookupTUrnserverRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtclookupturnserverrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTclookupTUrnserverResponse {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	turn_server     string
	has_turn_server bool
}

pub fn (o &CBroadcastWebRTclookupTUrnserverResponse) pack() []byte {
	mut res := []byte{}
	if o.has_turn_server {
		res << vproto.pack_string_field(o.turn_server, 1)
	}
	return res
}

pub fn cbroadcastwebrtclookupturnserverresponse_unpack(buf []byte) ?CBroadcastWebRTclookupTUrnserverResponse {
	mut res := CBroadcastWebRTclookupTUrnserverResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_turn_server = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.turn_server = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtclookupturnserverresponse() CBroadcastWebRTclookupTUrnserverResponse {
	return CBroadcastWebRTclookupTUrnserverResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtclookupturnserverresponse(o CBroadcastWebRTclookupTUrnserverResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtclookupturnserverresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTclookupTUrnserverResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtclookupturnserverresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTccandidate {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	sdp_mid             string
	has_sdp_mid         bool
	sdp_mline_index     int
	has_sdp_mline_index bool
	candidate           string
	has_candidate       bool
}

pub fn (o &CBroadcastWebRTccandidate) pack() []byte {
	mut res := []byte{}
	if o.has_sdp_mid {
		res << vproto.pack_string_field(o.sdp_mid, 1)
	}
	if o.has_sdp_mline_index {
		res << vproto.pack_int32_field(o.sdp_mline_index, 2)
	}
	if o.has_candidate {
		res << vproto.pack_string_field(o.candidate, 3)
	}
	return res
}

pub fn cbroadcastwebrtccandidate_unpack(buf []byte) ?CBroadcastWebRTccandidate {
	mut res := CBroadcastWebRTccandidate{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sdp_mid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sdp_mid = v
				i = ii
			}
			2 {
				res.has_sdp_mline_index = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.sdp_mline_index = v
				i = ii
			}
			3 {
				res.has_candidate = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.candidate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtccandidate() CBroadcastWebRTccandidate {
	return CBroadcastWebRTccandidate{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtccandidate(o CBroadcastWebRTccandidate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtccandidate(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTccandidate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtccandidate_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcaddHostCandidateRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	webrtc_session_id     u64
	has_webrtc_session_id bool
	candidate             CBroadcastWebRTccandidate
	has_candidate         bool
}

pub fn (o &CBroadcastWebRTcaddHostCandidateRequest) pack() []byte {
	mut res := []byte{}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 1)
	}
	if o.has_candidate {
		res << zzz_vproto_internal_pack_cbroadcastwebrtccandidate(o.candidate, 2)
	}
	return res
}

pub fn cbroadcastwebrtcaddhostcandidaterequest_unpack(buf []byte) ?CBroadcastWebRTcaddHostCandidateRequest {
	mut res := CBroadcastWebRTcaddHostCandidateRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			2 {
				res.has_candidate = true
				ii, v := zzz_vproto_internal_unpack_cbroadcastwebrtccandidate(cur_buf,
					tag_wiretype.wire_type)?
				res.candidate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcaddhostcandidaterequest() CBroadcastWebRTcaddHostCandidateRequest {
	return CBroadcastWebRTcaddHostCandidateRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcaddhostcandidaterequest(o CBroadcastWebRTcaddHostCandidateRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcaddhostcandidaterequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcaddHostCandidateRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcaddhostcandidaterequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcaddHostCandidateResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcastWebRTcaddHostCandidateResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcastwebrtcaddhostcandidateresponse_unpack(buf []byte) ?CBroadcastWebRTcaddHostCandidateResponse {
	res := CBroadcastWebRTcaddHostCandidateResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcaddhostcandidateresponse() CBroadcastWebRTcaddHostCandidateResponse {
	return CBroadcastWebRTcaddHostCandidateResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcaddhostcandidateresponse(o CBroadcastWebRTcaddHostCandidateResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcaddhostcandidateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcaddHostCandidateResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcaddhostcandidateresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcaddViewerCandidateRequest {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	broadcaster_steamid     u64
	has_broadcaster_steamid bool
	webrtc_session_id       u64
	has_webrtc_session_id   bool
	candidate               CBroadcastWebRTccandidate
	has_candidate           bool
}

pub fn (o &CBroadcastWebRTcaddViewerCandidateRequest) pack() []byte {
	mut res := []byte{}
	if o.has_broadcaster_steamid {
		res << vproto.pack_64bit_field(o.broadcaster_steamid, 1)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 2)
	}
	if o.has_candidate {
		res << zzz_vproto_internal_pack_cbroadcastwebrtccandidate(o.candidate, 3)
	}
	return res
}

pub fn cbroadcastwebrtcaddviewercandidaterequest_unpack(buf []byte) ?CBroadcastWebRTcaddViewerCandidateRequest {
	mut res := CBroadcastWebRTcaddViewerCandidateRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcaster_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcaster_steamid = v
				i = ii
			}
			2 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			3 {
				res.has_candidate = true
				ii, v := zzz_vproto_internal_unpack_cbroadcastwebrtccandidate(cur_buf,
					tag_wiretype.wire_type)?
				res.candidate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcaddviewercandidaterequest() CBroadcastWebRTcaddViewerCandidateRequest {
	return CBroadcastWebRTcaddViewerCandidateRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcaddviewercandidaterequest(o CBroadcastWebRTcaddViewerCandidateRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcaddviewercandidaterequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcaddViewerCandidateRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcaddviewercandidaterequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcaddViewerCandidateResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CBroadcastWebRTcaddViewerCandidateResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cbroadcastwebrtcaddviewercandidateresponse_unpack(buf []byte) ?CBroadcastWebRTcaddViewerCandidateResponse {
	res := CBroadcastWebRTcaddViewerCandidateResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcaddviewercandidateresponse() CBroadcastWebRTcaddViewerCandidateResponse {
	return CBroadcastWebRTcaddViewerCandidateResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcaddviewercandidateresponse(o CBroadcastWebRTcaddViewerCandidateResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcaddviewercandidateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcaddViewerCandidateResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcaddviewercandidateresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcgetHostCandidatesRequest {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	broadcaster_steamid      u64
	has_broadcaster_steamid  bool
	webrtc_session_id        u64
	has_webrtc_session_id    bool
	candidate_generation     u32
	has_candidate_generation bool
}

pub fn (o &CBroadcastWebRTcgetHostCandidatesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_broadcaster_steamid {
		res << vproto.pack_64bit_field(o.broadcaster_steamid, 1)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 2)
	}
	if o.has_candidate_generation {
		res << vproto.pack_uint32_field(o.candidate_generation, 3)
	}
	return res
}

pub fn cbroadcastwebrtcgethostcandidatesrequest_unpack(buf []byte) ?CBroadcastWebRTcgetHostCandidatesRequest {
	mut res := CBroadcastWebRTcgetHostCandidatesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcaster_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcaster_steamid = v
				i = ii
			}
			2 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			3 {
				res.has_candidate_generation = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.candidate_generation = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcgethostcandidatesrequest() CBroadcastWebRTcgetHostCandidatesRequest {
	return CBroadcastWebRTcgetHostCandidatesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcgethostcandidatesrequest(o CBroadcastWebRTcgetHostCandidatesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcgethostcandidatesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcgetHostCandidatesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcgethostcandidatesrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcgetHostCandidatesResponse {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	candidate_generation     u32
	has_candidate_generation bool
	candidates               []CBroadcastWebRTccandidate
}

pub fn (o &CBroadcastWebRTcgetHostCandidatesResponse) pack() []byte {
	mut res := []byte{}
	if o.has_candidate_generation {
		res << vproto.pack_uint32_field(o.candidate_generation, 1)
	}
	// [packed=false]
	for _, x in o.candidates {
		res << zzz_vproto_internal_pack_cbroadcastwebrtccandidate(x, 2)
	}
	return res
}

pub fn cbroadcastwebrtcgethostcandidatesresponse_unpack(buf []byte) ?CBroadcastWebRTcgetHostCandidatesResponse {
	mut res := CBroadcastWebRTcgetHostCandidatesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_candidate_generation = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.candidate_generation = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cbroadcastwebrtccandidate(cur_buf,
					tag_wiretype.wire_type)?
				res.candidates << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcgethostcandidatesresponse() CBroadcastWebRTcgetHostCandidatesResponse {
	return CBroadcastWebRTcgetHostCandidatesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcgethostcandidatesresponse(o CBroadcastWebRTcgetHostCandidatesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcgethostcandidatesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcgetHostCandidatesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcgethostcandidatesresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastUploadStatsRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	row_limit      u32
	has_row_limit  bool
	start_time     u32
	has_start_time bool
	upload_id      u64
	has_upload_id  bool
	steamid        u64
	has_steamid    bool
	session_id     u64
	has_session_id bool
}

pub fn (o &CBroadcastGetBroadcastUploadStatsRequest) pack() []byte {
	mut res := []byte{}
	if o.has_row_limit {
		res << vproto.pack_uint32_field(o.row_limit, 1)
	}
	if o.has_start_time {
		res << vproto.pack_uint32_field(o.start_time, 2)
	}
	if o.has_upload_id {
		res << vproto.pack_uint64_field(o.upload_id, 3)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 4)
	}
	if o.has_session_id {
		res << vproto.pack_uint64_field(o.session_id, 5)
	}
	return res
}

pub fn cbroadcastgetbroadcastuploadstatsrequest_unpack(buf []byte) ?CBroadcastGetBroadcastUploadStatsRequest {
	mut res := CBroadcastGetBroadcastUploadStatsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_row_limit = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.row_limit = v
				i = ii
			}
			2 {
				res.has_start_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_time = v
				i = ii
			}
			3 {
				res.has_upload_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_id = v
				i = ii
			}
			4 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			5 {
				res.has_session_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastuploadstatsrequest() CBroadcastGetBroadcastUploadStatsRequest {
	return CBroadcastGetBroadcastUploadStatsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastuploadstatsrequest(o CBroadcastGetBroadcastUploadStatsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastuploadstatsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastUploadStatsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastuploadstatsrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastUploadStatsResponseUploadStats {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	upload_result             u32
	has_upload_result         bool
	time_stopped              u32
	has_time_stopped          bool
	seconds_uploaded          u32
	has_seconds_uploaded      bool
	max_viewers               u32
	has_max_viewers           bool
	resolution_x              u32
	has_resolution_x          bool
	resolution_y              u32
	has_resolution_y          bool
	avg_bandwidth             u32
	has_avg_bandwidth         bool
	total_bytes               u64
	has_total_bytes           bool
	app_id                    u32
	has_app_id                bool
	total_unique_viewers      u32
	has_total_unique_viewers  bool
	total_seconds_watched     u64
	has_total_seconds_watched bool
	time_started              u32
	has_time_started          bool
	upload_id                 u64
	has_upload_id             bool
	local_address             string
	has_local_address         bool
	remote_address            string
	has_remote_address        bool
	frames_per_second         u32
	has_frames_per_second     bool
	num_representations       u32
	has_num_representations   bool
	app_name                  string
	has_app_name              bool
	is_replay                 bool
	has_is_replay             bool
	session_id                u64
	has_session_id            bool
}

pub fn (o &CBroadcastGetBroadcastUploadStatsResponseUploadStats) pack() []byte {
	mut res := []byte{}
	if o.has_upload_result {
		res << vproto.pack_uint32_field(o.upload_result, 1)
	}
	if o.has_time_stopped {
		res << vproto.pack_uint32_field(o.time_stopped, 2)
	}
	if o.has_seconds_uploaded {
		res << vproto.pack_uint32_field(o.seconds_uploaded, 3)
	}
	if o.has_max_viewers {
		res << vproto.pack_uint32_field(o.max_viewers, 4)
	}
	if o.has_resolution_x {
		res << vproto.pack_uint32_field(o.resolution_x, 5)
	}
	if o.has_resolution_y {
		res << vproto.pack_uint32_field(o.resolution_y, 6)
	}
	if o.has_avg_bandwidth {
		res << vproto.pack_uint32_field(o.avg_bandwidth, 7)
	}
	if o.has_total_bytes {
		res << vproto.pack_uint64_field(o.total_bytes, 8)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 9)
	}
	if o.has_total_unique_viewers {
		res << vproto.pack_uint32_field(o.total_unique_viewers, 10)
	}
	if o.has_total_seconds_watched {
		res << vproto.pack_uint64_field(o.total_seconds_watched, 11)
	}
	if o.has_time_started {
		res << vproto.pack_uint32_field(o.time_started, 12)
	}
	if o.has_upload_id {
		res << vproto.pack_uint64_field(o.upload_id, 13)
	}
	if o.has_local_address {
		res << vproto.pack_string_field(o.local_address, 14)
	}
	if o.has_remote_address {
		res << vproto.pack_string_field(o.remote_address, 15)
	}
	if o.has_frames_per_second {
		res << vproto.pack_uint32_field(o.frames_per_second, 16)
	}
	if o.has_num_representations {
		res << vproto.pack_uint32_field(o.num_representations, 17)
	}
	if o.has_app_name {
		res << vproto.pack_string_field(o.app_name, 18)
	}
	if o.has_is_replay {
		res << vproto.pack_bool_field(o.is_replay, 19)
	}
	if o.has_session_id {
		res << vproto.pack_uint64_field(o.session_id, 20)
	}
	return res
}

pub fn cbroadcastgetbroadcastuploadstatsresponseuploadstats_unpack(buf []byte) ?CBroadcastGetBroadcastUploadStatsResponseUploadStats {
	mut res := CBroadcastGetBroadcastUploadStatsResponseUploadStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_upload_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_result = v
				i = ii
			}
			2 {
				res.has_time_stopped = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_stopped = v
				i = ii
			}
			3 {
				res.has_seconds_uploaded = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_uploaded = v
				i = ii
			}
			4 {
				res.has_max_viewers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_viewers = v
				i = ii
			}
			5 {
				res.has_resolution_x = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.resolution_x = v
				i = ii
			}
			6 {
				res.has_resolution_y = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.resolution_y = v
				i = ii
			}
			7 {
				res.has_avg_bandwidth = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.avg_bandwidth = v
				i = ii
			}
			8 {
				res.has_total_bytes = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.total_bytes = v
				i = ii
			}
			9 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			10 {
				res.has_total_unique_viewers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_unique_viewers = v
				i = ii
			}
			11 {
				res.has_total_seconds_watched = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.total_seconds_watched = v
				i = ii
			}
			12 {
				res.has_time_started = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_started = v
				i = ii
			}
			13 {
				res.has_upload_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_id = v
				i = ii
			}
			14 {
				res.has_local_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.local_address = v
				i = ii
			}
			15 {
				res.has_remote_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.remote_address = v
				i = ii
			}
			16 {
				res.has_frames_per_second = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.frames_per_second = v
				i = ii
			}
			17 {
				res.has_num_representations = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_representations = v
				i = ii
			}
			18 {
				res.has_app_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.app_name = v
				i = ii
			}
			19 {
				res.has_is_replay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_replay = v
				i = ii
			}
			20 {
				res.has_session_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastuploadstatsresponseuploadstats() CBroadcastGetBroadcastUploadStatsResponseUploadStats {
	return CBroadcastGetBroadcastUploadStatsResponseUploadStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastuploadstatsresponseuploadstats(o CBroadcastGetBroadcastUploadStatsResponseUploadStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastuploadstatsresponseuploadstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastUploadStatsResponseUploadStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastuploadstatsresponseuploadstats_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastUploadStatsResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	upload_stats   []CBroadcastGetBroadcastUploadStatsResponseUploadStats
}

pub fn (o &CBroadcastGetBroadcastUploadStatsResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.upload_stats {
		res << zzz_vproto_internal_pack_cbroadcastgetbroadcastuploadstatsresponseuploadstats(x, 1)
	}
	return res
}

pub fn cbroadcastgetbroadcastuploadstatsresponse_unpack(buf []byte) ?CBroadcastGetBroadcastUploadStatsResponse {
	mut res := CBroadcastGetBroadcastUploadStatsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cbroadcastgetbroadcastuploadstatsresponseuploadstats(cur_buf,
					tag_wiretype.wire_type)?
				res.upload_stats << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastuploadstatsresponse() CBroadcastGetBroadcastUploadStatsResponse {
	return CBroadcastGetBroadcastUploadStatsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastuploadstatsresponse(o CBroadcastGetBroadcastUploadStatsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastuploadstatsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastUploadStatsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastuploadstatsresponse_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastViewerStatsRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	upload_id      u64
	has_upload_id  bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CBroadcastGetBroadcastViewerStatsRequest) pack() []byte {
	mut res := []byte{}
	if o.has_upload_id {
		res << vproto.pack_uint64_field(o.upload_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	return res
}

pub fn cbroadcastgetbroadcastviewerstatsrequest_unpack(buf []byte) ?CBroadcastGetBroadcastViewerStatsRequest {
	mut res := CBroadcastGetBroadcastViewerStatsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_upload_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastviewerstatsrequest() CBroadcastGetBroadcastViewerStatsRequest {
	return CBroadcastGetBroadcastViewerStatsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastviewerstatsrequest(o CBroadcastGetBroadcastViewerStatsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastviewerstatsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastViewerStatsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastviewerstatsrequest_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastViewerStatsResponseViewerStats {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	time            u32
	has_time        bool
	num_viewers     u32
	has_num_viewers bool
}

pub fn (o &CBroadcastGetBroadcastViewerStatsResponseViewerStats) pack() []byte {
	mut res := []byte{}
	if o.has_time {
		res << vproto.pack_uint32_field(o.time, 1)
	}
	if o.has_num_viewers {
		res << vproto.pack_uint32_field(o.num_viewers, 2)
	}
	return res
}

pub fn cbroadcastgetbroadcastviewerstatsresponseviewerstats_unpack(buf []byte) ?CBroadcastGetBroadcastViewerStatsResponseViewerStats {
	mut res := CBroadcastGetBroadcastViewerStatsResponseViewerStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time = v
				i = ii
			}
			2 {
				res.has_num_viewers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_viewers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastviewerstatsresponseviewerstats() CBroadcastGetBroadcastViewerStatsResponseViewerStats {
	return CBroadcastGetBroadcastViewerStatsResponseViewerStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastviewerstatsresponseviewerstats(o CBroadcastGetBroadcastViewerStatsResponseViewerStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastviewerstatsresponseviewerstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastViewerStatsResponseViewerStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastviewerstatsresponseviewerstats_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastViewerStatsResponseCountryStats {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	country_code     string
	has_country_code bool
	num_viewers      u32
	has_num_viewers  bool
}

pub fn (o &CBroadcastGetBroadcastViewerStatsResponseCountryStats) pack() []byte {
	mut res := []byte{}
	if o.has_country_code {
		res << vproto.pack_string_field(o.country_code, 1)
	}
	if o.has_num_viewers {
		res << vproto.pack_uint32_field(o.num_viewers, 2)
	}
	return res
}

pub fn cbroadcastgetbroadcastviewerstatsresponsecountrystats_unpack(buf []byte) ?CBroadcastGetBroadcastViewerStatsResponseCountryStats {
	mut res := CBroadcastGetBroadcastViewerStatsResponseCountryStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_country_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.country_code = v
				i = ii
			}
			2 {
				res.has_num_viewers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_viewers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastviewerstatsresponsecountrystats() CBroadcastGetBroadcastViewerStatsResponseCountryStats {
	return CBroadcastGetBroadcastViewerStatsResponseCountryStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastviewerstatsresponsecountrystats(o CBroadcastGetBroadcastViewerStatsResponseCountryStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastviewerstatsresponsecountrystats(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastViewerStatsResponseCountryStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastviewerstatsresponsecountrystats_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastGetBroadcastViewerStatsResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	viewer_stats   []CBroadcastGetBroadcastViewerStatsResponseViewerStats
	country_stats  []CBroadcastGetBroadcastViewerStatsResponseCountryStats
}

pub fn (o &CBroadcastGetBroadcastViewerStatsResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.viewer_stats {
		res << zzz_vproto_internal_pack_cbroadcastgetbroadcastviewerstatsresponseviewerstats(x, 1)
	}
	// [packed=false]
	for _, x in o.country_stats {
		res << zzz_vproto_internal_pack_cbroadcastgetbroadcastviewerstatsresponsecountrystats(x, 2)
	}
	return res
}

pub fn cbroadcastgetbroadcastviewerstatsresponse_unpack(buf []byte) ?CBroadcastGetBroadcastViewerStatsResponse {
	mut res := CBroadcastGetBroadcastViewerStatsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cbroadcastgetbroadcastviewerstatsresponseviewerstats(cur_buf,
					tag_wiretype.wire_type)?
				res.viewer_stats << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cbroadcastgetbroadcastviewerstatsresponsecountrystats(cur_buf,
					tag_wiretype.wire_type)?
				res.country_stats << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastgetbroadcastviewerstatsresponse() CBroadcastGetBroadcastViewerStatsResponse {
	return CBroadcastGetBroadcastViewerStatsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastgetbroadcastviewerstatsresponse(o CBroadcastGetBroadcastViewerStatsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastgetbroadcastviewerstatsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastGetBroadcastViewerStatsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastgetbroadcastviewerstatsresponse_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CBroadcastBroadcastViewerStateNotificationEViewerState {
	k_eviewerneedsapproval = 1
	k_eviewerwatching = 2
	k_eviewerleft = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cbroadcastbroadcastviewerstatenotificationeviewerstate(e CBroadcastBroadcastViewerStateNotificationEViewerState, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cbroadcastbroadcastviewerstatenotificationeviewerstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastBroadcastViewerStateNotificationEViewerState) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CBroadcastBroadcastViewerStateNotificationEViewerState(v)
}

pub struct CBroadcastBroadcastViewerStateNotification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	state          CBroadcastBroadcastViewerStateNotificationEViewerState
	has_state      bool
}

pub fn (o &CBroadcastBroadcastViewerStateNotification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_state {
		res <<
			zzz_vproto_internal_pack_cbroadcastbroadcastviewerstatenotificationeviewerstate(o.state, 2)
	}
	return res
}

pub fn cbroadcastbroadcastviewerstatenotification_unpack(buf []byte) ?CBroadcastBroadcastViewerStateNotification {
	mut res := CBroadcastBroadcastViewerStateNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_state = true
				ii, v := zzz_vproto_internal_unpack_cbroadcastbroadcastviewerstatenotificationeviewerstate(cur_buf,
					tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastbroadcastviewerstatenotification() CBroadcastBroadcastViewerStateNotification {
	return CBroadcastBroadcastViewerStateNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastbroadcastviewerstatenotification(o CBroadcastBroadcastViewerStateNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastbroadcastviewerstatenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastBroadcastViewerStateNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastbroadcastviewerstatenotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWaitingBroadcastViewerNotification {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	broadcast_id     u64
	has_broadcast_id bool
}

pub fn (o &CBroadcastWaitingBroadcastViewerNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	return res
}

pub fn cbroadcastwaitingbroadcastviewernotification_unpack(buf []byte) ?CBroadcastWaitingBroadcastViewerNotification {
	mut res := CBroadcastWaitingBroadcastViewerNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwaitingbroadcastviewernotification() CBroadcastWaitingBroadcastViewerNotification {
	return CBroadcastWaitingBroadcastViewerNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwaitingbroadcastviewernotification(o CBroadcastWaitingBroadcastViewerNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwaitingbroadcastviewernotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWaitingBroadcastViewerNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwaitingbroadcastviewernotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastBroadcastUploadStartedNotification {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	broadcast_id                   u64
	has_broadcast_id               bool
	upload_token                   string
	has_upload_token               bool
	upload_address                 string
	has_upload_address             bool
	http_address                   string
	has_http_address               bool
	broadcast_upload_id            u64
	has_broadcast_upload_id        bool
	heartbeat_interval_seconds     u32
	has_heartbeat_interval_seconds bool
	is_rtmp                        bool
	has_is_rtmp                    bool
}

pub fn (o &CBroadcastBroadcastUploadStartedNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	if o.has_upload_token {
		res << vproto.pack_string_field(o.upload_token, 2)
	}
	if o.has_upload_address {
		res << vproto.pack_string_field(o.upload_address, 3)
	}
	if o.has_http_address {
		res << vproto.pack_string_field(o.http_address, 4)
	}
	if o.has_broadcast_upload_id {
		res << vproto.pack_64bit_field(o.broadcast_upload_id, 5)
	}
	if o.has_heartbeat_interval_seconds {
		res << vproto.pack_uint32_field(o.heartbeat_interval_seconds, 6)
	}
	if o.has_is_rtmp {
		res << vproto.pack_bool_field(o.is_rtmp, 7)
	}
	return res
}

pub fn cbroadcastbroadcastuploadstartednotification_unpack(buf []byte) ?CBroadcastBroadcastUploadStartedNotification {
	mut res := CBroadcastBroadcastUploadStartedNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			2 {
				res.has_upload_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_token = v
				i = ii
			}
			3 {
				res.has_upload_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_address = v
				i = ii
			}
			4 {
				res.has_http_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.http_address = v
				i = ii
			}
			5 {
				res.has_broadcast_upload_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_upload_id = v
				i = ii
			}
			6 {
				res.has_heartbeat_interval_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.heartbeat_interval_seconds = v
				i = ii
			}
			7 {
				res.has_is_rtmp = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_rtmp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastbroadcastuploadstartednotification() CBroadcastBroadcastUploadStartedNotification {
	return CBroadcastBroadcastUploadStartedNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastbroadcastuploadstartednotification(o CBroadcastBroadcastUploadStartedNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastbroadcastuploadstartednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastBroadcastUploadStartedNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastbroadcastuploadstartednotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastStopBroadcastUploadNotification {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	broadcast_id              u64
	has_broadcast_id          bool
	broadcast_relay_id        u64
	has_broadcast_relay_id    bool
	upload_result             u32
	has_upload_result         bool
	too_many_poor_uploads     bool
	has_too_many_poor_uploads bool
}

pub fn (o &CBroadcastStopBroadcastUploadNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	if o.has_broadcast_relay_id {
		res << vproto.pack_64bit_field(o.broadcast_relay_id, 2)
	}
	if o.has_upload_result {
		res << vproto.pack_uint32_field(o.upload_result, 3)
	}
	if o.has_too_many_poor_uploads {
		res << vproto.pack_bool_field(o.too_many_poor_uploads, 4)
	}
	return res
}

pub fn cbroadcaststopbroadcastuploadnotification_unpack(buf []byte) ?CBroadcastStopBroadcastUploadNotification {
	mut res := CBroadcastStopBroadcastUploadNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			2 {
				res.has_broadcast_relay_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_relay_id = v
				i = ii
			}
			3 {
				res.has_upload_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.upload_result = v
				i = ii
			}
			4 {
				res.has_too_many_poor_uploads = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.too_many_poor_uploads = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcaststopbroadcastuploadnotification() CBroadcastStopBroadcastUploadNotification {
	return CBroadcastStopBroadcastUploadNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcaststopbroadcastuploadnotification(o CBroadcastStopBroadcastUploadNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcaststopbroadcastuploadnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastStopBroadcastUploadNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcaststopbroadcastuploadnotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastSessionClosedNotification {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	broadcast_id     u64
	has_broadcast_id bool
}

pub fn (o &CBroadcastSessionClosedNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	return res
}

pub fn cbroadcastsessionclosednotification_unpack(buf []byte) ?CBroadcastSessionClosedNotification {
	mut res := CBroadcastSessionClosedNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastsessionclosednotification() CBroadcastSessionClosedNotification {
	return CBroadcastSessionClosedNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastsessionclosednotification(o CBroadcastSessionClosedNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastsessionclosednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastSessionClosedNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastsessionclosednotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastViewerBroadcastInviteNotification {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	broadcaster_steamid     u64
	has_broadcaster_steamid bool
}

pub fn (o &CBroadcastViewerBroadcastInviteNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcaster_steamid {
		res << vproto.pack_64bit_field(o.broadcaster_steamid, 1)
	}
	return res
}

pub fn cbroadcastviewerbroadcastinvitenotification_unpack(buf []byte) ?CBroadcastViewerBroadcastInviteNotification {
	mut res := CBroadcastViewerBroadcastInviteNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcaster_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcaster_steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastviewerbroadcastinvitenotification() CBroadcastViewerBroadcastInviteNotification {
	return CBroadcastViewerBroadcastInviteNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastviewerbroadcastinvitenotification(o CBroadcastViewerBroadcastInviteNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastviewerbroadcastinvitenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastViewerBroadcastInviteNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastviewerbroadcastinvitenotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastBroadcastStatusNotification {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	broadcast_id     u64
	has_broadcast_id bool
	num_viewers      int
	has_num_viewers  bool
}

pub fn (o &CBroadcastBroadcastStatusNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_id {
		res << vproto.pack_64bit_field(o.broadcast_id, 1)
	}
	if o.has_num_viewers {
		res << vproto.pack_int32_field(o.num_viewers, 2)
	}
	return res
}

pub fn cbroadcastbroadcaststatusnotification_unpack(buf []byte) ?CBroadcastBroadcastStatusNotification {
	mut res := CBroadcastBroadcastStatusNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_id = v
				i = ii
			}
			2 {
				res.has_num_viewers = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_viewers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastbroadcaststatusnotification() CBroadcastBroadcastStatusNotification {
	return CBroadcastBroadcastStatusNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastbroadcaststatusnotification(o CBroadcastBroadcastStatusNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastbroadcaststatusnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastBroadcastStatusNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastbroadcaststatusnotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastBroadcastChannelLiveNotification {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	broadcast_channel_id         u64
	has_broadcast_channel_id     bool
	broadcast_channel_name       string
	has_broadcast_channel_name   bool
	broadcast_channel_avatar     string
	has_broadcast_channel_avatar bool
}

pub fn (o &CBroadcastBroadcastChannelLiveNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_channel_id {
		res << vproto.pack_64bit_field(o.broadcast_channel_id, 1)
	}
	if o.has_broadcast_channel_name {
		res << vproto.pack_string_field(o.broadcast_channel_name, 2)
	}
	if o.has_broadcast_channel_avatar {
		res << vproto.pack_string_field(o.broadcast_channel_avatar, 3)
	}
	return res
}

pub fn cbroadcastbroadcastchannellivenotification_unpack(buf []byte) ?CBroadcastBroadcastChannelLiveNotification {
	mut res := CBroadcastBroadcastChannelLiveNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_channel_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_channel_id = v
				i = ii
			}
			2 {
				res.has_broadcast_channel_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_channel_name = v
				i = ii
			}
			3 {
				res.has_broadcast_channel_avatar = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_channel_avatar = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastbroadcastchannellivenotification() CBroadcastBroadcastChannelLiveNotification {
	return CBroadcastBroadcastChannelLiveNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastbroadcastchannellivenotification(o CBroadcastBroadcastChannelLiveNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastbroadcastchannellivenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastBroadcastChannelLiveNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastbroadcastchannellivenotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastSendThumbnailToRelayNotification {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	thumbnail_upload_token             string
	has_thumbnail_upload_token         bool
	thumbnail_broadcast_session_id     u64
	has_thumbnail_broadcast_session_id bool
	thumbnail_data                     []byte
	has_thumbnail_data                 bool
	thumbnail_width                    u32
	has_thumbnail_width                bool
	thumbnail_height                   u32
	has_thumbnail_height               bool
}

pub fn (o &CBroadcastSendThumbnailToRelayNotification) pack() []byte {
	mut res := []byte{}
	if o.has_thumbnail_upload_token {
		res << vproto.pack_string_field(o.thumbnail_upload_token, 1)
	}
	if o.has_thumbnail_broadcast_session_id {
		res << vproto.pack_64bit_field(o.thumbnail_broadcast_session_id, 2)
	}
	if o.has_thumbnail_data {
		res << vproto.pack_bytes_field(o.thumbnail_data, 3)
	}
	if o.has_thumbnail_width {
		res << vproto.pack_uint32_field(o.thumbnail_width, 4)
	}
	if o.has_thumbnail_height {
		res << vproto.pack_uint32_field(o.thumbnail_height, 5)
	}
	return res
}

pub fn cbroadcastsendthumbnailtorelaynotification_unpack(buf []byte) ?CBroadcastSendThumbnailToRelayNotification {
	mut res := CBroadcastSendThumbnailToRelayNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_thumbnail_upload_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_upload_token = v
				i = ii
			}
			2 {
				res.has_thumbnail_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_broadcast_session_id = v
				i = ii
			}
			3 {
				res.has_thumbnail_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_data = v
				i = ii
			}
			4 {
				res.has_thumbnail_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_width = v
				i = ii
			}
			5 {
				res.has_thumbnail_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbnail_height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastsendthumbnailtorelaynotification() CBroadcastSendThumbnailToRelayNotification {
	return CBroadcastSendThumbnailToRelayNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastsendthumbnailtorelaynotification(o CBroadcastSendThumbnailToRelayNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastsendthumbnailtorelaynotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastSendThumbnailToRelayNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastsendthumbnailtorelaynotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcneedTUrnserverNotification {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	broadcast_session_id     u64
	has_broadcast_session_id bool
}

pub fn (o &CBroadcastWebRTcneedTUrnserverNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_session_id {
		res << vproto.pack_64bit_field(o.broadcast_session_id, 1)
	}
	return res
}

pub fn cbroadcastwebrtcneedturnservernotification_unpack(buf []byte) ?CBroadcastWebRTcneedTUrnserverNotification {
	mut res := CBroadcastWebRTcneedTUrnserverNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_session_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcneedturnservernotification() CBroadcastWebRTcneedTUrnserverNotification {
	return CBroadcastWebRTcneedTUrnserverNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcneedturnservernotification(o CBroadcastWebRTcneedTUrnserverNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcneedturnservernotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcneedTUrnserverNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcneedturnservernotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcstartNotification {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	broadcast_session_id     u64
	has_broadcast_session_id bool
	webrtc_session_id        u64
	has_webrtc_session_id    bool
	viewer_steamid           u64
	has_viewer_steamid       bool
	viewer_token             u64
	has_viewer_token         bool
}

pub fn (o &CBroadcastWebRTcstartNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_session_id {
		res << vproto.pack_64bit_field(o.broadcast_session_id, 1)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 2)
	}
	if o.has_viewer_steamid {
		res << vproto.pack_64bit_field(o.viewer_steamid, 3)
	}
	if o.has_viewer_token {
		res << vproto.pack_64bit_field(o.viewer_token, 4)
	}
	return res
}

pub fn cbroadcastwebrtcstartnotification_unpack(buf []byte) ?CBroadcastWebRTcstartNotification {
	mut res := CBroadcastWebRTcstartNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_session_id = v
				i = ii
			}
			2 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			3 {
				res.has_viewer_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.viewer_steamid = v
				i = ii
			}
			4 {
				res.has_viewer_token = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.viewer_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcstartnotification() CBroadcastWebRTcstartNotification {
	return CBroadcastWebRTcstartNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcstartnotification(o CBroadcastWebRTcstartNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcstartnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcstartNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcstartnotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcsetAnswerNotification {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	broadcast_session_id     u64
	has_broadcast_session_id bool
	webrtc_session_id        u64
	has_webrtc_session_id    bool
	answer                   string
	has_answer               bool
}

pub fn (o &CBroadcastWebRTcsetAnswerNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_session_id {
		res << vproto.pack_64bit_field(o.broadcast_session_id, 1)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 2)
	}
	if o.has_answer {
		res << vproto.pack_string_field(o.answer, 3)
	}
	return res
}

pub fn cbroadcastwebrtcsetanswernotification_unpack(buf []byte) ?CBroadcastWebRTcsetAnswerNotification {
	mut res := CBroadcastWebRTcsetAnswerNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_session_id = v
				i = ii
			}
			2 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			3 {
				res.has_answer = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.answer = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcsetanswernotification() CBroadcastWebRTcsetAnswerNotification {
	return CBroadcastWebRTcsetAnswerNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcsetanswernotification(o CBroadcastWebRTcsetAnswerNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcsetanswernotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcsetAnswerNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcsetanswernotification_unpack(v)?
	return i, unpacked
}

pub struct CBroadcastWebRTcaddViewerCandidateNotification {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	broadcast_session_id     u64
	has_broadcast_session_id bool
	webrtc_session_id        u64
	has_webrtc_session_id    bool
	candidate                CBroadcastWebRTccandidate
	has_candidate            bool
}

pub fn (o &CBroadcastWebRTcaddViewerCandidateNotification) pack() []byte {
	mut res := []byte{}
	if o.has_broadcast_session_id {
		res << vproto.pack_64bit_field(o.broadcast_session_id, 1)
	}
	if o.has_webrtc_session_id {
		res << vproto.pack_64bit_field(o.webrtc_session_id, 2)
	}
	if o.has_candidate {
		res << zzz_vproto_internal_pack_cbroadcastwebrtccandidate(o.candidate, 3)
	}
	return res
}

pub fn cbroadcastwebrtcaddviewercandidatenotification_unpack(buf []byte) ?CBroadcastWebRTcaddViewerCandidateNotification {
	mut res := CBroadcastWebRTcaddViewerCandidateNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_broadcast_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.broadcast_session_id = v
				i = ii
			}
			2 {
				res.has_webrtc_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.webrtc_session_id = v
				i = ii
			}
			3 {
				res.has_candidate = true
				ii, v := zzz_vproto_internal_unpack_cbroadcastwebrtccandidate(cur_buf,
					tag_wiretype.wire_type)?
				res.candidate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cbroadcastwebrtcaddviewercandidatenotification() CBroadcastWebRTcaddViewerCandidateNotification {
	return CBroadcastWebRTcaddViewerCandidateNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cbroadcastwebrtcaddviewercandidatenotification(o CBroadcastWebRTcaddViewerCandidateNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cbroadcastwebrtcaddviewercandidatenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CBroadcastWebRTcaddViewerCandidateNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cbroadcastwebrtcaddviewercandidatenotification_unpack(v)?
	return i, unpacked
}
