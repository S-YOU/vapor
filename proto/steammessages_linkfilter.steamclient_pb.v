// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CCommunityGetLinkFilterHashPrefixesRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	hit_type       u32
	has_hit_type   bool
	count          u32
	has_count      bool
	start          u64
	has_start      bool
}

pub fn (o &CCommunityGetLinkFilterHashPrefixesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_hit_type {
		res << vproto.pack_uint32_field(o.hit_type, 1)
	}
	if o.has_count {
		res << vproto.pack_uint32_field(o.count, 2)
	}
	if o.has_start {
		res << vproto.pack_uint64_field(o.start, 3)
	}
	return res
}

pub fn ccommunitygetlinkfilterhashprefixesrequest_unpack(buf []byte) ?CCommunityGetLinkFilterHashPrefixesRequest {
	mut res := CCommunityGetLinkFilterHashPrefixesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_hit_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.hit_type = v
				i = ii
			}
			2 {
				res.has_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			3 {
				res.has_start = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.start = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccommunitygetlinkfilterhashprefixesrequest() CCommunityGetLinkFilterHashPrefixesRequest {
	return CCommunityGetLinkFilterHashPrefixesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccommunitygetlinkfilterhashprefixesrequest(o CCommunityGetLinkFilterHashPrefixesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccommunitygetlinkfilterhashprefixesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCommunityGetLinkFilterHashPrefixesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccommunitygetlinkfilterhashprefixesrequest_unpack(v)?
	return i, unpacked
}

pub struct CCommunityGetLinkFilterHashPrefixesResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	hash_prefixes  []u32
}

pub fn (o &CCommunityGetLinkFilterHashPrefixesResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.hash_prefixes {
		res << vproto.pack_uint32_field(x, 1)
	}
	return res
}

pub fn ccommunitygetlinkfilterhashprefixesresponse_unpack(buf []byte) ?CCommunityGetLinkFilterHashPrefixesResponse {
	mut res := CCommunityGetLinkFilterHashPrefixesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.hash_prefixes << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccommunitygetlinkfilterhashprefixesresponse() CCommunityGetLinkFilterHashPrefixesResponse {
	return CCommunityGetLinkFilterHashPrefixesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccommunitygetlinkfilterhashprefixesresponse(o CCommunityGetLinkFilterHashPrefixesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccommunitygetlinkfilterhashprefixesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCommunityGetLinkFilterHashPrefixesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccommunitygetlinkfilterhashprefixesresponse_unpack(v)?
	return i, unpacked
}

pub struct CCommunityGetLinkFilterHashesRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	hit_type       u32
	has_hit_type   bool
	count          u32
	has_count      bool
	start          u64
	has_start      bool
}

pub fn (o &CCommunityGetLinkFilterHashesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_hit_type {
		res << vproto.pack_uint32_field(o.hit_type, 1)
	}
	if o.has_count {
		res << vproto.pack_uint32_field(o.count, 2)
	}
	if o.has_start {
		res << vproto.pack_uint64_field(o.start, 3)
	}
	return res
}

pub fn ccommunitygetlinkfilterhashesrequest_unpack(buf []byte) ?CCommunityGetLinkFilterHashesRequest {
	mut res := CCommunityGetLinkFilterHashesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_hit_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.hit_type = v
				i = ii
			}
			2 {
				res.has_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			3 {
				res.has_start = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.start = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccommunitygetlinkfilterhashesrequest() CCommunityGetLinkFilterHashesRequest {
	return CCommunityGetLinkFilterHashesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccommunitygetlinkfilterhashesrequest(o CCommunityGetLinkFilterHashesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccommunitygetlinkfilterhashesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCommunityGetLinkFilterHashesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccommunitygetlinkfilterhashesrequest_unpack(v)?
	return i, unpacked
}

pub struct CCommunityGetLinkFilterHashesResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	hashes         [][]byte
}

pub fn (o &CCommunityGetLinkFilterHashesResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.hashes {
		res << vproto.pack_bytes_field(x, 1)
	}
	return res
}

pub fn ccommunitygetlinkfilterhashesresponse_unpack(buf []byte) ?CCommunityGetLinkFilterHashesResponse {
	mut res := CCommunityGetLinkFilterHashesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.hashes << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccommunitygetlinkfilterhashesresponse() CCommunityGetLinkFilterHashesResponse {
	return CCommunityGetLinkFilterHashesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccommunitygetlinkfilterhashesresponse(o CCommunityGetLinkFilterHashesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccommunitygetlinkfilterhashesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCommunityGetLinkFilterHashesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccommunitygetlinkfilterhashesresponse_unpack(v)?
	return i, unpacked
}

pub struct CCommunityGetLinkFilterListVersionRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	hit_type       u32
	has_hit_type   bool
}

pub fn (o &CCommunityGetLinkFilterListVersionRequest) pack() []byte {
	mut res := []byte{}
	if o.has_hit_type {
		res << vproto.pack_uint32_field(o.hit_type, 1)
	}
	return res
}

pub fn ccommunitygetlinkfilterlistversionrequest_unpack(buf []byte) ?CCommunityGetLinkFilterListVersionRequest {
	mut res := CCommunityGetLinkFilterListVersionRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_hit_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.hit_type = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccommunitygetlinkfilterlistversionrequest() CCommunityGetLinkFilterListVersionRequest {
	return CCommunityGetLinkFilterListVersionRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccommunitygetlinkfilterlistversionrequest(o CCommunityGetLinkFilterListVersionRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccommunitygetlinkfilterlistversionrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CCommunityGetLinkFilterListVersionRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccommunitygetlinkfilterlistversionrequest_unpack(v)?
	return i, unpacked
}

pub struct CCommunityGetLinkFilterListVersionResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	version        string
	has_version    bool
	count          u64
	has_count      bool
}

pub fn (o &CCommunityGetLinkFilterListVersionResponse) pack() []byte {
	mut res := []byte{}
	if o.has_version {
		res << vproto.pack_string_field(o.version, 1)
	}
	if o.has_count {
		res << vproto.pack_uint64_field(o.count, 2)
	}
	return res
}

pub fn ccommunitygetlinkfilterlistversionresponse_unpack(buf []byte) ?CCommunityGetLinkFilterListVersionResponse {
	mut res := CCommunityGetLinkFilterListVersionResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_version = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.version = v
				i = ii
			}
			2 {
				res.has_count = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccommunitygetlinkfilterlistversionresponse() CCommunityGetLinkFilterListVersionResponse {
	return CCommunityGetLinkFilterListVersionResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccommunitygetlinkfilterlistversionresponse(o CCommunityGetLinkFilterListVersionResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccommunitygetlinkfilterlistversionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CCommunityGetLinkFilterListVersionResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccommunitygetlinkfilterlistversionresponse_unpack(v)?
	return i, unpacked
}
