// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CRemoteClient_CreateSession_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CRemoteClient_CreateSession_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cremoteclient_createsession_request_unpack(buf []byte) ?CRemoteClient_CreateSession_Request {
	res := CRemoteClient_CreateSession_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_createsession_request() CRemoteClient_CreateSession_Request {
	return CRemoteClient_CreateSession_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_createsession_request(o CRemoteClient_CreateSession_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_createsession_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_CreateSession_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_createsession_request_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_CreateSession_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	session_id     u64
	has_session_id bool
	euniverse      int
	has_euniverse  bool
}

pub fn (o &CRemoteClient_CreateSession_Response) pack() []byte {
	mut res := []byte{}
	if o.has_session_id {
		res << vproto.pack_64bit_field(o.session_id, 1)
	}
	if o.has_euniverse {
		res << vproto.pack_int32_field(o.euniverse, 2)
	}
	return res
}

pub fn cremoteclient_createsession_response_unpack(buf []byte) ?CRemoteClient_CreateSession_Response {
	mut res := CRemoteClient_CreateSession_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			2 {
				res.has_euniverse = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.euniverse = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_createsession_response() CRemoteClient_CreateSession_Response {
	return CRemoteClient_CreateSession_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_createsession_response(o CRemoteClient_CreateSession_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_createsession_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_CreateSession_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_createsession_response_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_StartPairing_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	session_id     u64
	has_session_id bool
}

pub fn (o &CRemoteClient_StartPairing_Request) pack() []byte {
	mut res := []byte{}
	if o.has_session_id {
		res << vproto.pack_64bit_field(o.session_id, 1)
	}
	return res
}

pub fn cremoteclient_startpairing_request_unpack(buf []byte) ?CRemoteClient_StartPairing_Request {
	mut res := CRemoteClient_StartPairing_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_startpairing_request() CRemoteClient_StartPairing_Request {
	return CRemoteClient_StartPairing_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_startpairing_request(o CRemoteClient_StartPairing_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_startpairing_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_StartPairing_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_startpairing_request_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_StartPairing_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	pin            u32
	has_pin        bool
}

pub fn (o &CRemoteClient_StartPairing_Response) pack() []byte {
	mut res := []byte{}
	if o.has_pin {
		res << vproto.pack_uint32_field(o.pin, 1)
	}
	return res
}

pub fn cremoteclient_startpairing_response_unpack(buf []byte) ?CRemoteClient_StartPairing_Response {
	mut res := CRemoteClient_StartPairing_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_pin = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.pin = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_startpairing_response() CRemoteClient_StartPairing_Response {
	return CRemoteClient_StartPairing_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_startpairing_response(o CRemoteClient_StartPairing_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_startpairing_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_StartPairing_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_startpairing_response_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_SetPairingInfo_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	session_id     u64
	has_session_id bool
	device_id      u64
	has_device_id  bool
	request        []byte
	has_request    bool
}

pub fn (o &CRemoteClient_SetPairingInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.has_session_id {
		res << vproto.pack_64bit_field(o.session_id, 1)
	}
	if o.has_device_id {
		res << vproto.pack_64bit_field(o.device_id, 2)
	}
	if o.has_request {
		res << vproto.pack_bytes_field(o.request, 3)
	}
	return res
}

pub fn cremoteclient_setpairinginfo_request_unpack(buf []byte) ?CRemoteClient_SetPairingInfo_Request {
	mut res := CRemoteClient_SetPairingInfo_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			2 {
				res.has_device_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.device_id = v
				i = ii
			}
			3 {
				res.has_request = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.request = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_setpairinginfo_request() CRemoteClient_SetPairingInfo_Request {
	return CRemoteClient_SetPairingInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_setpairinginfo_request(o CRemoteClient_SetPairingInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_setpairinginfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_SetPairingInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_setpairinginfo_request_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_SetPairingInfo_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CRemoteClient_SetPairingInfo_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cremoteclient_setpairinginfo_response_unpack(buf []byte) ?CRemoteClient_SetPairingInfo_Response {
	res := CRemoteClient_SetPairingInfo_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_setpairinginfo_response() CRemoteClient_SetPairingInfo_Response {
	return CRemoteClient_SetPairingInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_setpairinginfo_response(o CRemoteClient_SetPairingInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_setpairinginfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_SetPairingInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_setpairinginfo_response_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_GetPairingInfo_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	pin            u32
	has_pin        bool
}

pub fn (o &CRemoteClient_GetPairingInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.has_pin {
		res << vproto.pack_uint32_field(o.pin, 1)
	}
	return res
}

pub fn cremoteclient_getpairinginfo_request_unpack(buf []byte) ?CRemoteClient_GetPairingInfo_Request {
	mut res := CRemoteClient_GetPairingInfo_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_pin = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.pin = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_getpairinginfo_request() CRemoteClient_GetPairingInfo_Request {
	return CRemoteClient_GetPairingInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_getpairinginfo_request(o CRemoteClient_GetPairingInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_getpairinginfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_GetPairingInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_getpairinginfo_request_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_GetPairingInfo_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	session_id     u64
	has_session_id bool
	device_id      u64
	has_device_id  bool
	request        []byte
	has_request    bool
}

pub fn (o &CRemoteClient_GetPairingInfo_Response) pack() []byte {
	mut res := []byte{}
	if o.has_session_id {
		res << vproto.pack_64bit_field(o.session_id, 1)
	}
	if o.has_device_id {
		res << vproto.pack_64bit_field(o.device_id, 2)
	}
	if o.has_request {
		res << vproto.pack_bytes_field(o.request, 3)
	}
	return res
}

pub fn cremoteclient_getpairinginfo_response_unpack(buf []byte) ?CRemoteClient_GetPairingInfo_Response {
	mut res := CRemoteClient_GetPairingInfo_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			2 {
				res.has_device_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.device_id = v
				i = ii
			}
			3 {
				res.has_request = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.request = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_getpairinginfo_response() CRemoteClient_GetPairingInfo_Response {
	return CRemoteClient_GetPairingInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_getpairinginfo_response(o CRemoteClient_GetPairingInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_getpairinginfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_GetPairingInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_getpairinginfo_response_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_CancelPairing_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	session_id     u64
	has_session_id bool
}

pub fn (o &CRemoteClient_CancelPairing_Request) pack() []byte {
	mut res := []byte{}
	if o.has_session_id {
		res << vproto.pack_64bit_field(o.session_id, 1)
	}
	return res
}

pub fn cremoteclient_cancelpairing_request_unpack(buf []byte) ?CRemoteClient_CancelPairing_Request {
	mut res := CRemoteClient_CancelPairing_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_cancelpairing_request() CRemoteClient_CancelPairing_Request {
	return CRemoteClient_CancelPairing_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_cancelpairing_request(o CRemoteClient_CancelPairing_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_cancelpairing_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_CancelPairing_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_cancelpairing_request_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_CancelPairing_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CRemoteClient_CancelPairing_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cremoteclient_cancelpairing_response_unpack(buf []byte) ?CRemoteClient_CancelPairing_Response {
	res := CRemoteClient_CancelPairing_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_cancelpairing_response() CRemoteClient_CancelPairing_Response {
	return CRemoteClient_CancelPairing_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_cancelpairing_response(o CRemoteClient_CancelPairing_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_cancelpairing_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_CancelPairing_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_cancelpairing_response_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_RegisterStatusUpdate_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	session_id     u64
	has_session_id bool
	steamid        u64
	has_steamid    bool
	device_id      u64
	has_device_id  bool
}

pub fn (o &CRemoteClient_RegisterStatusUpdate_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_session_id {
		res << vproto.pack_64bit_field(o.session_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	if o.has_device_id {
		res << vproto.pack_64bit_field(o.device_id, 3)
	}
	return res
}

pub fn cremoteclient_registerstatusupdate_notification_unpack(buf []byte) ?CRemoteClient_RegisterStatusUpdate_Notification {
	mut res := CRemoteClient_RegisterStatusUpdate_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_device_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.device_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_registerstatusupdate_notification() CRemoteClient_RegisterStatusUpdate_Notification {
	return CRemoteClient_RegisterStatusUpdate_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_registerstatusupdate_notification(o CRemoteClient_RegisterStatusUpdate_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_registerstatusupdate_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_RegisterStatusUpdate_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_registerstatusupdate_notification_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_UnregisterStatusUpdate_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	session_id     u64
	has_session_id bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CRemoteClient_UnregisterStatusUpdate_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_session_id {
		res << vproto.pack_64bit_field(o.session_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	return res
}

pub fn cremoteclient_unregisterstatusupdate_notification_unpack(buf []byte) ?CRemoteClient_UnregisterStatusUpdate_Notification {
	mut res := CRemoteClient_UnregisterStatusUpdate_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_unregisterstatusupdate_notification() CRemoteClient_UnregisterStatusUpdate_Notification {
	return CRemoteClient_UnregisterStatusUpdate_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_unregisterstatusupdate_notification(o CRemoteClient_UnregisterStatusUpdate_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_unregisterstatusupdate_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_UnregisterStatusUpdate_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_unregisterstatusupdate_notification_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_Online_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CRemoteClient_Online_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cremoteclient_online_notification_unpack(buf []byte) ?CRemoteClient_Online_Notification {
	mut res := CRemoteClient_Online_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_online_notification() CRemoteClient_Online_Notification {
	return CRemoteClient_Online_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_online_notification(o CRemoteClient_Online_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_online_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_Online_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_online_notification_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_RemotePacket_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	session_id     u64
	has_session_id bool
	steamid        u64
	has_steamid    bool
	payload        []byte
	has_payload    bool
}

pub fn (o &CRemoteClient_RemotePacket_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_session_id {
		res << vproto.pack_64bit_field(o.session_id, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	if o.has_payload {
		res << vproto.pack_bytes_field(o.payload, 4)
	}
	return res
}

pub fn cremoteclient_remotepacket_notification_unpack(buf []byte) ?CRemoteClient_RemotePacket_Notification {
	mut res := CRemoteClient_RemotePacket_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			4 {
				res.has_payload = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.payload = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_remotepacket_notification() CRemoteClient_RemotePacket_Notification {
	return CRemoteClient_RemotePacket_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_remotepacket_notification(o CRemoteClient_RemotePacket_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_remotepacket_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_RemotePacket_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_remotepacket_notification_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_ReplyPacket_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	session_id     u64
	has_session_id bool
	payload        []byte
	has_payload    bool
}

pub fn (o &CRemoteClient_ReplyPacket_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_session_id {
		res << vproto.pack_64bit_field(o.session_id, 1)
	}
	if o.has_payload {
		res << vproto.pack_bytes_field(o.payload, 2)
	}
	return res
}

pub fn cremoteclient_replypacket_notification_unpack(buf []byte) ?CRemoteClient_ReplyPacket_Notification {
	mut res := CRemoteClient_ReplyPacket_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			2 {
				res.has_payload = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.payload = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_replypacket_notification() CRemoteClient_ReplyPacket_Notification {
	return CRemoteClient_ReplyPacket_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_replypacket_notification(o CRemoteClient_ReplyPacket_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_replypacket_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_ReplyPacket_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_replypacket_notification_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_GetReplies_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	session_id     u64
	has_session_id bool
}

pub fn (o &CRemoteClient_GetReplies_Request) pack() []byte {
	mut res := []byte{}
	if o.has_session_id {
		res << vproto.pack_64bit_field(o.session_id, 1)
	}
	return res
}

pub fn cremoteclient_getreplies_request_unpack(buf []byte) ?CRemoteClient_GetReplies_Request {
	mut res := CRemoteClient_GetReplies_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_session_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.session_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_getreplies_request() CRemoteClient_GetReplies_Request {
	return CRemoteClient_GetReplies_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_getreplies_request(o CRemoteClient_GetReplies_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_getreplies_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_GetReplies_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_getreplies_request_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_GetReplies_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	payload        [][]byte
}

pub fn (o &CRemoteClient_GetReplies_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.payload {
		res << vproto.pack_bytes_field(x, 1)
	}
	return res
}

pub fn cremoteclient_getreplies_response_unpack(buf []byte) ?CRemoteClient_GetReplies_Response {
	mut res := CRemoteClient_GetReplies_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.payload << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_getreplies_response() CRemoteClient_GetReplies_Response {
	return CRemoteClient_GetReplies_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_getreplies_response(o CRemoteClient_GetReplies_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_getreplies_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_GetReplies_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_getreplies_response_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_AllocateTURNServer_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	cellid          u32
	has_cellid      bool
	credentials     string
	has_credentials bool
}

pub fn (o &CRemoteClient_AllocateTURNServer_Request) pack() []byte {
	mut res := []byte{}
	if o.has_cellid {
		res << vproto.pack_uint32_field(o.cellid, 1)
	}
	if o.has_credentials {
		res << vproto.pack_string_field(o.credentials, 2)
	}
	return res
}

pub fn cremoteclient_allocateturnserver_request_unpack(buf []byte) ?CRemoteClient_AllocateTURNServer_Request {
	mut res := CRemoteClient_AllocateTURNServer_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cellid = v
				i = ii
			}
			2 {
				res.has_credentials = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.credentials = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_allocateturnserver_request() CRemoteClient_AllocateTURNServer_Request {
	return CRemoteClient_AllocateTURNServer_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_allocateturnserver_request(o CRemoteClient_AllocateTURNServer_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_allocateturnserver_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_AllocateTURNServer_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_allocateturnserver_request_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_AllocateTURNServer_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	turn_server     string
	has_turn_server bool
}

pub fn (o &CRemoteClient_AllocateTURNServer_Response) pack() []byte {
	mut res := []byte{}
	if o.has_turn_server {
		res << vproto.pack_string_field(o.turn_server, 1)
	}
	return res
}

pub fn cremoteclient_allocateturnserver_response_unpack(buf []byte) ?CRemoteClient_AllocateTURNServer_Response {
	mut res := CRemoteClient_AllocateTURNServer_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_turn_server = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.turn_server = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_allocateturnserver_response() CRemoteClient_AllocateTURNServer_Response {
	return CRemoteClient_AllocateTURNServer_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_allocateturnserver_response(o CRemoteClient_AllocateTURNServer_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_allocateturnserver_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_AllocateTURNServer_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_allocateturnserver_response_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_AllocateRelayServer_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	cellid          u32
	has_cellid      bool
	credentials     string
	has_credentials bool
}

pub fn (o &CRemoteClient_AllocateRelayServer_Request) pack() []byte {
	mut res := []byte{}
	if o.has_cellid {
		res << vproto.pack_uint32_field(o.cellid, 1)
	}
	if o.has_credentials {
		res << vproto.pack_string_field(o.credentials, 2)
	}
	return res
}

pub fn cremoteclient_allocaterelayserver_request_unpack(buf []byte) ?CRemoteClient_AllocateRelayServer_Request {
	mut res := CRemoteClient_AllocateRelayServer_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_cellid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cellid = v
				i = ii
			}
			2 {
				res.has_credentials = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.credentials = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_allocaterelayserver_request() CRemoteClient_AllocateRelayServer_Request {
	return CRemoteClient_AllocateRelayServer_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_allocaterelayserver_request(o CRemoteClient_AllocateRelayServer_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_allocaterelayserver_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_AllocateRelayServer_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_allocaterelayserver_request_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_AllocateRelayServer_Response {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	relay_server     string
	has_relay_server bool
}

pub fn (o &CRemoteClient_AllocateRelayServer_Response) pack() []byte {
	mut res := []byte{}
	if o.has_relay_server {
		res << vproto.pack_string_field(o.relay_server, 1)
	}
	return res
}

pub fn cremoteclient_allocaterelayserver_response_unpack(buf []byte) ?CRemoteClient_AllocateRelayServer_Response {
	mut res := CRemoteClient_AllocateRelayServer_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_relay_server = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.relay_server = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_allocaterelayserver_response() CRemoteClient_AllocateRelayServer_Response {
	return CRemoteClient_AllocateRelayServer_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_allocaterelayserver_response(o CRemoteClient_AllocateRelayServer_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_allocaterelayserver_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_AllocateRelayServer_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_allocaterelayserver_response_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_AllocateSDR_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
}

pub fn (o &CRemoteClient_AllocateSDR_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cremoteclient_allocatesdr_request_unpack(buf []byte) ?CRemoteClient_AllocateSDR_Request {
	mut res := CRemoteClient_AllocateSDR_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_allocatesdr_request() CRemoteClient_AllocateSDR_Request {
	return CRemoteClient_AllocateSDR_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_allocatesdr_request(o CRemoteClient_AllocateSDR_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_allocatesdr_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_AllocateSDR_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_allocatesdr_request_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_AllocateSDR_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CRemoteClient_AllocateSDR_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cremoteclient_allocatesdr_response_unpack(buf []byte) ?CRemoteClient_AllocateSDR_Response {
	res := CRemoteClient_AllocateSDR_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_allocatesdr_response() CRemoteClient_AllocateSDR_Response {
	return CRemoteClient_AllocateSDR_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_allocatesdr_response(o CRemoteClient_AllocateSDR_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_allocatesdr_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_AllocateSDR_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_allocatesdr_response_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_SteamBroadcast_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	clientid       u64
	has_clientid   bool
	payload        []byte
	has_payload    bool
}

pub fn (o &CRemoteClient_SteamBroadcast_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_clientid {
		res << vproto.pack_64bit_field(o.clientid, 2)
	}
	if o.has_payload {
		res << vproto.pack_bytes_field(o.payload, 3)
	}
	return res
}

pub fn cremoteclient_steambroadcast_notification_unpack(buf []byte) ?CRemoteClient_SteamBroadcast_Notification {
	mut res := CRemoteClient_SteamBroadcast_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_clientid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.clientid = v
				i = ii
			}
			3 {
				res.has_payload = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.payload = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_steambroadcast_notification() CRemoteClient_SteamBroadcast_Notification {
	return CRemoteClient_SteamBroadcast_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_steambroadcast_notification(o CRemoteClient_SteamBroadcast_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_steambroadcast_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_SteamBroadcast_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_steambroadcast_notification_unpack(v)?
	return i, unpacked
}

pub struct CRemoteClient_SteamToSteam_Notification {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steamid               u64
	has_steamid           bool
	src_clientid          u64
	has_src_clientid      bool
	dst_clientid          u64
	has_dst_clientid      bool
	secretid              u32
	has_secretid          bool
	encrypted_payload     []byte
	has_encrypted_payload bool
}

pub fn (o &CRemoteClient_SteamToSteam_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_src_clientid {
		res << vproto.pack_64bit_field(o.src_clientid, 2)
	}
	if o.has_dst_clientid {
		res << vproto.pack_64bit_field(o.dst_clientid, 3)
	}
	if o.has_secretid {
		res << vproto.pack_uint32_field(o.secretid, 4)
	}
	if o.has_encrypted_payload {
		res << vproto.pack_bytes_field(o.encrypted_payload, 5)
	}
	return res
}

pub fn cremoteclient_steamtosteam_notification_unpack(buf []byte) ?CRemoteClient_SteamToSteam_Notification {
	mut res := CRemoteClient_SteamToSteam_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_src_clientid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.src_clientid = v
				i = ii
			}
			3 {
				res.has_dst_clientid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.dst_clientid = v
				i = ii
			}
			4 {
				res.has_secretid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.secretid = v
				i = ii
			}
			5 {
				res.has_encrypted_payload = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.encrypted_payload = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclient_steamtosteam_notification() CRemoteClient_SteamToSteam_Notification {
	return CRemoteClient_SteamToSteam_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclient_steamtosteam_notification(o CRemoteClient_SteamToSteam_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclient_steamtosteam_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClient_SteamToSteam_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteclient_steamtosteam_notification_unpack(v)?
	return i, unpacked
}

pub struct CRemotePlay_SessionStarted_Request {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	host_account_id        u32
	has_host_account_id    bool
	client_account_id      u32
	has_client_account_id  bool
	appid                  u32
	has_appid              bool
	device_form_factor     int
	has_device_form_factor bool
}

pub fn (o &CRemotePlay_SessionStarted_Request) pack() []byte {
	mut res := []byte{}
	if o.has_host_account_id {
		res << vproto.pack_uint32_field(o.host_account_id, 1)
	}
	if o.has_client_account_id {
		res << vproto.pack_uint32_field(o.client_account_id, 2)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 3)
	}
	if o.has_device_form_factor {
		res << vproto.pack_int32_field(o.device_form_factor, 4)
	}
	return res
}

pub fn cremoteplay_sessionstarted_request_unpack(buf []byte) ?CRemotePlay_SessionStarted_Request {
	mut res := CRemotePlay_SessionStarted_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_host_account_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.host_account_id = v
				i = ii
			}
			2 {
				res.has_client_account_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_account_id = v
				i = ii
			}
			3 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			4 {
				res.has_device_form_factor = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.device_form_factor = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteplay_sessionstarted_request() CRemotePlay_SessionStarted_Request {
	return CRemotePlay_SessionStarted_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteplay_sessionstarted_request(o CRemotePlay_SessionStarted_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteplay_sessionstarted_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemotePlay_SessionStarted_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteplay_sessionstarted_request_unpack(v)?
	return i, unpacked
}

pub struct CRemotePlay_SessionStarted_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	record_id      u64
	has_record_id  bool
}

pub fn (o &CRemotePlay_SessionStarted_Response) pack() []byte {
	mut res := []byte{}
	if o.has_record_id {
		res << vproto.pack_64bit_field(o.record_id, 1)
	}
	return res
}

pub fn cremoteplay_sessionstarted_response_unpack(buf []byte) ?CRemotePlay_SessionStarted_Response {
	mut res := CRemotePlay_SessionStarted_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_record_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.record_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteplay_sessionstarted_response() CRemotePlay_SessionStarted_Response {
	return CRemotePlay_SessionStarted_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteplay_sessionstarted_response(o CRemotePlay_SessionStarted_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteplay_sessionstarted_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemotePlay_SessionStarted_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteplay_sessionstarted_response_unpack(v)?
	return i, unpacked
}

pub struct CRemotePlay_SessionStopped_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	record_id      u64
	has_record_id  bool
	used_x264      bool
	has_used_x264  bool
	used_h264      bool
	has_used_h264  bool
	used_hevc      bool
	has_used_hevc  bool
}

pub fn (o &CRemotePlay_SessionStopped_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_record_id {
		res << vproto.pack_64bit_field(o.record_id, 1)
	}
	if o.has_used_x264 {
		res << vproto.pack_bool_field(o.used_x264, 2)
	}
	if o.has_used_h264 {
		res << vproto.pack_bool_field(o.used_h264, 3)
	}
	if o.has_used_hevc {
		res << vproto.pack_bool_field(o.used_hevc, 4)
	}
	return res
}

pub fn cremoteplay_sessionstopped_notification_unpack(buf []byte) ?CRemotePlay_SessionStopped_Notification {
	mut res := CRemotePlay_SessionStopped_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_record_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.record_id = v
				i = ii
			}
			2 {
				res.has_used_x264 = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.used_x264 = v
				i = ii
			}
			3 {
				res.has_used_h264 = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.used_h264 = v
				i = ii
			}
			4 {
				res.has_used_hevc = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.used_hevc = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteplay_sessionstopped_notification() CRemotePlay_SessionStopped_Notification {
	return CRemotePlay_SessionStopped_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteplay_sessionstopped_notification(o CRemotePlay_SessionStopped_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteplay_sessionstopped_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemotePlay_SessionStopped_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteplay_sessionstopped_notification_unpack(v)?
	return i, unpacked
}

pub struct CRemotePlayTogether_Notification_ControllerSlots {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	slotid         u32
	has_slotid     bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CRemotePlayTogether_Notification_ControllerSlots) pack() []byte {
	mut res := []byte{}
	if o.has_slotid {
		res << vproto.pack_uint32_field(o.slotid, 1)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 2)
	}
	return res
}

pub fn cremoteplaytogether_notification_controllerslots_unpack(buf []byte) ?CRemotePlayTogether_Notification_ControllerSlots {
	mut res := CRemotePlayTogether_Notification_ControllerSlots{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_slotid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.slotid = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteplaytogether_notification_controllerslots() CRemotePlayTogether_Notification_ControllerSlots {
	return CRemotePlayTogether_Notification_ControllerSlots{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteplaytogether_notification_controllerslots(o CRemotePlayTogether_Notification_ControllerSlots, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteplaytogether_notification_controllerslots(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemotePlayTogether_Notification_ControllerSlots) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteplaytogether_notification_controllerslots_unpack(v)?
	return i, unpacked
}

pub struct CRemotePlayTogether_Notification_GroupUpdated {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	host_steamid      u64
	has_host_steamid  bool
	host_clientid     u64
	has_host_clientid bool
	players           []u64
	host_gameid       u64
	has_host_gameid   bool
	controller_slots  []CRemotePlayTogether_Notification_ControllerSlots
}

pub fn (o &CRemotePlayTogether_Notification_GroupUpdated) pack() []byte {
	mut res := []byte{}
	if o.has_host_steamid {
		res << vproto.pack_64bit_field(o.host_steamid, 1)
	}
	if o.has_host_clientid {
		res << vproto.pack_64bit_field(o.host_clientid, 2)
	}
	// [packed=false]
	for _, x in o.players {
		res << vproto.pack_64bit_field(x, 3)
	}
	if o.has_host_gameid {
		res << vproto.pack_64bit_field(o.host_gameid, 4)
	}
	// [packed=false]
	for _, x in o.controller_slots {
		res << zzz_vproto_internal_pack_cremoteplaytogether_notification_controllerslots(x, 5)
	}
	return res
}

pub fn cremoteplaytogether_notification_groupupdated_unpack(buf []byte) ?CRemotePlayTogether_Notification_GroupUpdated {
	mut res := CRemotePlayTogether_Notification_GroupUpdated{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_host_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.host_steamid = v
				i = ii
			}
			2 {
				res.has_host_clientid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.host_clientid = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.players << v
				i = ii
			}
			4 {
				res.has_host_gameid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.host_gameid = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cremoteplaytogether_notification_controllerslots(cur_buf,
					tag_wiretype.wire_type)?
				res.controller_slots << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteplaytogether_notification_groupupdated() CRemotePlayTogether_Notification_GroupUpdated {
	return CRemotePlayTogether_Notification_GroupUpdated{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteplaytogether_notification_groupupdated(o CRemotePlayTogether_Notification_GroupUpdated, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteplaytogether_notification_groupupdated(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemotePlayTogether_Notification_GroupUpdated) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteplaytogether_notification_groupupdated_unpack(v)?
	return i, unpacked
}

pub struct CRemotePlayTogether_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CRemotePlayTogether_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cremoteplaytogether_notification_unpack(buf []byte) ?CRemotePlayTogether_Notification {
	mut res := CRemotePlayTogether_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteplaytogether_notification() CRemotePlayTogether_Notification {
	return CRemotePlayTogether_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteplaytogether_notification(o CRemotePlayTogether_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteplaytogether_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemotePlayTogether_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremoteplaytogether_notification_unpack(v)?
	return i, unpacked
}
