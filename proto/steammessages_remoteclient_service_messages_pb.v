
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


pub struct CRemoteClientCreateSessionRequest {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CRemoteClientCreateSessionRequest) pack() []byte {
res := []byte{}
return res
}

pub fn cremoteclientcreatesessionrequest_unpack(buf []byte) ?CRemoteClientCreateSessionRequest {
res := CRemoteClientCreateSessionRequest{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientcreatesessionrequest() CRemoteClientCreateSessionRequest {
return CRemoteClientCreateSessionRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientcreatesessionrequest(o CRemoteClientCreateSessionRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientcreatesessionrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientCreateSessionRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientcreatesessionrequest_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientCreateSessionResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
session_id u64
has_session_id bool
euniverse int
has_euniverse bool
}
pub fn (o &CRemoteClientCreateSessionResponse) pack() []byte {
mut res := []byte{}
if o.has_session_id {
res << vproto.pack_64bit_field(o.session_id, 1)
}

if o.has_euniverse {
res << vproto.pack_int32_field(o.euniverse, 2)
}

return res
}

pub fn cremoteclientcreatesessionresponse_unpack(buf []byte) ?CRemoteClientCreateSessionResponse {
mut res := CRemoteClientCreateSessionResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_session_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.session_id = v
i = ii
}

2 {
res.has_euniverse = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.euniverse = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientcreatesessionresponse() CRemoteClientCreateSessionResponse {
return CRemoteClientCreateSessionResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientcreatesessionresponse(o CRemoteClientCreateSessionResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientcreatesessionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientCreateSessionResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientcreatesessionresponse_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientStartPairingRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
session_id u64
has_session_id bool
}
pub fn (o &CRemoteClientStartPairingRequest) pack() []byte {
mut res := []byte{}
if o.has_session_id {
res << vproto.pack_64bit_field(o.session_id, 1)
}

return res
}

pub fn cremoteclientstartpairingrequest_unpack(buf []byte) ?CRemoteClientStartPairingRequest {
mut res := CRemoteClientStartPairingRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_session_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.session_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientstartpairingrequest() CRemoteClientStartPairingRequest {
return CRemoteClientStartPairingRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientstartpairingrequest(o CRemoteClientStartPairingRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientstartpairingrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientStartPairingRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientstartpairingrequest_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientStartPairingResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
pin u32
has_pin bool
}
pub fn (o &CRemoteClientStartPairingResponse) pack() []byte {
mut res := []byte{}
if o.has_pin {
res << vproto.pack_uint32_field(o.pin, 1)
}

return res
}

pub fn cremoteclientstartpairingresponse_unpack(buf []byte) ?CRemoteClientStartPairingResponse {
mut res := CRemoteClientStartPairingResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_pin = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.pin = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientstartpairingresponse() CRemoteClientStartPairingResponse {
return CRemoteClientStartPairingResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientstartpairingresponse(o CRemoteClientStartPairingResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientstartpairingresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientStartPairingResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientstartpairingresponse_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientSetPairingInfoRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
session_id u64
has_session_id bool
device_id u64
has_device_id bool
request []byte
has_request bool
}
pub fn (o &CRemoteClientSetPairingInfoRequest) pack() []byte {
mut res := []byte{}
if o.has_session_id {
res << vproto.pack_64bit_field(o.session_id, 1)
}

if o.has_device_id {
res << vproto.pack_64bit_field(o.device_id, 2)
}

if o.has_request {
res << vproto.pack_bytes_field(o.request, 3)
}

return res
}

pub fn cremoteclientsetpairinginforequest_unpack(buf []byte) ?CRemoteClientSetPairingInfoRequest {
mut res := CRemoteClientSetPairingInfoRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_session_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.session_id = v
i = ii
}

2 {
res.has_device_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.device_id = v
i = ii
}

3 {
res.has_request = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.request = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientsetpairinginforequest() CRemoteClientSetPairingInfoRequest {
return CRemoteClientSetPairingInfoRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientsetpairinginforequest(o CRemoteClientSetPairingInfoRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientsetpairinginforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientSetPairingInfoRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientsetpairinginforequest_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientSetPairingInfoResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CRemoteClientSetPairingInfoResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cremoteclientsetpairinginforesponse_unpack(buf []byte) ?CRemoteClientSetPairingInfoResponse {
res := CRemoteClientSetPairingInfoResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientsetpairinginforesponse() CRemoteClientSetPairingInfoResponse {
return CRemoteClientSetPairingInfoResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientsetpairinginforesponse(o CRemoteClientSetPairingInfoResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientsetpairinginforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientSetPairingInfoResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientsetpairinginforesponse_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientGetPairingInfoRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
pin u32
has_pin bool
}
pub fn (o &CRemoteClientGetPairingInfoRequest) pack() []byte {
mut res := []byte{}
if o.has_pin {
res << vproto.pack_uint32_field(o.pin, 1)
}

return res
}

pub fn cremoteclientgetpairinginforequest_unpack(buf []byte) ?CRemoteClientGetPairingInfoRequest {
mut res := CRemoteClientGetPairingInfoRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_pin = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.pin = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientgetpairinginforequest() CRemoteClientGetPairingInfoRequest {
return CRemoteClientGetPairingInfoRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientgetpairinginforequest(o CRemoteClientGetPairingInfoRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientgetpairinginforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientGetPairingInfoRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientgetpairinginforequest_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientGetPairingInfoResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
session_id u64
has_session_id bool
device_id u64
has_device_id bool
request []byte
has_request bool
}
pub fn (o &CRemoteClientGetPairingInfoResponse) pack() []byte {
mut res := []byte{}
if o.has_session_id {
res << vproto.pack_64bit_field(o.session_id, 1)
}

if o.has_device_id {
res << vproto.pack_64bit_field(o.device_id, 2)
}

if o.has_request {
res << vproto.pack_bytes_field(o.request, 3)
}

return res
}

pub fn cremoteclientgetpairinginforesponse_unpack(buf []byte) ?CRemoteClientGetPairingInfoResponse {
mut res := CRemoteClientGetPairingInfoResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_session_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.session_id = v
i = ii
}

2 {
res.has_device_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.device_id = v
i = ii
}

3 {
res.has_request = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.request = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientgetpairinginforesponse() CRemoteClientGetPairingInfoResponse {
return CRemoteClientGetPairingInfoResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientgetpairinginforesponse(o CRemoteClientGetPairingInfoResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientgetpairinginforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientGetPairingInfoResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientgetpairinginforesponse_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientCancelPairingRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
session_id u64
has_session_id bool
}
pub fn (o &CRemoteClientCancelPairingRequest) pack() []byte {
mut res := []byte{}
if o.has_session_id {
res << vproto.pack_64bit_field(o.session_id, 1)
}

return res
}

pub fn cremoteclientcancelpairingrequest_unpack(buf []byte) ?CRemoteClientCancelPairingRequest {
mut res := CRemoteClientCancelPairingRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_session_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.session_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientcancelpairingrequest() CRemoteClientCancelPairingRequest {
return CRemoteClientCancelPairingRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientcancelpairingrequest(o CRemoteClientCancelPairingRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientcancelpairingrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientCancelPairingRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientcancelpairingrequest_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientCancelPairingResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CRemoteClientCancelPairingResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cremoteclientcancelpairingresponse_unpack(buf []byte) ?CRemoteClientCancelPairingResponse {
res := CRemoteClientCancelPairingResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientcancelpairingresponse() CRemoteClientCancelPairingResponse {
return CRemoteClientCancelPairingResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientcancelpairingresponse(o CRemoteClientCancelPairingResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientcancelpairingresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientCancelPairingResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientcancelpairingresponse_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientRegisterStatusUpdateNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
session_id u64
has_session_id bool
steamid u64
has_steamid bool
device_id u64
has_device_id bool
}
pub fn (o &CRemoteClientRegisterStatusUpdateNotification) pack() []byte {
mut res := []byte{}
if o.has_session_id {
res << vproto.pack_64bit_field(o.session_id, 1)
}

if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 2)
}

if o.has_device_id {
res << vproto.pack_64bit_field(o.device_id, 3)
}

return res
}

pub fn cremoteclientregisterstatusupdatenotification_unpack(buf []byte) ?CRemoteClientRegisterStatusUpdateNotification {
mut res := CRemoteClientRegisterStatusUpdateNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_session_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.session_id = v
i = ii
}

2 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

3 {
res.has_device_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.device_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientregisterstatusupdatenotification() CRemoteClientRegisterStatusUpdateNotification {
return CRemoteClientRegisterStatusUpdateNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientregisterstatusupdatenotification(o CRemoteClientRegisterStatusUpdateNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientregisterstatusupdatenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientRegisterStatusUpdateNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientregisterstatusupdatenotification_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientUnregisterStatusUpdateNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
session_id u64
has_session_id bool
steamid u64
has_steamid bool
}
pub fn (o &CRemoteClientUnregisterStatusUpdateNotification) pack() []byte {
mut res := []byte{}
if o.has_session_id {
res << vproto.pack_64bit_field(o.session_id, 1)
}

if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 2)
}

return res
}

pub fn cremoteclientunregisterstatusupdatenotification_unpack(buf []byte) ?CRemoteClientUnregisterStatusUpdateNotification {
mut res := CRemoteClientUnregisterStatusUpdateNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_session_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.session_id = v
i = ii
}

2 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientunregisterstatusupdatenotification() CRemoteClientUnregisterStatusUpdateNotification {
return CRemoteClientUnregisterStatusUpdateNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientunregisterstatusupdatenotification(o CRemoteClientUnregisterStatusUpdateNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientunregisterstatusupdatenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientUnregisterStatusUpdateNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientunregisterstatusupdatenotification_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientOnlineNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
}
pub fn (o &CRemoteClientOnlineNotification) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

return res
}

pub fn cremoteclientonlinenotification_unpack(buf []byte) ?CRemoteClientOnlineNotification {
mut res := CRemoteClientOnlineNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientonlinenotification() CRemoteClientOnlineNotification {
return CRemoteClientOnlineNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientonlinenotification(o CRemoteClientOnlineNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientonlinenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientOnlineNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientonlinenotification_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientRemotePacketNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
session_id u64
has_session_id bool
steamid u64
has_steamid bool
payload []byte
has_payload bool
}
pub fn (o &CRemoteClientRemotePacketNotification) pack() []byte {
mut res := []byte{}
if o.has_session_id {
res << vproto.pack_64bit_field(o.session_id, 1)
}

if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 2)
}

if o.has_payload {
res << vproto.pack_bytes_field(o.payload, 4)
}

return res
}

pub fn cremoteclientremotepacketnotification_unpack(buf []byte) ?CRemoteClientRemotePacketNotification {
mut res := CRemoteClientRemotePacketNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_session_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.session_id = v
i = ii
}

2 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

4 {
res.has_payload = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.payload = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientremotepacketnotification() CRemoteClientRemotePacketNotification {
return CRemoteClientRemotePacketNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientremotepacketnotification(o CRemoteClientRemotePacketNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientremotepacketnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientRemotePacketNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientremotepacketnotification_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientReplyPacketNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
session_id u64
has_session_id bool
payload []byte
has_payload bool
}
pub fn (o &CRemoteClientReplyPacketNotification) pack() []byte {
mut res := []byte{}
if o.has_session_id {
res << vproto.pack_64bit_field(o.session_id, 1)
}

if o.has_payload {
res << vproto.pack_bytes_field(o.payload, 2)
}

return res
}

pub fn cremoteclientreplypacketnotification_unpack(buf []byte) ?CRemoteClientReplyPacketNotification {
mut res := CRemoteClientReplyPacketNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_session_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.session_id = v
i = ii
}

2 {
res.has_payload = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.payload = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientreplypacketnotification() CRemoteClientReplyPacketNotification {
return CRemoteClientReplyPacketNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientreplypacketnotification(o CRemoteClientReplyPacketNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientreplypacketnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientReplyPacketNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientreplypacketnotification_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientGetRepliesRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
session_id u64
has_session_id bool
}
pub fn (o &CRemoteClientGetRepliesRequest) pack() []byte {
mut res := []byte{}
if o.has_session_id {
res << vproto.pack_64bit_field(o.session_id, 1)
}

return res
}

pub fn cremoteclientgetrepliesrequest_unpack(buf []byte) ?CRemoteClientGetRepliesRequest {
mut res := CRemoteClientGetRepliesRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_session_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.session_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientgetrepliesrequest() CRemoteClientGetRepliesRequest {
return CRemoteClientGetRepliesRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientgetrepliesrequest(o CRemoteClientGetRepliesRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientgetrepliesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientGetRepliesRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientgetrepliesrequest_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientGetRepliesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
payload [][]byte
}
pub fn (o &CRemoteClientGetRepliesResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.payload {
res << vproto.pack_bytes_field(x, 1)
}

return res
}

pub fn cremoteclientgetrepliesresponse_unpack(buf []byte) ?CRemoteClientGetRepliesResponse {
mut res := CRemoteClientGetRepliesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.payload << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientgetrepliesresponse() CRemoteClientGetRepliesResponse {
return CRemoteClientGetRepliesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientgetrepliesresponse(o CRemoteClientGetRepliesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientgetrepliesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientGetRepliesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientgetrepliesresponse_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientAllocateTUrnserverRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
cellid u32
has_cellid bool
credentials string
has_credentials bool
}
pub fn (o &CRemoteClientAllocateTUrnserverRequest) pack() []byte {
mut res := []byte{}
if o.has_cellid {
res << vproto.pack_uint32_field(o.cellid, 1)
}

if o.has_credentials {
res << vproto.pack_string_field(o.credentials, 2)
}

return res
}

pub fn cremoteclientallocateturnserverrequest_unpack(buf []byte) ?CRemoteClientAllocateTUrnserverRequest {
mut res := CRemoteClientAllocateTUrnserverRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_cellid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cellid = v
i = ii
}

2 {
res.has_credentials = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.credentials = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientallocateturnserverrequest() CRemoteClientAllocateTUrnserverRequest {
return CRemoteClientAllocateTUrnserverRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientallocateturnserverrequest(o CRemoteClientAllocateTUrnserverRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientallocateturnserverrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientAllocateTUrnserverRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientallocateturnserverrequest_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientAllocateTUrnserverResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
turn_server string
has_turn_server bool
}
pub fn (o &CRemoteClientAllocateTUrnserverResponse) pack() []byte {
mut res := []byte{}
if o.has_turn_server {
res << vproto.pack_string_field(o.turn_server, 1)
}

return res
}

pub fn cremoteclientallocateturnserverresponse_unpack(buf []byte) ?CRemoteClientAllocateTUrnserverResponse {
mut res := CRemoteClientAllocateTUrnserverResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_turn_server = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.turn_server = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientallocateturnserverresponse() CRemoteClientAllocateTUrnserverResponse {
return CRemoteClientAllocateTUrnserverResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientallocateturnserverresponse(o CRemoteClientAllocateTUrnserverResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientallocateturnserverresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientAllocateTUrnserverResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientallocateturnserverresponse_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientAllocateRelayServerRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
cellid u32
has_cellid bool
credentials string
has_credentials bool
}
pub fn (o &CRemoteClientAllocateRelayServerRequest) pack() []byte {
mut res := []byte{}
if o.has_cellid {
res << vproto.pack_uint32_field(o.cellid, 1)
}

if o.has_credentials {
res << vproto.pack_string_field(o.credentials, 2)
}

return res
}

pub fn cremoteclientallocaterelayserverrequest_unpack(buf []byte) ?CRemoteClientAllocateRelayServerRequest {
mut res := CRemoteClientAllocateRelayServerRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_cellid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cellid = v
i = ii
}

2 {
res.has_credentials = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.credentials = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientallocaterelayserverrequest() CRemoteClientAllocateRelayServerRequest {
return CRemoteClientAllocateRelayServerRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientallocaterelayserverrequest(o CRemoteClientAllocateRelayServerRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientallocaterelayserverrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientAllocateRelayServerRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientallocaterelayserverrequest_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientAllocateRelayServerResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
relay_server string
has_relay_server bool
}
pub fn (o &CRemoteClientAllocateRelayServerResponse) pack() []byte {
mut res := []byte{}
if o.has_relay_server {
res << vproto.pack_string_field(o.relay_server, 1)
}

return res
}

pub fn cremoteclientallocaterelayserverresponse_unpack(buf []byte) ?CRemoteClientAllocateRelayServerResponse {
mut res := CRemoteClientAllocateRelayServerResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_relay_server = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.relay_server = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientallocaterelayserverresponse() CRemoteClientAllocateRelayServerResponse {
return CRemoteClientAllocateRelayServerResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientallocaterelayserverresponse(o CRemoteClientAllocateRelayServerResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientallocaterelayserverresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientAllocateRelayServerResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientallocaterelayserverresponse_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientAllocateSDrrequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
}
pub fn (o &CRemoteClientAllocateSDrrequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

return res
}

pub fn cremoteclientallocatesdrrequest_unpack(buf []byte) ?CRemoteClientAllocateSDrrequest {
mut res := CRemoteClientAllocateSDrrequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientallocatesdrrequest() CRemoteClientAllocateSDrrequest {
return CRemoteClientAllocateSDrrequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientallocatesdrrequest(o CRemoteClientAllocateSDrrequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientallocatesdrrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientAllocateSDrrequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientallocatesdrrequest_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientAllocateSDrresponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CRemoteClientAllocateSDrresponse) pack() []byte {
res := []byte{}
return res
}

pub fn cremoteclientallocatesdrresponse_unpack(buf []byte) ?CRemoteClientAllocateSDrresponse {
res := CRemoteClientAllocateSDrresponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientallocatesdrresponse() CRemoteClientAllocateSDrresponse {
return CRemoteClientAllocateSDrresponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientallocatesdrresponse(o CRemoteClientAllocateSDrresponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientallocatesdrresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientAllocateSDrresponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientallocatesdrresponse_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientSteamBroadcastNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
clientid u64
has_clientid bool
payload []byte
has_payload bool
}
pub fn (o &CRemoteClientSteamBroadcastNotification) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_clientid {
res << vproto.pack_64bit_field(o.clientid, 2)
}

if o.has_payload {
res << vproto.pack_bytes_field(o.payload, 3)
}

return res
}

pub fn cremoteclientsteambroadcastnotification_unpack(buf []byte) ?CRemoteClientSteamBroadcastNotification {
mut res := CRemoteClientSteamBroadcastNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_clientid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.clientid = v
i = ii
}

3 {
res.has_payload = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.payload = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientsteambroadcastnotification() CRemoteClientSteamBroadcastNotification {
return CRemoteClientSteamBroadcastNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientsteambroadcastnotification(o CRemoteClientSteamBroadcastNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientsteambroadcastnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientSteamBroadcastNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientsteambroadcastnotification_unpack(v)?
return i, unpacked
}
pub struct CRemoteClientSteamToSteamNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
src_clientid u64
has_src_clientid bool
dst_clientid u64
has_dst_clientid bool
secretid u32
has_secretid bool
encrypted_payload []byte
has_encrypted_payload bool
}
pub fn (o &CRemoteClientSteamToSteamNotification) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_src_clientid {
res << vproto.pack_64bit_field(o.src_clientid, 2)
}

if o.has_dst_clientid {
res << vproto.pack_64bit_field(o.dst_clientid, 3)
}

if o.has_secretid {
res << vproto.pack_uint32_field(o.secretid, 4)
}

if o.has_encrypted_payload {
res << vproto.pack_bytes_field(o.encrypted_payload, 5)
}

return res
}

pub fn cremoteclientsteamtosteamnotification_unpack(buf []byte) ?CRemoteClientSteamToSteamNotification {
mut res := CRemoteClientSteamToSteamNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_src_clientid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.src_clientid = v
i = ii
}

3 {
res.has_dst_clientid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.dst_clientid = v
i = ii
}

4 {
res.has_secretid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.secretid = v
i = ii
}

5 {
res.has_encrypted_payload = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.encrypted_payload = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteclientsteamtosteamnotification() CRemoteClientSteamToSteamNotification {
return CRemoteClientSteamToSteamNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteclientsteamtosteamnotification(o CRemoteClientSteamToSteamNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteclientsteamtosteamnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteClientSteamToSteamNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteclientsteamtosteamnotification_unpack(v)?
return i, unpacked
}
pub struct CRemotePlaySessionStartedRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
host_account_id u32
has_host_account_id bool
client_account_id u32
has_client_account_id bool
appid u32
has_appid bool
device_form_factor int
has_device_form_factor bool
}
pub fn (o &CRemotePlaySessionStartedRequest) pack() []byte {
mut res := []byte{}
if o.has_host_account_id {
res << vproto.pack_uint32_field(o.host_account_id, 1)
}

if o.has_client_account_id {
res << vproto.pack_uint32_field(o.client_account_id, 2)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 3)
}

if o.has_device_form_factor {
res << vproto.pack_int32_field(o.device_form_factor, 4)
}

return res
}

pub fn cremoteplaysessionstartedrequest_unpack(buf []byte) ?CRemotePlaySessionStartedRequest {
mut res := CRemotePlaySessionStartedRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_host_account_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.host_account_id = v
i = ii
}

2 {
res.has_client_account_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.client_account_id = v
i = ii
}

3 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

4 {
res.has_device_form_factor = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.device_form_factor = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteplaysessionstartedrequest() CRemotePlaySessionStartedRequest {
return CRemotePlaySessionStartedRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteplaysessionstartedrequest(o CRemotePlaySessionStartedRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteplaysessionstartedrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemotePlaySessionStartedRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteplaysessionstartedrequest_unpack(v)?
return i, unpacked
}
pub struct CRemotePlaySessionStartedResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
record_id u64
has_record_id bool
}
pub fn (o &CRemotePlaySessionStartedResponse) pack() []byte {
mut res := []byte{}
if o.has_record_id {
res << vproto.pack_64bit_field(o.record_id, 1)
}

return res
}

pub fn cremoteplaysessionstartedresponse_unpack(buf []byte) ?CRemotePlaySessionStartedResponse {
mut res := CRemotePlaySessionStartedResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_record_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.record_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteplaysessionstartedresponse() CRemotePlaySessionStartedResponse {
return CRemotePlaySessionStartedResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteplaysessionstartedresponse(o CRemotePlaySessionStartedResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteplaysessionstartedresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemotePlaySessionStartedResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteplaysessionstartedresponse_unpack(v)?
return i, unpacked
}
pub struct CRemotePlaySessionStoppedNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
record_id u64
has_record_id bool
used_x264 bool
has_used_x264 bool
used_h264 bool
has_used_h264 bool
used_hevc bool
has_used_hevc bool
}
pub fn (o &CRemotePlaySessionStoppedNotification) pack() []byte {
mut res := []byte{}
if o.has_record_id {
res << vproto.pack_64bit_field(o.record_id, 1)
}

if o.has_used_x264 {
res << vproto.pack_bool_field(o.used_x264, 2)
}

if o.has_used_h264 {
res << vproto.pack_bool_field(o.used_h264, 3)
}

if o.has_used_hevc {
res << vproto.pack_bool_field(o.used_hevc, 4)
}

return res
}

pub fn cremoteplaysessionstoppednotification_unpack(buf []byte) ?CRemotePlaySessionStoppedNotification {
mut res := CRemotePlaySessionStoppedNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_record_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.record_id = v
i = ii
}

2 {
res.has_used_x264 = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.used_x264 = v
i = ii
}

3 {
res.has_used_h264 = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.used_h264 = v
i = ii
}

4 {
res.has_used_hevc = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.used_hevc = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteplaysessionstoppednotification() CRemotePlaySessionStoppedNotification {
return CRemotePlaySessionStoppedNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteplaysessionstoppednotification(o CRemotePlaySessionStoppedNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteplaysessionstoppednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemotePlaySessionStoppedNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteplaysessionstoppednotification_unpack(v)?
return i, unpacked
}
pub struct CRemotePlayTogetherNotificationControllerSlots {
mut:
unknown_fields []vproto.UnknownField
pub mut:
slotid u32
has_slotid bool
steamid u64
has_steamid bool
}
pub fn (o &CRemotePlayTogetherNotificationControllerSlots) pack() []byte {
mut res := []byte{}
if o.has_slotid {
res << vproto.pack_uint32_field(o.slotid, 1)
}

if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 2)
}

return res
}

pub fn cremoteplaytogethernotificationcontrollerslots_unpack(buf []byte) ?CRemotePlayTogetherNotificationControllerSlots {
mut res := CRemotePlayTogetherNotificationControllerSlots{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_slotid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.slotid = v
i = ii
}

2 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteplaytogethernotificationcontrollerslots() CRemotePlayTogetherNotificationControllerSlots {
return CRemotePlayTogetherNotificationControllerSlots{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteplaytogethernotificationcontrollerslots(o CRemotePlayTogetherNotificationControllerSlots, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteplaytogethernotificationcontrollerslots(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemotePlayTogetherNotificationControllerSlots) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteplaytogethernotificationcontrollerslots_unpack(v)?
return i, unpacked
}
pub struct CRemotePlayTogetherNotificationGroupUpdated {
mut:
unknown_fields []vproto.UnknownField
pub mut:
host_steamid u64
has_host_steamid bool
host_clientid u64
has_host_clientid bool
players []u64
host_gameid u64
has_host_gameid bool
controller_slots []CRemotePlayTogetherNotificationControllerSlots
}
pub fn (o &CRemotePlayTogetherNotificationGroupUpdated) pack() []byte {
mut res := []byte{}
if o.has_host_steamid {
res << vproto.pack_64bit_field(o.host_steamid, 1)
}

if o.has_host_clientid {
res << vproto.pack_64bit_field(o.host_clientid, 2)
}

// [packed=false]
for _, x in o.players {
res << vproto.pack_64bit_field(x, 3)
}

if o.has_host_gameid {
res << vproto.pack_64bit_field(o.host_gameid, 4)
}

// [packed=false]
for _, x in o.controller_slots {
res << zzz_vproto_internal_pack_cremoteplaytogethernotificationcontrollerslots(x, 5)
}

return res
}

pub fn cremoteplaytogethernotificationgroupupdated_unpack(buf []byte) ?CRemotePlayTogetherNotificationGroupUpdated {
mut res := CRemotePlayTogetherNotificationGroupUpdated{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_host_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.host_steamid = v
i = ii
}

2 {
res.has_host_clientid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.host_clientid = v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.players << v
i = ii
}

4 {
res.has_host_gameid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.host_gameid = v
i = ii
}

5 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cremoteplaytogethernotificationcontrollerslots(cur_buf, tag_wiretype.wire_type)?
res.controller_slots << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteplaytogethernotificationgroupupdated() CRemotePlayTogetherNotificationGroupUpdated {
return CRemotePlayTogetherNotificationGroupUpdated{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteplaytogethernotificationgroupupdated(o CRemotePlayTogetherNotificationGroupUpdated, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteplaytogethernotificationgroupupdated(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemotePlayTogetherNotificationGroupUpdated) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteplaytogethernotificationgroupupdated_unpack(v)?
return i, unpacked
}
pub struct CRemotePlayTogetherNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
}
pub fn (o &CRemotePlayTogetherNotification) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

return res
}

pub fn cremoteplaytogethernotification_unpack(buf []byte) ?CRemotePlayTogetherNotification {
mut res := CRemotePlayTogetherNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremoteplaytogethernotification() CRemotePlayTogetherNotification {
return CRemotePlayTogetherNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremoteplaytogethernotification(o CRemotePlayTogetherNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremoteplaytogethernotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemotePlayTogetherNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cremoteplaytogethernotification_unpack(v)?
return i, unpacked
}
