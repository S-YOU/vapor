
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


pub struct CMsgClientUCmaddScreenshotTag {
mut:
unknown_fields []vproto.UnknownField
pub mut:
tag_name string
has_tag_name bool
tag_value string
has_tag_value bool
}
pub fn (o &CMsgClientUCmaddScreenshotTag) pack() []byte {
mut res := []byte{}
if o.has_tag_name {
res << vproto.pack_string_field(o.tag_name, 1)
}

if o.has_tag_value {
res << vproto.pack_string_field(o.tag_value, 2)
}

return res
}

pub fn cmsgclientucmaddscreenshottag_unpack(buf []byte) ?CMsgClientUCmaddScreenshotTag {
mut res := CMsgClientUCmaddScreenshotTag{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_tag_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.tag_name = v
i = ii
}

2 {
res.has_tag_value = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.tag_value = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmaddscreenshottag() CMsgClientUCmaddScreenshotTag {
return CMsgClientUCmaddScreenshotTag{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmaddscreenshottag(o CMsgClientUCmaddScreenshotTag, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmaddscreenshottag(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmaddScreenshotTag) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmaddscreenshottag_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmaddScreenshot {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
filename string
has_filename bool
thumbname string
has_thumbname bool
vr_filename string
has_vr_filename bool
rtime32_created u32
has_rtime32_created bool
width u32
has_width bool
height u32
has_height bool
permissions u32
has_permissions bool
caption string
has_caption bool
shortcut_name string
has_shortcut_name bool
tag []CMsgClientUCmaddScreenshotTag
tagged_steamid []u64
spoiler_tag bool
has_spoiler_tag bool
tagged_publishedfileid []u64
}
pub fn (o &CMsgClientUCmaddScreenshot) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_filename {
res << vproto.pack_string_field(o.filename, 2)
}

if o.has_thumbname {
res << vproto.pack_string_field(o.thumbname, 3)
}

if o.has_vr_filename {
res << vproto.pack_string_field(o.vr_filename, 14)
}

if o.has_rtime32_created {
res << vproto.pack_32bit_field(o.rtime32_created, 4)
}

if o.has_width {
res << vproto.pack_uint32_field(o.width, 5)
}

if o.has_height {
res << vproto.pack_uint32_field(o.height, 6)
}

if o.has_permissions {
res << vproto.pack_uint32_field(o.permissions, 7)
}

if o.has_caption {
res << vproto.pack_string_field(o.caption, 8)
}

if o.has_shortcut_name {
res << vproto.pack_string_field(o.shortcut_name, 9)
}

// [packed=false]
for _, x in o.tag {
res << zzz_vproto_internal_pack_cmsgclientucmaddscreenshottag(x, 10)
}

// [packed=false]
for _, x in o.tagged_steamid {
res << vproto.pack_64bit_field(x, 11)
}

if o.has_spoiler_tag {
res << vproto.pack_bool_field(o.spoiler_tag, 12)
}

// [packed=false]
for _, x in o.tagged_publishedfileid {
res << vproto.pack_uint64_field(x, 13)
}

return res
}

pub fn cmsgclientucmaddscreenshot_unpack(buf []byte) ?CMsgClientUCmaddScreenshot {
mut res := CMsgClientUCmaddScreenshot{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename = v
i = ii
}

3 {
res.has_thumbname = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.thumbname = v
i = ii
}

14 {
res.has_vr_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.vr_filename = v
i = ii
}

4 {
res.has_rtime32_created = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.rtime32_created = v
i = ii
}

5 {
res.has_width = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.width = v
i = ii
}

6 {
res.has_height = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.height = v
i = ii
}

7 {
res.has_permissions = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.permissions = v
i = ii
}

8 {
res.has_caption = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.caption = v
i = ii
}

9 {
res.has_shortcut_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.shortcut_name = v
i = ii
}

10 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientucmaddscreenshottag(cur_buf, tag_wiretype.wire_type)?
res.tag << v
i = ii
}

11 {
// [packed=false]
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.tagged_steamid << v
i = ii
}

12 {
res.has_spoiler_tag = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.spoiler_tag = v
i = ii
}

13 {
// [packed=false]
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.tagged_publishedfileid << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmaddscreenshot() CMsgClientUCmaddScreenshot {
return CMsgClientUCmaddScreenshot{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmaddscreenshot(o CMsgClientUCmaddScreenshot, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmaddscreenshot(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmaddScreenshot) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmaddscreenshot_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmaddScreenshotResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
screenshotid u64
has_screenshotid bool
}
pub fn (o &CMsgClientUCmaddScreenshotResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_screenshotid {
res << vproto.pack_64bit_field(o.screenshotid, 2)
}

return res
}

pub fn cmsgclientucmaddscreenshotresponse_unpack(buf []byte) ?CMsgClientUCmaddScreenshotResponse {
mut res := CMsgClientUCmaddScreenshotResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_screenshotid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.screenshotid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmaddscreenshotresponse() CMsgClientUCmaddScreenshotResponse {
return CMsgClientUCmaddScreenshotResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmaddscreenshotresponse(o CMsgClientUCmaddScreenshotResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmaddscreenshotresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmaddScreenshotResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmaddscreenshotresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmdeleteScreenshot {
mut:
unknown_fields []vproto.UnknownField
pub mut:
screenshotid u64
has_screenshotid bool
}
pub fn (o &CMsgClientUCmdeleteScreenshot) pack() []byte {
mut res := []byte{}
if o.has_screenshotid {
res << vproto.pack_64bit_field(o.screenshotid, 1)
}

return res
}

pub fn cmsgclientucmdeletescreenshot_unpack(buf []byte) ?CMsgClientUCmdeleteScreenshot {
mut res := CMsgClientUCmdeleteScreenshot{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_screenshotid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.screenshotid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmdeletescreenshot() CMsgClientUCmdeleteScreenshot {
return CMsgClientUCmdeleteScreenshot{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmdeletescreenshot(o CMsgClientUCmdeleteScreenshot, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmdeletescreenshot(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmdeleteScreenshot) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmdeletescreenshot_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmdeleteScreenshotResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
}
pub fn (o &CMsgClientUCmdeleteScreenshotResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

return res
}

pub fn cmsgclientucmdeletescreenshotresponse_unpack(buf []byte) ?CMsgClientUCmdeleteScreenshotResponse {
mut res := CMsgClientUCmdeleteScreenshotResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmdeletescreenshotresponse() CMsgClientUCmdeleteScreenshotResponse {
return CMsgClientUCmdeleteScreenshotResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmdeletescreenshotresponse(o CMsgClientUCmdeleteScreenshotResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmdeletescreenshotresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmdeleteScreenshotResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmdeletescreenshotresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmpublishFile {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
file_name string
has_file_name bool
preview_file_name string
has_preview_file_name bool
consumer_app_id u32
has_consumer_app_id bool
title string
has_title bool
description string
has_description bool
tags []string
workshop_file bool
has_workshop_file bool
visibility int
has_visibility bool
file_type u32
has_file_type bool
url string
has_url bool
video_provider u32
has_video_provider bool
video_account_name string
has_video_account_name bool
video_identifier string
has_video_identifier bool
in_progress bool
has_in_progress bool
}
pub fn (o &CMsgClientUCmpublishFile) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_file_name {
res << vproto.pack_string_field(o.file_name, 2)
}

if o.has_preview_file_name {
res << vproto.pack_string_field(o.preview_file_name, 3)
}

if o.has_consumer_app_id {
res << vproto.pack_uint32_field(o.consumer_app_id, 4)
}

if o.has_title {
res << vproto.pack_string_field(o.title, 5)
}

if o.has_description {
res << vproto.pack_string_field(o.description, 6)
}

// [packed=false]
for _, x in o.tags {
res << vproto.pack_string_field(x, 8)
}

if o.has_workshop_file {
res << vproto.pack_bool_field(o.workshop_file, 9)
}

if o.has_visibility {
res << vproto.pack_int32_field(o.visibility, 10)
}

if o.has_file_type {
res << vproto.pack_uint32_field(o.file_type, 11)
}

if o.has_url {
res << vproto.pack_string_field(o.url, 12)
}

if o.has_video_provider {
res << vproto.pack_uint32_field(o.video_provider, 13)
}

if o.has_video_account_name {
res << vproto.pack_string_field(o.video_account_name, 14)
}

if o.has_video_identifier {
res << vproto.pack_string_field(o.video_identifier, 15)
}

if o.has_in_progress {
res << vproto.pack_bool_field(o.in_progress, 16)
}

return res
}

pub fn cmsgclientucmpublishfile_unpack(buf []byte) ?CMsgClientUCmpublishFile {
mut res := CMsgClientUCmpublishFile{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_name = v
i = ii
}

3 {
res.has_preview_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.preview_file_name = v
i = ii
}

4 {
res.has_consumer_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.consumer_app_id = v
i = ii
}

5 {
res.has_title = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.title = v
i = ii
}

6 {
res.has_description = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.description = v
i = ii
}

8 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.tags << v
i = ii
}

9 {
res.has_workshop_file = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.workshop_file = v
i = ii
}

10 {
res.has_visibility = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.visibility = v
i = ii
}

11 {
res.has_file_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.file_type = v
i = ii
}

12 {
res.has_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.url = v
i = ii
}

13 {
res.has_video_provider = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.video_provider = v
i = ii
}

14 {
res.has_video_account_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.video_account_name = v
i = ii
}

15 {
res.has_video_identifier = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.video_identifier = v
i = ii
}

16 {
res.has_in_progress = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.in_progress = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmpublishfile() CMsgClientUCmpublishFile {
return CMsgClientUCmpublishFile{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmpublishfile(o CMsgClientUCmpublishFile, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmpublishfile(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmpublishFile) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmpublishfile_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmpublishFileResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
published_file_id u64
has_published_file_id bool
needs_workshop_legal_agreement_acceptance bool
has_needs_workshop_legal_agreement_acceptance bool
}
pub fn (o &CMsgClientUCmpublishFileResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 2)
}

if o.has_needs_workshop_legal_agreement_acceptance {
res << vproto.pack_bool_field(o.needs_workshop_legal_agreement_acceptance, 3)
}

return res
}

pub fn cmsgclientucmpublishfileresponse_unpack(buf []byte) ?CMsgClientUCmpublishFileResponse {
mut res := CMsgClientUCmpublishFileResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

3 {
res.has_needs_workshop_legal_agreement_acceptance = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.needs_workshop_legal_agreement_acceptance = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmpublishfileresponse() CMsgClientUCmpublishFileResponse {
return CMsgClientUCmpublishFileResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmpublishfileresponse(o CMsgClientUCmpublishFileResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmpublishfileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmpublishFileResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmpublishfileresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmupdatePublishedFileKeyValueTag {
mut:
unknown_fields []vproto.UnknownField
pub mut:
key string
has_key bool
value string
has_value bool
}
pub fn (o &CMsgClientUCmupdatePublishedFileKeyValueTag) pack() []byte {
mut res := []byte{}
if o.has_key {
res << vproto.pack_string_field(o.key, 1)
}

if o.has_value {
res << vproto.pack_string_field(o.value, 2)
}

return res
}

pub fn cmsgclientucmupdatepublishedfilekeyvaluetag_unpack(buf []byte) ?CMsgClientUCmupdatePublishedFileKeyValueTag {
mut res := CMsgClientUCmupdatePublishedFileKeyValueTag{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_key = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.key = v
i = ii
}

2 {
res.has_value = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.value = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmupdatepublishedfilekeyvaluetag() CMsgClientUCmupdatePublishedFileKeyValueTag {
return CMsgClientUCmupdatePublishedFileKeyValueTag{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmupdatepublishedfilekeyvaluetag(o CMsgClientUCmupdatePublishedFileKeyValueTag, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmupdatepublishedfilekeyvaluetag(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmupdatePublishedFileKeyValueTag) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmupdatepublishedfilekeyvaluetag_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmupdatePublishedFileAdditionalPreview {
mut:
unknown_fields []vproto.UnknownField
pub mut:
original_file_name string
has_original_file_name bool
internal_file_name string
has_internal_file_name bool
videoid string
has_videoid bool
preview_type u32
has_preview_type bool
update_index int
has_update_index bool
}
pub fn (o &CMsgClientUCmupdatePublishedFileAdditionalPreview) pack() []byte {
mut res := []byte{}
if o.has_original_file_name {
res << vproto.pack_string_field(o.original_file_name, 1)
}

if o.has_internal_file_name {
res << vproto.pack_string_field(o.internal_file_name, 2)
}

if o.has_videoid {
res << vproto.pack_string_field(o.videoid, 3)
}

if o.has_preview_type {
res << vproto.pack_uint32_field(o.preview_type, 4)
}

if o.has_update_index {
res << vproto.pack_int32_field(o.update_index, 5)
}

return res
}

pub fn cmsgclientucmupdatepublishedfileadditionalpreview_unpack(buf []byte) ?CMsgClientUCmupdatePublishedFileAdditionalPreview {
mut res := CMsgClientUCmupdatePublishedFileAdditionalPreview{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_original_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.original_file_name = v
i = ii
}

2 {
res.has_internal_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.internal_file_name = v
i = ii
}

3 {
res.has_videoid = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.videoid = v
i = ii
}

4 {
res.has_preview_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.preview_type = v
i = ii
}

5 {
res.has_update_index = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.update_index = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmupdatepublishedfileadditionalpreview() CMsgClientUCmupdatePublishedFileAdditionalPreview {
return CMsgClientUCmupdatePublishedFileAdditionalPreview{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmupdatepublishedfileadditionalpreview(o CMsgClientUCmupdatePublishedFileAdditionalPreview, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmupdatepublishedfileadditionalpreview(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmupdatePublishedFileAdditionalPreview) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmupdatepublishedfileadditionalpreview_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmupdatePublishedFile {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
published_file_id u64
has_published_file_id bool
file_name string
has_file_name bool
preview_file_name string
has_preview_file_name bool
title string
has_title bool
description string
has_description bool
tags []string
visibility int
has_visibility bool
update_file bool
has_update_file bool
update_preview_file bool
has_update_preview_file bool
update_title bool
has_update_title bool
update_description bool
has_update_description bool
update_tags bool
has_update_tags bool
update_visibility bool
has_update_visibility bool
change_description string
has_change_description bool
update_url bool
has_update_url bool
url string
has_url bool
update_content_manifest bool
has_update_content_manifest bool
content_manifest u64
has_content_manifest bool
metadata string
has_metadata bool
update_metadata bool
has_update_metadata bool
language int
has_language bool
removed_kvtags []string
kvtags []CMsgClientUCmupdatePublishedFileKeyValueTag
previews []CMsgClientUCmupdatePublishedFileAdditionalPreview
previews_to_remove []int
clear_in_progress bool
has_clear_in_progress bool
remove_all_kvtags bool
has_remove_all_kvtags bool
}
pub fn (o &CMsgClientUCmupdatePublishedFile) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 2)
}

if o.has_file_name {
res << vproto.pack_string_field(o.file_name, 3)
}

if o.has_preview_file_name {
res << vproto.pack_string_field(o.preview_file_name, 4)
}

if o.has_title {
res << vproto.pack_string_field(o.title, 5)
}

if o.has_description {
res << vproto.pack_string_field(o.description, 6)
}

// [packed=false]
for _, x in o.tags {
res << vproto.pack_string_field(x, 7)
}

if o.has_visibility {
res << vproto.pack_int32_field(o.visibility, 8)
}

if o.has_update_file {
res << vproto.pack_bool_field(o.update_file, 9)
}

if o.has_update_preview_file {
res << vproto.pack_bool_field(o.update_preview_file, 10)
}

if o.has_update_title {
res << vproto.pack_bool_field(o.update_title, 11)
}

if o.has_update_description {
res << vproto.pack_bool_field(o.update_description, 12)
}

if o.has_update_tags {
res << vproto.pack_bool_field(o.update_tags, 13)
}

if o.has_update_visibility {
res << vproto.pack_bool_field(o.update_visibility, 14)
}

if o.has_change_description {
res << vproto.pack_string_field(o.change_description, 15)
}

if o.has_update_url {
res << vproto.pack_bool_field(o.update_url, 16)
}

if o.has_url {
res << vproto.pack_string_field(o.url, 17)
}

if o.has_update_content_manifest {
res << vproto.pack_bool_field(o.update_content_manifest, 18)
}

if o.has_content_manifest {
res << vproto.pack_64bit_field(o.content_manifest, 19)
}

if o.has_metadata {
res << vproto.pack_string_field(o.metadata, 20)
}

if o.has_update_metadata {
res << vproto.pack_bool_field(o.update_metadata, 21)
}

if o.has_language {
res << vproto.pack_int32_field(o.language, 22)
}

// [packed=false]
for _, x in o.removed_kvtags {
res << vproto.pack_string_field(x, 23)
}

// [packed=false]
for _, x in o.kvtags {
res << zzz_vproto_internal_pack_cmsgclientucmupdatepublishedfilekeyvaluetag(x, 24)
}

// [packed=false]
for _, x in o.previews {
res << zzz_vproto_internal_pack_cmsgclientucmupdatepublishedfileadditionalpreview(x, 25)
}

// [packed=false]
for _, x in o.previews_to_remove {
res << vproto.pack_int32_field(x, 26)
}

if o.has_clear_in_progress {
res << vproto.pack_bool_field(o.clear_in_progress, 27)
}

if o.has_remove_all_kvtags {
res << vproto.pack_bool_field(o.remove_all_kvtags, 28)
}

return res
}

pub fn cmsgclientucmupdatepublishedfile_unpack(buf []byte) ?CMsgClientUCmupdatePublishedFile {
mut res := CMsgClientUCmupdatePublishedFile{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

3 {
res.has_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.file_name = v
i = ii
}

4 {
res.has_preview_file_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.preview_file_name = v
i = ii
}

5 {
res.has_title = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.title = v
i = ii
}

6 {
res.has_description = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.description = v
i = ii
}

7 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.tags << v
i = ii
}

8 {
res.has_visibility = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.visibility = v
i = ii
}

9 {
res.has_update_file = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.update_file = v
i = ii
}

10 {
res.has_update_preview_file = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.update_preview_file = v
i = ii
}

11 {
res.has_update_title = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.update_title = v
i = ii
}

12 {
res.has_update_description = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.update_description = v
i = ii
}

13 {
res.has_update_tags = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.update_tags = v
i = ii
}

14 {
res.has_update_visibility = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.update_visibility = v
i = ii
}

15 {
res.has_change_description = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.change_description = v
i = ii
}

16 {
res.has_update_url = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.update_url = v
i = ii
}

17 {
res.has_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.url = v
i = ii
}

18 {
res.has_update_content_manifest = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.update_content_manifest = v
i = ii
}

19 {
res.has_content_manifest = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.content_manifest = v
i = ii
}

20 {
res.has_metadata = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.metadata = v
i = ii
}

21 {
res.has_update_metadata = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.update_metadata = v
i = ii
}

22 {
res.has_language = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

23 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.removed_kvtags << v
i = ii
}

24 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientucmupdatepublishedfilekeyvaluetag(cur_buf, tag_wiretype.wire_type)?
res.kvtags << v
i = ii
}

25 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientucmupdatepublishedfileadditionalpreview(cur_buf, tag_wiretype.wire_type)?
res.previews << v
i = ii
}

26 {
// [packed=false]
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.previews_to_remove << v
i = ii
}

27 {
res.has_clear_in_progress = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.clear_in_progress = v
i = ii
}

28 {
res.has_remove_all_kvtags = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.remove_all_kvtags = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmupdatepublishedfile() CMsgClientUCmupdatePublishedFile {
return CMsgClientUCmupdatePublishedFile{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmupdatepublishedfile(o CMsgClientUCmupdatePublishedFile, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmupdatepublishedfile(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmupdatePublishedFile) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmupdatepublishedfile_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmupdatePublishedFileResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
needs_workshop_legal_agreement_acceptance bool
has_needs_workshop_legal_agreement_acceptance bool
}
pub fn (o &CMsgClientUCmupdatePublishedFileResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_needs_workshop_legal_agreement_acceptance {
res << vproto.pack_bool_field(o.needs_workshop_legal_agreement_acceptance, 2)
}

return res
}

pub fn cmsgclientucmupdatepublishedfileresponse_unpack(buf []byte) ?CMsgClientUCmupdatePublishedFileResponse {
mut res := CMsgClientUCmupdatePublishedFileResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_needs_workshop_legal_agreement_acceptance = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.needs_workshop_legal_agreement_acceptance = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmupdatepublishedfileresponse() CMsgClientUCmupdatePublishedFileResponse {
return CMsgClientUCmupdatePublishedFileResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmupdatepublishedfileresponse(o CMsgClientUCmupdatePublishedFileResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmupdatepublishedfileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmupdatePublishedFileResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmupdatepublishedfileresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmdeletePublishedFile {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
app_id u32
has_app_id bool
}
pub fn (o &CMsgClientUCmdeletePublishedFile) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

return res
}

pub fn cmsgclientucmdeletepublishedfile_unpack(buf []byte) ?CMsgClientUCmdeletePublishedFile {
mut res := CMsgClientUCmdeletePublishedFile{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmdeletepublishedfile() CMsgClientUCmdeletePublishedFile {
return CMsgClientUCmdeletePublishedFile{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmdeletepublishedfile(o CMsgClientUCmdeletePublishedFile, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmdeletepublishedfile(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmdeletePublishedFile) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmdeletepublishedfile_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmdeletePublishedFileResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
}
pub fn (o &CMsgClientUCmdeletePublishedFileResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

return res
}

pub fn cmsgclientucmdeletepublishedfileresponse_unpack(buf []byte) ?CMsgClientUCmdeletePublishedFileResponse {
mut res := CMsgClientUCmdeletePublishedFileResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmdeletepublishedfileresponse() CMsgClientUCmdeletePublishedFileResponse {
return CMsgClientUCmdeletePublishedFileResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmdeletepublishedfileresponse(o CMsgClientUCmdeletePublishedFileResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmdeletepublishedfileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmdeletePublishedFileResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmdeletepublishedfileresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmenumerateUserPublishedFiles {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
start_index u32
has_start_index bool
sort_order u32
has_sort_order bool
}
pub fn (o &CMsgClientUCmenumerateUserPublishedFiles) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_start_index {
res << vproto.pack_uint32_field(o.start_index, 2)
}

if o.has_sort_order {
res << vproto.pack_uint32_field(o.sort_order, 3)
}

return res
}

pub fn cmsgclientucmenumerateuserpublishedfiles_unpack(buf []byte) ?CMsgClientUCmenumerateUserPublishedFiles {
mut res := CMsgClientUCmenumerateUserPublishedFiles{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_start_index = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.start_index = v
i = ii
}

3 {
res.has_sort_order = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.sort_order = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateuserpublishedfiles() CMsgClientUCmenumerateUserPublishedFiles {
return CMsgClientUCmenumerateUserPublishedFiles{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateuserpublishedfiles(o CMsgClientUCmenumerateUserPublishedFiles, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateuserpublishedfiles(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmenumerateUserPublishedFiles) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmenumerateuserpublishedfiles_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmenumerateUserPublishedFilesResponsePublishedFileId {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
}
pub fn (o &CMsgClientUCmenumerateUserPublishedFilesResponsePublishedFileId) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

return res
}

pub fn cmsgclientucmenumerateuserpublishedfilesresponsepublishedfileid_unpack(buf []byte) ?CMsgClientUCmenumerateUserPublishedFilesResponsePublishedFileId {
mut res := CMsgClientUCmenumerateUserPublishedFilesResponsePublishedFileId{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateuserpublishedfilesresponsepublishedfileid() CMsgClientUCmenumerateUserPublishedFilesResponsePublishedFileId {
return CMsgClientUCmenumerateUserPublishedFilesResponsePublishedFileId{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateuserpublishedfilesresponsepublishedfileid(o CMsgClientUCmenumerateUserPublishedFilesResponsePublishedFileId, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateuserpublishedfilesresponsepublishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmenumerateUserPublishedFilesResponsePublishedFileId) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmenumerateuserpublishedfilesresponsepublishedfileid_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmenumerateUserPublishedFilesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
published_files []CMsgClientUCmenumerateUserPublishedFilesResponsePublishedFileId
total_results u32
has_total_results bool
}
pub fn (o &CMsgClientUCmenumerateUserPublishedFilesResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

// [packed=false]
for _, x in o.published_files {
res << zzz_vproto_internal_pack_cmsgclientucmenumerateuserpublishedfilesresponsepublishedfileid(x, 2)
}

if o.has_total_results {
res << vproto.pack_uint32_field(o.total_results, 3)
}

return res
}

pub fn cmsgclientucmenumerateuserpublishedfilesresponse_unpack(buf []byte) ?CMsgClientUCmenumerateUserPublishedFilesResponse {
mut res := CMsgClientUCmenumerateUserPublishedFilesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientucmenumerateuserpublishedfilesresponsepublishedfileid(cur_buf, tag_wiretype.wire_type)?
res.published_files << v
i = ii
}

3 {
res.has_total_results = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.total_results = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateuserpublishedfilesresponse() CMsgClientUCmenumerateUserPublishedFilesResponse {
return CMsgClientUCmenumerateUserPublishedFilesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateuserpublishedfilesresponse(o CMsgClientUCmenumerateUserPublishedFilesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateuserpublishedfilesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmenumerateUserPublishedFilesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmenumerateuserpublishedfilesresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmenumerateUserSubscribedFiles {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
start_index u32
has_start_index bool
list_type u32
has_list_type bool
matching_file_type u32
has_matching_file_type bool
count u32
has_count bool
}
pub fn (o &CMsgClientUCmenumerateUserSubscribedFiles) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_start_index {
res << vproto.pack_uint32_field(o.start_index, 2)
}

if o.has_list_type {
res << vproto.pack_uint32_field(o.list_type, 3)
}

if o.has_matching_file_type {
res << vproto.pack_uint32_field(o.matching_file_type, 4)
}

if o.has_count {
res << vproto.pack_uint32_field(o.count, 5)
}

return res
}

pub fn cmsgclientucmenumerateusersubscribedfiles_unpack(buf []byte) ?CMsgClientUCmenumerateUserSubscribedFiles {
mut res := CMsgClientUCmenumerateUserSubscribedFiles{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_start_index = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.start_index = v
i = ii
}

3 {
res.has_list_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.list_type = v
i = ii
}

4 {
res.has_matching_file_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.matching_file_type = v
i = ii
}

5 {
res.has_count = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.count = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateusersubscribedfiles() CMsgClientUCmenumerateUserSubscribedFiles {
return CMsgClientUCmenumerateUserSubscribedFiles{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfiles(o CMsgClientUCmenumerateUserSubscribedFiles, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfiles(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmenumerateUserSubscribedFiles) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmenumerateusersubscribedfiles_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmenumerateUserSubscribedFilesResponsePublishedFileId {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
rtime32_subscribed u32
has_rtime32_subscribed bool
}
pub fn (o &CMsgClientUCmenumerateUserSubscribedFilesResponsePublishedFileId) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_rtime32_subscribed {
res << vproto.pack_32bit_field(o.rtime32_subscribed, 2)
}

return res
}

pub fn cmsgclientucmenumerateusersubscribedfilesresponsepublishedfileid_unpack(buf []byte) ?CMsgClientUCmenumerateUserSubscribedFilesResponsePublishedFileId {
mut res := CMsgClientUCmenumerateUserSubscribedFilesResponsePublishedFileId{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_rtime32_subscribed = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.rtime32_subscribed = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateusersubscribedfilesresponsepublishedfileid() CMsgClientUCmenumerateUserSubscribedFilesResponsePublishedFileId {
return CMsgClientUCmenumerateUserSubscribedFilesResponsePublishedFileId{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfilesresponsepublishedfileid(o CMsgClientUCmenumerateUserSubscribedFilesResponsePublishedFileId, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfilesresponsepublishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmenumerateUserSubscribedFilesResponsePublishedFileId) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmenumerateusersubscribedfilesresponsepublishedfileid_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmenumerateUserSubscribedFilesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
subscribed_files []CMsgClientUCmenumerateUserSubscribedFilesResponsePublishedFileId
total_results u32
has_total_results bool
}
pub fn (o &CMsgClientUCmenumerateUserSubscribedFilesResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

// [packed=false]
for _, x in o.subscribed_files {
res << zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfilesresponsepublishedfileid(x, 2)
}

if o.has_total_results {
res << vproto.pack_uint32_field(o.total_results, 3)
}

return res
}

pub fn cmsgclientucmenumerateusersubscribedfilesresponse_unpack(buf []byte) ?CMsgClientUCmenumerateUserSubscribedFilesResponse {
mut res := CMsgClientUCmenumerateUserSubscribedFilesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfilesresponsepublishedfileid(cur_buf, tag_wiretype.wire_type)?
res.subscribed_files << v
i = ii
}

3 {
res.has_total_results = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.total_results = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateusersubscribedfilesresponse() CMsgClientUCmenumerateUserSubscribedFilesResponse {
return CMsgClientUCmenumerateUserSubscribedFilesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfilesresponse(o CMsgClientUCmenumerateUserSubscribedFilesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfilesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmenumerateUserSubscribedFilesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmenumerateusersubscribedfilesresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmenumerateUserSubscribedFilesWithUpdates {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
start_index u32
has_start_index bool
start_time u32
has_start_time bool
desired_revision u32
has_desired_revision bool
}
pub fn (o &CMsgClientUCmenumerateUserSubscribedFilesWithUpdates) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_start_index {
res << vproto.pack_uint32_field(o.start_index, 2)
}

if o.has_start_time {
res << vproto.pack_32bit_field(o.start_time, 3)
}

if o.has_desired_revision {
res << vproto.pack_uint32_field(o.desired_revision, 4)
}

return res
}

pub fn cmsgclientucmenumerateusersubscribedfileswithupdates_unpack(buf []byte) ?CMsgClientUCmenumerateUserSubscribedFilesWithUpdates {
mut res := CMsgClientUCmenumerateUserSubscribedFilesWithUpdates{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_start_index = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.start_index = v
i = ii
}

3 {
res.has_start_time = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.start_time = v
i = ii
}

4 {
res.has_desired_revision = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.desired_revision = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateusersubscribedfileswithupdates() CMsgClientUCmenumerateUserSubscribedFilesWithUpdates {
return CMsgClientUCmenumerateUserSubscribedFilesWithUpdates{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfileswithupdates(o CMsgClientUCmenumerateUserSubscribedFilesWithUpdates, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfileswithupdates(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmenumerateUserSubscribedFilesWithUpdates) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmenumerateusersubscribedfileswithupdates_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponsePublishedFileId {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
rtime32_subscribed u32
has_rtime32_subscribed bool
appid u32
has_appid bool
file_hcontent u64
has_file_hcontent bool
file_size u32
has_file_size bool
rtime32_last_updated u32
has_rtime32_last_updated bool
is_depot_content bool
has_is_depot_content bool
}
pub fn (o &CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponsePublishedFileId) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_rtime32_subscribed {
res << vproto.pack_32bit_field(o.rtime32_subscribed, 2)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 3)
}

if o.has_file_hcontent {
res << vproto.pack_64bit_field(o.file_hcontent, 4)
}

if o.has_file_size {
res << vproto.pack_uint32_field(o.file_size, 5)
}

if o.has_rtime32_last_updated {
res << vproto.pack_32bit_field(o.rtime32_last_updated, 6)
}

if o.has_is_depot_content {
res << vproto.pack_bool_field(o.is_depot_content, 7)
}

return res
}

pub fn cmsgclientucmenumerateusersubscribedfileswithupdatesresponsepublishedfileid_unpack(buf []byte) ?CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponsePublishedFileId {
mut res := CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponsePublishedFileId{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_rtime32_subscribed = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.rtime32_subscribed = v
i = ii
}

3 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

4 {
res.has_file_hcontent = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.file_hcontent = v
i = ii
}

5 {
res.has_file_size = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.file_size = v
i = ii
}

6 {
res.has_rtime32_last_updated = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.rtime32_last_updated = v
i = ii
}

7 {
res.has_is_depot_content = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_depot_content = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateusersubscribedfileswithupdatesresponsepublishedfileid() CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponsePublishedFileId {
return CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponsePublishedFileId{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfileswithupdatesresponsepublishedfileid(o CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponsePublishedFileId, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfileswithupdatesresponsepublishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponsePublishedFileId) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmenumerateusersubscribedfileswithupdatesresponsepublishedfileid_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
subscribed_files []CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponsePublishedFileId
total_results u32
has_total_results bool
}
pub fn (o &CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

// [packed=false]
for _, x in o.subscribed_files {
res << zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfileswithupdatesresponsepublishedfileid(x, 2)
}

if o.has_total_results {
res << vproto.pack_uint32_field(o.total_results, 3)
}

return res
}

pub fn cmsgclientucmenumerateusersubscribedfileswithupdatesresponse_unpack(buf []byte) ?CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponse {
mut res := CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfileswithupdatesresponsepublishedfileid(cur_buf, tag_wiretype.wire_type)?
res.subscribed_files << v
i = ii
}

3 {
res.has_total_results = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.total_results = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateusersubscribedfileswithupdatesresponse() CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponse {
return CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfileswithupdatesresponse(o CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfileswithupdatesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmenumerateUserSubscribedFilesWithUpdatesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmenumerateusersubscribedfileswithupdatesresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmpublishedFileUpdated {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
app_id u32
has_app_id bool
time_updated u32
has_time_updated bool
hcontent u64
has_hcontent bool
file_size u32
has_file_size bool
is_depot_content bool
has_is_depot_content bool
revision u32
has_revision bool
}
pub fn (o &CMsgClientUCmpublishedFileUpdated) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

if o.has_time_updated {
res << vproto.pack_uint32_field(o.time_updated, 3)
}

if o.has_hcontent {
res << vproto.pack_64bit_field(o.hcontent, 4)
}

if o.has_file_size {
res << vproto.pack_32bit_field(o.file_size, 5)
}

if o.has_is_depot_content {
res << vproto.pack_bool_field(o.is_depot_content, 6)
}

if o.has_revision {
res << vproto.pack_uint32_field(o.revision, 7)
}

return res
}

pub fn cmsgclientucmpublishedfileupdated_unpack(buf []byte) ?CMsgClientUCmpublishedFileUpdated {
mut res := CMsgClientUCmpublishedFileUpdated{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

3 {
res.has_time_updated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_updated = v
i = ii
}

4 {
res.has_hcontent = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.hcontent = v
i = ii
}

5 {
res.has_file_size = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.file_size = v
i = ii
}

6 {
res.has_is_depot_content = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_depot_content = v
i = ii
}

7 {
res.has_revision = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.revision = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmpublishedfileupdated() CMsgClientUCmpublishedFileUpdated {
return CMsgClientUCmpublishedFileUpdated{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmpublishedfileupdated(o CMsgClientUCmpublishedFileUpdated, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmpublishedfileupdated(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmpublishedFileUpdated) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmpublishedfileupdated_unpack(v)?
return i, unpacked
}
pub struct CMsgClientWorkshopItemChangesRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
last_time_updated u32
has_last_time_updated bool
num_items_needed u32
has_num_items_needed bool
}
pub fn (o &CMsgClientWorkshopItemChangesRequest) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_last_time_updated {
res << vproto.pack_uint32_field(o.last_time_updated, 2)
}

if o.has_num_items_needed {
res << vproto.pack_uint32_field(o.num_items_needed, 3)
}

return res
}

pub fn cmsgclientworkshopitemchangesrequest_unpack(buf []byte) ?CMsgClientWorkshopItemChangesRequest {
mut res := CMsgClientWorkshopItemChangesRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_last_time_updated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_time_updated = v
i = ii
}

3 {
res.has_num_items_needed = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.num_items_needed = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopitemchangesrequest() CMsgClientWorkshopItemChangesRequest {
return CMsgClientWorkshopItemChangesRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopitemchangesrequest(o CMsgClientWorkshopItemChangesRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopitemchangesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemChangesRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientworkshopitemchangesrequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientWorkshopItemChangesResponseWorkshopItemInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
time_updated u32
has_time_updated bool
manifest_id u64
has_manifest_id bool
}
pub fn (o &CMsgClientWorkshopItemChangesResponseWorkshopItemInfo) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_time_updated {
res << vproto.pack_uint32_field(o.time_updated, 2)
}

if o.has_manifest_id {
res << vproto.pack_64bit_field(o.manifest_id, 3)
}

return res
}

pub fn cmsgclientworkshopitemchangesresponseworkshopiteminfo_unpack(buf []byte) ?CMsgClientWorkshopItemChangesResponseWorkshopItemInfo {
mut res := CMsgClientWorkshopItemChangesResponseWorkshopItemInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_time_updated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_updated = v
i = ii
}

3 {
res.has_manifest_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.manifest_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopitemchangesresponseworkshopiteminfo() CMsgClientWorkshopItemChangesResponseWorkshopItemInfo {
return CMsgClientWorkshopItemChangesResponseWorkshopItemInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopitemchangesresponseworkshopiteminfo(o CMsgClientWorkshopItemChangesResponseWorkshopItemInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopitemchangesresponseworkshopiteminfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemChangesResponseWorkshopItemInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientworkshopitemchangesresponseworkshopiteminfo_unpack(v)?
return i, unpacked
}
pub struct CMsgClientWorkshopItemChangesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
update_time u32
has_update_time bool
workshop_items []CMsgClientWorkshopItemChangesResponseWorkshopItemInfo
}
pub fn (o &CMsgClientWorkshopItemChangesResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_update_time {
res << vproto.pack_uint32_field(o.update_time, 2)
}

// [packed=false]
for _, x in o.workshop_items {
res << zzz_vproto_internal_pack_cmsgclientworkshopitemchangesresponseworkshopiteminfo(x, 5)
}

return res
}

pub fn cmsgclientworkshopitemchangesresponse_unpack(buf []byte) ?CMsgClientWorkshopItemChangesResponse {
mut res := CMsgClientWorkshopItemChangesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_update_time = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.update_time = v
i = ii
}

5 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientworkshopitemchangesresponseworkshopiteminfo(cur_buf, tag_wiretype.wire_type)?
res.workshop_items << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopitemchangesresponse() CMsgClientWorkshopItemChangesResponse {
return CMsgClientWorkshopItemChangesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopitemchangesresponse(o CMsgClientWorkshopItemChangesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopitemchangesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemChangesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientworkshopitemchangesresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientWorkshopItemInfoRequestWorkshopItem {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
time_updated u32
has_time_updated bool
}
pub fn (o &CMsgClientWorkshopItemInfoRequestWorkshopItem) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_time_updated {
res << vproto.pack_uint32_field(o.time_updated, 2)
}

return res
}

pub fn cmsgclientworkshopiteminforequestworkshopitem_unpack(buf []byte) ?CMsgClientWorkshopItemInfoRequestWorkshopItem {
mut res := CMsgClientWorkshopItemInfoRequestWorkshopItem{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_time_updated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_updated = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopiteminforequestworkshopitem() CMsgClientWorkshopItemInfoRequestWorkshopItem {
return CMsgClientWorkshopItemInfoRequestWorkshopItem{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopiteminforequestworkshopitem(o CMsgClientWorkshopItemInfoRequestWorkshopItem, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopiteminforequestworkshopitem(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemInfoRequestWorkshopItem) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientworkshopiteminforequestworkshopitem_unpack(v)?
return i, unpacked
}
pub struct CMsgClientWorkshopItemInfoRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
last_time_updated u32
has_last_time_updated bool
workshop_items []CMsgClientWorkshopItemInfoRequestWorkshopItem
}
pub fn (o &CMsgClientWorkshopItemInfoRequest) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_last_time_updated {
res << vproto.pack_uint32_field(o.last_time_updated, 2)
}

// [packed=false]
for _, x in o.workshop_items {
res << zzz_vproto_internal_pack_cmsgclientworkshopiteminforequestworkshopitem(x, 3)
}

return res
}

pub fn cmsgclientworkshopiteminforequest_unpack(buf []byte) ?CMsgClientWorkshopItemInfoRequest {
mut res := CMsgClientWorkshopItemInfoRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_last_time_updated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_time_updated = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientworkshopiteminforequestworkshopitem(cur_buf, tag_wiretype.wire_type)?
res.workshop_items << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopiteminforequest() CMsgClientWorkshopItemInfoRequest {
return CMsgClientWorkshopItemInfoRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopiteminforequest(o CMsgClientWorkshopItemInfoRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopiteminforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemInfoRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientworkshopiteminforequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientWorkshopItemInfoResponseWorkshopItemInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
time_updated u32
has_time_updated bool
manifest_id u64
has_manifest_id bool
is_legacy bool
has_is_legacy bool
}
pub fn (o &CMsgClientWorkshopItemInfoResponseWorkshopItemInfo) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_time_updated {
res << vproto.pack_uint32_field(o.time_updated, 2)
}

if o.has_manifest_id {
res << vproto.pack_64bit_field(o.manifest_id, 3)
}

if o.has_is_legacy {
res << vproto.pack_bool_field(o.is_legacy, 4)
}

return res
}

pub fn cmsgclientworkshopiteminforesponseworkshopiteminfo_unpack(buf []byte) ?CMsgClientWorkshopItemInfoResponseWorkshopItemInfo {
mut res := CMsgClientWorkshopItemInfoResponseWorkshopItemInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_time_updated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_updated = v
i = ii
}

3 {
res.has_manifest_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.manifest_id = v
i = ii
}

4 {
res.has_is_legacy = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_legacy = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopiteminforesponseworkshopiteminfo() CMsgClientWorkshopItemInfoResponseWorkshopItemInfo {
return CMsgClientWorkshopItemInfoResponseWorkshopItemInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopiteminforesponseworkshopiteminfo(o CMsgClientWorkshopItemInfoResponseWorkshopItemInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopiteminforesponseworkshopiteminfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemInfoResponseWorkshopItemInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientworkshopiteminforesponseworkshopiteminfo_unpack(v)?
return i, unpacked
}
pub struct CMsgClientWorkshopItemInfoResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
update_time u32
has_update_time bool
workshop_items []CMsgClientWorkshopItemInfoResponseWorkshopItemInfo
private_items []u64
}
pub fn (o &CMsgClientWorkshopItemInfoResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_update_time {
res << vproto.pack_uint32_field(o.update_time, 2)
}

// [packed=false]
for _, x in o.workshop_items {
res << zzz_vproto_internal_pack_cmsgclientworkshopiteminforesponseworkshopiteminfo(x, 3)
}

// [packed=false]
for _, x in o.private_items {
res << vproto.pack_64bit_field(x, 4)
}

return res
}

pub fn cmsgclientworkshopiteminforesponse_unpack(buf []byte) ?CMsgClientWorkshopItemInfoResponse {
mut res := CMsgClientWorkshopItemInfoResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_update_time = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.update_time = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientworkshopiteminforesponseworkshopiteminfo(cur_buf, tag_wiretype.wire_type)?
res.workshop_items << v
i = ii
}

4 {
// [packed=false]
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.private_items << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopiteminforesponse() CMsgClientWorkshopItemInfoResponse {
return CMsgClientWorkshopItemInfoResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopiteminforesponse(o CMsgClientWorkshopItemInfoResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopiteminforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemInfoResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientworkshopiteminforesponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmgetPublishedFilesForUser {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
creator_steam_id u64
has_creator_steam_id bool
required_tags []string
excluded_tags []string
start_index u32
has_start_index bool
}
pub fn (o &CMsgClientUCmgetPublishedFilesForUser) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_creator_steam_id {
res << vproto.pack_64bit_field(o.creator_steam_id, 2)
}

// [packed=false]
for _, x in o.required_tags {
res << vproto.pack_string_field(x, 3)
}

// [packed=false]
for _, x in o.excluded_tags {
res << vproto.pack_string_field(x, 4)
}

if o.has_start_index {
res << vproto.pack_uint32_field(o.start_index, 5)
}

return res
}

pub fn cmsgclientucmgetpublishedfilesforuser_unpack(buf []byte) ?CMsgClientUCmgetPublishedFilesForUser {
mut res := CMsgClientUCmgetPublishedFilesForUser{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_creator_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.creator_steam_id = v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.required_tags << v
i = ii
}

4 {
// [packed=false]
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.excluded_tags << v
i = ii
}

5 {
res.has_start_index = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.start_index = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmgetpublishedfilesforuser() CMsgClientUCmgetPublishedFilesForUser {
return CMsgClientUCmgetPublishedFilesForUser{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmgetpublishedfilesforuser(o CMsgClientUCmgetPublishedFilesForUser, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmgetpublishedfilesforuser(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmgetPublishedFilesForUser) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmgetpublishedfilesforuser_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmgetPublishedFilesForUserResponsePublishedFileId {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
}
pub fn (o &CMsgClientUCmgetPublishedFilesForUserResponsePublishedFileId) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

return res
}

pub fn cmsgclientucmgetpublishedfilesforuserresponsepublishedfileid_unpack(buf []byte) ?CMsgClientUCmgetPublishedFilesForUserResponsePublishedFileId {
mut res := CMsgClientUCmgetPublishedFilesForUserResponsePublishedFileId{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmgetpublishedfilesforuserresponsepublishedfileid() CMsgClientUCmgetPublishedFilesForUserResponsePublishedFileId {
return CMsgClientUCmgetPublishedFilesForUserResponsePublishedFileId{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmgetpublishedfilesforuserresponsepublishedfileid(o CMsgClientUCmgetPublishedFilesForUserResponsePublishedFileId, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmgetpublishedfilesforuserresponsepublishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmgetPublishedFilesForUserResponsePublishedFileId) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmgetpublishedfilesforuserresponsepublishedfileid_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmgetPublishedFilesForUserResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
published_files []CMsgClientUCmgetPublishedFilesForUserResponsePublishedFileId
total_results u32
has_total_results bool
}
pub fn (o &CMsgClientUCmgetPublishedFilesForUserResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

// [packed=false]
for _, x in o.published_files {
res << zzz_vproto_internal_pack_cmsgclientucmgetpublishedfilesforuserresponsepublishedfileid(x, 2)
}

if o.has_total_results {
res << vproto.pack_uint32_field(o.total_results, 3)
}

return res
}

pub fn cmsgclientucmgetpublishedfilesforuserresponse_unpack(buf []byte) ?CMsgClientUCmgetPublishedFilesForUserResponse {
mut res := CMsgClientUCmgetPublishedFilesForUserResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientucmgetpublishedfilesforuserresponsepublishedfileid(cur_buf, tag_wiretype.wire_type)?
res.published_files << v
i = ii
}

3 {
res.has_total_results = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.total_results = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmgetpublishedfilesforuserresponse() CMsgClientUCmgetPublishedFilesForUserResponse {
return CMsgClientUCmgetPublishedFilesForUserResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmgetpublishedfilesforuserresponse(o CMsgClientUCmgetPublishedFilesForUserResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmgetpublishedfilesforuserresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmgetPublishedFilesForUserResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmgetpublishedfilesforuserresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmsetUserPublishedFileAction {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
app_id u32
has_app_id bool
action int
has_action bool
}
pub fn (o &CMsgClientUCmsetUserPublishedFileAction) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

if o.has_action {
res << vproto.pack_int32_field(o.action, 3)
}

return res
}

pub fn cmsgclientucmsetuserpublishedfileaction_unpack(buf []byte) ?CMsgClientUCmsetUserPublishedFileAction {
mut res := CMsgClientUCmsetUserPublishedFileAction{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

3 {
res.has_action = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.action = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmsetuserpublishedfileaction() CMsgClientUCmsetUserPublishedFileAction {
return CMsgClientUCmsetUserPublishedFileAction{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmsetuserpublishedfileaction(o CMsgClientUCmsetUserPublishedFileAction, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmsetuserpublishedfileaction(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmsetUserPublishedFileAction) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmsetuserpublishedfileaction_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmsetUserPublishedFileActionResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
}
pub fn (o &CMsgClientUCmsetUserPublishedFileActionResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

return res
}

pub fn cmsgclientucmsetuserpublishedfileactionresponse_unpack(buf []byte) ?CMsgClientUCmsetUserPublishedFileActionResponse {
mut res := CMsgClientUCmsetUserPublishedFileActionResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmsetuserpublishedfileactionresponse() CMsgClientUCmsetUserPublishedFileActionResponse {
return CMsgClientUCmsetUserPublishedFileActionResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmsetuserpublishedfileactionresponse(o CMsgClientUCmsetUserPublishedFileActionResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmsetuserpublishedfileactionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmsetUserPublishedFileActionResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmsetuserpublishedfileactionresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmenumeratePublishedFilesByUserAction {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
start_index u32
has_start_index bool
action int
has_action bool
}
pub fn (o &CMsgClientUCmenumeratePublishedFilesByUserAction) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_start_index {
res << vproto.pack_uint32_field(o.start_index, 2)
}

if o.has_action {
res << vproto.pack_int32_field(o.action, 3)
}

return res
}

pub fn cmsgclientucmenumeratepublishedfilesbyuseraction_unpack(buf []byte) ?CMsgClientUCmenumeratePublishedFilesByUserAction {
mut res := CMsgClientUCmenumeratePublishedFilesByUserAction{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_start_index = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.start_index = v
i = ii
}

3 {
res.has_action = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.action = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumeratepublishedfilesbyuseraction() CMsgClientUCmenumeratePublishedFilesByUserAction {
return CMsgClientUCmenumeratePublishedFilesByUserAction{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumeratepublishedfilesbyuseraction(o CMsgClientUCmenumeratePublishedFilesByUserAction, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumeratepublishedfilesbyuseraction(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmenumeratePublishedFilesByUserAction) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmenumeratepublishedfilesbyuseraction_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmenumeratePublishedFilesByUserActionResponsePublishedFileId {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
rtime_time_stamp u32
has_rtime_time_stamp bool
}
pub fn (o &CMsgClientUCmenumeratePublishedFilesByUserActionResponsePublishedFileId) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_rtime_time_stamp {
res << vproto.pack_32bit_field(o.rtime_time_stamp, 2)
}

return res
}

pub fn cmsgclientucmenumeratepublishedfilesbyuseractionresponsepublishedfileid_unpack(buf []byte) ?CMsgClientUCmenumeratePublishedFilesByUserActionResponsePublishedFileId {
mut res := CMsgClientUCmenumeratePublishedFilesByUserActionResponsePublishedFileId{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_rtime_time_stamp = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.rtime_time_stamp = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumeratepublishedfilesbyuseractionresponsepublishedfileid() CMsgClientUCmenumeratePublishedFilesByUserActionResponsePublishedFileId {
return CMsgClientUCmenumeratePublishedFilesByUserActionResponsePublishedFileId{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumeratepublishedfilesbyuseractionresponsepublishedfileid(o CMsgClientUCmenumeratePublishedFilesByUserActionResponsePublishedFileId, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumeratepublishedfilesbyuseractionresponsepublishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmenumeratePublishedFilesByUserActionResponsePublishedFileId) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmenumeratepublishedfilesbyuseractionresponsepublishedfileid_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUCmenumeratePublishedFilesByUserActionResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
published_files []CMsgClientUCmenumeratePublishedFilesByUserActionResponsePublishedFileId
total_results u32
has_total_results bool
}
pub fn (o &CMsgClientUCmenumeratePublishedFilesByUserActionResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

// [packed=false]
for _, x in o.published_files {
res << zzz_vproto_internal_pack_cmsgclientucmenumeratepublishedfilesbyuseractionresponsepublishedfileid(x, 2)
}

if o.has_total_results {
res << vproto.pack_uint32_field(o.total_results, 3)
}

return res
}

pub fn cmsgclientucmenumeratepublishedfilesbyuseractionresponse_unpack(buf []byte) ?CMsgClientUCmenumeratePublishedFilesByUserActionResponse {
mut res := CMsgClientUCmenumeratePublishedFilesByUserActionResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientucmenumeratepublishedfilesbyuseractionresponsepublishedfileid(cur_buf, tag_wiretype.wire_type)?
res.published_files << v
i = ii
}

3 {
res.has_total_results = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.total_results = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumeratepublishedfilesbyuseractionresponse() CMsgClientUCmenumeratePublishedFilesByUserActionResponse {
return CMsgClientUCmenumeratePublishedFilesByUserActionResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumeratepublishedfilesbyuseractionresponse(o CMsgClientUCmenumeratePublishedFilesByUserActionResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumeratepublishedfilesbyuseractionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCmenumeratePublishedFilesByUserActionResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientucmenumeratepublishedfilesbyuseractionresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientScreenshotsChanged {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CMsgClientScreenshotsChanged) pack() []byte {
res := []byte{}
return res
}

pub fn cmsgclientscreenshotschanged_unpack(buf []byte) ?CMsgClientScreenshotsChanged {
res := CMsgClientScreenshotsChanged{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientscreenshotschanged() CMsgClientScreenshotsChanged {
return CMsgClientScreenshotsChanged{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientscreenshotschanged(o CMsgClientScreenshotsChanged, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientscreenshotschanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientScreenshotsChanged) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientscreenshotschanged_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUpdateUserGameInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid_idgs u64
has_steamid_idgs bool
gameid u64
has_gameid bool
game_ip u32
has_game_ip bool
game_port u32
has_game_port bool
token []byte
has_token bool
}
pub fn (o &CMsgClientUpdateUserGameInfo) pack() []byte {
mut res := []byte{}
if o.has_steamid_idgs {
res << vproto.pack_64bit_field(o.steamid_idgs, 1)
}

if o.has_gameid {
res << vproto.pack_64bit_field(o.gameid, 2)
}

if o.has_game_ip {
res << vproto.pack_uint32_field(o.game_ip, 3)
}

if o.has_game_port {
res << vproto.pack_uint32_field(o.game_port, 4)
}

if o.has_token {
res << vproto.pack_bytes_field(o.token, 5)
}

return res
}

pub fn cmsgclientupdateusergameinfo_unpack(buf []byte) ?CMsgClientUpdateUserGameInfo {
mut res := CMsgClientUpdateUserGameInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid_idgs = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid_idgs = v
i = ii
}

2 {
res.has_gameid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.gameid = v
i = ii
}

3 {
res.has_game_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.game_ip = v
i = ii
}

4 {
res.has_game_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.game_port = v
i = ii
}

5 {
res.has_token = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientupdateusergameinfo() CMsgClientUpdateUserGameInfo {
return CMsgClientUpdateUserGameInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientupdateusergameinfo(o CMsgClientUpdateUserGameInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientupdateusergameinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUpdateUserGameInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientupdateusergameinfo_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRichPresenceUpload {
mut:
unknown_fields []vproto.UnknownField
pub mut:
rich_presence_kv []byte
has_rich_presence_kv bool
steamid_broadcast []u64
}
pub fn (o &CMsgClientRichPresenceUpload) pack() []byte {
mut res := []byte{}
if o.has_rich_presence_kv {
res << vproto.pack_bytes_field(o.rich_presence_kv, 1)
}

// [packed=false]
for _, x in o.steamid_broadcast {
res << vproto.pack_64bit_field(x, 2)
}

return res
}

pub fn cmsgclientrichpresenceupload_unpack(buf []byte) ?CMsgClientRichPresenceUpload {
mut res := CMsgClientRichPresenceUpload{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_rich_presence_kv = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.rich_presence_kv = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid_broadcast << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrichpresenceupload() CMsgClientRichPresenceUpload {
return CMsgClientRichPresenceUpload{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrichpresenceupload(o CMsgClientRichPresenceUpload, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrichpresenceupload(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRichPresenceUpload) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrichpresenceupload_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRichPresenceRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid_request []u64
}
pub fn (o &CMsgClientRichPresenceRequest) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.steamid_request {
res << vproto.pack_64bit_field(x, 1)
}

return res
}

pub fn cmsgclientrichpresencerequest_unpack(buf []byte) ?CMsgClientRichPresenceRequest {
mut res := CMsgClientRichPresenceRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid_request << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrichpresencerequest() CMsgClientRichPresenceRequest {
return CMsgClientRichPresenceRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrichpresencerequest(o CMsgClientRichPresenceRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrichpresencerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRichPresenceRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrichpresencerequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRichPresenceInfoRichPresence {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid_user u64
has_steamid_user bool
rich_presence_kv []byte
has_rich_presence_kv bool
}
pub fn (o &CMsgClientRichPresenceInfoRichPresence) pack() []byte {
mut res := []byte{}
if o.has_steamid_user {
res << vproto.pack_64bit_field(o.steamid_user, 1)
}

if o.has_rich_presence_kv {
res << vproto.pack_bytes_field(o.rich_presence_kv, 2)
}

return res
}

pub fn cmsgclientrichpresenceinforichpresence_unpack(buf []byte) ?CMsgClientRichPresenceInfoRichPresence {
mut res := CMsgClientRichPresenceInfoRichPresence{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid_user = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid_user = v
i = ii
}

2 {
res.has_rich_presence_kv = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.rich_presence_kv = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrichpresenceinforichpresence() CMsgClientRichPresenceInfoRichPresence {
return CMsgClientRichPresenceInfoRichPresence{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrichpresenceinforichpresence(o CMsgClientRichPresenceInfoRichPresence, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrichpresenceinforichpresence(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRichPresenceInfoRichPresence) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrichpresenceinforichpresence_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRichPresenceInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
rich_presence []CMsgClientRichPresenceInfoRichPresence
}
pub fn (o &CMsgClientRichPresenceInfo) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.rich_presence {
res << zzz_vproto_internal_pack_cmsgclientrichpresenceinforichpresence(x, 1)
}

return res
}

pub fn cmsgclientrichpresenceinfo_unpack(buf []byte) ?CMsgClientRichPresenceInfo {
mut res := CMsgClientRichPresenceInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientrichpresenceinforichpresence(cur_buf, tag_wiretype.wire_type)?
res.rich_presence << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrichpresenceinfo() CMsgClientRichPresenceInfo {
return CMsgClientRichPresenceInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrichpresenceinfo(o CMsgClientRichPresenceInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrichpresenceinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRichPresenceInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrichpresenceinfo_unpack(v)?
return i, unpacked
}
pub struct CMsgClientCheckFileSignature {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
}
pub fn (o &CMsgClientCheckFileSignature) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

return res
}

pub fn cmsgclientcheckfilesignature_unpack(buf []byte) ?CMsgClientCheckFileSignature {
mut res := CMsgClientCheckFileSignature{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcheckfilesignature() CMsgClientCheckFileSignature {
return CMsgClientCheckFileSignature{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcheckfilesignature(o CMsgClientCheckFileSignature, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcheckfilesignature(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCheckFileSignature) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientcheckfilesignature_unpack(v)?
return i, unpacked
}
pub struct CMsgClientCheckFileSignatureResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
pid u32
has_pid bool
eresult u32
has_eresult bool
filename string
has_filename bool
esignatureresult u32
has_esignatureresult bool
sha_file []byte
has_sha_file bool
signatureheader []byte
has_signatureheader bool
filesize u32
has_filesize bool
getlasterror u32
has_getlasterror bool
evalvesignaturecheckdetail u32
has_evalvesignaturecheckdetail bool
}
pub fn (o &CMsgClientCheckFileSignatureResponse) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_pid {
res << vproto.pack_uint32_field(o.pid, 2)
}

if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 3)
}

if o.has_filename {
res << vproto.pack_string_field(o.filename, 4)
}

if o.has_esignatureresult {
res << vproto.pack_uint32_field(o.esignatureresult, 5)
}

if o.has_sha_file {
res << vproto.pack_bytes_field(o.sha_file, 6)
}

if o.has_signatureheader {
res << vproto.pack_bytes_field(o.signatureheader, 7)
}

if o.has_filesize {
res << vproto.pack_uint32_field(o.filesize, 8)
}

if o.has_getlasterror {
res << vproto.pack_uint32_field(o.getlasterror, 9)
}

if o.has_evalvesignaturecheckdetail {
res << vproto.pack_uint32_field(o.evalvesignaturecheckdetail, 10)
}

return res
}

pub fn cmsgclientcheckfilesignatureresponse_unpack(buf []byte) ?CMsgClientCheckFileSignatureResponse {
mut res := CMsgClientCheckFileSignatureResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_pid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.pid = v
i = ii
}

3 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

4 {
res.has_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename = v
i = ii
}

5 {
res.has_esignatureresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.esignatureresult = v
i = ii
}

6 {
res.has_sha_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_file = v
i = ii
}

7 {
res.has_signatureheader = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.signatureheader = v
i = ii
}

8 {
res.has_filesize = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.filesize = v
i = ii
}

9 {
res.has_getlasterror = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.getlasterror = v
i = ii
}

10 {
res.has_evalvesignaturecheckdetail = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.evalvesignaturecheckdetail = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcheckfilesignatureresponse() CMsgClientCheckFileSignatureResponse {
return CMsgClientCheckFileSignatureResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcheckfilesignatureresponse(o CMsgClientCheckFileSignatureResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcheckfilesignatureresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCheckFileSignatureResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientcheckfilesignatureresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientReadMachineAuth {
mut:
unknown_fields []vproto.UnknownField
pub mut:
filename string
has_filename bool
offset u32
has_offset bool
cubtoread u32
has_cubtoread bool
}
pub fn (o &CMsgClientReadMachineAuth) pack() []byte {
mut res := []byte{}
if o.has_filename {
res << vproto.pack_string_field(o.filename, 1)
}

if o.has_offset {
res << vproto.pack_uint32_field(o.offset, 2)
}

if o.has_cubtoread {
res << vproto.pack_uint32_field(o.cubtoread, 3)
}

return res
}

pub fn cmsgclientreadmachineauth_unpack(buf []byte) ?CMsgClientReadMachineAuth {
mut res := CMsgClientReadMachineAuth{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename = v
i = ii
}

2 {
res.has_offset = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.offset = v
i = ii
}

3 {
res.has_cubtoread = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cubtoread = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientreadmachineauth() CMsgClientReadMachineAuth {
return CMsgClientReadMachineAuth{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientreadmachineauth(o CMsgClientReadMachineAuth, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientreadmachineauth(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientReadMachineAuth) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientreadmachineauth_unpack(v)?
return i, unpacked
}
pub struct CMsgClientReadMachineAuthResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
filename string
has_filename bool
eresult u32
has_eresult bool
filesize u32
has_filesize bool
sha_file []byte
has_sha_file bool
getlasterror u32
has_getlasterror bool
offset u32
has_offset bool
cubread u32
has_cubread bool
bytes_read []byte
has_bytes_read bool
filename_sentry string
has_filename_sentry bool
}
pub fn (o &CMsgClientReadMachineAuthResponse) pack() []byte {
mut res := []byte{}
if o.has_filename {
res << vproto.pack_string_field(o.filename, 1)
}

if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 2)
}

if o.has_filesize {
res << vproto.pack_uint32_field(o.filesize, 3)
}

if o.has_sha_file {
res << vproto.pack_bytes_field(o.sha_file, 4)
}

if o.has_getlasterror {
res << vproto.pack_uint32_field(o.getlasterror, 5)
}

if o.has_offset {
res << vproto.pack_uint32_field(o.offset, 6)
}

if o.has_cubread {
res << vproto.pack_uint32_field(o.cubread, 7)
}

if o.has_bytes_read {
res << vproto.pack_bytes_field(o.bytes_read, 8)
}

if o.has_filename_sentry {
res << vproto.pack_string_field(o.filename_sentry, 9)
}

return res
}

pub fn cmsgclientreadmachineauthresponse_unpack(buf []byte) ?CMsgClientReadMachineAuthResponse {
mut res := CMsgClientReadMachineAuthResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename = v
i = ii
}

2 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

3 {
res.has_filesize = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.filesize = v
i = ii
}

4 {
res.has_sha_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_file = v
i = ii
}

5 {
res.has_getlasterror = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.getlasterror = v
i = ii
}

6 {
res.has_offset = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.offset = v
i = ii
}

7 {
res.has_cubread = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cubread = v
i = ii
}

8 {
res.has_bytes_read = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.bytes_read = v
i = ii
}

9 {
res.has_filename_sentry = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename_sentry = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientreadmachineauthresponse() CMsgClientReadMachineAuthResponse {
return CMsgClientReadMachineAuthResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientreadmachineauthresponse(o CMsgClientReadMachineAuthResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientreadmachineauthresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientReadMachineAuthResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientreadmachineauthresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUpdateMachineAuth {
mut:
unknown_fields []vproto.UnknownField
pub mut:
filename string
has_filename bool
offset u32
has_offset bool
cubtowrite u32
has_cubtowrite bool
bytes []byte
has_bytes bool
otp_type u32
has_otp_type bool
otp_identifier string
has_otp_identifier bool
otp_sharedsecret []byte
has_otp_sharedsecret bool
otp_timedrift u32
has_otp_timedrift bool
}
pub fn (o &CMsgClientUpdateMachineAuth) pack() []byte {
mut res := []byte{}
if o.has_filename {
res << vproto.pack_string_field(o.filename, 1)
}

if o.has_offset {
res << vproto.pack_uint32_field(o.offset, 2)
}

if o.has_cubtowrite {
res << vproto.pack_uint32_field(o.cubtowrite, 3)
}

if o.has_bytes {
res << vproto.pack_bytes_field(o.bytes, 4)
}

if o.has_otp_type {
res << vproto.pack_uint32_field(o.otp_type, 5)
}

if o.has_otp_identifier {
res << vproto.pack_string_field(o.otp_identifier, 6)
}

if o.has_otp_sharedsecret {
res << vproto.pack_bytes_field(o.otp_sharedsecret, 7)
}

if o.has_otp_timedrift {
res << vproto.pack_uint32_field(o.otp_timedrift, 8)
}

return res
}

pub fn cmsgclientupdatemachineauth_unpack(buf []byte) ?CMsgClientUpdateMachineAuth {
mut res := CMsgClientUpdateMachineAuth{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename = v
i = ii
}

2 {
res.has_offset = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.offset = v
i = ii
}

3 {
res.has_cubtowrite = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cubtowrite = v
i = ii
}

4 {
res.has_bytes = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.bytes = v
i = ii
}

5 {
res.has_otp_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.otp_type = v
i = ii
}

6 {
res.has_otp_identifier = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.otp_identifier = v
i = ii
}

7 {
res.has_otp_sharedsecret = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.otp_sharedsecret = v
i = ii
}

8 {
res.has_otp_timedrift = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.otp_timedrift = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientupdatemachineauth() CMsgClientUpdateMachineAuth {
return CMsgClientUpdateMachineAuth{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientupdatemachineauth(o CMsgClientUpdateMachineAuth, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientupdatemachineauth(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUpdateMachineAuth) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientupdatemachineauth_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUpdateMachineAuthResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
filename string
has_filename bool
eresult u32
has_eresult bool
filesize u32
has_filesize bool
sha_file []byte
has_sha_file bool
getlasterror u32
has_getlasterror bool
offset u32
has_offset bool
cubwrote u32
has_cubwrote bool
otp_type int
has_otp_type bool
otp_value u32
has_otp_value bool
otp_identifier string
has_otp_identifier bool
}
pub fn (o &CMsgClientUpdateMachineAuthResponse) pack() []byte {
mut res := []byte{}
if o.has_filename {
res << vproto.pack_string_field(o.filename, 1)
}

if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 2)
}

if o.has_filesize {
res << vproto.pack_uint32_field(o.filesize, 3)
}

if o.has_sha_file {
res << vproto.pack_bytes_field(o.sha_file, 4)
}

if o.has_getlasterror {
res << vproto.pack_uint32_field(o.getlasterror, 5)
}

if o.has_offset {
res << vproto.pack_uint32_field(o.offset, 6)
}

if o.has_cubwrote {
res << vproto.pack_uint32_field(o.cubwrote, 7)
}

if o.has_otp_type {
res << vproto.pack_int32_field(o.otp_type, 8)
}

if o.has_otp_value {
res << vproto.pack_uint32_field(o.otp_value, 9)
}

if o.has_otp_identifier {
res << vproto.pack_string_field(o.otp_identifier, 10)
}

return res
}

pub fn cmsgclientupdatemachineauthresponse_unpack(buf []byte) ?CMsgClientUpdateMachineAuthResponse {
mut res := CMsgClientUpdateMachineAuthResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename = v
i = ii
}

2 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

3 {
res.has_filesize = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.filesize = v
i = ii
}

4 {
res.has_sha_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_file = v
i = ii
}

5 {
res.has_getlasterror = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.getlasterror = v
i = ii
}

6 {
res.has_offset = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.offset = v
i = ii
}

7 {
res.has_cubwrote = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cubwrote = v
i = ii
}

8 {
res.has_otp_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.otp_type = v
i = ii
}

9 {
res.has_otp_value = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.otp_value = v
i = ii
}

10 {
res.has_otp_identifier = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.otp_identifier = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientupdatemachineauthresponse() CMsgClientUpdateMachineAuthResponse {
return CMsgClientUpdateMachineAuthResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientupdatemachineauthresponse(o CMsgClientUpdateMachineAuthResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientupdatemachineauthresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUpdateMachineAuthResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientupdatemachineauthresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestMachineAuth {
mut:
unknown_fields []vproto.UnknownField
pub mut:
filename string
has_filename bool
eresult_sentryfile u32
has_eresult_sentryfile bool
filesize u32
has_filesize bool
sha_sentryfile []byte
has_sha_sentryfile bool
lock_account_action int
has_lock_account_action bool
otp_type u32
has_otp_type bool
otp_identifier string
has_otp_identifier bool
otp_sharedsecret []byte
has_otp_sharedsecret bool
otp_value u32
has_otp_value bool
machine_name string
has_machine_name bool
machine_name_userchosen string
has_machine_name_userchosen bool
}
pub fn (o &CMsgClientRequestMachineAuth) pack() []byte {
mut res := []byte{}
if o.has_filename {
res << vproto.pack_string_field(o.filename, 1)
}

if o.has_eresult_sentryfile {
res << vproto.pack_uint32_field(o.eresult_sentryfile, 2)
}

if o.has_filesize {
res << vproto.pack_uint32_field(o.filesize, 3)
}

if o.has_sha_sentryfile {
res << vproto.pack_bytes_field(o.sha_sentryfile, 4)
}

if o.has_lock_account_action {
res << vproto.pack_int32_field(o.lock_account_action, 6)
}

if o.has_otp_type {
res << vproto.pack_uint32_field(o.otp_type, 7)
}

if o.has_otp_identifier {
res << vproto.pack_string_field(o.otp_identifier, 8)
}

if o.has_otp_sharedsecret {
res << vproto.pack_bytes_field(o.otp_sharedsecret, 9)
}

if o.has_otp_value {
res << vproto.pack_uint32_field(o.otp_value, 10)
}

if o.has_machine_name {
res << vproto.pack_string_field(o.machine_name, 11)
}

if o.has_machine_name_userchosen {
res << vproto.pack_string_field(o.machine_name_userchosen, 12)
}

return res
}

pub fn cmsgclientrequestmachineauth_unpack(buf []byte) ?CMsgClientRequestMachineAuth {
mut res := CMsgClientRequestMachineAuth{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_filename = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filename = v
i = ii
}

2 {
res.has_eresult_sentryfile = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult_sentryfile = v
i = ii
}

3 {
res.has_filesize = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.filesize = v
i = ii
}

4 {
res.has_sha_sentryfile = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sha_sentryfile = v
i = ii
}

6 {
res.has_lock_account_action = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.lock_account_action = v
i = ii
}

7 {
res.has_otp_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.otp_type = v
i = ii
}

8 {
res.has_otp_identifier = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.otp_identifier = v
i = ii
}

9 {
res.has_otp_sharedsecret = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.otp_sharedsecret = v
i = ii
}

10 {
res.has_otp_value = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.otp_value = v
i = ii
}

11 {
res.has_machine_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.machine_name = v
i = ii
}

12 {
res.has_machine_name_userchosen = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.machine_name_userchosen = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestmachineauth() CMsgClientRequestMachineAuth {
return CMsgClientRequestMachineAuth{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestmachineauth(o CMsgClientRequestMachineAuth, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestmachineauth(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestMachineAuth) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestmachineauth_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestMachineAuthResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult u32
has_eresult bool
}
pub fn (o &CMsgClientRequestMachineAuthResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 1)
}

return res
}

pub fn cmsgclientrequestmachineauthresponse_unpack(buf []byte) ?CMsgClientRequestMachineAuthResponse {
mut res := CMsgClientRequestMachineAuthResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestmachineauthresponse() CMsgClientRequestMachineAuthResponse {
return CMsgClientRequestMachineAuthResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestmachineauthresponse(o CMsgClientRequestMachineAuthResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestmachineauthresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestMachineAuthResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestmachineauthresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRegisterKey {
mut:
unknown_fields []vproto.UnknownField
pub mut:
key string
has_key bool
}
pub fn (o &CMsgClientRegisterKey) pack() []byte {
mut res := []byte{}
if o.has_key {
res << vproto.pack_string_field(o.key, 1)
}

return res
}

pub fn cmsgclientregisterkey_unpack(buf []byte) ?CMsgClientRegisterKey {
mut res := CMsgClientRegisterKey{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_key = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.key = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientregisterkey() CMsgClientRegisterKey {
return CMsgClientRegisterKey{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientregisterkey(o CMsgClientRegisterKey, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientregisterkey(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRegisterKey) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientregisterkey_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPurchaseResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
purchase_result_details int
has_purchase_result_details bool
purchase_receipt_info []byte
has_purchase_receipt_info bool
}
pub fn (o &CMsgClientPurchaseResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_purchase_result_details {
res << vproto.pack_int32_field(o.purchase_result_details, 2)
}

if o.has_purchase_receipt_info {
res << vproto.pack_bytes_field(o.purchase_receipt_info, 3)
}

return res
}

pub fn cmsgclientpurchaseresponse_unpack(buf []byte) ?CMsgClientPurchaseResponse {
mut res := CMsgClientPurchaseResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_purchase_result_details = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.purchase_result_details = v
i = ii
}

3 {
res.has_purchase_receipt_info = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.purchase_receipt_info = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpurchaseresponse() CMsgClientPurchaseResponse {
return CMsgClientPurchaseResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpurchaseresponse(o CMsgClientPurchaseResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpurchaseresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPurchaseResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpurchaseresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientActivateOEmlicense {
mut:
unknown_fields []vproto.UnknownField
pub mut:
bios_manufacturer string
has_bios_manufacturer bool
bios_serialnumber string
has_bios_serialnumber bool
license_file []byte
has_license_file bool
mainboard_manufacturer string
has_mainboard_manufacturer bool
mainboard_product string
has_mainboard_product bool
mainboard_serialnumber string
has_mainboard_serialnumber bool
}
pub fn (o &CMsgClientActivateOEmlicense) pack() []byte {
mut res := []byte{}
if o.has_bios_manufacturer {
res << vproto.pack_string_field(o.bios_manufacturer, 1)
}

if o.has_bios_serialnumber {
res << vproto.pack_string_field(o.bios_serialnumber, 2)
}

if o.has_license_file {
res << vproto.pack_bytes_field(o.license_file, 3)
}

if o.has_mainboard_manufacturer {
res << vproto.pack_string_field(o.mainboard_manufacturer, 4)
}

if o.has_mainboard_product {
res << vproto.pack_string_field(o.mainboard_product, 5)
}

if o.has_mainboard_serialnumber {
res << vproto.pack_string_field(o.mainboard_serialnumber, 6)
}

return res
}

pub fn cmsgclientactivateoemlicense_unpack(buf []byte) ?CMsgClientActivateOEmlicense {
mut res := CMsgClientActivateOEmlicense{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_bios_manufacturer = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.bios_manufacturer = v
i = ii
}

2 {
res.has_bios_serialnumber = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.bios_serialnumber = v
i = ii
}

3 {
res.has_license_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.license_file = v
i = ii
}

4 {
res.has_mainboard_manufacturer = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.mainboard_manufacturer = v
i = ii
}

5 {
res.has_mainboard_product = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.mainboard_product = v
i = ii
}

6 {
res.has_mainboard_serialnumber = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.mainboard_serialnumber = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientactivateoemlicense() CMsgClientActivateOEmlicense {
return CMsgClientActivateOEmlicense{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientactivateoemlicense(o CMsgClientActivateOEmlicense, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientactivateoemlicense(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientActivateOEmlicense) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientactivateoemlicense_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRegisterOEmmachine {
mut:
unknown_fields []vproto.UnknownField
pub mut:
oem_register_file []byte
has_oem_register_file bool
}
pub fn (o &CMsgClientRegisterOEmmachine) pack() []byte {
mut res := []byte{}
if o.has_oem_register_file {
res << vproto.pack_bytes_field(o.oem_register_file, 1)
}

return res
}

pub fn cmsgclientregisteroemmachine_unpack(buf []byte) ?CMsgClientRegisterOEmmachine {
mut res := CMsgClientRegisterOEmmachine{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_oem_register_file = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.oem_register_file = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientregisteroemmachine() CMsgClientRegisterOEmmachine {
return CMsgClientRegisterOEmmachine{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientregisteroemmachine(o CMsgClientRegisterOEmmachine, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientregisteroemmachine(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRegisterOEmmachine) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientregisteroemmachine_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRegisterOEmmachineResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult u32
has_eresult bool
}
pub fn (o &CMsgClientRegisterOEmmachineResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 1)
}

return res
}

pub fn cmsgclientregisteroemmachineresponse_unpack(buf []byte) ?CMsgClientRegisterOEmmachineResponse {
mut res := CMsgClientRegisterOEmmachineResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientregisteroemmachineresponse() CMsgClientRegisterOEmmachineResponse {
return CMsgClientRegisterOEmmachineResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientregisteroemmachineresponse(o CMsgClientRegisterOEmmachineResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientregisteroemmachineresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRegisterOEmmachineResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientregisteroemmachineresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPurchaseWithMachineID {
mut:
unknown_fields []vproto.UnknownField
pub mut:
package_id u32
has_package_id bool
machine_info []byte
has_machine_info bool
}
pub fn (o &CMsgClientPurchaseWithMachineID) pack() []byte {
mut res := []byte{}
if o.has_package_id {
res << vproto.pack_uint32_field(o.package_id, 1)
}

if o.has_machine_info {
res << vproto.pack_bytes_field(o.machine_info, 2)
}

return res
}

pub fn cmsgclientpurchasewithmachineid_unpack(buf []byte) ?CMsgClientPurchaseWithMachineID {
mut res := CMsgClientPurchaseWithMachineID{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_package_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.package_id = v
i = ii
}

2 {
res.has_machine_info = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.machine_info = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpurchasewithmachineid() CMsgClientPurchaseWithMachineID {
return CMsgClientPurchaseWithMachineID{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpurchasewithmachineid(o CMsgClientPurchaseWithMachineID, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpurchasewithmachineid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPurchaseWithMachineID) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientpurchasewithmachineid_unpack(v)?
return i, unpacked
}
pub struct CMsgTradingInitiateTradeRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
trade_request_id u32
has_trade_request_id bool
other_steamid u64
has_other_steamid bool
other_name string
has_other_name bool
}
pub fn (o &CMsgTradingInitiateTradeRequest) pack() []byte {
mut res := []byte{}
if o.has_trade_request_id {
res << vproto.pack_uint32_field(o.trade_request_id, 1)
}

if o.has_other_steamid {
res << vproto.pack_uint64_field(o.other_steamid, 2)
}

if o.has_other_name {
res << vproto.pack_string_field(o.other_name, 3)
}

return res
}

pub fn cmsgtradinginitiatetraderequest_unpack(buf []byte) ?CMsgTradingInitiateTradeRequest {
mut res := CMsgTradingInitiateTradeRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_trade_request_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.trade_request_id = v
i = ii
}

2 {
res.has_other_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.other_steamid = v
i = ii
}

3 {
res.has_other_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.other_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtradinginitiatetraderequest() CMsgTradingInitiateTradeRequest {
return CMsgTradingInitiateTradeRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtradinginitiatetraderequest(o CMsgTradingInitiateTradeRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtradinginitiatetraderequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTradingInitiateTradeRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgtradinginitiatetraderequest_unpack(v)?
return i, unpacked
}
pub struct CMsgTradingInitiateTradeResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
response u32
has_response bool
trade_request_id u32
has_trade_request_id bool
other_steamid u64
has_other_steamid bool
steamguard_required_days u32
has_steamguard_required_days bool
new_device_cooldown_days u32
has_new_device_cooldown_days bool
default_password_reset_probation_days u32
has_default_password_reset_probation_days bool
password_reset_probation_days u32
has_password_reset_probation_days bool
default_email_change_probation_days u32
has_default_email_change_probation_days bool
email_change_probation_days u32
has_email_change_probation_days bool
}
pub fn (o &CMsgTradingInitiateTradeResponse) pack() []byte {
mut res := []byte{}
if o.has_response {
res << vproto.pack_uint32_field(o.response, 1)
}

if o.has_trade_request_id {
res << vproto.pack_uint32_field(o.trade_request_id, 2)
}

if o.has_other_steamid {
res << vproto.pack_uint64_field(o.other_steamid, 3)
}

if o.has_steamguard_required_days {
res << vproto.pack_uint32_field(o.steamguard_required_days, 4)
}

if o.has_new_device_cooldown_days {
res << vproto.pack_uint32_field(o.new_device_cooldown_days, 5)
}

if o.has_default_password_reset_probation_days {
res << vproto.pack_uint32_field(o.default_password_reset_probation_days, 6)
}

if o.has_password_reset_probation_days {
res << vproto.pack_uint32_field(o.password_reset_probation_days, 7)
}

if o.has_default_email_change_probation_days {
res << vproto.pack_uint32_field(o.default_email_change_probation_days, 8)
}

if o.has_email_change_probation_days {
res << vproto.pack_uint32_field(o.email_change_probation_days, 9)
}

return res
}

pub fn cmsgtradinginitiatetraderesponse_unpack(buf []byte) ?CMsgTradingInitiateTradeResponse {
mut res := CMsgTradingInitiateTradeResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_response = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.response = v
i = ii
}

2 {
res.has_trade_request_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.trade_request_id = v
i = ii
}

3 {
res.has_other_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.other_steamid = v
i = ii
}

4 {
res.has_steamguard_required_days = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.steamguard_required_days = v
i = ii
}

5 {
res.has_new_device_cooldown_days = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.new_device_cooldown_days = v
i = ii
}

6 {
res.has_default_password_reset_probation_days = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.default_password_reset_probation_days = v
i = ii
}

7 {
res.has_password_reset_probation_days = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.password_reset_probation_days = v
i = ii
}

8 {
res.has_default_email_change_probation_days = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.default_email_change_probation_days = v
i = ii
}

9 {
res.has_email_change_probation_days = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.email_change_probation_days = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtradinginitiatetraderesponse() CMsgTradingInitiateTradeResponse {
return CMsgTradingInitiateTradeResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtradinginitiatetraderesponse(o CMsgTradingInitiateTradeResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtradinginitiatetraderesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTradingInitiateTradeResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgtradinginitiatetraderesponse_unpack(v)?
return i, unpacked
}
pub struct CMsgTradingCancelTradeRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
other_steamid u64
has_other_steamid bool
}
pub fn (o &CMsgTradingCancelTradeRequest) pack() []byte {
mut res := []byte{}
if o.has_other_steamid {
res << vproto.pack_uint64_field(o.other_steamid, 1)
}

return res
}

pub fn cmsgtradingcanceltraderequest_unpack(buf []byte) ?CMsgTradingCancelTradeRequest {
mut res := CMsgTradingCancelTradeRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_other_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.other_steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtradingcanceltraderequest() CMsgTradingCancelTradeRequest {
return CMsgTradingCancelTradeRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtradingcanceltraderequest(o CMsgTradingCancelTradeRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtradingcanceltraderequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTradingCancelTradeRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgtradingcanceltraderequest_unpack(v)?
return i, unpacked
}
pub struct CMsgTradingStartSession {
mut:
unknown_fields []vproto.UnknownField
pub mut:
other_steamid u64
has_other_steamid bool
}
pub fn (o &CMsgTradingStartSession) pack() []byte {
mut res := []byte{}
if o.has_other_steamid {
res << vproto.pack_uint64_field(o.other_steamid, 1)
}

return res
}

pub fn cmsgtradingstartsession_unpack(buf []byte) ?CMsgTradingStartSession {
mut res := CMsgTradingStartSession{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_other_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.other_steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtradingstartsession() CMsgTradingStartSession {
return CMsgTradingStartSession{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtradingstartsession(o CMsgTradingStartSession, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtradingstartsession(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTradingStartSession) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgtradingstartsession_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetCDnauthToken {
mut:
unknown_fields []vproto.UnknownField
pub mut:
depot_id u32
has_depot_id bool
host_name string
has_host_name bool
app_id u32
has_app_id bool
}
pub fn (o &CMsgClientGetCDnauthToken) pack() []byte {
mut res := []byte{}
if o.has_depot_id {
res << vproto.pack_uint32_field(o.depot_id, 1)
}

if o.has_host_name {
res << vproto.pack_string_field(o.host_name, 2)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 3)
}

return res
}

pub fn cmsgclientgetcdnauthtoken_unpack(buf []byte) ?CMsgClientGetCDnauthToken {
mut res := CMsgClientGetCDnauthToken{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_depot_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.depot_id = v
i = ii
}

2 {
res.has_host_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.host_name = v
i = ii
}

3 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetcdnauthtoken() CMsgClientGetCDnauthToken {
return CMsgClientGetCDnauthToken{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetcdnauthtoken(o CMsgClientGetCDnauthToken, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetcdnauthtoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetCDnauthToken) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetcdnauthtoken_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetDepotDecryptionKey {
mut:
unknown_fields []vproto.UnknownField
pub mut:
depot_id u32
has_depot_id bool
app_id u32
has_app_id bool
}
pub fn (o &CMsgClientGetDepotDecryptionKey) pack() []byte {
mut res := []byte{}
if o.has_depot_id {
res << vproto.pack_uint32_field(o.depot_id, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

return res
}

pub fn cmsgclientgetdepotdecryptionkey_unpack(buf []byte) ?CMsgClientGetDepotDecryptionKey {
mut res := CMsgClientGetDepotDecryptionKey{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_depot_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.depot_id = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetdepotdecryptionkey() CMsgClientGetDepotDecryptionKey {
return CMsgClientGetDepotDecryptionKey{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetdepotdecryptionkey(o CMsgClientGetDepotDecryptionKey, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetdepotdecryptionkey(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetDepotDecryptionKey) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetdepotdecryptionkey_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetDepotDecryptionKeyResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
depot_id u32
has_depot_id bool
depot_encryption_key []byte
has_depot_encryption_key bool
}
pub fn (o &CMsgClientGetDepotDecryptionKeyResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_depot_id {
res << vproto.pack_uint32_field(o.depot_id, 2)
}

if o.has_depot_encryption_key {
res << vproto.pack_bytes_field(o.depot_encryption_key, 3)
}

return res
}

pub fn cmsgclientgetdepotdecryptionkeyresponse_unpack(buf []byte) ?CMsgClientGetDepotDecryptionKeyResponse {
mut res := CMsgClientGetDepotDecryptionKeyResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_depot_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.depot_id = v
i = ii
}

3 {
res.has_depot_encryption_key = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.depot_encryption_key = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetdepotdecryptionkeyresponse() CMsgClientGetDepotDecryptionKeyResponse {
return CMsgClientGetDepotDecryptionKeyResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetdepotdecryptionkeyresponse(o CMsgClientGetDepotDecryptionKeyResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetdepotdecryptionkeyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetDepotDecryptionKeyResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetdepotdecryptionkeyresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientCheckAppBetaPassword {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
betapassword string
has_betapassword bool
}
pub fn (o &CMsgClientCheckAppBetaPassword) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_betapassword {
res << vproto.pack_string_field(o.betapassword, 2)
}

return res
}

pub fn cmsgclientcheckappbetapassword_unpack(buf []byte) ?CMsgClientCheckAppBetaPassword {
mut res := CMsgClientCheckAppBetaPassword{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_betapassword = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.betapassword = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcheckappbetapassword() CMsgClientCheckAppBetaPassword {
return CMsgClientCheckAppBetaPassword{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcheckappbetapassword(o CMsgClientCheckAppBetaPassword, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcheckappbetapassword(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCheckAppBetaPassword) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientcheckappbetapassword_unpack(v)?
return i, unpacked
}
pub struct CMsgClientCheckAppBetaPasswordResponseBetaPassword {
mut:
unknown_fields []vproto.UnknownField
pub mut:
betaname string
has_betaname bool
betapassword string
has_betapassword bool
}
pub fn (o &CMsgClientCheckAppBetaPasswordResponseBetaPassword) pack() []byte {
mut res := []byte{}
if o.has_betaname {
res << vproto.pack_string_field(o.betaname, 1)
}

if o.has_betapassword {
res << vproto.pack_string_field(o.betapassword, 2)
}

return res
}

pub fn cmsgclientcheckappbetapasswordresponsebetapassword_unpack(buf []byte) ?CMsgClientCheckAppBetaPasswordResponseBetaPassword {
mut res := CMsgClientCheckAppBetaPasswordResponseBetaPassword{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_betaname = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.betaname = v
i = ii
}

2 {
res.has_betapassword = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.betapassword = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcheckappbetapasswordresponsebetapassword() CMsgClientCheckAppBetaPasswordResponseBetaPassword {
return CMsgClientCheckAppBetaPasswordResponseBetaPassword{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcheckappbetapasswordresponsebetapassword(o CMsgClientCheckAppBetaPasswordResponseBetaPassword, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcheckappbetapasswordresponsebetapassword(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCheckAppBetaPasswordResponseBetaPassword) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientcheckappbetapasswordresponsebetapassword_unpack(v)?
return i, unpacked
}
pub struct CMsgClientCheckAppBetaPasswordResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
betapasswords []CMsgClientCheckAppBetaPasswordResponseBetaPassword
}
pub fn (o &CMsgClientCheckAppBetaPasswordResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

// [packed=false]
for _, x in o.betapasswords {
res << zzz_vproto_internal_pack_cmsgclientcheckappbetapasswordresponsebetapassword(x, 4)
}

return res
}

pub fn cmsgclientcheckappbetapasswordresponse_unpack(buf []byte) ?CMsgClientCheckAppBetaPasswordResponse {
mut res := CMsgClientCheckAppBetaPasswordResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientcheckappbetapasswordresponsebetapassword(cur_buf, tag_wiretype.wire_type)?
res.betapasswords << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcheckappbetapasswordresponse() CMsgClientCheckAppBetaPasswordResponse {
return CMsgClientCheckAppBetaPasswordResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcheckappbetapasswordresponse(o CMsgClientCheckAppBetaPasswordResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcheckappbetapasswordresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCheckAppBetaPasswordResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientcheckappbetapasswordresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUpdateAppJobReport {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
depot_ids []u32
app_state u32
has_app_state bool
job_app_error u32
has_job_app_error bool
error_details string
has_error_details bool
job_duration u32
has_job_duration bool
files_validation_failed u32
has_files_validation_failed bool
job_bytes_downloaded u64
has_job_bytes_downloaded bool
job_bytes_staged u64
has_job_bytes_staged bool
bytes_comitted u64
has_bytes_comitted bool
start_app_state u32
has_start_app_state bool
stats_machine_id u64
has_stats_machine_id bool
branch_name string
has_branch_name bool
total_bytes_downloaded u64
has_total_bytes_downloaded bool
total_bytes_staged u64
has_total_bytes_staged bool
total_bytes_restored u64
has_total_bytes_restored bool
is_borrowed bool
has_is_borrowed bool
is_free_weekend bool
has_is_free_weekend bool
total_bytes_legacy u64
has_total_bytes_legacy bool
total_bytes_patched u64
has_total_bytes_patched bool
total_bytes_saved u64
has_total_bytes_saved bool
cell_id u32
has_cell_id bool
}
pub fn (o &CMsgClientUpdateAppJobReport) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

// [packed=false]
for _, x in o.depot_ids {
res << vproto.pack_uint32_field(x, 2)
}

if o.has_app_state {
res << vproto.pack_uint32_field(o.app_state, 3)
}

if o.has_job_app_error {
res << vproto.pack_uint32_field(o.job_app_error, 4)
}

if o.has_error_details {
res << vproto.pack_string_field(o.error_details, 5)
}

if o.has_job_duration {
res << vproto.pack_uint32_field(o.job_duration, 6)
}

if o.has_files_validation_failed {
res << vproto.pack_uint32_field(o.files_validation_failed, 7)
}

if o.has_job_bytes_downloaded {
res << vproto.pack_uint64_field(o.job_bytes_downloaded, 8)
}

if o.has_job_bytes_staged {
res << vproto.pack_uint64_field(o.job_bytes_staged, 9)
}

if o.has_bytes_comitted {
res << vproto.pack_uint64_field(o.bytes_comitted, 10)
}

if o.has_start_app_state {
res << vproto.pack_uint32_field(o.start_app_state, 11)
}

if o.has_stats_machine_id {
res << vproto.pack_64bit_field(o.stats_machine_id, 12)
}

if o.has_branch_name {
res << vproto.pack_string_field(o.branch_name, 13)
}

if o.has_total_bytes_downloaded {
res << vproto.pack_uint64_field(o.total_bytes_downloaded, 14)
}

if o.has_total_bytes_staged {
res << vproto.pack_uint64_field(o.total_bytes_staged, 15)
}

if o.has_total_bytes_restored {
res << vproto.pack_uint64_field(o.total_bytes_restored, 16)
}

if o.has_is_borrowed {
res << vproto.pack_bool_field(o.is_borrowed, 17)
}

if o.has_is_free_weekend {
res << vproto.pack_bool_field(o.is_free_weekend, 18)
}

if o.has_total_bytes_legacy {
res << vproto.pack_uint64_field(o.total_bytes_legacy, 19)
}

if o.has_total_bytes_patched {
res << vproto.pack_uint64_field(o.total_bytes_patched, 20)
}

if o.has_total_bytes_saved {
res << vproto.pack_uint64_field(o.total_bytes_saved, 21)
}

if o.has_cell_id {
res << vproto.pack_uint32_field(o.cell_id, 22)
}

return res
}

pub fn cmsgclientupdateappjobreport_unpack(buf []byte) ?CMsgClientUpdateAppJobReport {
mut res := CMsgClientUpdateAppJobReport{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.depot_ids << v
i = ii
}

3 {
res.has_app_state = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_state = v
i = ii
}

4 {
res.has_job_app_error = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.job_app_error = v
i = ii
}

5 {
res.has_error_details = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.error_details = v
i = ii
}

6 {
res.has_job_duration = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.job_duration = v
i = ii
}

7 {
res.has_files_validation_failed = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.files_validation_failed = v
i = ii
}

8 {
res.has_job_bytes_downloaded = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.job_bytes_downloaded = v
i = ii
}

9 {
res.has_job_bytes_staged = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.job_bytes_staged = v
i = ii
}

10 {
res.has_bytes_comitted = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.bytes_comitted = v
i = ii
}

11 {
res.has_start_app_state = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.start_app_state = v
i = ii
}

12 {
res.has_stats_machine_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.stats_machine_id = v
i = ii
}

13 {
res.has_branch_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.branch_name = v
i = ii
}

14 {
res.has_total_bytes_downloaded = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.total_bytes_downloaded = v
i = ii
}

15 {
res.has_total_bytes_staged = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.total_bytes_staged = v
i = ii
}

16 {
res.has_total_bytes_restored = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.total_bytes_restored = v
i = ii
}

17 {
res.has_is_borrowed = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_borrowed = v
i = ii
}

18 {
res.has_is_free_weekend = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_free_weekend = v
i = ii
}

19 {
res.has_total_bytes_legacy = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.total_bytes_legacy = v
i = ii
}

20 {
res.has_total_bytes_patched = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.total_bytes_patched = v
i = ii
}

21 {
res.has_total_bytes_saved = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.total_bytes_saved = v
i = ii
}

22 {
res.has_cell_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cell_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientupdateappjobreport() CMsgClientUpdateAppJobReport {
return CMsgClientUpdateAppJobReport{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientupdateappjobreport(o CMsgClientUpdateAppJobReport, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientupdateappjobreport(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUpdateAppJobReport) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientupdateappjobreport_unpack(v)?
return i, unpacked
}
pub struct CMsgClientDPcontentStatsReport {
mut:
unknown_fields []vproto.UnknownField
pub mut:
stats_machine_id u64
has_stats_machine_id bool
country_code string
has_country_code bool
os_type int
has_os_type bool
language int
has_language bool
num_install_folders u32
has_num_install_folders bool
num_installed_games u32
has_num_installed_games bool
size_installed_games u64
has_size_installed_games bool
}
pub fn (o &CMsgClientDPcontentStatsReport) pack() []byte {
mut res := []byte{}
if o.has_stats_machine_id {
res << vproto.pack_64bit_field(o.stats_machine_id, 1)
}

if o.has_country_code {
res << vproto.pack_string_field(o.country_code, 2)
}

if o.has_os_type {
res << vproto.pack_int32_field(o.os_type, 3)
}

if o.has_language {
res << vproto.pack_int32_field(o.language, 4)
}

if o.has_num_install_folders {
res << vproto.pack_uint32_field(o.num_install_folders, 5)
}

if o.has_num_installed_games {
res << vproto.pack_uint32_field(o.num_installed_games, 6)
}

if o.has_size_installed_games {
res << vproto.pack_uint64_field(o.size_installed_games, 7)
}

return res
}

pub fn cmsgclientdpcontentstatsreport_unpack(buf []byte) ?CMsgClientDPcontentStatsReport {
mut res := CMsgClientDPcontentStatsReport{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_stats_machine_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.stats_machine_id = v
i = ii
}

2 {
res.has_country_code = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.country_code = v
i = ii
}

3 {
res.has_os_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.os_type = v
i = ii
}

4 {
res.has_language = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

5 {
res.has_num_install_folders = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.num_install_folders = v
i = ii
}

6 {
res.has_num_installed_games = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.num_installed_games = v
i = ii
}

7 {
res.has_size_installed_games = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.size_installed_games = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdpcontentstatsreport() CMsgClientDPcontentStatsReport {
return CMsgClientDPcontentStatsReport{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdpcontentstatsreport(o CMsgClientDPcontentStatsReport, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdpcontentstatsreport(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDPcontentStatsReport) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientdpcontentstatsreport_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetCDnauthTokenResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult u32
has_eresult bool
token string
has_token bool
expiration_time u32
has_expiration_time bool
}
pub fn (o &CMsgClientGetCDnauthTokenResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 1)
}

if o.has_token {
res << vproto.pack_string_field(o.token, 2)
}

if o.has_expiration_time {
res << vproto.pack_uint32_field(o.expiration_time, 3)
}

return res
}

pub fn cmsgclientgetcdnauthtokenresponse_unpack(buf []byte) ?CMsgClientGetCDnauthTokenResponse {
mut res := CMsgClientGetCDnauthTokenResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_token = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.token = v
i = ii
}

3 {
res.has_expiration_time = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.expiration_time = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetcdnauthtokenresponse() CMsgClientGetCDnauthTokenResponse {
return CMsgClientGetCDnauthTokenResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetcdnauthtokenresponse(o CMsgClientGetCDnauthTokenResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetcdnauthtokenresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetCDnauthTokenResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetcdnauthtokenresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgDownloadRateStatisticsStatsInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
source_type u32
has_source_type bool
source_id u32
has_source_id bool
seconds u32
has_seconds bool
bytes u64
has_bytes bool
host_name string
has_host_name bool
microseconds u64
has_microseconds bool
used_ipv6 bool
has_used_ipv6 bool
proxied bool
has_proxied bool
}
pub fn (o &CMsgDownloadRateStatisticsStatsInfo) pack() []byte {
mut res := []byte{}
if o.has_source_type {
res << vproto.pack_uint32_field(o.source_type, 1)
}

if o.has_source_id {
res << vproto.pack_uint32_field(o.source_id, 2)
}

if o.has_seconds {
res << vproto.pack_uint32_field(o.seconds, 3)
}

if o.has_bytes {
res << vproto.pack_uint64_field(o.bytes, 4)
}

if o.has_host_name {
res << vproto.pack_string_field(o.host_name, 5)
}

if o.has_microseconds {
res << vproto.pack_uint64_field(o.microseconds, 6)
}

if o.has_used_ipv6 {
res << vproto.pack_bool_field(o.used_ipv6, 7)
}

if o.has_proxied {
res << vproto.pack_bool_field(o.proxied, 8)
}

return res
}

pub fn cmsgdownloadratestatisticsstatsinfo_unpack(buf []byte) ?CMsgDownloadRateStatisticsStatsInfo {
mut res := CMsgDownloadRateStatisticsStatsInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_source_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.source_type = v
i = ii
}

2 {
res.has_source_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.source_id = v
i = ii
}

3 {
res.has_seconds = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds = v
i = ii
}

4 {
res.has_bytes = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.bytes = v
i = ii
}

5 {
res.has_host_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.host_name = v
i = ii
}

6 {
res.has_microseconds = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.microseconds = v
i = ii
}

7 {
res.has_used_ipv6 = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.used_ipv6 = v
i = ii
}

8 {
res.has_proxied = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.proxied = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdownloadratestatisticsstatsinfo() CMsgDownloadRateStatisticsStatsInfo {
return CMsgDownloadRateStatisticsStatsInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdownloadratestatisticsstatsinfo(o CMsgDownloadRateStatisticsStatsInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdownloadratestatisticsstatsinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDownloadRateStatisticsStatsInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgdownloadratestatisticsstatsinfo_unpack(v)?
return i, unpacked
}
pub struct CMsgDownloadRateStatistics {
mut:
unknown_fields []vproto.UnknownField
pub mut:
cell_id u32
has_cell_id bool
stats []CMsgDownloadRateStatisticsStatsInfo
throttling_kbps u32
has_throttling_kbps bool
}
pub fn (o &CMsgDownloadRateStatistics) pack() []byte {
mut res := []byte{}
if o.has_cell_id {
res << vproto.pack_uint32_field(o.cell_id, 1)
}

// [packed=false]
for _, x in o.stats {
res << zzz_vproto_internal_pack_cmsgdownloadratestatisticsstatsinfo(x, 2)
}

if o.has_throttling_kbps {
res << vproto.pack_uint32_field(o.throttling_kbps, 3)
}

return res
}

pub fn cmsgdownloadratestatistics_unpack(buf []byte) ?CMsgDownloadRateStatistics {
mut res := CMsgDownloadRateStatistics{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_cell_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cell_id = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgdownloadratestatisticsstatsinfo(cur_buf, tag_wiretype.wire_type)?
res.stats << v
i = ii
}

3 {
res.has_throttling_kbps = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.throttling_kbps = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdownloadratestatistics() CMsgDownloadRateStatistics {
return CMsgDownloadRateStatistics{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdownloadratestatistics(o CMsgDownloadRateStatistics, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdownloadratestatistics(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDownloadRateStatistics) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgdownloadratestatistics_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestAccountData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
account_or_email string
has_account_or_email bool
action u32
has_action bool
}
pub fn (o &CMsgClientRequestAccountData) pack() []byte {
mut res := []byte{}
if o.has_account_or_email {
res << vproto.pack_string_field(o.account_or_email, 1)
}

if o.has_action {
res << vproto.pack_uint32_field(o.action, 2)
}

return res
}

pub fn cmsgclientrequestaccountdata_unpack(buf []byte) ?CMsgClientRequestAccountData {
mut res := CMsgClientRequestAccountData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_account_or_email = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.account_or_email = v
i = ii
}

2 {
res.has_action = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.action = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestaccountdata() CMsgClientRequestAccountData {
return CMsgClientRequestAccountData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestaccountdata(o CMsgClientRequestAccountData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestaccountdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestAccountData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestaccountdata_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestAccountDataResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
action u32
has_action bool
eresult u32
has_eresult bool
account_name string
has_account_name bool
ct_matches u32
has_ct_matches bool
account_name_suggestion1 string
has_account_name_suggestion1 bool
account_name_suggestion2 string
has_account_name_suggestion2 bool
account_name_suggestion3 string
has_account_name_suggestion3 bool
}
pub fn (o &CMsgClientRequestAccountDataResponse) pack() []byte {
mut res := []byte{}
if o.has_action {
res << vproto.pack_uint32_field(o.action, 1)
}

if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 2)
}

if o.has_account_name {
res << vproto.pack_string_field(o.account_name, 3)
}

if o.has_ct_matches {
res << vproto.pack_uint32_field(o.ct_matches, 4)
}

if o.has_account_name_suggestion1 {
res << vproto.pack_string_field(o.account_name_suggestion1, 5)
}

if o.has_account_name_suggestion2 {
res << vproto.pack_string_field(o.account_name_suggestion2, 6)
}

if o.has_account_name_suggestion3 {
res << vproto.pack_string_field(o.account_name_suggestion3, 7)
}

return res
}

pub fn cmsgclientrequestaccountdataresponse_unpack(buf []byte) ?CMsgClientRequestAccountDataResponse {
mut res := CMsgClientRequestAccountDataResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_action = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.action = v
i = ii
}

2 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

3 {
res.has_account_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.account_name = v
i = ii
}

4 {
res.has_ct_matches = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ct_matches = v
i = ii
}

5 {
res.has_account_name_suggestion1 = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.account_name_suggestion1 = v
i = ii
}

6 {
res.has_account_name_suggestion2 = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.account_name_suggestion2 = v
i = ii
}

7 {
res.has_account_name_suggestion3 = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.account_name_suggestion3 = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestaccountdataresponse() CMsgClientRequestAccountDataResponse {
return CMsgClientRequestAccountDataResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestaccountdataresponse(o CMsgClientRequestAccountDataResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestaccountdataresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestAccountDataResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestaccountdataresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUGsgetGlobalStats {
mut:
unknown_fields []vproto.UnknownField
pub mut:
gameid u64
has_gameid bool
history_days_requested u32
has_history_days_requested bool
time_last_requested u32
has_time_last_requested bool
first_day_cached u32
has_first_day_cached bool
days_cached u32
has_days_cached bool
}
pub fn (o &CMsgClientUGsgetGlobalStats) pack() []byte {
mut res := []byte{}
if o.has_gameid {
res << vproto.pack_uint64_field(o.gameid, 1)
}

if o.has_history_days_requested {
res << vproto.pack_uint32_field(o.history_days_requested, 2)
}

if o.has_time_last_requested {
res << vproto.pack_32bit_field(o.time_last_requested, 3)
}

if o.has_first_day_cached {
res << vproto.pack_uint32_field(o.first_day_cached, 4)
}

if o.has_days_cached {
res << vproto.pack_uint32_field(o.days_cached, 5)
}

return res
}

pub fn cmsgclientugsgetglobalstats_unpack(buf []byte) ?CMsgClientUGsgetGlobalStats {
mut res := CMsgClientUGsgetGlobalStats{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_gameid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.gameid = v
i = ii
}

2 {
res.has_history_days_requested = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.history_days_requested = v
i = ii
}

3 {
res.has_time_last_requested = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.time_last_requested = v
i = ii
}

4 {
res.has_first_day_cached = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.first_day_cached = v
i = ii
}

5 {
res.has_days_cached = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.days_cached = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientugsgetglobalstats() CMsgClientUGsgetGlobalStats {
return CMsgClientUGsgetGlobalStats{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientugsgetglobalstats(o CMsgClientUGsgetGlobalStats, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientugsgetglobalstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUGsgetGlobalStats) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientugsgetglobalstats_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUGsgetGlobalStatsResponseDayStat {
mut:
unknown_fields []vproto.UnknownField
pub mut:
stat_id int
has_stat_id bool
data i64
has_data bool
}
pub fn (o &CMsgClientUGsgetGlobalStatsResponseDayStat) pack() []byte {
mut res := []byte{}
if o.has_stat_id {
res << vproto.pack_int32_field(o.stat_id, 1)
}

if o.has_data {
res << vproto.pack_int64_field(o.data, 2)
}

return res
}

pub fn cmsgclientugsgetglobalstatsresponsedaystat_unpack(buf []byte) ?CMsgClientUGsgetGlobalStatsResponseDayStat {
mut res := CMsgClientUGsgetGlobalStatsResponseDayStat{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_stat_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.stat_id = v
i = ii
}

2 {
res.has_data = true
ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
res.data = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientugsgetglobalstatsresponsedaystat() CMsgClientUGsgetGlobalStatsResponseDayStat {
return CMsgClientUGsgetGlobalStatsResponseDayStat{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientugsgetglobalstatsresponsedaystat(o CMsgClientUGsgetGlobalStatsResponseDayStat, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientugsgetglobalstatsresponsedaystat(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUGsgetGlobalStatsResponseDayStat) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientugsgetglobalstatsresponsedaystat_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUGsgetGlobalStatsResponseDay {
mut:
unknown_fields []vproto.UnknownField
pub mut:
day_id u32
has_day_id bool
stats []CMsgClientUGsgetGlobalStatsResponseDayStat
}
pub fn (o &CMsgClientUGsgetGlobalStatsResponseDay) pack() []byte {
mut res := []byte{}
if o.has_day_id {
res << vproto.pack_uint32_field(o.day_id, 1)
}

// [packed=false]
for _, x in o.stats {
res << zzz_vproto_internal_pack_cmsgclientugsgetglobalstatsresponsedaystat(x, 2)
}

return res
}

pub fn cmsgclientugsgetglobalstatsresponseday_unpack(buf []byte) ?CMsgClientUGsgetGlobalStatsResponseDay {
mut res := CMsgClientUGsgetGlobalStatsResponseDay{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_day_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.day_id = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientugsgetglobalstatsresponsedaystat(cur_buf, tag_wiretype.wire_type)?
res.stats << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientugsgetglobalstatsresponseday() CMsgClientUGsgetGlobalStatsResponseDay {
return CMsgClientUGsgetGlobalStatsResponseDay{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientugsgetglobalstatsresponseday(o CMsgClientUGsgetGlobalStatsResponseDay, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientugsgetglobalstatsresponseday(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUGsgetGlobalStatsResponseDay) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientugsgetglobalstatsresponseday_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUGsgetGlobalStatsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
timestamp u32
has_timestamp bool
day_current int
has_day_current bool
days []CMsgClientUGsgetGlobalStatsResponseDay
}
pub fn (o &CMsgClientUGsgetGlobalStatsResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_timestamp {
res << vproto.pack_32bit_field(o.timestamp, 2)
}

if o.has_day_current {
res << vproto.pack_int32_field(o.day_current, 3)
}

// [packed=false]
for _, x in o.days {
res << zzz_vproto_internal_pack_cmsgclientugsgetglobalstatsresponseday(x, 4)
}

return res
}

pub fn cmsgclientugsgetglobalstatsresponse_unpack(buf []byte) ?CMsgClientUGsgetGlobalStatsResponse {
mut res := CMsgClientUGsgetGlobalStatsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_timestamp = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp = v
i = ii
}

3 {
res.has_day_current = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.day_current = v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientugsgetglobalstatsresponseday(cur_buf, tag_wiretype.wire_type)?
res.days << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientugsgetglobalstatsresponse() CMsgClientUGsgetGlobalStatsResponse {
return CMsgClientUGsgetGlobalStatsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientugsgetglobalstatsresponse(o CMsgClientUGsgetGlobalStatsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientugsgetglobalstatsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUGsgetGlobalStatsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientugsgetglobalstatsresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgGameServerDataPlayer {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
}
pub fn (o &CMsgGameServerDataPlayer) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

return res
}

pub fn cmsggameserverdataplayer_unpack(buf []byte) ?CMsgGameServerDataPlayer {
mut res := CMsgGameServerDataPlayer{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameserverdataplayer() CMsgGameServerDataPlayer {
return CMsgGameServerDataPlayer{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameserverdataplayer(o CMsgGameServerDataPlayer, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameserverdataplayer(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameServerDataPlayer) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggameserverdataplayer_unpack(v)?
return i, unpacked
}
pub struct CMsgGameServerData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id_gs u64
has_steam_id_gs bool
deprecated_ip u32
has_deprecated_ip bool
query_port u32
has_query_port bool
game_port u32
has_game_port bool
sourcetv_port u32
has_sourcetv_port bool
name string
has_name bool
game_ip_address CMsgIPaddress
has_game_ip_address bool
app_id u32
has_app_id bool
gamedir string
has_gamedir bool
version string
has_version bool
product string
has_product bool
region string
has_region bool
players []CMsgGameServerDataPlayer
max_players u32
has_max_players bool
bot_count u32
has_bot_count bool
password bool
has_password bool
secure bool
has_secure bool
dedicated bool
has_dedicated bool
os string
has_os bool
game_data string
has_game_data bool
game_data_version u32
has_game_data_version bool
game_type string
has_game_type bool
map string
has_map bool
}
pub fn (o &CMsgGameServerData) pack() []byte {
mut res := []byte{}
if o.has_steam_id_gs {
res << vproto.pack_64bit_field(o.steam_id_gs, 1)
}

if o.has_deprecated_ip {
res << vproto.pack_uint32_field(o.deprecated_ip, 2)
}

if o.has_query_port {
res << vproto.pack_uint32_field(o.query_port, 3)
}

if o.has_game_port {
res << vproto.pack_uint32_field(o.game_port, 4)
}

if o.has_sourcetv_port {
res << vproto.pack_uint32_field(o.sourcetv_port, 5)
}

if o.has_name {
res << vproto.pack_string_field(o.name, 22)
}

if o.has_game_ip_address {
res << zzz_vproto_internal_pack_cmsgipaddress(o.game_ip_address, 23)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 6)
}

if o.has_gamedir {
res << vproto.pack_string_field(o.gamedir, 7)
}

if o.has_version {
res << vproto.pack_string_field(o.version, 8)
}

if o.has_product {
res << vproto.pack_string_field(o.product, 9)
}

if o.has_region {
res << vproto.pack_string_field(o.region, 10)
}

// [packed=false]
for _, x in o.players {
res << zzz_vproto_internal_pack_cmsggameserverdataplayer(x, 11)
}

if o.has_max_players {
res << vproto.pack_uint32_field(o.max_players, 12)
}

if o.has_bot_count {
res << vproto.pack_uint32_field(o.bot_count, 13)
}

if o.has_password {
res << vproto.pack_bool_field(o.password, 14)
}

if o.has_secure {
res << vproto.pack_bool_field(o.secure, 15)
}

if o.has_dedicated {
res << vproto.pack_bool_field(o.dedicated, 16)
}

if o.has_os {
res << vproto.pack_string_field(o.os, 17)
}

if o.has_game_data {
res << vproto.pack_string_field(o.game_data, 18)
}

if o.has_game_data_version {
res << vproto.pack_uint32_field(o.game_data_version, 19)
}

if o.has_game_type {
res << vproto.pack_string_field(o.game_type, 20)
}

if o.has_map {
res << vproto.pack_string_field(o.map, 21)
}

return res
}

pub fn cmsggameserverdata_unpack(buf []byte) ?CMsgGameServerData {
mut res := CMsgGameServerData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id_gs = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_gs = v
i = ii
}

2 {
res.has_deprecated_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_ip = v
i = ii
}

3 {
res.has_query_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.query_port = v
i = ii
}

4 {
res.has_game_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.game_port = v
i = ii
}

5 {
res.has_sourcetv_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.sourcetv_port = v
i = ii
}

22 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

23 {
res.has_game_ip_address = true
ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
res.game_ip_address = v
i = ii
}

6 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

7 {
res.has_gamedir = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.gamedir = v
i = ii
}

8 {
res.has_version = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.version = v
i = ii
}

9 {
res.has_product = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.product = v
i = ii
}

10 {
res.has_region = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.region = v
i = ii
}

11 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsggameserverdataplayer(cur_buf, tag_wiretype.wire_type)?
res.players << v
i = ii
}

12 {
res.has_max_players = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.max_players = v
i = ii
}

13 {
res.has_bot_count = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.bot_count = v
i = ii
}

14 {
res.has_password = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.password = v
i = ii
}

15 {
res.has_secure = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.secure = v
i = ii
}

16 {
res.has_dedicated = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.dedicated = v
i = ii
}

17 {
res.has_os = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.os = v
i = ii
}

18 {
res.has_game_data = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.game_data = v
i = ii
}

19 {
res.has_game_data_version = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.game_data_version = v
i = ii
}

20 {
res.has_game_type = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.game_type = v
i = ii
}

21 {
res.has_map = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.map = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameserverdata() CMsgGameServerData {
return CMsgGameServerData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameserverdata(o CMsgGameServerData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameserverdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameServerData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggameserverdata_unpack(v)?
return i, unpacked
}
pub struct CMsgGameServerRemove {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
deprecated_ip u32
has_deprecated_ip bool
query_port u32
has_query_port bool
ip CMsgIPaddress
has_ip bool
}
pub fn (o &CMsgGameServerRemove) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

if o.has_deprecated_ip {
res << vproto.pack_uint32_field(o.deprecated_ip, 2)
}

if o.has_query_port {
res << vproto.pack_uint32_field(o.query_port, 3)
}

if o.has_ip {
res << zzz_vproto_internal_pack_cmsgipaddress(o.ip, 4)
}

return res
}

pub fn cmsggameserverremove_unpack(buf []byte) ?CMsgGameServerRemove {
mut res := CMsgGameServerRemove{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

2 {
res.has_deprecated_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_ip = v
i = ii
}

3 {
res.has_query_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.query_port = v
i = ii
}

4 {
res.has_ip = true
ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
res.ip = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameserverremove() CMsgGameServerRemove {
return CMsgGameServerRemove{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameserverremove(o CMsgGameServerRemove, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameserverremove(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameServerRemove) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggameserverremove_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGMsserverQuery {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
geo_location_ip u32
has_geo_location_ip bool
region_code u32
has_region_code bool
filter_text string
has_filter_text bool
max_servers u32
has_max_servers bool
}
pub fn (o &CMsgClientGMsserverQuery) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_geo_location_ip {
res << vproto.pack_uint32_field(o.geo_location_ip, 2)
}

if o.has_region_code {
res << vproto.pack_uint32_field(o.region_code, 3)
}

if o.has_filter_text {
res << vproto.pack_string_field(o.filter_text, 4)
}

if o.has_max_servers {
res << vproto.pack_uint32_field(o.max_servers, 5)
}

return res
}

pub fn cmsgclientgmsserverquery_unpack(buf []byte) ?CMsgClientGMsserverQuery {
mut res := CMsgClientGMsserverQuery{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_geo_location_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.geo_location_ip = v
i = ii
}

3 {
res.has_region_code = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.region_code = v
i = ii
}

4 {
res.has_filter_text = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.filter_text = v
i = ii
}

5 {
res.has_max_servers = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.max_servers = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgmsserverquery() CMsgClientGMsserverQuery {
return CMsgClientGMsserverQuery{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgmsserverquery(o CMsgClientGMsserverQuery, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgmsserverquery(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGMsserverQuery) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgmsserverquery_unpack(v)?
return i, unpacked
}
pub struct CMsgGMsclientServerQueryResponseServer {
mut:
unknown_fields []vproto.UnknownField
pub mut:
deprecated_server_ip u32
has_deprecated_server_ip bool
server_port u32
has_server_port bool
auth_players u32
has_auth_players bool
server_ip CMsgIPaddress
has_server_ip bool
}
pub fn (o &CMsgGMsclientServerQueryResponseServer) pack() []byte {
mut res := []byte{}
if o.has_deprecated_server_ip {
res << vproto.pack_uint32_field(o.deprecated_server_ip, 1)
}

if o.has_server_port {
res << vproto.pack_uint32_field(o.server_port, 2)
}

if o.has_auth_players {
res << vproto.pack_uint32_field(o.auth_players, 3)
}

if o.has_server_ip {
res << zzz_vproto_internal_pack_cmsgipaddress(o.server_ip, 4)
}

return res
}

pub fn cmsggmsclientserverqueryresponseserver_unpack(buf []byte) ?CMsgGMsclientServerQueryResponseServer {
mut res := CMsgGMsclientServerQueryResponseServer{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_deprecated_server_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deprecated_server_ip = v
i = ii
}

2 {
res.has_server_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.server_port = v
i = ii
}

3 {
res.has_auth_players = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.auth_players = v
i = ii
}

4 {
res.has_server_ip = true
ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
res.server_ip = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggmsclientserverqueryresponseserver() CMsgGMsclientServerQueryResponseServer {
return CMsgGMsclientServerQueryResponseServer{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggmsclientserverqueryresponseserver(o CMsgGMsclientServerQueryResponseServer, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggmsclientserverqueryresponseserver(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGMsclientServerQueryResponseServer) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggmsclientserverqueryresponseserver_unpack(v)?
return i, unpacked
}
pub struct CMsgGMsclientServerQueryResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
servers []CMsgGMsclientServerQueryResponseServer
error string
has_error bool
}
pub fn (o &CMsgGMsclientServerQueryResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.servers {
res << zzz_vproto_internal_pack_cmsggmsclientserverqueryresponseserver(x, 1)
}

if o.has_error {
res << vproto.pack_string_field(o.error, 2)
}

return res
}

pub fn cmsggmsclientserverqueryresponse_unpack(buf []byte) ?CMsgGMsclientServerQueryResponse {
mut res := CMsgGMsclientServerQueryResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsggmsclientserverqueryresponseserver(cur_buf, tag_wiretype.wire_type)?
res.servers << v
i = ii
}

2 {
res.has_error = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.error = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggmsclientserverqueryresponse() CMsgGMsclientServerQueryResponse {
return CMsgGMsclientServerQueryResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggmsclientserverqueryresponse(o CMsgGMsclientServerQueryResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggmsclientserverqueryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGMsclientServerQueryResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggmsclientserverqueryresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgGameServerOutOfDate {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id_gs u64
has_steam_id_gs bool
reject bool
has_reject bool
message string
has_message bool
}
pub fn (o &CMsgGameServerOutOfDate) pack() []byte {
mut res := []byte{}
if o.has_steam_id_gs {
res << vproto.pack_64bit_field(o.steam_id_gs, 1)
}

if o.has_reject {
res << vproto.pack_bool_field(o.reject, 2)
}

if o.has_message {
res << vproto.pack_string_field(o.message, 3)
}

return res
}

pub fn cmsggameserveroutofdate_unpack(buf []byte) ?CMsgGameServerOutOfDate {
mut res := CMsgGameServerOutOfDate{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id_gs = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_gs = v
i = ii
}

2 {
res.has_reject = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.reject = v
i = ii
}

3 {
res.has_message = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.message = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameserveroutofdate() CMsgGameServerOutOfDate {
return CMsgGameServerOutOfDate{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameserveroutofdate(o CMsgGameServerOutOfDate, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameserveroutofdate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameServerOutOfDate) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggameserveroutofdate_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRedeemGuestPass {
mut:
unknown_fields []vproto.UnknownField
pub mut:
guest_pass_id u64
has_guest_pass_id bool
}
pub fn (o &CMsgClientRedeemGuestPass) pack() []byte {
mut res := []byte{}
if o.has_guest_pass_id {
res << vproto.pack_64bit_field(o.guest_pass_id, 1)
}

return res
}

pub fn cmsgclientredeemguestpass_unpack(buf []byte) ?CMsgClientRedeemGuestPass {
mut res := CMsgClientRedeemGuestPass{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_guest_pass_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.guest_pass_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientredeemguestpass() CMsgClientRedeemGuestPass {
return CMsgClientRedeemGuestPass{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientredeemguestpass(o CMsgClientRedeemGuestPass, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientredeemguestpass(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRedeemGuestPass) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientredeemguestpass_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRedeemGuestPassResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult u32
has_eresult bool
package_id u32
has_package_id bool
must_own_appid u32
has_must_own_appid bool
}
pub fn (o &CMsgClientRedeemGuestPassResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 1)
}

if o.has_package_id {
res << vproto.pack_uint32_field(o.package_id, 2)
}

if o.has_must_own_appid {
res << vproto.pack_uint32_field(o.must_own_appid, 3)
}

return res
}

pub fn cmsgclientredeemguestpassresponse_unpack(buf []byte) ?CMsgClientRedeemGuestPassResponse {
mut res := CMsgClientRedeemGuestPassResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_package_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.package_id = v
i = ii
}

3 {
res.has_must_own_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.must_own_appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientredeemguestpassresponse() CMsgClientRedeemGuestPassResponse {
return CMsgClientRedeemGuestPassResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientredeemguestpassresponse(o CMsgClientRedeemGuestPassResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientredeemguestpassresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRedeemGuestPassResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientredeemguestpassresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetClanActivityCounts {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid_clans []u64
}
pub fn (o &CMsgClientGetClanActivityCounts) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.steamid_clans {
res << vproto.pack_uint64_field(x, 1)
}

return res
}

pub fn cmsgclientgetclanactivitycounts_unpack(buf []byte) ?CMsgClientGetClanActivityCounts {
mut res := CMsgClientGetClanActivityCounts{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steamid_clans << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclanactivitycounts() CMsgClientGetClanActivityCounts {
return CMsgClientGetClanActivityCounts{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclanactivitycounts(o CMsgClientGetClanActivityCounts, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclanactivitycounts(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClanActivityCounts) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetclanactivitycounts_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetClanActivityCountsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult u32
has_eresult bool
}
pub fn (o &CMsgClientGetClanActivityCountsResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 1)
}

return res
}

pub fn cmsgclientgetclanactivitycountsresponse_unpack(buf []byte) ?CMsgClientGetClanActivityCountsResponse {
mut res := CMsgClientGetClanActivityCountsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclanactivitycountsresponse() CMsgClientGetClanActivityCountsResponse {
return CMsgClientGetClanActivityCountsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclanactivitycountsresponse(o CMsgClientGetClanActivityCountsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclanactivitycountsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClanActivityCountsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetclanactivitycountsresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientOGsreportString {
mut:
unknown_fields []vproto.UnknownField
pub mut:
accumulated bool
has_accumulated bool
sessionid u64
has_sessionid bool
severity int
has_severity bool
formatter string
has_formatter bool
varargs []byte
has_varargs bool
}
pub fn (o &CMsgClientOGsreportString) pack() []byte {
mut res := []byte{}
if o.has_accumulated {
res << vproto.pack_bool_field(o.accumulated, 1)
}

if o.has_sessionid {
res << vproto.pack_uint64_field(o.sessionid, 2)
}

if o.has_severity {
res << vproto.pack_int32_field(o.severity, 3)
}

if o.has_formatter {
res << vproto.pack_string_field(o.formatter, 4)
}

if o.has_varargs {
res << vproto.pack_bytes_field(o.varargs, 5)
}

return res
}

pub fn cmsgclientogsreportstring_unpack(buf []byte) ?CMsgClientOGsreportString {
mut res := CMsgClientOGsreportString{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_accumulated = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.accumulated = v
i = ii
}

2 {
res.has_sessionid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.sessionid = v
i = ii
}

3 {
res.has_severity = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.severity = v
i = ii
}

4 {
res.has_formatter = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.formatter = v
i = ii
}

5 {
res.has_varargs = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.varargs = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientogsreportstring() CMsgClientOGsreportString {
return CMsgClientOGsreportString{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientogsreportstring(o CMsgClientOGsreportString, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientogsreportstring(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientOGsreportString) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientogsreportstring_unpack(v)?
return i, unpacked
}
pub struct CMsgClientOGsreportBug {
mut:
unknown_fields []vproto.UnknownField
pub mut:
sessionid u64
has_sessionid bool
bugtext string
has_bugtext bool
screenshot []byte
has_screenshot bool
}
pub fn (o &CMsgClientOGsreportBug) pack() []byte {
mut res := []byte{}
if o.has_sessionid {
res << vproto.pack_uint64_field(o.sessionid, 1)
}

if o.has_bugtext {
res << vproto.pack_string_field(o.bugtext, 2)
}

if o.has_screenshot {
res << vproto.pack_bytes_field(o.screenshot, 3)
}

return res
}

pub fn cmsgclientogsreportbug_unpack(buf []byte) ?CMsgClientOGsreportBug {
mut res := CMsgClientOGsreportBug{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_sessionid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.sessionid = v
i = ii
}

2 {
res.has_bugtext = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.bugtext = v
i = ii
}

3 {
res.has_screenshot = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.screenshot = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientogsreportbug() CMsgClientOGsreportBug {
return CMsgClientOGsreportBug{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientogsreportbug(o CMsgClientOGsreportBug, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientogsreportbug(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientOGsreportBug) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientogsreportbug_unpack(v)?
return i, unpacked
}
pub struct CMsgGSassociateWithClan {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id_clan u64
has_steam_id_clan bool
}
pub fn (o &CMsgGSassociateWithClan) pack() []byte {
mut res := []byte{}
if o.has_steam_id_clan {
res << vproto.pack_64bit_field(o.steam_id_clan, 1)
}

return res
}

pub fn cmsggsassociatewithclan_unpack(buf []byte) ?CMsgGSassociateWithClan {
mut res := CMsgGSassociateWithClan{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id_clan = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_clan = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsassociatewithclan() CMsgGSassociateWithClan {
return CMsgGSassociateWithClan{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsassociatewithclan(o CMsgGSassociateWithClan, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsassociatewithclan(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSassociateWithClan) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggsassociatewithclan_unpack(v)?
return i, unpacked
}
pub struct CMsgGSassociateWithClanResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id_clan u64
has_steam_id_clan bool
eresult u32
has_eresult bool
}
pub fn (o &CMsgGSassociateWithClanResponse) pack() []byte {
mut res := []byte{}
if o.has_steam_id_clan {
res << vproto.pack_64bit_field(o.steam_id_clan, 1)
}

if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 2)
}

return res
}

pub fn cmsggsassociatewithclanresponse_unpack(buf []byte) ?CMsgGSassociateWithClanResponse {
mut res := CMsgGSassociateWithClanResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id_clan = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_clan = v
i = ii
}

2 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsassociatewithclanresponse() CMsgGSassociateWithClanResponse {
return CMsgGSassociateWithClanResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsassociatewithclanresponse(o CMsgGSassociateWithClanResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsassociatewithclanresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSassociateWithClanResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggsassociatewithclanresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgGScomputeNewPlayerCompatibility {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id_candidate u64
has_steam_id_candidate bool
}
pub fn (o &CMsgGScomputeNewPlayerCompatibility) pack() []byte {
mut res := []byte{}
if o.has_steam_id_candidate {
res << vproto.pack_64bit_field(o.steam_id_candidate, 1)
}

return res
}

pub fn cmsggscomputenewplayercompatibility_unpack(buf []byte) ?CMsgGScomputeNewPlayerCompatibility {
mut res := CMsgGScomputeNewPlayerCompatibility{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id_candidate = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_candidate = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggscomputenewplayercompatibility() CMsgGScomputeNewPlayerCompatibility {
return CMsgGScomputeNewPlayerCompatibility{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggscomputenewplayercompatibility(o CMsgGScomputeNewPlayerCompatibility, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggscomputenewplayercompatibility(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGScomputeNewPlayerCompatibility) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggscomputenewplayercompatibility_unpack(v)?
return i, unpacked
}
pub struct CMsgGScomputeNewPlayerCompatibilityResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id_candidate u64
has_steam_id_candidate bool
eresult u32
has_eresult bool
is_clan_member bool
has_is_clan_member bool
ct_dont_like_you int
has_ct_dont_like_you bool
ct_you_dont_like int
has_ct_you_dont_like bool
ct_clanmembers_dont_like_you int
has_ct_clanmembers_dont_like_you bool
}
pub fn (o &CMsgGScomputeNewPlayerCompatibilityResponse) pack() []byte {
mut res := []byte{}
if o.has_steam_id_candidate {
res << vproto.pack_64bit_field(o.steam_id_candidate, 1)
}

if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 2)
}

if o.has_is_clan_member {
res << vproto.pack_bool_field(o.is_clan_member, 3)
}

if o.has_ct_dont_like_you {
res << vproto.pack_int32_field(o.ct_dont_like_you, 4)
}

if o.has_ct_you_dont_like {
res << vproto.pack_int32_field(o.ct_you_dont_like, 5)
}

if o.has_ct_clanmembers_dont_like_you {
res << vproto.pack_int32_field(o.ct_clanmembers_dont_like_you, 6)
}

return res
}

pub fn cmsggscomputenewplayercompatibilityresponse_unpack(buf []byte) ?CMsgGScomputeNewPlayerCompatibilityResponse {
mut res := CMsgGScomputeNewPlayerCompatibilityResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id_candidate = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id_candidate = v
i = ii
}

2 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

3 {
res.has_is_clan_member = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_clan_member = v
i = ii
}

4 {
res.has_ct_dont_like_you = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.ct_dont_like_you = v
i = ii
}

5 {
res.has_ct_you_dont_like = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.ct_you_dont_like = v
i = ii
}

6 {
res.has_ct_clanmembers_dont_like_you = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.ct_clanmembers_dont_like_you = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggscomputenewplayercompatibilityresponse() CMsgGScomputeNewPlayerCompatibilityResponse {
return CMsgGScomputeNewPlayerCompatibilityResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggscomputenewplayercompatibilityresponse(o CMsgGScomputeNewPlayerCompatibilityResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggscomputenewplayercompatibilityresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGScomputeNewPlayerCompatibilityResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggscomputenewplayercompatibilityresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientSentLogs {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CMsgClientSentLogs) pack() []byte {
res := []byte{}
return res
}

pub fn cmsgclientsentlogs_unpack(buf []byte) ?CMsgClientSentLogs {
res := CMsgClientSentLogs{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsentlogs() CMsgClientSentLogs {
return CMsgClientSentLogs{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsentlogs(o CMsgClientSentLogs, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsentlogs(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSentLogs) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientsentlogs_unpack(v)?
return i, unpacked
}
pub struct CMsgGCclient {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
msgtype u32
has_msgtype bool
payload []byte
has_payload bool
steamid u64
has_steamid bool
gcname string
has_gcname bool
ip u32
has_ip bool
}
pub fn (o &CMsgGCclient) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_msgtype {
res << vproto.pack_uint32_field(o.msgtype, 2)
}

if o.has_payload {
res << vproto.pack_bytes_field(o.payload, 3)
}

if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 4)
}

if o.has_gcname {
res << vproto.pack_string_field(o.gcname, 5)
}

if o.has_ip {
res << vproto.pack_uint32_field(o.ip, 6)
}

return res
}

pub fn cmsggcclient_unpack(buf []byte) ?CMsgGCclient {
mut res := CMsgGCclient{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_msgtype = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.msgtype = v
i = ii
}

3 {
res.has_payload = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.payload = v
i = ii
}

4 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

5 {
res.has_gcname = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.gcname = v
i = ii
}

6 {
res.has_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ip = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggcclient() CMsgGCclient {
return CMsgGCclient{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggcclient(o CMsgGCclient, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggcclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGCclient) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggcclient_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestFreeLicense {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appids []u32
}
pub fn (o &CMsgClientRequestFreeLicense) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.appids {
res << vproto.pack_uint32_field(x, 2)
}

return res
}

pub fn cmsgclientrequestfreelicense_unpack(buf []byte) ?CMsgClientRequestFreeLicense {
mut res := CMsgClientRequestFreeLicense{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestfreelicense() CMsgClientRequestFreeLicense {
return CMsgClientRequestFreeLicense{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestfreelicense(o CMsgClientRequestFreeLicense, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestfreelicense(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestFreeLicense) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestfreelicense_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestFreeLicenseResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult u32
has_eresult bool
granted_packageids []u32
granted_appids []u32
}
pub fn (o &CMsgClientRequestFreeLicenseResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 1)
}

// [packed=false]
for _, x in o.granted_packageids {
res << vproto.pack_uint32_field(x, 2)
}

// [packed=false]
for _, x in o.granted_appids {
res << vproto.pack_uint32_field(x, 3)
}

return res
}

pub fn cmsgclientrequestfreelicenseresponse_unpack(buf []byte) ?CMsgClientRequestFreeLicenseResponse {
mut res := CMsgClientRequestFreeLicenseResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.granted_packageids << v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.granted_appids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestfreelicenseresponse() CMsgClientRequestFreeLicenseResponse {
return CMsgClientRequestFreeLicenseResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestfreelicenseresponse(o CMsgClientRequestFreeLicenseResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestfreelicenseresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestFreeLicenseResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestfreelicenseresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgDRmdownloadRequestWithCrashData {
mut:
unknown_fields []vproto.UnknownField
pub mut:
download_flags u32
has_download_flags bool
download_types_known u32
has_download_types_known bool
guid_drm []byte
has_guid_drm bool
guid_split []byte
has_guid_split bool
guid_merge []byte
has_guid_merge bool
module_name string
has_module_name bool
module_path string
has_module_path bool
crash_data []byte
has_crash_data bool
}
pub fn (o &CMsgDRmdownloadRequestWithCrashData) pack() []byte {
mut res := []byte{}
if o.has_download_flags {
res << vproto.pack_uint32_field(o.download_flags, 1)
}

if o.has_download_types_known {
res << vproto.pack_uint32_field(o.download_types_known, 2)
}

if o.has_guid_drm {
res << vproto.pack_bytes_field(o.guid_drm, 3)
}

if o.has_guid_split {
res << vproto.pack_bytes_field(o.guid_split, 4)
}

if o.has_guid_merge {
res << vproto.pack_bytes_field(o.guid_merge, 5)
}

if o.has_module_name {
res << vproto.pack_string_field(o.module_name, 6)
}

if o.has_module_path {
res << vproto.pack_string_field(o.module_path, 7)
}

if o.has_crash_data {
res << vproto.pack_bytes_field(o.crash_data, 8)
}

return res
}

pub fn cmsgdrmdownloadrequestwithcrashdata_unpack(buf []byte) ?CMsgDRmdownloadRequestWithCrashData {
mut res := CMsgDRmdownloadRequestWithCrashData{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_download_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.download_flags = v
i = ii
}

2 {
res.has_download_types_known = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.download_types_known = v
i = ii
}

3 {
res.has_guid_drm = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.guid_drm = v
i = ii
}

4 {
res.has_guid_split = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.guid_split = v
i = ii
}

5 {
res.has_guid_merge = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.guid_merge = v
i = ii
}

6 {
res.has_module_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.module_name = v
i = ii
}

7 {
res.has_module_path = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.module_path = v
i = ii
}

8 {
res.has_crash_data = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.crash_data = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdrmdownloadrequestwithcrashdata() CMsgDRmdownloadRequestWithCrashData {
return CMsgDRmdownloadRequestWithCrashData{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdrmdownloadrequestwithcrashdata(o CMsgDRmdownloadRequestWithCrashData, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdrmdownloadrequestwithcrashdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDRmdownloadRequestWithCrashData) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgdrmdownloadrequestwithcrashdata_unpack(v)?
return i, unpacked
}
pub struct CMsgDRmdownloadResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult u32
has_eresult bool
app_id u32
has_app_id bool
blob_download_type u32
has_blob_download_type bool
merge_guid []byte
has_merge_guid bool
download_file_dfs_ip u32
has_download_file_dfs_ip bool
download_file_dfs_port u32
has_download_file_dfs_port bool
download_file_url string
has_download_file_url bool
module_path string
has_module_path bool
}
pub fn (o &CMsgDRmdownloadResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

if o.has_blob_download_type {
res << vproto.pack_uint32_field(o.blob_download_type, 3)
}

if o.has_merge_guid {
res << vproto.pack_bytes_field(o.merge_guid, 4)
}

if o.has_download_file_dfs_ip {
res << vproto.pack_uint32_field(o.download_file_dfs_ip, 5)
}

if o.has_download_file_dfs_port {
res << vproto.pack_uint32_field(o.download_file_dfs_port, 6)
}

if o.has_download_file_url {
res << vproto.pack_string_field(o.download_file_url, 7)
}

if o.has_module_path {
res << vproto.pack_string_field(o.module_path, 8)
}

return res
}

pub fn cmsgdrmdownloadresponse_unpack(buf []byte) ?CMsgDRmdownloadResponse {
mut res := CMsgDRmdownloadResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

3 {
res.has_blob_download_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.blob_download_type = v
i = ii
}

4 {
res.has_merge_guid = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.merge_guid = v
i = ii
}

5 {
res.has_download_file_dfs_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.download_file_dfs_ip = v
i = ii
}

6 {
res.has_download_file_dfs_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.download_file_dfs_port = v
i = ii
}

7 {
res.has_download_file_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.download_file_url = v
i = ii
}

8 {
res.has_module_path = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.module_path = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdrmdownloadresponse() CMsgDRmdownloadResponse {
return CMsgDRmdownloadResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdrmdownloadresponse(o CMsgDRmdownloadResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdrmdownloadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDRmdownloadResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgdrmdownloadresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgDRmfinalResult {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult u32
has_eresult bool
app_id u32
has_app_id bool
blob_download_type u32
has_blob_download_type bool
error_detail u32
has_error_detail bool
merge_guid []byte
has_merge_guid bool
download_file_dfs_ip u32
has_download_file_dfs_ip bool
download_file_dfs_port u32
has_download_file_dfs_port bool
download_file_url string
has_download_file_url bool
}
pub fn (o &CMsgDRmfinalResult) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 1)
}

if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 2)
}

if o.has_blob_download_type {
res << vproto.pack_uint32_field(o.blob_download_type, 3)
}

if o.has_error_detail {
res << vproto.pack_uint32_field(o.error_detail, 4)
}

if o.has_merge_guid {
res << vproto.pack_bytes_field(o.merge_guid, 5)
}

if o.has_download_file_dfs_ip {
res << vproto.pack_uint32_field(o.download_file_dfs_ip, 6)
}

if o.has_download_file_dfs_port {
res << vproto.pack_uint32_field(o.download_file_dfs_port, 7)
}

if o.has_download_file_url {
res << vproto.pack_string_field(o.download_file_url, 8)
}

return res
}

pub fn cmsgdrmfinalresult_unpack(buf []byte) ?CMsgDRmfinalResult {
mut res := CMsgDRmfinalResult{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

3 {
res.has_blob_download_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.blob_download_type = v
i = ii
}

4 {
res.has_error_detail = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.error_detail = v
i = ii
}

5 {
res.has_merge_guid = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.merge_guid = v
i = ii
}

6 {
res.has_download_file_dfs_ip = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.download_file_dfs_ip = v
i = ii
}

7 {
res.has_download_file_dfs_port = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.download_file_dfs_port = v
i = ii
}

8 {
res.has_download_file_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.download_file_url = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdrmfinalresult() CMsgDRmfinalResult {
return CMsgDRmfinalResult{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdrmfinalresult(o CMsgDRmfinalResult, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdrmfinalresult(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDRmfinalResult) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgdrmfinalresult_unpack(v)?
return i, unpacked
}
pub struct CMsgClientDPcheckSpecialSurvey {
mut:
unknown_fields []vproto.UnknownField
pub mut:
survey_id u32
has_survey_id bool
}
pub fn (o &CMsgClientDPcheckSpecialSurvey) pack() []byte {
mut res := []byte{}
if o.has_survey_id {
res << vproto.pack_uint32_field(o.survey_id, 1)
}

return res
}

pub fn cmsgclientdpcheckspecialsurvey_unpack(buf []byte) ?CMsgClientDPcheckSpecialSurvey {
mut res := CMsgClientDPcheckSpecialSurvey{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_survey_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.survey_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdpcheckspecialsurvey() CMsgClientDPcheckSpecialSurvey {
return CMsgClientDPcheckSpecialSurvey{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdpcheckspecialsurvey(o CMsgClientDPcheckSpecialSurvey, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdpcheckspecialsurvey(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDPcheckSpecialSurvey) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientdpcheckspecialsurvey_unpack(v)?
return i, unpacked
}
pub struct CMsgClientDPcheckSpecialSurveyResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult u32
has_eresult bool
state u32
has_state bool
name string
has_name bool
custom_url string
has_custom_url bool
include_software bool
has_include_software bool
token []byte
has_token bool
}
pub fn (o &CMsgClientDPcheckSpecialSurveyResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 1)
}

if o.has_state {
res << vproto.pack_uint32_field(o.state, 2)
}

if o.has_name {
res << vproto.pack_string_field(o.name, 3)
}

if o.has_custom_url {
res << vproto.pack_string_field(o.custom_url, 4)
}

if o.has_include_software {
res << vproto.pack_bool_field(o.include_software, 5)
}

if o.has_token {
res << vproto.pack_bytes_field(o.token, 6)
}

return res
}

pub fn cmsgclientdpcheckspecialsurveyresponse_unpack(buf []byte) ?CMsgClientDPcheckSpecialSurveyResponse {
mut res := CMsgClientDPcheckSpecialSurveyResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_state = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.state = v
i = ii
}

3 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

4 {
res.has_custom_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.custom_url = v
i = ii
}

5 {
res.has_include_software = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.include_software = v
i = ii
}

6 {
res.has_token = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdpcheckspecialsurveyresponse() CMsgClientDPcheckSpecialSurveyResponse {
return CMsgClientDPcheckSpecialSurveyResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdpcheckspecialsurveyresponse(o CMsgClientDPcheckSpecialSurveyResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdpcheckspecialsurveyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDPcheckSpecialSurveyResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientdpcheckspecialsurveyresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientDPsendSpecialSurveyResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
survey_id u32
has_survey_id bool
data []byte
has_data bool
}
pub fn (o &CMsgClientDPsendSpecialSurveyResponse) pack() []byte {
mut res := []byte{}
if o.has_survey_id {
res << vproto.pack_uint32_field(o.survey_id, 1)
}

if o.has_data {
res << vproto.pack_bytes_field(o.data, 2)
}

return res
}

pub fn cmsgclientdpsendspecialsurveyresponse_unpack(buf []byte) ?CMsgClientDPsendSpecialSurveyResponse {
mut res := CMsgClientDPsendSpecialSurveyResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_survey_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.survey_id = v
i = ii
}

2 {
res.has_data = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.data = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdpsendspecialsurveyresponse() CMsgClientDPsendSpecialSurveyResponse {
return CMsgClientDPsendSpecialSurveyResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdpsendspecialsurveyresponse(o CMsgClientDPsendSpecialSurveyResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdpsendspecialsurveyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDPsendSpecialSurveyResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientdpsendspecialsurveyresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientDPsendSpecialSurveyResponseReply {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult u32
has_eresult bool
token []byte
has_token bool
}
pub fn (o &CMsgClientDPsendSpecialSurveyResponseReply) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 1)
}

if o.has_token {
res << vproto.pack_bytes_field(o.token, 2)
}

return res
}

pub fn cmsgclientdpsendspecialsurveyresponsereply_unpack(buf []byte) ?CMsgClientDPsendSpecialSurveyResponseReply {
mut res := CMsgClientDPsendSpecialSurveyResponseReply{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_token = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdpsendspecialsurveyresponsereply() CMsgClientDPsendSpecialSurveyResponseReply {
return CMsgClientDPsendSpecialSurveyResponseReply{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdpsendspecialsurveyresponsereply(o CMsgClientDPsendSpecialSurveyResponseReply, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdpsendspecialsurveyresponsereply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDPsendSpecialSurveyResponseReply) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientdpsendspecialsurveyresponsereply_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestForgottenPasswordEmail {
mut:
unknown_fields []vproto.UnknownField
pub mut:
account_name string
has_account_name bool
password_tried string
has_password_tried bool
}
pub fn (o &CMsgClientRequestForgottenPasswordEmail) pack() []byte {
mut res := []byte{}
if o.has_account_name {
res << vproto.pack_string_field(o.account_name, 1)
}

if o.has_password_tried {
res << vproto.pack_string_field(o.password_tried, 2)
}

return res
}

pub fn cmsgclientrequestforgottenpasswordemail_unpack(buf []byte) ?CMsgClientRequestForgottenPasswordEmail {
mut res := CMsgClientRequestForgottenPasswordEmail{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_account_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.account_name = v
i = ii
}

2 {
res.has_password_tried = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.password_tried = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestforgottenpasswordemail() CMsgClientRequestForgottenPasswordEmail {
return CMsgClientRequestForgottenPasswordEmail{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestforgottenpasswordemail(o CMsgClientRequestForgottenPasswordEmail, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestforgottenpasswordemail(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestForgottenPasswordEmail) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestforgottenpasswordemail_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestForgottenPasswordEmailResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult u32
has_eresult bool
use_secret_question bool
has_use_secret_question bool
}
pub fn (o &CMsgClientRequestForgottenPasswordEmailResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 1)
}

if o.has_use_secret_question {
res << vproto.pack_bool_field(o.use_secret_question, 2)
}

return res
}

pub fn cmsgclientrequestforgottenpasswordemailresponse_unpack(buf []byte) ?CMsgClientRequestForgottenPasswordEmailResponse {
mut res := CMsgClientRequestForgottenPasswordEmailResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_use_secret_question = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.use_secret_question = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestforgottenpasswordemailresponse() CMsgClientRequestForgottenPasswordEmailResponse {
return CMsgClientRequestForgottenPasswordEmailResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestforgottenpasswordemailresponse(o CMsgClientRequestForgottenPasswordEmailResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestforgottenpasswordemailresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestForgottenPasswordEmailResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestforgottenpasswordemailresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientItemAnnouncementsUnseenItem {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
context_id u64
has_context_id bool
asset_id u64
has_asset_id bool
amount u64
has_amount bool
rtime32_gained u32
has_rtime32_gained bool
source_appid u32
has_source_appid bool
}
pub fn (o &CMsgClientItemAnnouncementsUnseenItem) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_context_id {
res << vproto.pack_uint64_field(o.context_id, 2)
}

if o.has_asset_id {
res << vproto.pack_uint64_field(o.asset_id, 3)
}

if o.has_amount {
res << vproto.pack_uint64_field(o.amount, 4)
}

if o.has_rtime32_gained {
res << vproto.pack_32bit_field(o.rtime32_gained, 5)
}

if o.has_source_appid {
res << vproto.pack_uint32_field(o.source_appid, 6)
}

return res
}

pub fn cmsgclientitemannouncementsunseenitem_unpack(buf []byte) ?CMsgClientItemAnnouncementsUnseenItem {
mut res := CMsgClientItemAnnouncementsUnseenItem{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_context_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.context_id = v
i = ii
}

3 {
res.has_asset_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.asset_id = v
i = ii
}

4 {
res.has_amount = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.amount = v
i = ii
}

5 {
res.has_rtime32_gained = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.rtime32_gained = v
i = ii
}

6 {
res.has_source_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.source_appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientitemannouncementsunseenitem() CMsgClientItemAnnouncementsUnseenItem {
return CMsgClientItemAnnouncementsUnseenItem{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientitemannouncementsunseenitem(o CMsgClientItemAnnouncementsUnseenItem, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientitemannouncementsunseenitem(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientItemAnnouncementsUnseenItem) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientitemannouncementsunseenitem_unpack(v)?
return i, unpacked
}
pub struct CMsgClientItemAnnouncements {
mut:
unknown_fields []vproto.UnknownField
pub mut:
count_new_items u32
has_count_new_items bool
unseen_items []CMsgClientItemAnnouncementsUnseenItem
}
pub fn (o &CMsgClientItemAnnouncements) pack() []byte {
mut res := []byte{}
if o.has_count_new_items {
res << vproto.pack_uint32_field(o.count_new_items, 1)
}

// [packed=false]
for _, x in o.unseen_items {
res << zzz_vproto_internal_pack_cmsgclientitemannouncementsunseenitem(x, 2)
}

return res
}

pub fn cmsgclientitemannouncements_unpack(buf []byte) ?CMsgClientItemAnnouncements {
mut res := CMsgClientItemAnnouncements{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_count_new_items = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.count_new_items = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientitemannouncementsunseenitem(cur_buf, tag_wiretype.wire_type)?
res.unseen_items << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientitemannouncements() CMsgClientItemAnnouncements {
return CMsgClientItemAnnouncements{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientitemannouncements(o CMsgClientItemAnnouncements, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientitemannouncements(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientItemAnnouncements) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientitemannouncements_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestItemAnnouncements {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CMsgClientRequestItemAnnouncements) pack() []byte {
res := []byte{}
return res
}

pub fn cmsgclientrequestitemannouncements_unpack(buf []byte) ?CMsgClientRequestItemAnnouncements {
res := CMsgClientRequestItemAnnouncements{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestitemannouncements() CMsgClientRequestItemAnnouncements {
return CMsgClientRequestItemAnnouncements{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestitemannouncements(o CMsgClientRequestItemAnnouncements, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestitemannouncements(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestItemAnnouncements) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestitemannouncements_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUserNotificationsNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
user_notification_type u32
has_user_notification_type bool
count u32
has_count bool
}
pub fn (o &CMsgClientUserNotificationsNotification) pack() []byte {
mut res := []byte{}
if o.has_user_notification_type {
res << vproto.pack_uint32_field(o.user_notification_type, 1)
}

if o.has_count {
res << vproto.pack_uint32_field(o.count, 2)
}

return res
}

pub fn cmsgclientusernotificationsnotification_unpack(buf []byte) ?CMsgClientUserNotificationsNotification {
mut res := CMsgClientUserNotificationsNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_user_notification_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.user_notification_type = v
i = ii
}

2 {
res.has_count = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.count = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientusernotificationsnotification() CMsgClientUserNotificationsNotification {
return CMsgClientUserNotificationsNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientusernotificationsnotification(o CMsgClientUserNotificationsNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientusernotificationsnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUserNotificationsNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientusernotificationsnotification_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUserNotifications {
mut:
unknown_fields []vproto.UnknownField
pub mut:
notifications []CMsgClientUserNotificationsNotification
}
pub fn (o &CMsgClientUserNotifications) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.notifications {
res << zzz_vproto_internal_pack_cmsgclientusernotificationsnotification(x, 1)
}

return res
}

pub fn cmsgclientusernotifications_unpack(buf []byte) ?CMsgClientUserNotifications {
mut res := CMsgClientUserNotifications{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientusernotificationsnotification(cur_buf, tag_wiretype.wire_type)?
res.notifications << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientusernotifications() CMsgClientUserNotifications {
return CMsgClientUserNotifications{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientusernotifications(o CMsgClientUserNotifications, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientusernotifications(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUserNotifications) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientusernotifications_unpack(v)?
return i, unpacked
}
pub struct CMsgClientCommentNotifications {
mut:
unknown_fields []vproto.UnknownField
pub mut:
count_new_comments u32
has_count_new_comments bool
count_new_comments_owner u32
has_count_new_comments_owner bool
count_new_comments_subscriptions u32
has_count_new_comments_subscriptions bool
}
pub fn (o &CMsgClientCommentNotifications) pack() []byte {
mut res := []byte{}
if o.has_count_new_comments {
res << vproto.pack_uint32_field(o.count_new_comments, 1)
}

if o.has_count_new_comments_owner {
res << vproto.pack_uint32_field(o.count_new_comments_owner, 2)
}

if o.has_count_new_comments_subscriptions {
res << vproto.pack_uint32_field(o.count_new_comments_subscriptions, 3)
}

return res
}

pub fn cmsgclientcommentnotifications_unpack(buf []byte) ?CMsgClientCommentNotifications {
mut res := CMsgClientCommentNotifications{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_count_new_comments = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.count_new_comments = v
i = ii
}

2 {
res.has_count_new_comments_owner = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.count_new_comments_owner = v
i = ii
}

3 {
res.has_count_new_comments_subscriptions = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.count_new_comments_subscriptions = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcommentnotifications() CMsgClientCommentNotifications {
return CMsgClientCommentNotifications{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcommentnotifications(o CMsgClientCommentNotifications, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcommentnotifications(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCommentNotifications) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientcommentnotifications_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestCommentNotifications {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CMsgClientRequestCommentNotifications) pack() []byte {
res := []byte{}
return res
}

pub fn cmsgclientrequestcommentnotifications_unpack(buf []byte) ?CMsgClientRequestCommentNotifications {
res := CMsgClientRequestCommentNotifications{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestcommentnotifications() CMsgClientRequestCommentNotifications {
return CMsgClientRequestCommentNotifications{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestcommentnotifications(o CMsgClientRequestCommentNotifications, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestcommentnotifications(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestCommentNotifications) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestcommentnotifications_unpack(v)?
return i, unpacked
}
pub struct CMsgClientOfflineMessageNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
offline_messages u32
has_offline_messages bool
friends_with_offline_messages []u32
}
pub fn (o &CMsgClientOfflineMessageNotification) pack() []byte {
mut res := []byte{}
if o.has_offline_messages {
res << vproto.pack_uint32_field(o.offline_messages, 1)
}

// [packed=false]
for _, x in o.friends_with_offline_messages {
res << vproto.pack_uint32_field(x, 2)
}

return res
}

pub fn cmsgclientofflinemessagenotification_unpack(buf []byte) ?CMsgClientOfflineMessageNotification {
mut res := CMsgClientOfflineMessageNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_offline_messages = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.offline_messages = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.friends_with_offline_messages << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientofflinemessagenotification() CMsgClientOfflineMessageNotification {
return CMsgClientOfflineMessageNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientofflinemessagenotification(o CMsgClientOfflineMessageNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientofflinemessagenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientOfflineMessageNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientofflinemessagenotification_unpack(v)?
return i, unpacked
}
pub struct CMsgClientRequestOfflineMessageCount {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CMsgClientRequestOfflineMessageCount) pack() []byte {
res := []byte{}
return res
}

pub fn cmsgclientrequestofflinemessagecount_unpack(buf []byte) ?CMsgClientRequestOfflineMessageCount {
res := CMsgClientRequestOfflineMessageCount{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestofflinemessagecount() CMsgClientRequestOfflineMessageCount {
return CMsgClientRequestOfflineMessageCount{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestofflinemessagecount(o CMsgClientRequestOfflineMessageCount, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestofflinemessagecount(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestOfflineMessageCount) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientrequestofflinemessagecount_unpack(v)?
return i, unpacked
}
pub struct CMsgClientChatGetFriendMessageHistory {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
}
pub fn (o &CMsgClientChatGetFriendMessageHistory) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

return res
}

pub fn cmsgclientchatgetfriendmessagehistory_unpack(buf []byte) ?CMsgClientChatGetFriendMessageHistory {
mut res := CMsgClientChatGetFriendMessageHistory{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientchatgetfriendmessagehistory() CMsgClientChatGetFriendMessageHistory {
return CMsgClientChatGetFriendMessageHistory{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientchatgetfriendmessagehistory(o CMsgClientChatGetFriendMessageHistory, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientchatgetfriendmessagehistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChatGetFriendMessageHistory) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientchatgetfriendmessagehistory_unpack(v)?
return i, unpacked
}
pub struct CMsgClientChatGetFriendMessageHistoryResponseFriendMessage {
mut:
unknown_fields []vproto.UnknownField
pub mut:
accountid u32
has_accountid bool
timestamp u32
has_timestamp bool
message string
has_message bool
unread bool
has_unread bool
}
pub fn (o &CMsgClientChatGetFriendMessageHistoryResponseFriendMessage) pack() []byte {
mut res := []byte{}
if o.has_accountid {
res << vproto.pack_uint32_field(o.accountid, 1)
}

if o.has_timestamp {
res << vproto.pack_uint32_field(o.timestamp, 2)
}

if o.has_message {
res << vproto.pack_string_field(o.message, 3)
}

if o.has_unread {
res << vproto.pack_bool_field(o.unread, 4)
}

return res
}

pub fn cmsgclientchatgetfriendmessagehistoryresponsefriendmessage_unpack(buf []byte) ?CMsgClientChatGetFriendMessageHistoryResponseFriendMessage {
mut res := CMsgClientChatGetFriendMessageHistoryResponseFriendMessage{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_accountid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.accountid = v
i = ii
}

2 {
res.has_timestamp = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp = v
i = ii
}

3 {
res.has_message = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.message = v
i = ii
}

4 {
res.has_unread = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.unread = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientchatgetfriendmessagehistoryresponsefriendmessage() CMsgClientChatGetFriendMessageHistoryResponseFriendMessage {
return CMsgClientChatGetFriendMessageHistoryResponseFriendMessage{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientchatgetfriendmessagehistoryresponsefriendmessage(o CMsgClientChatGetFriendMessageHistoryResponseFriendMessage, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientchatgetfriendmessagehistoryresponsefriendmessage(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChatGetFriendMessageHistoryResponseFriendMessage) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientchatgetfriendmessagehistoryresponsefriendmessage_unpack(v)?
return i, unpacked
}
pub struct CMsgClientChatGetFriendMessageHistoryResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
success u32
has_success bool
messages []CMsgClientChatGetFriendMessageHistoryResponseFriendMessage
}
pub fn (o &CMsgClientChatGetFriendMessageHistoryResponse) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_success {
res << vproto.pack_uint32_field(o.success, 2)
}

// [packed=false]
for _, x in o.messages {
res << zzz_vproto_internal_pack_cmsgclientchatgetfriendmessagehistoryresponsefriendmessage(x, 3)
}

return res
}

pub fn cmsgclientchatgetfriendmessagehistoryresponse_unpack(buf []byte) ?CMsgClientChatGetFriendMessageHistoryResponse {
mut res := CMsgClientChatGetFriendMessageHistoryResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_success = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.success = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientchatgetfriendmessagehistoryresponsefriendmessage(cur_buf, tag_wiretype.wire_type)?
res.messages << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientchatgetfriendmessagehistoryresponse() CMsgClientChatGetFriendMessageHistoryResponse {
return CMsgClientChatGetFriendMessageHistoryResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientchatgetfriendmessagehistoryresponse(o CMsgClientChatGetFriendMessageHistoryResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientchatgetfriendmessagehistoryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChatGetFriendMessageHistoryResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientchatgetfriendmessagehistoryresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CMsgClientChatGetFriendMessageHistoryForOfflineMessages) pack() []byte {
res := []byte{}
return res
}

pub fn cmsgclientchatgetfriendmessagehistoryforofflinemessages_unpack(buf []byte) ?CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
res := CMsgClientChatGetFriendMessageHistoryForOfflineMessages{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientchatgetfriendmessagehistoryforofflinemessages() CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
return CMsgClientChatGetFriendMessageHistoryForOfflineMessages{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientchatgetfriendmessagehistoryforofflinemessages(o CMsgClientChatGetFriendMessageHistoryForOfflineMessages, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientchatgetfriendmessagehistoryforofflinemessages(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChatGetFriendMessageHistoryForOfflineMessages) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientchatgetfriendmessagehistoryforofflinemessages_unpack(v)?
return i, unpacked
}
pub struct CMsgClientFSgetFriendsSteamLevels {
mut:
unknown_fields []vproto.UnknownField
pub mut:
accountids []u32
}
pub fn (o &CMsgClientFSgetFriendsSteamLevels) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.accountids {
res << vproto.pack_uint32_field(x, 1)
}

return res
}

pub fn cmsgclientfsgetfriendssteamlevels_unpack(buf []byte) ?CMsgClientFSgetFriendsSteamLevels {
mut res := CMsgClientFSgetFriendsSteamLevels{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.accountids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfsgetfriendssteamlevels() CMsgClientFSgetFriendsSteamLevels {
return CMsgClientFSgetFriendsSteamLevels{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfsgetfriendssteamlevels(o CMsgClientFSgetFriendsSteamLevels, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfsgetfriendssteamlevels(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFSgetFriendsSteamLevels) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientfsgetfriendssteamlevels_unpack(v)?
return i, unpacked
}
pub struct CMsgClientFSgetFriendsSteamLevelsResponseFriend {
mut:
unknown_fields []vproto.UnknownField
pub mut:
accountid u32
has_accountid bool
level u32
has_level bool
}
pub fn (o &CMsgClientFSgetFriendsSteamLevelsResponseFriend) pack() []byte {
mut res := []byte{}
if o.has_accountid {
res << vproto.pack_uint32_field(o.accountid, 1)
}

if o.has_level {
res << vproto.pack_uint32_field(o.level, 2)
}

return res
}

pub fn cmsgclientfsgetfriendssteamlevelsresponsefriend_unpack(buf []byte) ?CMsgClientFSgetFriendsSteamLevelsResponseFriend {
mut res := CMsgClientFSgetFriendsSteamLevelsResponseFriend{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_accountid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.accountid = v
i = ii
}

2 {
res.has_level = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.level = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfsgetfriendssteamlevelsresponsefriend() CMsgClientFSgetFriendsSteamLevelsResponseFriend {
return CMsgClientFSgetFriendsSteamLevelsResponseFriend{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfsgetfriendssteamlevelsresponsefriend(o CMsgClientFSgetFriendsSteamLevelsResponseFriend, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfsgetfriendssteamlevelsresponsefriend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFSgetFriendsSteamLevelsResponseFriend) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientfsgetfriendssteamlevelsresponsefriend_unpack(v)?
return i, unpacked
}
pub struct CMsgClientFSgetFriendsSteamLevelsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
friends []CMsgClientFSgetFriendsSteamLevelsResponseFriend
}
pub fn (o &CMsgClientFSgetFriendsSteamLevelsResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.friends {
res << zzz_vproto_internal_pack_cmsgclientfsgetfriendssteamlevelsresponsefriend(x, 1)
}

return res
}

pub fn cmsgclientfsgetfriendssteamlevelsresponse_unpack(buf []byte) ?CMsgClientFSgetFriendsSteamLevelsResponse {
mut res := CMsgClientFSgetFriendsSteamLevelsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientfsgetfriendssteamlevelsresponsefriend(cur_buf, tag_wiretype.wire_type)?
res.friends << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfsgetfriendssteamlevelsresponse() CMsgClientFSgetFriendsSteamLevelsResponse {
return CMsgClientFSgetFriendsSteamLevelsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfsgetfriendssteamlevelsresponse(o CMsgClientFSgetFriendsSteamLevelsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfsgetfriendssteamlevelsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFSgetFriendsSteamLevelsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientfsgetfriendssteamlevelsresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientEmailAddrInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
email_address string
has_email_address bool
email_is_validated bool
has_email_is_validated bool
email_validation_changed bool
has_email_validation_changed bool
credential_change_requires_code bool
has_credential_change_requires_code bool
password_or_secretqa_change_requires_code bool
has_password_or_secretqa_change_requires_code bool
remind_user_about_email bool
has_remind_user_about_email bool
}
pub fn (o &CMsgClientEmailAddrInfo) pack() []byte {
mut res := []byte{}
if o.has_email_address {
res << vproto.pack_string_field(o.email_address, 1)
}

if o.has_email_is_validated {
res << vproto.pack_bool_field(o.email_is_validated, 2)
}

if o.has_email_validation_changed {
res << vproto.pack_bool_field(o.email_validation_changed, 3)
}

if o.has_credential_change_requires_code {
res << vproto.pack_bool_field(o.credential_change_requires_code, 4)
}

if o.has_password_or_secretqa_change_requires_code {
res << vproto.pack_bool_field(o.password_or_secretqa_change_requires_code, 5)
}

if o.has_remind_user_about_email {
res << vproto.pack_bool_field(o.remind_user_about_email, 6)
}

return res
}

pub fn cmsgclientemailaddrinfo_unpack(buf []byte) ?CMsgClientEmailAddrInfo {
mut res := CMsgClientEmailAddrInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_email_address = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.email_address = v
i = ii
}

2 {
res.has_email_is_validated = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.email_is_validated = v
i = ii
}

3 {
res.has_email_validation_changed = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.email_validation_changed = v
i = ii
}

4 {
res.has_credential_change_requires_code = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.credential_change_requires_code = v
i = ii
}

5 {
res.has_password_or_secretqa_change_requires_code = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.password_or_secretqa_change_requires_code = v
i = ii
}

6 {
res.has_remind_user_about_email = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.remind_user_about_email = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientemailaddrinfo() CMsgClientEmailAddrInfo {
return CMsgClientEmailAddrInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientemailaddrinfo(o CMsgClientEmailAddrInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientemailaddrinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientEmailAddrInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientemailaddrinfo_unpack(v)?
return i, unpacked
}
pub struct CMsgCReitemVoteSummaryPublishedFileId {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
}
pub fn (o &CMsgCReitemVoteSummaryPublishedFileId) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

return res
}

pub fn cmsgcreitemvotesummarypublishedfileid_unpack(buf []byte) ?CMsgCReitemVoteSummaryPublishedFileId {
mut res := CMsgCReitemVoteSummaryPublishedFileId{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcreitemvotesummarypublishedfileid() CMsgCReitemVoteSummaryPublishedFileId {
return CMsgCReitemVoteSummaryPublishedFileId{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcreitemvotesummarypublishedfileid(o CMsgCReitemVoteSummaryPublishedFileId, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcreitemvotesummarypublishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCReitemVoteSummaryPublishedFileId) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgcreitemvotesummarypublishedfileid_unpack(v)?
return i, unpacked
}
pub struct CMsgCReitemVoteSummary {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_ids []CMsgCReitemVoteSummaryPublishedFileId
}
pub fn (o &CMsgCReitemVoteSummary) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.published_file_ids {
res << zzz_vproto_internal_pack_cmsgcreitemvotesummarypublishedfileid(x, 1)
}

return res
}

pub fn cmsgcreitemvotesummary_unpack(buf []byte) ?CMsgCReitemVoteSummary {
mut res := CMsgCReitemVoteSummary{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgcreitemvotesummarypublishedfileid(cur_buf, tag_wiretype.wire_type)?
res.published_file_ids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcreitemvotesummary() CMsgCReitemVoteSummary {
return CMsgCReitemVoteSummary{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcreitemvotesummary(o CMsgCReitemVoteSummary, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcreitemvotesummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCReitemVoteSummary) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgcreitemvotesummary_unpack(v)?
return i, unpacked
}
pub struct CMsgCReitemVoteSummaryResponseItemVoteSummary {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
votes_for int
has_votes_for bool
votes_against int
has_votes_against bool
reports int
has_reports bool
score f32
has_score bool
}
pub fn (o &CMsgCReitemVoteSummaryResponseItemVoteSummary) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_votes_for {
res << vproto.pack_int32_field(o.votes_for, 2)
}

if o.has_votes_against {
res << vproto.pack_int32_field(o.votes_against, 3)
}

if o.has_reports {
res << vproto.pack_int32_field(o.reports, 4)
}

if o.has_score {
res << vproto.pack_float_field(o.score, 5)
}

return res
}

pub fn cmsgcreitemvotesummaryresponseitemvotesummary_unpack(buf []byte) ?CMsgCReitemVoteSummaryResponseItemVoteSummary {
mut res := CMsgCReitemVoteSummaryResponseItemVoteSummary{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_votes_for = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.votes_for = v
i = ii
}

3 {
res.has_votes_against = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.votes_against = v
i = ii
}

4 {
res.has_reports = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.reports = v
i = ii
}

5 {
res.has_score = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.score = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcreitemvotesummaryresponseitemvotesummary() CMsgCReitemVoteSummaryResponseItemVoteSummary {
return CMsgCReitemVoteSummaryResponseItemVoteSummary{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcreitemvotesummaryresponseitemvotesummary(o CMsgCReitemVoteSummaryResponseItemVoteSummary, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcreitemvotesummaryresponseitemvotesummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCReitemVoteSummaryResponseItemVoteSummary) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgcreitemvotesummaryresponseitemvotesummary_unpack(v)?
return i, unpacked
}
pub struct CMsgCReitemVoteSummaryResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
item_vote_summaries []CMsgCReitemVoteSummaryResponseItemVoteSummary
}
pub fn (o &CMsgCReitemVoteSummaryResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

// [packed=false]
for _, x in o.item_vote_summaries {
res << zzz_vproto_internal_pack_cmsgcreitemvotesummaryresponseitemvotesummary(x, 2)
}

return res
}

pub fn cmsgcreitemvotesummaryresponse_unpack(buf []byte) ?CMsgCReitemVoteSummaryResponse {
mut res := CMsgCReitemVoteSummaryResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgcreitemvotesummaryresponseitemvotesummary(cur_buf, tag_wiretype.wire_type)?
res.item_vote_summaries << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcreitemvotesummaryresponse() CMsgCReitemVoteSummaryResponse {
return CMsgCReitemVoteSummaryResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcreitemvotesummaryresponse(o CMsgCReitemVoteSummaryResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcreitemvotesummaryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCReitemVoteSummaryResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgcreitemvotesummaryresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgCReupdateUserPublishedItemVote {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
vote_up bool
has_vote_up bool
}
pub fn (o &CMsgCReupdateUserPublishedItemVote) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_vote_up {
res << vproto.pack_bool_field(o.vote_up, 2)
}

return res
}

pub fn cmsgcreupdateuserpublisheditemvote_unpack(buf []byte) ?CMsgCReupdateUserPublishedItemVote {
mut res := CMsgCReupdateUserPublishedItemVote{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_vote_up = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.vote_up = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcreupdateuserpublisheditemvote() CMsgCReupdateUserPublishedItemVote {
return CMsgCReupdateUserPublishedItemVote{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcreupdateuserpublisheditemvote(o CMsgCReupdateUserPublishedItemVote, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcreupdateuserpublisheditemvote(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCReupdateUserPublishedItemVote) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgcreupdateuserpublisheditemvote_unpack(v)?
return i, unpacked
}
pub struct CMsgCReupdateUserPublishedItemVoteResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
}
pub fn (o &CMsgCReupdateUserPublishedItemVoteResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

return res
}

pub fn cmsgcreupdateuserpublisheditemvoteresponse_unpack(buf []byte) ?CMsgCReupdateUserPublishedItemVoteResponse {
mut res := CMsgCReupdateUserPublishedItemVoteResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcreupdateuserpublisheditemvoteresponse() CMsgCReupdateUserPublishedItemVoteResponse {
return CMsgCReupdateUserPublishedItemVoteResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcreupdateuserpublisheditemvoteresponse(o CMsgCReupdateUserPublishedItemVoteResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcreupdateuserpublisheditemvoteresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCReupdateUserPublishedItemVoteResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgcreupdateuserpublisheditemvoteresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgCRegetUserPublishedItemVoteDetailsPublishedFileId {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
}
pub fn (o &CMsgCRegetUserPublishedItemVoteDetailsPublishedFileId) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

return res
}

pub fn cmsgcregetuserpublisheditemvotedetailspublishedfileid_unpack(buf []byte) ?CMsgCRegetUserPublishedItemVoteDetailsPublishedFileId {
mut res := CMsgCRegetUserPublishedItemVoteDetailsPublishedFileId{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcregetuserpublisheditemvotedetailspublishedfileid() CMsgCRegetUserPublishedItemVoteDetailsPublishedFileId {
return CMsgCRegetUserPublishedItemVoteDetailsPublishedFileId{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcregetuserpublisheditemvotedetailspublishedfileid(o CMsgCRegetUserPublishedItemVoteDetailsPublishedFileId, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcregetuserpublisheditemvotedetailspublishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCRegetUserPublishedItemVoteDetailsPublishedFileId) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgcregetuserpublisheditemvotedetailspublishedfileid_unpack(v)?
return i, unpacked
}
pub struct CMsgCRegetUserPublishedItemVoteDetails {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_ids []CMsgCRegetUserPublishedItemVoteDetailsPublishedFileId
}
pub fn (o &CMsgCRegetUserPublishedItemVoteDetails) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.published_file_ids {
res << zzz_vproto_internal_pack_cmsgcregetuserpublisheditemvotedetailspublishedfileid(x, 1)
}

return res
}

pub fn cmsgcregetuserpublisheditemvotedetails_unpack(buf []byte) ?CMsgCRegetUserPublishedItemVoteDetails {
mut res := CMsgCRegetUserPublishedItemVoteDetails{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgcregetuserpublisheditemvotedetailspublishedfileid(cur_buf, tag_wiretype.wire_type)?
res.published_file_ids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcregetuserpublisheditemvotedetails() CMsgCRegetUserPublishedItemVoteDetails {
return CMsgCRegetUserPublishedItemVoteDetails{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcregetuserpublisheditemvotedetails(o CMsgCRegetUserPublishedItemVoteDetails, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcregetuserpublisheditemvotedetails(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCRegetUserPublishedItemVoteDetails) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgcregetuserpublisheditemvotedetails_unpack(v)?
return i, unpacked
}
pub struct CMsgCRegetUserPublishedItemVoteDetailsResponseUserItemVoteDetail {
mut:
unknown_fields []vproto.UnknownField
pub mut:
published_file_id u64
has_published_file_id bool
vote int
has_vote bool
}
pub fn (o &CMsgCRegetUserPublishedItemVoteDetailsResponseUserItemVoteDetail) pack() []byte {
mut res := []byte{}
if o.has_published_file_id {
res << vproto.pack_64bit_field(o.published_file_id, 1)
}

if o.has_vote {
res << vproto.pack_int32_field(o.vote, 2)
}

return res
}

pub fn cmsgcregetuserpublisheditemvotedetailsresponseuseritemvotedetail_unpack(buf []byte) ?CMsgCRegetUserPublishedItemVoteDetailsResponseUserItemVoteDetail {
mut res := CMsgCRegetUserPublishedItemVoteDetailsResponseUserItemVoteDetail{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_published_file_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.published_file_id = v
i = ii
}

2 {
res.has_vote = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.vote = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcregetuserpublisheditemvotedetailsresponseuseritemvotedetail() CMsgCRegetUserPublishedItemVoteDetailsResponseUserItemVoteDetail {
return CMsgCRegetUserPublishedItemVoteDetailsResponseUserItemVoteDetail{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcregetuserpublisheditemvotedetailsresponseuseritemvotedetail(o CMsgCRegetUserPublishedItemVoteDetailsResponseUserItemVoteDetail, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcregetuserpublisheditemvotedetailsresponseuseritemvotedetail(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCRegetUserPublishedItemVoteDetailsResponseUserItemVoteDetail) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgcregetuserpublisheditemvotedetailsresponseuseritemvotedetail_unpack(v)?
return i, unpacked
}
pub struct CMsgCRegetUserPublishedItemVoteDetailsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
user_item_vote_details []CMsgCRegetUserPublishedItemVoteDetailsResponseUserItemVoteDetail
}
pub fn (o &CMsgCRegetUserPublishedItemVoteDetailsResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

// [packed=false]
for _, x in o.user_item_vote_details {
res << zzz_vproto_internal_pack_cmsgcregetuserpublisheditemvotedetailsresponseuseritemvotedetail(x, 2)
}

return res
}

pub fn cmsgcregetuserpublisheditemvotedetailsresponse_unpack(buf []byte) ?CMsgCRegetUserPublishedItemVoteDetailsResponse {
mut res := CMsgCRegetUserPublishedItemVoteDetailsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgcregetuserpublisheditemvotedetailsresponseuseritemvotedetail(cur_buf, tag_wiretype.wire_type)?
res.user_item_vote_details << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcregetuserpublisheditemvotedetailsresponse() CMsgCRegetUserPublishedItemVoteDetailsResponse {
return CMsgCRegetUserPublishedItemVoteDetailsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcregetuserpublisheditemvotedetailsresponse(o CMsgCRegetUserPublishedItemVoteDetailsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcregetuserpublisheditemvotedetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCRegetUserPublishedItemVoteDetailsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgcregetuserpublisheditemvotedetailsresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgGameServerPingSampleSample {
mut:
unknown_fields []vproto.UnknownField
pub mut:
ip u32
has_ip bool
avg_ping_ms u32
has_avg_ping_ms bool
stddev_ping_ms_x10 u32
has_stddev_ping_ms_x10 bool
}
pub fn (o &CMsgGameServerPingSampleSample) pack() []byte {
mut res := []byte{}
if o.has_ip {
res << vproto.pack_32bit_field(o.ip, 1)
}

if o.has_avg_ping_ms {
res << vproto.pack_uint32_field(o.avg_ping_ms, 2)
}

if o.has_stddev_ping_ms_x10 {
res << vproto.pack_uint32_field(o.stddev_ping_ms_x10, 3)
}

return res
}

pub fn cmsggameserverpingsamplesample_unpack(buf []byte) ?CMsgGameServerPingSampleSample {
mut res := CMsgGameServerPingSampleSample{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_ip = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.ip = v
i = ii
}

2 {
res.has_avg_ping_ms = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.avg_ping_ms = v
i = ii
}

3 {
res.has_stddev_ping_ms_x10 = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.stddev_ping_ms_x10 = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameserverpingsamplesample() CMsgGameServerPingSampleSample {
return CMsgGameServerPingSampleSample{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameserverpingsamplesample(o CMsgGameServerPingSampleSample, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameserverpingsamplesample(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameServerPingSampleSample) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggameserverpingsamplesample_unpack(v)?
return i, unpacked
}
pub struct CMsgGameServerPingSample {
mut:
unknown_fields []vproto.UnknownField
pub mut:
my_ip u32
has_my_ip bool
gs_app_id int
has_gs_app_id bool
gs_samples []CMsgGameServerPingSampleSample
}
pub fn (o &CMsgGameServerPingSample) pack() []byte {
mut res := []byte{}
if o.has_my_ip {
res << vproto.pack_32bit_field(o.my_ip, 1)
}

if o.has_gs_app_id {
res << vproto.pack_int32_field(o.gs_app_id, 2)
}

// [packed=false]
for _, x in o.gs_samples {
res << zzz_vproto_internal_pack_cmsggameserverpingsamplesample(x, 3)
}

return res
}

pub fn cmsggameserverpingsample_unpack(buf []byte) ?CMsgGameServerPingSample {
mut res := CMsgGameServerPingSample{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_my_ip = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.my_ip = v
i = ii
}

2 {
res.has_gs_app_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.gs_app_id = v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsggameserverpingsamplesample(cur_buf, tag_wiretype.wire_type)?
res.gs_samples << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameserverpingsample() CMsgGameServerPingSample {
return CMsgGameServerPingSample{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameserverpingsample(o CMsgGameServerPingSample, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameserverpingsample(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameServerPingSample) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsggameserverpingsample_unpack(v)?
return i, unpacked
}
pub struct CMsgFSgetFollowerCount {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
}
pub fn (o &CMsgFSgetFollowerCount) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

return res
}

pub fn cmsgfsgetfollowercount_unpack(buf []byte) ?CMsgFSgetFollowerCount {
mut res := CMsgFSgetFollowerCount{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfsgetfollowercount() CMsgFSgetFollowerCount {
return CMsgFSgetFollowerCount{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfsgetfollowercount(o CMsgFSgetFollowerCount, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfsgetfollowercount(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFSgetFollowerCount) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgfsgetfollowercount_unpack(v)?
return i, unpacked
}
pub struct CMsgFSgetFollowerCountResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
count int
has_count bool
}
pub fn (o &CMsgFSgetFollowerCountResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_count {
res << vproto.pack_int32_field(o.count, 2)
}

return res
}

pub fn cmsgfsgetfollowercountresponse_unpack(buf []byte) ?CMsgFSgetFollowerCountResponse {
mut res := CMsgFSgetFollowerCountResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_count = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.count = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfsgetfollowercountresponse() CMsgFSgetFollowerCountResponse {
return CMsgFSgetFollowerCountResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfsgetfollowercountresponse(o CMsgFSgetFollowerCountResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfsgetfollowercountresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFSgetFollowerCountResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgfsgetfollowercountresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgFSgetIsFollowing {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steam_id u64
has_steam_id bool
}
pub fn (o &CMsgFSgetIsFollowing) pack() []byte {
mut res := []byte{}
if o.has_steam_id {
res << vproto.pack_64bit_field(o.steam_id, 1)
}

return res
}

pub fn cmsgfsgetisfollowing_unpack(buf []byte) ?CMsgFSgetIsFollowing {
mut res := CMsgFSgetIsFollowing{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steam_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfsgetisfollowing() CMsgFSgetIsFollowing {
return CMsgFSgetIsFollowing{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfsgetisfollowing(o CMsgFSgetIsFollowing, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfsgetisfollowing(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFSgetIsFollowing) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgfsgetisfollowing_unpack(v)?
return i, unpacked
}
pub struct CMsgFSgetIsFollowingResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
is_following bool
has_is_following bool
}
pub fn (o &CMsgFSgetIsFollowingResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_is_following {
res << vproto.pack_bool_field(o.is_following, 2)
}

return res
}

pub fn cmsgfsgetisfollowingresponse_unpack(buf []byte) ?CMsgFSgetIsFollowingResponse {
mut res := CMsgFSgetIsFollowingResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_is_following = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_following = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfsgetisfollowingresponse() CMsgFSgetIsFollowingResponse {
return CMsgFSgetIsFollowingResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfsgetisfollowingresponse(o CMsgFSgetIsFollowingResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfsgetisfollowingresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFSgetIsFollowingResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgfsgetisfollowingresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgFSenumerateFollowingList {
mut:
unknown_fields []vproto.UnknownField
pub mut:
start_index u32
has_start_index bool
}
pub fn (o &CMsgFSenumerateFollowingList) pack() []byte {
mut res := []byte{}
if o.has_start_index {
res << vproto.pack_uint32_field(o.start_index, 1)
}

return res
}

pub fn cmsgfsenumeratefollowinglist_unpack(buf []byte) ?CMsgFSenumerateFollowingList {
mut res := CMsgFSenumerateFollowingList{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_start_index = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.start_index = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfsenumeratefollowinglist() CMsgFSenumerateFollowingList {
return CMsgFSenumerateFollowingList{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfsenumeratefollowinglist(o CMsgFSenumerateFollowingList, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfsenumeratefollowinglist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFSenumerateFollowingList) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgfsenumeratefollowinglist_unpack(v)?
return i, unpacked
}
pub struct CMsgFSenumerateFollowingListResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
total_results int
has_total_results bool
steam_ids []u64
}
pub fn (o &CMsgFSenumerateFollowingListResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_total_results {
res << vproto.pack_int32_field(o.total_results, 2)
}

// [packed=false]
for _, x in o.steam_ids {
res << vproto.pack_64bit_field(x, 3)
}

return res
}

pub fn cmsgfsenumeratefollowinglistresponse_unpack(buf []byte) ?CMsgFSenumerateFollowingListResponse {
mut res := CMsgFSenumerateFollowingListResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_total_results = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.total_results = v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steam_ids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfsenumeratefollowinglistresponse() CMsgFSenumerateFollowingListResponse {
return CMsgFSenumerateFollowingListResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfsenumeratefollowinglistresponse(o CMsgFSenumerateFollowingListResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfsenumeratefollowinglistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFSenumerateFollowingListResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgfsenumeratefollowinglistresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgDPgetNumberOfCurrentPlayers {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
}
pub fn (o &CMsgDPgetNumberOfCurrentPlayers) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

return res
}

pub fn cmsgdpgetnumberofcurrentplayers_unpack(buf []byte) ?CMsgDPgetNumberOfCurrentPlayers {
mut res := CMsgDPgetNumberOfCurrentPlayers{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdpgetnumberofcurrentplayers() CMsgDPgetNumberOfCurrentPlayers {
return CMsgDPgetNumberOfCurrentPlayers{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdpgetnumberofcurrentplayers(o CMsgDPgetNumberOfCurrentPlayers, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdpgetnumberofcurrentplayers(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDPgetNumberOfCurrentPlayers) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgdpgetnumberofcurrentplayers_unpack(v)?
return i, unpacked
}
pub struct CMsgDPgetNumberOfCurrentPlayersResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
player_count int
has_player_count bool
}
pub fn (o &CMsgDPgetNumberOfCurrentPlayersResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_player_count {
res << vproto.pack_int32_field(o.player_count, 2)
}

return res
}

pub fn cmsgdpgetnumberofcurrentplayersresponse_unpack(buf []byte) ?CMsgDPgetNumberOfCurrentPlayersResponse {
mut res := CMsgDPgetNumberOfCurrentPlayersResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_player_count = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.player_count = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdpgetnumberofcurrentplayersresponse() CMsgDPgetNumberOfCurrentPlayersResponse {
return CMsgDPgetNumberOfCurrentPlayersResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdpgetnumberofcurrentplayersresponse(o CMsgDPgetNumberOfCurrentPlayersResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdpgetnumberofcurrentplayersresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDPgetNumberOfCurrentPlayersResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgdpgetnumberofcurrentplayersresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientFriendUserStatusPublished {
mut:
unknown_fields []vproto.UnknownField
pub mut:
friend_steamid u64
has_friend_steamid bool
appid u32
has_appid bool
status_text string
has_status_text bool
}
pub fn (o &CMsgClientFriendUserStatusPublished) pack() []byte {
mut res := []byte{}
if o.has_friend_steamid {
res << vproto.pack_64bit_field(o.friend_steamid, 1)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 2)
}

if o.has_status_text {
res << vproto.pack_string_field(o.status_text, 3)
}

return res
}

pub fn cmsgclientfrienduserstatuspublished_unpack(buf []byte) ?CMsgClientFriendUserStatusPublished {
mut res := CMsgClientFriendUserStatusPublished{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_friend_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.friend_steamid = v
i = ii
}

2 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

3 {
res.has_status_text = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.status_text = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfrienduserstatuspublished() CMsgClientFriendUserStatusPublished {
return CMsgClientFriendUserStatusPublished{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfrienduserstatuspublished(o CMsgClientFriendUserStatusPublished, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfrienduserstatuspublished(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendUserStatusPublished) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientfrienduserstatuspublished_unpack(v)?
return i, unpacked
}
pub struct CMsgClientServiceMethodLegacy {
mut:
unknown_fields []vproto.UnknownField
pub mut:
method_name string
has_method_name bool
serialized_method []byte
has_serialized_method bool
is_notification bool
has_is_notification bool
}
pub fn (o &CMsgClientServiceMethodLegacy) pack() []byte {
mut res := []byte{}
if o.has_method_name {
res << vproto.pack_string_field(o.method_name, 1)
}

if o.has_serialized_method {
res << vproto.pack_bytes_field(o.serialized_method, 2)
}

if o.has_is_notification {
res << vproto.pack_bool_field(o.is_notification, 3)
}

return res
}

pub fn cmsgclientservicemethodlegacy_unpack(buf []byte) ?CMsgClientServiceMethodLegacy {
mut res := CMsgClientServiceMethodLegacy{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_method_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.method_name = v
i = ii
}

2 {
res.has_serialized_method = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.serialized_method = v
i = ii
}

3 {
res.has_is_notification = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_notification = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientservicemethodlegacy() CMsgClientServiceMethodLegacy {
return CMsgClientServiceMethodLegacy{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientservicemethodlegacy(o CMsgClientServiceMethodLegacy, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientservicemethodlegacy(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServiceMethodLegacy) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientservicemethodlegacy_unpack(v)?
return i, unpacked
}
pub struct CMsgClientServiceMethodLegacyResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
method_name string
has_method_name bool
serialized_method_response []byte
has_serialized_method_response bool
}
pub fn (o &CMsgClientServiceMethodLegacyResponse) pack() []byte {
mut res := []byte{}
if o.has_method_name {
res << vproto.pack_string_field(o.method_name, 1)
}

if o.has_serialized_method_response {
res << vproto.pack_bytes_field(o.serialized_method_response, 2)
}

return res
}

pub fn cmsgclientservicemethodlegacyresponse_unpack(buf []byte) ?CMsgClientServiceMethodLegacyResponse {
mut res := CMsgClientServiceMethodLegacyResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_method_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.method_name = v
i = ii
}

2 {
res.has_serialized_method_response = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.serialized_method_response = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientservicemethodlegacyresponse() CMsgClientServiceMethodLegacyResponse {
return CMsgClientServiceMethodLegacyResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientservicemethodlegacyresponse(o CMsgClientServiceMethodLegacyResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientservicemethodlegacyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServiceMethodLegacyResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientservicemethodlegacyresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUImode {
mut:
unknown_fields []vproto.UnknownField
pub mut:
uimode u32
has_uimode bool
chat_mode u32
has_chat_mode bool
}
pub fn (o &CMsgClientUImode) pack() []byte {
mut res := []byte{}
if o.has_uimode {
res << vproto.pack_uint32_field(o.uimode, 1)
}

if o.has_chat_mode {
res << vproto.pack_uint32_field(o.chat_mode, 2)
}

return res
}

pub fn cmsgclientuimode_unpack(buf []byte) ?CMsgClientUImode {
mut res := CMsgClientUImode{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_uimode = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.uimode = v
i = ii
}

2 {
res.has_chat_mode = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.chat_mode = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientuimode() CMsgClientUImode {
return CMsgClientUImode{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientuimode(o CMsgClientUImode, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientuimode(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUImode) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientuimode_unpack(v)?
return i, unpacked
}
pub struct CMsgClientVanityURlchangedNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
vanity_url string
has_vanity_url bool
}
pub fn (o &CMsgClientVanityURlchangedNotification) pack() []byte {
mut res := []byte{}
if o.has_vanity_url {
res << vproto.pack_string_field(o.vanity_url, 1)
}

return res
}

pub fn cmsgclientvanityurlchangednotification_unpack(buf []byte) ?CMsgClientVanityURlchangedNotification {
mut res := CMsgClientVanityURlchangedNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_vanity_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.vanity_url = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientvanityurlchangednotification() CMsgClientVanityURlchangedNotification {
return CMsgClientVanityURlchangedNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientvanityurlchangednotification(o CMsgClientVanityURlchangedNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientvanityurlchangednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientVanityURlchangedNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientvanityurlchangednotification_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAuthorizeLocalDeviceRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
device_description string
has_device_description bool
owner_account_id u32
has_owner_account_id bool
local_device_token u64
has_local_device_token bool
}
pub fn (o &CMsgClientAuthorizeLocalDeviceRequest) pack() []byte {
mut res := []byte{}
if o.has_device_description {
res << vproto.pack_string_field(o.device_description, 1)
}

if o.has_owner_account_id {
res << vproto.pack_uint32_field(o.owner_account_id, 2)
}

if o.has_local_device_token {
res << vproto.pack_uint64_field(o.local_device_token, 3)
}

return res
}

pub fn cmsgclientauthorizelocaldevicerequest_unpack(buf []byte) ?CMsgClientAuthorizeLocalDeviceRequest {
mut res := CMsgClientAuthorizeLocalDeviceRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_device_description = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.device_description = v
i = ii
}

2 {
res.has_owner_account_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.owner_account_id = v
i = ii
}

3 {
res.has_local_device_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.local_device_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientauthorizelocaldevicerequest() CMsgClientAuthorizeLocalDeviceRequest {
return CMsgClientAuthorizeLocalDeviceRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientauthorizelocaldevicerequest(o CMsgClientAuthorizeLocalDeviceRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientauthorizelocaldevicerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAuthorizeLocalDeviceRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientauthorizelocaldevicerequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAuthorizeLocalDevice {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
owner_account_id u32
has_owner_account_id bool
authed_device_token u64
has_authed_device_token bool
}
pub fn (o &CMsgClientAuthorizeLocalDevice) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_owner_account_id {
res << vproto.pack_uint32_field(o.owner_account_id, 2)
}

if o.has_authed_device_token {
res << vproto.pack_uint64_field(o.authed_device_token, 3)
}

return res
}

pub fn cmsgclientauthorizelocaldevice_unpack(buf []byte) ?CMsgClientAuthorizeLocalDevice {
mut res := CMsgClientAuthorizeLocalDevice{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_owner_account_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.owner_account_id = v
i = ii
}

3 {
res.has_authed_device_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.authed_device_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientauthorizelocaldevice() CMsgClientAuthorizeLocalDevice {
return CMsgClientAuthorizeLocalDevice{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientauthorizelocaldevice(o CMsgClientAuthorizeLocalDevice, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientauthorizelocaldevice(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAuthorizeLocalDevice) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientauthorizelocaldevice_unpack(v)?
return i, unpacked
}
pub struct CMsgClientAuthorizeLocalDeviceNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
owner_account_id u32
has_owner_account_id bool
local_device_token u64
has_local_device_token bool
}
pub fn (o &CMsgClientAuthorizeLocalDeviceNotification) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_owner_account_id {
res << vproto.pack_uint32_field(o.owner_account_id, 2)
}

if o.has_local_device_token {
res << vproto.pack_uint64_field(o.local_device_token, 3)
}

return res
}

pub fn cmsgclientauthorizelocaldevicenotification_unpack(buf []byte) ?CMsgClientAuthorizeLocalDeviceNotification {
mut res := CMsgClientAuthorizeLocalDeviceNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_owner_account_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.owner_account_id = v
i = ii
}

3 {
res.has_local_device_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.local_device_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientauthorizelocaldevicenotification() CMsgClientAuthorizeLocalDeviceNotification {
return CMsgClientAuthorizeLocalDeviceNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientauthorizelocaldevicenotification(o CMsgClientAuthorizeLocalDeviceNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientauthorizelocaldevicenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAuthorizeLocalDeviceNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientauthorizelocaldevicenotification_unpack(v)?
return i, unpacked
}
pub struct CMsgClientDeauthorizeDeviceRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
deauthorization_account_id u32
has_deauthorization_account_id bool
deauthorization_device_token u64
has_deauthorization_device_token bool
}
pub fn (o &CMsgClientDeauthorizeDeviceRequest) pack() []byte {
mut res := []byte{}
if o.has_deauthorization_account_id {
res << vproto.pack_uint32_field(o.deauthorization_account_id, 1)
}

if o.has_deauthorization_device_token {
res << vproto.pack_uint64_field(o.deauthorization_device_token, 2)
}

return res
}

pub fn cmsgclientdeauthorizedevicerequest_unpack(buf []byte) ?CMsgClientDeauthorizeDeviceRequest {
mut res := CMsgClientDeauthorizeDeviceRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_deauthorization_account_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deauthorization_account_id = v
i = ii
}

2 {
res.has_deauthorization_device_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.deauthorization_device_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdeauthorizedevicerequest() CMsgClientDeauthorizeDeviceRequest {
return CMsgClientDeauthorizeDeviceRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdeauthorizedevicerequest(o CMsgClientDeauthorizeDeviceRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdeauthorizedevicerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDeauthorizeDeviceRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientdeauthorizedevicerequest_unpack(v)?
return i, unpacked
}
pub struct CMsgClientDeauthorizeDevice {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
deauthorization_account_id u32
has_deauthorization_account_id bool
}
pub fn (o &CMsgClientDeauthorizeDevice) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_deauthorization_account_id {
res << vproto.pack_uint32_field(o.deauthorization_account_id, 2)
}

return res
}

pub fn cmsgclientdeauthorizedevice_unpack(buf []byte) ?CMsgClientDeauthorizeDevice {
mut res := CMsgClientDeauthorizeDevice{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_deauthorization_account_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deauthorization_account_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdeauthorizedevice() CMsgClientDeauthorizeDevice {
return CMsgClientDeauthorizeDevice{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdeauthorizedevice(o CMsgClientDeauthorizeDevice, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdeauthorizedevice(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDeauthorizeDevice) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientdeauthorizedevice_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUseLocalDeviceAuthorizationsDeviceToken {
mut:
unknown_fields []vproto.UnknownField
pub mut:
owner_account_id u32
has_owner_account_id bool
token_id u64
has_token_id bool
}
pub fn (o &CMsgClientUseLocalDeviceAuthorizationsDeviceToken) pack() []byte {
mut res := []byte{}
if o.has_owner_account_id {
res << vproto.pack_uint32_field(o.owner_account_id, 1)
}

if o.has_token_id {
res << vproto.pack_uint64_field(o.token_id, 2)
}

return res
}

pub fn cmsgclientuselocaldeviceauthorizationsdevicetoken_unpack(buf []byte) ?CMsgClientUseLocalDeviceAuthorizationsDeviceToken {
mut res := CMsgClientUseLocalDeviceAuthorizationsDeviceToken{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_owner_account_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.owner_account_id = v
i = ii
}

2 {
res.has_token_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.token_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientuselocaldeviceauthorizationsdevicetoken() CMsgClientUseLocalDeviceAuthorizationsDeviceToken {
return CMsgClientUseLocalDeviceAuthorizationsDeviceToken{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientuselocaldeviceauthorizationsdevicetoken(o CMsgClientUseLocalDeviceAuthorizationsDeviceToken, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientuselocaldeviceauthorizationsdevicetoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUseLocalDeviceAuthorizationsDeviceToken) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientuselocaldeviceauthorizationsdevicetoken_unpack(v)?
return i, unpacked
}
pub struct CMsgClientUseLocalDeviceAuthorizations {
mut:
unknown_fields []vproto.UnknownField
pub mut:
authorization_account_id []u32
device_tokens []CMsgClientUseLocalDeviceAuthorizationsDeviceToken
}
pub fn (o &CMsgClientUseLocalDeviceAuthorizations) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.authorization_account_id {
res << vproto.pack_uint32_field(x, 1)
}

// [packed=false]
for _, x in o.device_tokens {
res << zzz_vproto_internal_pack_cmsgclientuselocaldeviceauthorizationsdevicetoken(x, 2)
}

return res
}

pub fn cmsgclientuselocaldeviceauthorizations_unpack(buf []byte) ?CMsgClientUseLocalDeviceAuthorizations {
mut res := CMsgClientUseLocalDeviceAuthorizations{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.authorization_account_id << v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientuselocaldeviceauthorizationsdevicetoken(cur_buf, tag_wiretype.wire_type)?
res.device_tokens << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientuselocaldeviceauthorizations() CMsgClientUseLocalDeviceAuthorizations {
return CMsgClientUseLocalDeviceAuthorizations{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientuselocaldeviceauthorizations(o CMsgClientUseLocalDeviceAuthorizations, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientuselocaldeviceauthorizations(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUseLocalDeviceAuthorizations) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientuselocaldeviceauthorizations_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetAuthorizedDevices {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CMsgClientGetAuthorizedDevices) pack() []byte {
res := []byte{}
return res
}

pub fn cmsgclientgetauthorizeddevices_unpack(buf []byte) ?CMsgClientGetAuthorizedDevices {
res := CMsgClientGetAuthorizedDevices{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetauthorizeddevices() CMsgClientGetAuthorizedDevices {
return CMsgClientGetAuthorizedDevices{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetauthorizeddevices(o CMsgClientGetAuthorizedDevices, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetauthorizeddevices(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetAuthorizedDevices) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetauthorizeddevices_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetAuthorizedDevicesResponseAuthorizedDevice {
mut:
unknown_fields []vproto.UnknownField
pub mut:
auth_device_token u64
has_auth_device_token bool
device_name string
has_device_name bool
last_access_time u32
has_last_access_time bool
borrower_id u32
has_borrower_id bool
is_pending bool
has_is_pending bool
app_played u32
has_app_played bool
}
pub fn (o &CMsgClientGetAuthorizedDevicesResponseAuthorizedDevice) pack() []byte {
mut res := []byte{}
if o.has_auth_device_token {
res << vproto.pack_uint64_field(o.auth_device_token, 1)
}

if o.has_device_name {
res << vproto.pack_string_field(o.device_name, 2)
}

if o.has_last_access_time {
res << vproto.pack_uint32_field(o.last_access_time, 3)
}

if o.has_borrower_id {
res << vproto.pack_uint32_field(o.borrower_id, 4)
}

if o.has_is_pending {
res << vproto.pack_bool_field(o.is_pending, 5)
}

if o.has_app_played {
res << vproto.pack_uint32_field(o.app_played, 6)
}

return res
}

pub fn cmsgclientgetauthorizeddevicesresponseauthorizeddevice_unpack(buf []byte) ?CMsgClientGetAuthorizedDevicesResponseAuthorizedDevice {
mut res := CMsgClientGetAuthorizedDevicesResponseAuthorizedDevice{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_auth_device_token = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.auth_device_token = v
i = ii
}

2 {
res.has_device_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.device_name = v
i = ii
}

3 {
res.has_last_access_time = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_access_time = v
i = ii
}

4 {
res.has_borrower_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.borrower_id = v
i = ii
}

5 {
res.has_is_pending = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_pending = v
i = ii
}

6 {
res.has_app_played = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_played = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetauthorizeddevicesresponseauthorizeddevice() CMsgClientGetAuthorizedDevicesResponseAuthorizedDevice {
return CMsgClientGetAuthorizedDevicesResponseAuthorizedDevice{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetauthorizeddevicesresponseauthorizeddevice(o CMsgClientGetAuthorizedDevicesResponseAuthorizedDevice, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetauthorizeddevicesresponseauthorizeddevice(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetAuthorizedDevicesResponseAuthorizedDevice) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetauthorizeddevicesresponseauthorizeddevice_unpack(v)?
return i, unpacked
}
pub struct CMsgClientGetAuthorizedDevicesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
authorized_device []CMsgClientGetAuthorizedDevicesResponseAuthorizedDevice
}
pub fn (o &CMsgClientGetAuthorizedDevicesResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

// [packed=false]
for _, x in o.authorized_device {
res << zzz_vproto_internal_pack_cmsgclientgetauthorizeddevicesresponseauthorizeddevice(x, 2)
}

return res
}

pub fn cmsgclientgetauthorizeddevicesresponse_unpack(buf []byte) ?CMsgClientGetAuthorizedDevicesResponse {
mut res := CMsgClientGetAuthorizedDevicesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientgetauthorizeddevicesresponseauthorizeddevice(cur_buf, tag_wiretype.wire_type)?
res.authorized_device << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetauthorizeddevicesresponse() CMsgClientGetAuthorizedDevicesResponse {
return CMsgClientGetAuthorizedDevicesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetauthorizeddevicesresponse(o CMsgClientGetAuthorizedDevicesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetauthorizeddevicesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetAuthorizedDevicesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientgetauthorizeddevicesresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientSharedLibraryLockStatusLockedLibrary {
mut:
unknown_fields []vproto.UnknownField
pub mut:
owner_id u32
has_owner_id bool
locked_by u32
has_locked_by bool
}
pub fn (o &CMsgClientSharedLibraryLockStatusLockedLibrary) pack() []byte {
mut res := []byte{}
if o.has_owner_id {
res << vproto.pack_uint32_field(o.owner_id, 1)
}

if o.has_locked_by {
res << vproto.pack_uint32_field(o.locked_by, 2)
}

return res
}

pub fn cmsgclientsharedlibrarylockstatuslockedlibrary_unpack(buf []byte) ?CMsgClientSharedLibraryLockStatusLockedLibrary {
mut res := CMsgClientSharedLibraryLockStatusLockedLibrary{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_owner_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.owner_id = v
i = ii
}

2 {
res.has_locked_by = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.locked_by = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsharedlibrarylockstatuslockedlibrary() CMsgClientSharedLibraryLockStatusLockedLibrary {
return CMsgClientSharedLibraryLockStatusLockedLibrary{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsharedlibrarylockstatuslockedlibrary(o CMsgClientSharedLibraryLockStatusLockedLibrary, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsharedlibrarylockstatuslockedlibrary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSharedLibraryLockStatusLockedLibrary) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientsharedlibrarylockstatuslockedlibrary_unpack(v)?
return i, unpacked
}
pub struct CMsgClientSharedLibraryLockStatus {
mut:
unknown_fields []vproto.UnknownField
pub mut:
locked_library []CMsgClientSharedLibraryLockStatusLockedLibrary
own_library_locked_by u32
has_own_library_locked_by bool
}
pub fn (o &CMsgClientSharedLibraryLockStatus) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.locked_library {
res << zzz_vproto_internal_pack_cmsgclientsharedlibrarylockstatuslockedlibrary(x, 1)
}

if o.has_own_library_locked_by {
res << vproto.pack_uint32_field(o.own_library_locked_by, 2)
}

return res
}

pub fn cmsgclientsharedlibrarylockstatus_unpack(buf []byte) ?CMsgClientSharedLibraryLockStatus {
mut res := CMsgClientSharedLibraryLockStatus{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientsharedlibrarylockstatuslockedlibrary(cur_buf, tag_wiretype.wire_type)?
res.locked_library << v
i = ii
}

2 {
res.has_own_library_locked_by = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.own_library_locked_by = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsharedlibrarylockstatus() CMsgClientSharedLibraryLockStatus {
return CMsgClientSharedLibraryLockStatus{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsharedlibrarylockstatus(o CMsgClientSharedLibraryLockStatus, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsharedlibrarylockstatus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSharedLibraryLockStatus) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientsharedlibrarylockstatus_unpack(v)?
return i, unpacked
}
pub struct CMsgClientSharedLibraryStopPlayingStopApp {
mut:
unknown_fields []vproto.UnknownField
pub mut:
app_id u32
has_app_id bool
owner_id u32
has_owner_id bool
}
pub fn (o &CMsgClientSharedLibraryStopPlayingStopApp) pack() []byte {
mut res := []byte{}
if o.has_app_id {
res << vproto.pack_uint32_field(o.app_id, 1)
}

if o.has_owner_id {
res << vproto.pack_uint32_field(o.owner_id, 2)
}

return res
}

pub fn cmsgclientsharedlibrarystopplayingstopapp_unpack(buf []byte) ?CMsgClientSharedLibraryStopPlayingStopApp {
mut res := CMsgClientSharedLibraryStopPlayingStopApp{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_app_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.app_id = v
i = ii
}

2 {
res.has_owner_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.owner_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsharedlibrarystopplayingstopapp() CMsgClientSharedLibraryStopPlayingStopApp {
return CMsgClientSharedLibraryStopPlayingStopApp{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsharedlibrarystopplayingstopapp(o CMsgClientSharedLibraryStopPlayingStopApp, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsharedlibrarystopplayingstopapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSharedLibraryStopPlayingStopApp) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientsharedlibrarystopplayingstopapp_unpack(v)?
return i, unpacked
}
pub struct CMsgClientSharedLibraryStopPlaying {
mut:
unknown_fields []vproto.UnknownField
pub mut:
seconds_left int
has_seconds_left bool
stop_apps []CMsgClientSharedLibraryStopPlayingStopApp
}
pub fn (o &CMsgClientSharedLibraryStopPlaying) pack() []byte {
mut res := []byte{}
if o.has_seconds_left {
res << vproto.pack_int32_field(o.seconds_left, 1)
}

// [packed=false]
for _, x in o.stop_apps {
res << zzz_vproto_internal_pack_cmsgclientsharedlibrarystopplayingstopapp(x, 2)
}

return res
}

pub fn cmsgclientsharedlibrarystopplaying_unpack(buf []byte) ?CMsgClientSharedLibraryStopPlaying {
mut res := CMsgClientSharedLibraryStopPlaying{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_seconds_left = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_left = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cmsgclientsharedlibrarystopplayingstopapp(cur_buf, tag_wiretype.wire_type)?
res.stop_apps << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsharedlibrarystopplaying() CMsgClientSharedLibraryStopPlaying {
return CMsgClientSharedLibraryStopPlaying{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsharedlibrarystopplaying(o CMsgClientSharedLibraryStopPlaying, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsharedlibrarystopplaying(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSharedLibraryStopPlaying) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientsharedlibrarystopplaying_unpack(v)?
return i, unpacked
}
pub struct CMsgClientServiceCall {
mut:
unknown_fields []vproto.UnknownField
pub mut:
sysid_routing []byte
has_sysid_routing bool
call_handle u32
has_call_handle bool
module_crc u32
has_module_crc bool
module_hash []byte
has_module_hash bool
function_id u32
has_function_id bool
cub_output_max u32
has_cub_output_max bool
flags u32
has_flags bool
callparameter []byte
has_callparameter bool
ping_only bool
has_ping_only bool
max_outstanding_calls u32
has_max_outstanding_calls bool
}
pub fn (o &CMsgClientServiceCall) pack() []byte {
mut res := []byte{}
if o.has_sysid_routing {
res << vproto.pack_bytes_field(o.sysid_routing, 1)
}

if o.has_call_handle {
res << vproto.pack_uint32_field(o.call_handle, 2)
}

if o.has_module_crc {
res << vproto.pack_uint32_field(o.module_crc, 3)
}

if o.has_module_hash {
res << vproto.pack_bytes_field(o.module_hash, 4)
}

if o.has_function_id {
res << vproto.pack_uint32_field(o.function_id, 5)
}

if o.has_cub_output_max {
res << vproto.pack_uint32_field(o.cub_output_max, 6)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 7)
}

if o.has_callparameter {
res << vproto.pack_bytes_field(o.callparameter, 8)
}

if o.has_ping_only {
res << vproto.pack_bool_field(o.ping_only, 9)
}

if o.has_max_outstanding_calls {
res << vproto.pack_uint32_field(o.max_outstanding_calls, 10)
}

return res
}

pub fn cmsgclientservicecall_unpack(buf []byte) ?CMsgClientServiceCall {
mut res := CMsgClientServiceCall{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_sysid_routing = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sysid_routing = v
i = ii
}

2 {
res.has_call_handle = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.call_handle = v
i = ii
}

3 {
res.has_module_crc = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.module_crc = v
i = ii
}

4 {
res.has_module_hash = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.module_hash = v
i = ii
}

5 {
res.has_function_id = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.function_id = v
i = ii
}

6 {
res.has_cub_output_max = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cub_output_max = v
i = ii
}

7 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

8 {
res.has_callparameter = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.callparameter = v
i = ii
}

9 {
res.has_ping_only = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.ping_only = v
i = ii
}

10 {
res.has_max_outstanding_calls = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.max_outstanding_calls = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientservicecall() CMsgClientServiceCall {
return CMsgClientServiceCall{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientservicecall(o CMsgClientServiceCall, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientservicecall(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServiceCall) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientservicecall_unpack(v)?
return i, unpacked
}
pub struct CMsgClientServiceModule {
mut:
unknown_fields []vproto.UnknownField
pub mut:
module_crc u32
has_module_crc bool
module_hash []byte
has_module_hash bool
module_content []byte
has_module_content bool
}
pub fn (o &CMsgClientServiceModule) pack() []byte {
mut res := []byte{}
if o.has_module_crc {
res << vproto.pack_uint32_field(o.module_crc, 1)
}

if o.has_module_hash {
res << vproto.pack_bytes_field(o.module_hash, 2)
}

if o.has_module_content {
res << vproto.pack_bytes_field(o.module_content, 3)
}

return res
}

pub fn cmsgclientservicemodule_unpack(buf []byte) ?CMsgClientServiceModule {
mut res := CMsgClientServiceModule{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_module_crc = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.module_crc = v
i = ii
}

2 {
res.has_module_hash = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.module_hash = v
i = ii
}

3 {
res.has_module_content = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.module_content = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientservicemodule() CMsgClientServiceModule {
return CMsgClientServiceModule{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientservicemodule(o CMsgClientServiceModule, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientservicemodule(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServiceModule) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientservicemodule_unpack(v)?
return i, unpacked
}
pub struct CMsgClientServiceCallResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
sysid_routing []byte
has_sysid_routing bool
call_handle u32
has_call_handle bool
module_crc u32
has_module_crc bool
module_hash []byte
has_module_hash bool
ecallresult u32
has_ecallresult bool
result_content []byte
has_result_content bool
os_version_info []byte
has_os_version_info bool
system_info []byte
has_system_info bool
load_address u64
has_load_address bool
exception_record []byte
has_exception_record bool
portable_os_version_info []byte
has_portable_os_version_info bool
portable_system_info []byte
has_portable_system_info bool
was_converted bool
has_was_converted bool
internal_result u32
has_internal_result bool
current_count u32
has_current_count bool
last_call_handle u32
has_last_call_handle bool
last_call_module_crc u32
has_last_call_module_crc bool
last_call_sysid_routing []byte
has_last_call_sysid_routing bool
last_ecallresult u32
has_last_ecallresult bool
last_callissue_delta u32
has_last_callissue_delta bool
last_callcomplete_delta u32
has_last_callcomplete_delta bool
}
pub fn (o &CMsgClientServiceCallResponse) pack() []byte {
mut res := []byte{}
if o.has_sysid_routing {
res << vproto.pack_bytes_field(o.sysid_routing, 1)
}

if o.has_call_handle {
res << vproto.pack_uint32_field(o.call_handle, 2)
}

if o.has_module_crc {
res << vproto.pack_uint32_field(o.module_crc, 3)
}

if o.has_module_hash {
res << vproto.pack_bytes_field(o.module_hash, 4)
}

if o.has_ecallresult {
res << vproto.pack_uint32_field(o.ecallresult, 5)
}

if o.has_result_content {
res << vproto.pack_bytes_field(o.result_content, 6)
}

if o.has_os_version_info {
res << vproto.pack_bytes_field(o.os_version_info, 7)
}

if o.has_system_info {
res << vproto.pack_bytes_field(o.system_info, 8)
}

if o.has_load_address {
res << vproto.pack_64bit_field(o.load_address, 9)
}

if o.has_exception_record {
res << vproto.pack_bytes_field(o.exception_record, 10)
}

if o.has_portable_os_version_info {
res << vproto.pack_bytes_field(o.portable_os_version_info, 11)
}

if o.has_portable_system_info {
res << vproto.pack_bytes_field(o.portable_system_info, 12)
}

if o.has_was_converted {
res << vproto.pack_bool_field(o.was_converted, 13)
}

if o.has_internal_result {
res << vproto.pack_uint32_field(o.internal_result, 14)
}

if o.has_current_count {
res << vproto.pack_uint32_field(o.current_count, 15)
}

if o.has_last_call_handle {
res << vproto.pack_uint32_field(o.last_call_handle, 16)
}

if o.has_last_call_module_crc {
res << vproto.pack_uint32_field(o.last_call_module_crc, 17)
}

if o.has_last_call_sysid_routing {
res << vproto.pack_bytes_field(o.last_call_sysid_routing, 18)
}

if o.has_last_ecallresult {
res << vproto.pack_uint32_field(o.last_ecallresult, 19)
}

if o.has_last_callissue_delta {
res << vproto.pack_uint32_field(o.last_callissue_delta, 20)
}

if o.has_last_callcomplete_delta {
res << vproto.pack_uint32_field(o.last_callcomplete_delta, 21)
}

return res
}

pub fn cmsgclientservicecallresponse_unpack(buf []byte) ?CMsgClientServiceCallResponse {
mut res := CMsgClientServiceCallResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_sysid_routing = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.sysid_routing = v
i = ii
}

2 {
res.has_call_handle = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.call_handle = v
i = ii
}

3 {
res.has_module_crc = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.module_crc = v
i = ii
}

4 {
res.has_module_hash = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.module_hash = v
i = ii
}

5 {
res.has_ecallresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ecallresult = v
i = ii
}

6 {
res.has_result_content = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.result_content = v
i = ii
}

7 {
res.has_os_version_info = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.os_version_info = v
i = ii
}

8 {
res.has_system_info = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.system_info = v
i = ii
}

9 {
res.has_load_address = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.load_address = v
i = ii
}

10 {
res.has_exception_record = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.exception_record = v
i = ii
}

11 {
res.has_portable_os_version_info = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.portable_os_version_info = v
i = ii
}

12 {
res.has_portable_system_info = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.portable_system_info = v
i = ii
}

13 {
res.has_was_converted = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.was_converted = v
i = ii
}

14 {
res.has_internal_result = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.internal_result = v
i = ii
}

15 {
res.has_current_count = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.current_count = v
i = ii
}

16 {
res.has_last_call_handle = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_call_handle = v
i = ii
}

17 {
res.has_last_call_module_crc = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_call_module_crc = v
i = ii
}

18 {
res.has_last_call_sysid_routing = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.last_call_sysid_routing = v
i = ii
}

19 {
res.has_last_ecallresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_ecallresult = v
i = ii
}

20 {
res.has_last_callissue_delta = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_callissue_delta = v
i = ii
}

21 {
res.has_last_callcomplete_delta = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_callcomplete_delta = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientservicecallresponse() CMsgClientServiceCallResponse {
return CMsgClientServiceCallResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientservicecallresponse(o CMsgClientServiceCallResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientservicecallresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServiceCallResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientservicecallresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgAMunlockStreaming {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CMsgAMunlockStreaming) pack() []byte {
res := []byte{}
return res
}

pub fn cmsgamunlockstreaming_unpack(buf []byte) ?CMsgAMunlockStreaming {
res := CMsgAMunlockStreaming{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgamunlockstreaming() CMsgAMunlockStreaming {
return CMsgAMunlockStreaming{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgamunlockstreaming(o CMsgAMunlockStreaming, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgamunlockstreaming(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAMunlockStreaming) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgamunlockstreaming_unpack(v)?
return i, unpacked
}
pub struct CMsgAMunlockStreamingResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
encryption_key []byte
has_encryption_key bool
}
pub fn (o &CMsgAMunlockStreamingResponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

if o.has_encryption_key {
res << vproto.pack_bytes_field(o.encryption_key, 2)
}

return res
}

pub fn cmsgamunlockstreamingresponse_unpack(buf []byte) ?CMsgAMunlockStreamingResponse {
mut res := CMsgAMunlockStreamingResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

2 {
res.has_encryption_key = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.encryption_key = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgamunlockstreamingresponse() CMsgAMunlockStreamingResponse {
return CMsgAMunlockStreamingResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgamunlockstreamingresponse(o CMsgAMunlockStreamingResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgamunlockstreamingresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAMunlockStreamingResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgamunlockstreamingresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgAMunlockHEvc {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CMsgAMunlockHEvc) pack() []byte {
res := []byte{}
return res
}

pub fn cmsgamunlockhevc_unpack(buf []byte) ?CMsgAMunlockHEvc {
res := CMsgAMunlockHEvc{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgamunlockhevc() CMsgAMunlockHEvc {
return CMsgAMunlockHEvc{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgamunlockhevc(o CMsgAMunlockHEvc, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgamunlockhevc(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAMunlockHEvc) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgamunlockhevc_unpack(v)?
return i, unpacked
}
pub struct CMsgAMunlockHEvcresponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
eresult int
has_eresult bool
}
pub fn (o &CMsgAMunlockHEvcresponse) pack() []byte {
mut res := []byte{}
if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 1)
}

return res
}

pub fn cmsgamunlockhevcresponse_unpack(buf []byte) ?CMsgAMunlockHEvcresponse {
mut res := CMsgAMunlockHEvcresponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgamunlockhevcresponse() CMsgAMunlockHEvcresponse {
return CMsgAMunlockHEvcresponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgamunlockhevcresponse(o CMsgAMunlockHEvcresponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgamunlockhevcresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAMunlockHEvcresponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgamunlockhevcresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgClientPlayingSessionState {
mut:
unknown_fields []vproto.UnknownField
pub mut:
playing_blocked bool
has_playing_blocked bool
playing_app u32
has_playing_app bool
}
pub fn (o &CMsgClientPlayingSessionState) pack() []byte {
mut res := []byte{}
if o.has_playing_blocked {
res << vproto.pack_bool_field(o.playing_blocked, 2)
}

if o.has_playing_app {
res << vproto.pack_uint32_field(o.playing_app, 3)
}

return res
}

pub fn cmsgclientplayingsessionstate_unpack(buf []byte) ?CMsgClientPlayingSessionState {
mut res := CMsgClientPlayingSessionState{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
2 {
res.has_playing_blocked = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.playing_blocked = v
i = ii
}

3 {
res.has_playing_app = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.playing_app = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientplayingsessionstate() CMsgClientPlayingSessionState {
return CMsgClientPlayingSessionState{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientplayingsessionstate(o CMsgClientPlayingSessionState, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientplayingsessionstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPlayingSessionState) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientplayingsessionstate_unpack(v)?
return i, unpacked
}
pub struct CMsgClientKickPlayingSession {
mut:
unknown_fields []vproto.UnknownField
pub mut:
only_stop_game bool
has_only_stop_game bool
}
pub fn (o &CMsgClientKickPlayingSession) pack() []byte {
mut res := []byte{}
if o.has_only_stop_game {
res << vproto.pack_bool_field(o.only_stop_game, 1)
}

return res
}

pub fn cmsgclientkickplayingsession_unpack(buf []byte) ?CMsgClientKickPlayingSession {
mut res := CMsgClientKickPlayingSession{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_only_stop_game = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.only_stop_game = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientkickplayingsession() CMsgClientKickPlayingSession {
return CMsgClientKickPlayingSession{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientkickplayingsession(o CMsgClientKickPlayingSession, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientkickplayingsession(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientKickPlayingSession) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientkickplayingsession_unpack(v)?
return i, unpacked
}
pub struct CMsgClientVoiceCallPreAuthorize {
mut:
unknown_fields []vproto.UnknownField
pub mut:
caller_steamid u64
has_caller_steamid bool
receiver_steamid u64
has_receiver_steamid bool
caller_id int
has_caller_id bool
hangup bool
has_hangup bool
}
pub fn (o &CMsgClientVoiceCallPreAuthorize) pack() []byte {
mut res := []byte{}
if o.has_caller_steamid {
res << vproto.pack_64bit_field(o.caller_steamid, 1)
}

if o.has_receiver_steamid {
res << vproto.pack_64bit_field(o.receiver_steamid, 2)
}

if o.has_caller_id {
res << vproto.pack_int32_field(o.caller_id, 3)
}

if o.has_hangup {
res << vproto.pack_bool_field(o.hangup, 4)
}

return res
}

pub fn cmsgclientvoicecallpreauthorize_unpack(buf []byte) ?CMsgClientVoiceCallPreAuthorize {
mut res := CMsgClientVoiceCallPreAuthorize{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_caller_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.caller_steamid = v
i = ii
}

2 {
res.has_receiver_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.receiver_steamid = v
i = ii
}

3 {
res.has_caller_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.caller_id = v
i = ii
}

4 {
res.has_hangup = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.hangup = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientvoicecallpreauthorize() CMsgClientVoiceCallPreAuthorize {
return CMsgClientVoiceCallPreAuthorize{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientvoicecallpreauthorize(o CMsgClientVoiceCallPreAuthorize, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientvoicecallpreauthorize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientVoiceCallPreAuthorize) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientvoicecallpreauthorize_unpack(v)?
return i, unpacked
}
pub struct CMsgClientVoiceCallPreAuthorizeResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
caller_steamid u64
has_caller_steamid bool
receiver_steamid u64
has_receiver_steamid bool
eresult int
has_eresult bool
caller_id int
has_caller_id bool
}
pub fn (o &CMsgClientVoiceCallPreAuthorizeResponse) pack() []byte {
mut res := []byte{}
if o.has_caller_steamid {
res << vproto.pack_64bit_field(o.caller_steamid, 1)
}

if o.has_receiver_steamid {
res << vproto.pack_64bit_field(o.receiver_steamid, 2)
}

if o.has_eresult {
res << vproto.pack_int32_field(o.eresult, 3)
}

if o.has_caller_id {
res << vproto.pack_int32_field(o.caller_id, 4)
}

return res
}

pub fn cmsgclientvoicecallpreauthorizeresponse_unpack(buf []byte) ?CMsgClientVoiceCallPreAuthorizeResponse {
mut res := CMsgClientVoiceCallPreAuthorizeResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_caller_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.caller_steamid = v
i = ii
}

2 {
res.has_receiver_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.receiver_steamid = v
i = ii
}

3 {
res.has_eresult = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

4 {
res.has_caller_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.caller_id = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientvoicecallpreauthorizeresponse() CMsgClientVoiceCallPreAuthorizeResponse {
return CMsgClientVoiceCallPreAuthorizeResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientvoicecallpreauthorizeresponse(o CMsgClientVoiceCallPreAuthorizeResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientvoicecallpreauthorizeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientVoiceCallPreAuthorizeResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgclientvoicecallpreauthorizeresponse_unpack(v)?
return i, unpacked
}
pub struct CMsgBadgeCraftedNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
badge_level u32
has_badge_level bool
}
pub fn (o &CMsgBadgeCraftedNotification) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_badge_level {
res << vproto.pack_uint32_field(o.badge_level, 2)
}

return res
}

pub fn cmsgbadgecraftednotification_unpack(buf []byte) ?CMsgBadgeCraftedNotification {
mut res := CMsgBadgeCraftedNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_badge_level = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.badge_level = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgbadgecraftednotification() CMsgBadgeCraftedNotification {
return CMsgBadgeCraftedNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgbadgecraftednotification(o CMsgBadgeCraftedNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgbadgecraftednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBadgeCraftedNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cmsgbadgecraftednotification_unpack(v)?
return i, unpacked
}
