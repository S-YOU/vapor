// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CMsgClientUCMAddScreenshot_Tag {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	tag_name       string
	has_tag_name   bool
	tag_value      string
	has_tag_value  bool
}

pub fn (o &CMsgClientUCMAddScreenshot_Tag) pack() []byte {
	mut res := []byte{}
	if o.has_tag_name {
		res << vproto.pack_string_field(o.tag_name, 1)
	}
	if o.has_tag_value {
		res << vproto.pack_string_field(o.tag_value, 2)
	}
	return res
}

pub fn cmsgclientucmaddscreenshot_tag_unpack(buf []byte) ?CMsgClientUCMAddScreenshot_Tag {
	mut res := CMsgClientUCMAddScreenshot_Tag{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_tag_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tag_name = v
				i = ii
			}
			2 {
				res.has_tag_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tag_value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmaddscreenshot_tag() CMsgClientUCMAddScreenshot_Tag {
	return CMsgClientUCMAddScreenshot_Tag{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmaddscreenshot_tag(o CMsgClientUCMAddScreenshot_Tag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmaddscreenshot_tag(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMAddScreenshot_Tag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmaddscreenshot_tag_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMAddScreenshot {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	appid                  u32
	has_appid              bool
	filename               string
	has_filename           bool
	thumbname              string
	has_thumbname          bool
	vr_filename            string
	has_vr_filename        bool
	rtime32_created        u32
	has_rtime32_created    bool
	width                  u32
	has_width              bool
	height                 u32
	has_height             bool
	permissions            u32
	has_permissions        bool
	caption                string
	has_caption            bool
	shortcut_name          string
	has_shortcut_name      bool
	tag                    []CMsgClientUCMAddScreenshot_Tag
	tagged_steamid         []u64
	spoiler_tag            bool
	has_spoiler_tag        bool
	tagged_publishedfileid []u64
}

pub fn (o &CMsgClientUCMAddScreenshot) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 2)
	}
	if o.has_thumbname {
		res << vproto.pack_string_field(o.thumbname, 3)
	}
	if o.has_vr_filename {
		res << vproto.pack_string_field(o.vr_filename, 14)
	}
	if o.has_rtime32_created {
		res << vproto.pack_32bit_field(o.rtime32_created, 4)
	}
	if o.has_width {
		res << vproto.pack_uint32_field(o.width, 5)
	}
	if o.has_height {
		res << vproto.pack_uint32_field(o.height, 6)
	}
	if o.has_permissions {
		res << vproto.pack_uint32_field(o.permissions, 7)
	}
	if o.has_caption {
		res << vproto.pack_string_field(o.caption, 8)
	}
	if o.has_shortcut_name {
		res << vproto.pack_string_field(o.shortcut_name, 9)
	}
	// [packed=false]
	for _, x in o.tag {
		res << zzz_vproto_internal_pack_cmsgclientucmaddscreenshot_tag(x, 10)
	}
	// [packed=false]
	for _, x in o.tagged_steamid {
		res << vproto.pack_64bit_field(x, 11)
	}
	if o.has_spoiler_tag {
		res << vproto.pack_bool_field(o.spoiler_tag, 12)
	}
	// [packed=false]
	for _, x in o.tagged_publishedfileid {
		res << vproto.pack_uint64_field(x, 13)
	}
	return res
}

pub fn cmsgclientucmaddscreenshot_unpack(buf []byte) ?CMsgClientUCMAddScreenshot {
	mut res := CMsgClientUCMAddScreenshot{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			3 {
				res.has_thumbname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.thumbname = v
				i = ii
			}
			14 {
				res.has_vr_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.vr_filename = v
				i = ii
			}
			4 {
				res.has_rtime32_created = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_created = v
				i = ii
			}
			5 {
				res.has_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			6 {
				res.has_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			7 {
				res.has_permissions = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.permissions = v
				i = ii
			}
			8 {
				res.has_caption = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.caption = v
				i = ii
			}
			9 {
				res.has_shortcut_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.shortcut_name = v
				i = ii
			}
			10 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientucmaddscreenshot_tag(cur_buf,
					tag_wiretype.wire_type)?
				res.tag << v
				i = ii
			}
			11 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.tagged_steamid << v
				i = ii
			}
			12 {
				res.has_spoiler_tag = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.spoiler_tag = v
				i = ii
			}
			13 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.tagged_publishedfileid << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmaddscreenshot() CMsgClientUCMAddScreenshot {
	return CMsgClientUCMAddScreenshot{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmaddscreenshot(o CMsgClientUCMAddScreenshot, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmaddscreenshot(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMAddScreenshot) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmaddscreenshot_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMAddScreenshotResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	eresult          int
	has_eresult      bool
	screenshotid     u64
	has_screenshotid bool
}

pub fn (o &CMsgClientUCMAddScreenshotResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_screenshotid {
		res << vproto.pack_64bit_field(o.screenshotid, 2)
	}
	return res
}

pub fn cmsgclientucmaddscreenshotresponse_unpack(buf []byte) ?CMsgClientUCMAddScreenshotResponse {
	mut res := CMsgClientUCMAddScreenshotResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_screenshotid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.screenshotid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmaddscreenshotresponse() CMsgClientUCMAddScreenshotResponse {
	return CMsgClientUCMAddScreenshotResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmaddscreenshotresponse(o CMsgClientUCMAddScreenshotResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmaddscreenshotresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMAddScreenshotResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmaddscreenshotresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMDeleteScreenshot {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	screenshotid     u64
	has_screenshotid bool
}

pub fn (o &CMsgClientUCMDeleteScreenshot) pack() []byte {
	mut res := []byte{}
	if o.has_screenshotid {
		res << vproto.pack_64bit_field(o.screenshotid, 1)
	}
	return res
}

pub fn cmsgclientucmdeletescreenshot_unpack(buf []byte) ?CMsgClientUCMDeleteScreenshot {
	mut res := CMsgClientUCMDeleteScreenshot{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_screenshotid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.screenshotid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmdeletescreenshot() CMsgClientUCMDeleteScreenshot {
	return CMsgClientUCMDeleteScreenshot{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmdeletescreenshot(o CMsgClientUCMDeleteScreenshot, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmdeletescreenshot(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMDeleteScreenshot) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmdeletescreenshot_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMDeleteScreenshotResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
}

pub fn (o &CMsgClientUCMDeleteScreenshotResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientucmdeletescreenshotresponse_unpack(buf []byte) ?CMsgClientUCMDeleteScreenshotResponse {
	mut res := CMsgClientUCMDeleteScreenshotResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmdeletescreenshotresponse() CMsgClientUCMDeleteScreenshotResponse {
	return CMsgClientUCMDeleteScreenshotResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmdeletescreenshotresponse(o CMsgClientUCMDeleteScreenshotResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmdeletescreenshotresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMDeleteScreenshotResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmdeletescreenshotresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMPublishFile {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	app_id                 u32
	has_app_id             bool
	file_name              string
	has_file_name          bool
	preview_file_name      string
	has_preview_file_name  bool
	consumer_app_id        u32
	has_consumer_app_id    bool
	title                  string
	has_title              bool
	description            string
	has_description        bool
	tags                   []string
	workshop_file          bool
	has_workshop_file      bool
	visibility             int
	has_visibility         bool
	file_type              u32
	has_file_type          bool
	url                    string
	has_url                bool
	video_provider         u32
	has_video_provider     bool
	video_account_name     string
	has_video_account_name bool
	video_identifier       string
	has_video_identifier   bool
	in_progress            bool
	has_in_progress        bool
}

pub fn (o &CMsgClientUCMPublishFile) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_file_name {
		res << vproto.pack_string_field(o.file_name, 2)
	}
	if o.has_preview_file_name {
		res << vproto.pack_string_field(o.preview_file_name, 3)
	}
	if o.has_consumer_app_id {
		res << vproto.pack_uint32_field(o.consumer_app_id, 4)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 5)
	}
	if o.has_description {
		res << vproto.pack_string_field(o.description, 6)
	}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 8)
	}
	if o.has_workshop_file {
		res << vproto.pack_bool_field(o.workshop_file, 9)
	}
	if o.has_visibility {
		res << vproto.pack_int32_field(o.visibility, 10)
	}
	if o.has_file_type {
		res << vproto.pack_uint32_field(o.file_type, 11)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 12)
	}
	if o.has_video_provider {
		res << vproto.pack_uint32_field(o.video_provider, 13)
	}
	if o.has_video_account_name {
		res << vproto.pack_string_field(o.video_account_name, 14)
	}
	if o.has_video_identifier {
		res << vproto.pack_string_field(o.video_identifier, 15)
	}
	if o.has_in_progress {
		res << vproto.pack_bool_field(o.in_progress, 16)
	}
	return res
}

pub fn cmsgclientucmpublishfile_unpack(buf []byte) ?CMsgClientUCMPublishFile {
	mut res := CMsgClientUCMPublishFile{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_name = v
				i = ii
			}
			3 {
				res.has_preview_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.preview_file_name = v
				i = ii
			}
			4 {
				res.has_consumer_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.consumer_app_id = v
				i = ii
			}
			5 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			6 {
				res.has_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.description = v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			9 {
				res.has_workshop_file = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.workshop_file = v
				i = ii
			}
			10 {
				res.has_visibility = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.visibility = v
				i = ii
			}
			11 {
				res.has_file_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_type = v
				i = ii
			}
			12 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			13 {
				res.has_video_provider = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.video_provider = v
				i = ii
			}
			14 {
				res.has_video_account_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.video_account_name = v
				i = ii
			}
			15 {
				res.has_video_identifier = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.video_identifier = v
				i = ii
			}
			16 {
				res.has_in_progress = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.in_progress = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmpublishfile() CMsgClientUCMPublishFile {
	return CMsgClientUCMPublishFile{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmpublishfile(o CMsgClientUCMPublishFile, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmpublishfile(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMPublishFile) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmpublishfile_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMPublishFileResponse {
mut:
	unknown_fields                                []vproto.UnknownField
pub mut:
	eresult                                       int
	has_eresult                                   bool
	published_file_id                             u64
	has_published_file_id                         bool
	needs_workshop_legal_agreement_acceptance     bool
	has_needs_workshop_legal_agreement_acceptance bool
}

pub fn (o &CMsgClientUCMPublishFileResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 2)
	}
	if o.has_needs_workshop_legal_agreement_acceptance {
		res << vproto.pack_bool_field(o.needs_workshop_legal_agreement_acceptance, 3)
	}
	return res
}

pub fn cmsgclientucmpublishfileresponse_unpack(buf []byte) ?CMsgClientUCMPublishFileResponse {
	mut res := CMsgClientUCMPublishFileResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			3 {
				res.has_needs_workshop_legal_agreement_acceptance = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.needs_workshop_legal_agreement_acceptance = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmpublishfileresponse() CMsgClientUCMPublishFileResponse {
	return CMsgClientUCMPublishFileResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmpublishfileresponse(o CMsgClientUCMPublishFileResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmpublishfileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMPublishFileResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmpublishfileresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMUpdatePublishedFile_KeyValueTag {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &CMsgClientUCMUpdatePublishedFile_KeyValueTag) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn cmsgclientucmupdatepublishedfile_keyvaluetag_unpack(buf []byte) ?CMsgClientUCMUpdatePublishedFile_KeyValueTag {
	mut res := CMsgClientUCMUpdatePublishedFile_KeyValueTag{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmupdatepublishedfile_keyvaluetag() CMsgClientUCMUpdatePublishedFile_KeyValueTag {
	return CMsgClientUCMUpdatePublishedFile_KeyValueTag{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmupdatepublishedfile_keyvaluetag(o CMsgClientUCMUpdatePublishedFile_KeyValueTag, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmupdatepublishedfile_keyvaluetag(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMUpdatePublishedFile_KeyValueTag) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmupdatepublishedfile_keyvaluetag_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	original_file_name     string
	has_original_file_name bool
	internal_file_name     string
	has_internal_file_name bool
	videoid                string
	has_videoid            bool
	preview_type           u32
	has_preview_type       bool
	update_index           int
	has_update_index       bool
}

pub fn (o &CMsgClientUCMUpdatePublishedFile_AdditionalPreview) pack() []byte {
	mut res := []byte{}
	if o.has_original_file_name {
		res << vproto.pack_string_field(o.original_file_name, 1)
	}
	if o.has_internal_file_name {
		res << vproto.pack_string_field(o.internal_file_name, 2)
	}
	if o.has_videoid {
		res << vproto.pack_string_field(o.videoid, 3)
	}
	if o.has_preview_type {
		res << vproto.pack_uint32_field(o.preview_type, 4)
	}
	if o.has_update_index {
		res << vproto.pack_int32_field(o.update_index, 5)
	}
	return res
}

pub fn cmsgclientucmupdatepublishedfile_additionalpreview_unpack(buf []byte) ?CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
	mut res := CMsgClientUCMUpdatePublishedFile_AdditionalPreview{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_original_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.original_file_name = v
				i = ii
			}
			2 {
				res.has_internal_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.internal_file_name = v
				i = ii
			}
			3 {
				res.has_videoid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.videoid = v
				i = ii
			}
			4 {
				res.has_preview_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.preview_type = v
				i = ii
			}
			5 {
				res.has_update_index = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.update_index = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmupdatepublishedfile_additionalpreview() CMsgClientUCMUpdatePublishedFile_AdditionalPreview {
	return CMsgClientUCMUpdatePublishedFile_AdditionalPreview{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmupdatepublishedfile_additionalpreview(o CMsgClientUCMUpdatePublishedFile_AdditionalPreview, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmupdatepublishedfile_additionalpreview(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMUpdatePublishedFile_AdditionalPreview) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmupdatepublishedfile_additionalpreview_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMUpdatePublishedFile {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	app_id                      u32
	has_app_id                  bool
	published_file_id           u64
	has_published_file_id       bool
	file_name                   string
	has_file_name               bool
	preview_file_name           string
	has_preview_file_name       bool
	title                       string
	has_title                   bool
	description                 string
	has_description             bool
	tags                        []string
	visibility                  int
	has_visibility              bool
	update_file                 bool
	has_update_file             bool
	update_preview_file         bool
	has_update_preview_file     bool
	update_title                bool
	has_update_title            bool
	update_description          bool
	has_update_description      bool
	update_tags                 bool
	has_update_tags             bool
	update_visibility           bool
	has_update_visibility       bool
	change_description          string
	has_change_description      bool
	update_url                  bool
	has_update_url              bool
	url                         string
	has_url                     bool
	update_content_manifest     bool
	has_update_content_manifest bool
	content_manifest            u64
	has_content_manifest        bool
	metadata                    string
	has_metadata                bool
	update_metadata             bool
	has_update_metadata         bool
	language                    int
	has_language                bool
	removed_kvtags              []string
	kvtags                      []CMsgClientUCMUpdatePublishedFile_KeyValueTag
	previews                    []CMsgClientUCMUpdatePublishedFile_AdditionalPreview
	previews_to_remove          []int
	clear_in_progress           bool
	has_clear_in_progress       bool
	remove_all_kvtags           bool
	has_remove_all_kvtags       bool
}

pub fn (o &CMsgClientUCMUpdatePublishedFile) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 2)
	}
	if o.has_file_name {
		res << vproto.pack_string_field(o.file_name, 3)
	}
	if o.has_preview_file_name {
		res << vproto.pack_string_field(o.preview_file_name, 4)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 5)
	}
	if o.has_description {
		res << vproto.pack_string_field(o.description, 6)
	}
	// [packed=false]
	for _, x in o.tags {
		res << vproto.pack_string_field(x, 7)
	}
	if o.has_visibility {
		res << vproto.pack_int32_field(o.visibility, 8)
	}
	if o.has_update_file {
		res << vproto.pack_bool_field(o.update_file, 9)
	}
	if o.has_update_preview_file {
		res << vproto.pack_bool_field(o.update_preview_file, 10)
	}
	if o.has_update_title {
		res << vproto.pack_bool_field(o.update_title, 11)
	}
	if o.has_update_description {
		res << vproto.pack_bool_field(o.update_description, 12)
	}
	if o.has_update_tags {
		res << vproto.pack_bool_field(o.update_tags, 13)
	}
	if o.has_update_visibility {
		res << vproto.pack_bool_field(o.update_visibility, 14)
	}
	if o.has_change_description {
		res << vproto.pack_string_field(o.change_description, 15)
	}
	if o.has_update_url {
		res << vproto.pack_bool_field(o.update_url, 16)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 17)
	}
	if o.has_update_content_manifest {
		res << vproto.pack_bool_field(o.update_content_manifest, 18)
	}
	if o.has_content_manifest {
		res << vproto.pack_64bit_field(o.content_manifest, 19)
	}
	if o.has_metadata {
		res << vproto.pack_string_field(o.metadata, 20)
	}
	if o.has_update_metadata {
		res << vproto.pack_bool_field(o.update_metadata, 21)
	}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 22)
	}
	// [packed=false]
	for _, x in o.removed_kvtags {
		res << vproto.pack_string_field(x, 23)
	}
	// [packed=false]
	for _, x in o.kvtags {
		res << zzz_vproto_internal_pack_cmsgclientucmupdatepublishedfile_keyvaluetag(x, 24)
	}
	// [packed=false]
	for _, x in o.previews {
		res << zzz_vproto_internal_pack_cmsgclientucmupdatepublishedfile_additionalpreview(x, 25)
	}
	// [packed=false]
	for _, x in o.previews_to_remove {
		res << vproto.pack_int32_field(x, 26)
	}
	if o.has_clear_in_progress {
		res << vproto.pack_bool_field(o.clear_in_progress, 27)
	}
	if o.has_remove_all_kvtags {
		res << vproto.pack_bool_field(o.remove_all_kvtags, 28)
	}
	return res
}

pub fn cmsgclientucmupdatepublishedfile_unpack(buf []byte) ?CMsgClientUCMUpdatePublishedFile {
	mut res := CMsgClientUCMUpdatePublishedFile{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			3 {
				res.has_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.file_name = v
				i = ii
			}
			4 {
				res.has_preview_file_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.preview_file_name = v
				i = ii
			}
			5 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			6 {
				res.has_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.description = v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.tags << v
				i = ii
			}
			8 {
				res.has_visibility = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.visibility = v
				i = ii
			}
			9 {
				res.has_update_file = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.update_file = v
				i = ii
			}
			10 {
				res.has_update_preview_file = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.update_preview_file = v
				i = ii
			}
			11 {
				res.has_update_title = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.update_title = v
				i = ii
			}
			12 {
				res.has_update_description = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.update_description = v
				i = ii
			}
			13 {
				res.has_update_tags = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.update_tags = v
				i = ii
			}
			14 {
				res.has_update_visibility = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.update_visibility = v
				i = ii
			}
			15 {
				res.has_change_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.change_description = v
				i = ii
			}
			16 {
				res.has_update_url = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.update_url = v
				i = ii
			}
			17 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			18 {
				res.has_update_content_manifest = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.update_content_manifest = v
				i = ii
			}
			19 {
				res.has_content_manifest = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.content_manifest = v
				i = ii
			}
			20 {
				res.has_metadata = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.metadata = v
				i = ii
			}
			21 {
				res.has_update_metadata = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.update_metadata = v
				i = ii
			}
			22 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			23 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.removed_kvtags << v
				i = ii
			}
			24 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientucmupdatepublishedfile_keyvaluetag(cur_buf,
					tag_wiretype.wire_type)?
				res.kvtags << v
				i = ii
			}
			25 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientucmupdatepublishedfile_additionalpreview(cur_buf,
					tag_wiretype.wire_type)?
				res.previews << v
				i = ii
			}
			26 {
				// [packed=false]
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.previews_to_remove << v
				i = ii
			}
			27 {
				res.has_clear_in_progress = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.clear_in_progress = v
				i = ii
			}
			28 {
				res.has_remove_all_kvtags = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.remove_all_kvtags = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmupdatepublishedfile() CMsgClientUCMUpdatePublishedFile {
	return CMsgClientUCMUpdatePublishedFile{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmupdatepublishedfile(o CMsgClientUCMUpdatePublishedFile, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmupdatepublishedfile(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMUpdatePublishedFile) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmupdatepublishedfile_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMUpdatePublishedFileResponse {
mut:
	unknown_fields                                []vproto.UnknownField
pub mut:
	eresult                                       int
	has_eresult                                   bool
	needs_workshop_legal_agreement_acceptance     bool
	has_needs_workshop_legal_agreement_acceptance bool
}

pub fn (o &CMsgClientUCMUpdatePublishedFileResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_needs_workshop_legal_agreement_acceptance {
		res << vproto.pack_bool_field(o.needs_workshop_legal_agreement_acceptance, 2)
	}
	return res
}

pub fn cmsgclientucmupdatepublishedfileresponse_unpack(buf []byte) ?CMsgClientUCMUpdatePublishedFileResponse {
	mut res := CMsgClientUCMUpdatePublishedFileResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_needs_workshop_legal_agreement_acceptance = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.needs_workshop_legal_agreement_acceptance = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmupdatepublishedfileresponse() CMsgClientUCMUpdatePublishedFileResponse {
	return CMsgClientUCMUpdatePublishedFileResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmupdatepublishedfileresponse(o CMsgClientUCMUpdatePublishedFileResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmupdatepublishedfileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMUpdatePublishedFileResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmupdatepublishedfileresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMDeletePublishedFile {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	app_id                u32
	has_app_id            bool
}

pub fn (o &CMsgClientUCMDeletePublishedFile) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	return res
}

pub fn cmsgclientucmdeletepublishedfile_unpack(buf []byte) ?CMsgClientUCMDeletePublishedFile {
	mut res := CMsgClientUCMDeletePublishedFile{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmdeletepublishedfile() CMsgClientUCMDeletePublishedFile {
	return CMsgClientUCMDeletePublishedFile{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmdeletepublishedfile(o CMsgClientUCMDeletePublishedFile, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmdeletepublishedfile(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMDeletePublishedFile) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmdeletepublishedfile_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMDeletePublishedFileResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
}

pub fn (o &CMsgClientUCMDeletePublishedFileResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientucmdeletepublishedfileresponse_unpack(buf []byte) ?CMsgClientUCMDeletePublishedFileResponse {
	mut res := CMsgClientUCMDeletePublishedFileResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmdeletepublishedfileresponse() CMsgClientUCMDeletePublishedFileResponse {
	return CMsgClientUCMDeletePublishedFileResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmdeletepublishedfileresponse(o CMsgClientUCMDeletePublishedFileResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmdeletepublishedfileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMDeletePublishedFileResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmdeletepublishedfileresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMEnumerateUserPublishedFiles {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	app_id          u32
	has_app_id      bool
	start_index     u32
	has_start_index bool
	sort_order      u32
	has_sort_order  bool
}

pub fn (o &CMsgClientUCMEnumerateUserPublishedFiles) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_start_index {
		res << vproto.pack_uint32_field(o.start_index, 2)
	}
	if o.has_sort_order {
		res << vproto.pack_uint32_field(o.sort_order, 3)
	}
	return res
}

pub fn cmsgclientucmenumerateuserpublishedfiles_unpack(buf []byte) ?CMsgClientUCMEnumerateUserPublishedFiles {
	mut res := CMsgClientUCMEnumerateUserPublishedFiles{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_start_index = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_index = v
				i = ii
			}
			3 {
				res.has_sort_order = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sort_order = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateuserpublishedfiles() CMsgClientUCMEnumerateUserPublishedFiles {
	return CMsgClientUCMEnumerateUserPublishedFiles{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateuserpublishedfiles(o CMsgClientUCMEnumerateUserPublishedFiles, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateuserpublishedfiles(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMEnumerateUserPublishedFiles) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmenumerateuserpublishedfiles_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
}

pub fn (o &CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	return res
}

pub fn cmsgclientucmenumerateuserpublishedfilesresponse_publishedfileid_unpack(buf []byte) ?CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
	mut res := CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateuserpublishedfilesresponse_publishedfileid() CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId {
	return CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateuserpublishedfilesresponse_publishedfileid(o CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateuserpublishedfilesresponse_publishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmenumerateuserpublishedfilesresponse_publishedfileid_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMEnumerateUserPublishedFilesResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	eresult           int
	has_eresult       bool
	published_files   []CMsgClientUCMEnumerateUserPublishedFilesResponse_PublishedFileId
	total_results     u32
	has_total_results bool
}

pub fn (o &CMsgClientUCMEnumerateUserPublishedFilesResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	// [packed=false]
	for _, x in o.published_files {
		res <<
			zzz_vproto_internal_pack_cmsgclientucmenumerateuserpublishedfilesresponse_publishedfileid(x, 2)
	}
	if o.has_total_results {
		res << vproto.pack_uint32_field(o.total_results, 3)
	}
	return res
}

pub fn cmsgclientucmenumerateuserpublishedfilesresponse_unpack(buf []byte) ?CMsgClientUCMEnumerateUserPublishedFilesResponse {
	mut res := CMsgClientUCMEnumerateUserPublishedFilesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientucmenumerateuserpublishedfilesresponse_publishedfileid(cur_buf,
					tag_wiretype.wire_type)?
				res.published_files << v
				i = ii
			}
			3 {
				res.has_total_results = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_results = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateuserpublishedfilesresponse() CMsgClientUCMEnumerateUserPublishedFilesResponse {
	return CMsgClientUCMEnumerateUserPublishedFilesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateuserpublishedfilesresponse(o CMsgClientUCMEnumerateUserPublishedFilesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateuserpublishedfilesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMEnumerateUserPublishedFilesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmenumerateuserpublishedfilesresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMEnumerateUserSubscribedFiles {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	app_id                 u32
	has_app_id             bool
	start_index            u32
	has_start_index        bool
	list_type              u32
	has_list_type          bool
	matching_file_type     u32
	has_matching_file_type bool
	count                  u32
	has_count              bool
}

pub fn (o &CMsgClientUCMEnumerateUserSubscribedFiles) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_start_index {
		res << vproto.pack_uint32_field(o.start_index, 2)
	}
	if o.has_list_type {
		res << vproto.pack_uint32_field(o.list_type, 3)
	}
	if o.has_matching_file_type {
		res << vproto.pack_uint32_field(o.matching_file_type, 4)
	}
	if o.has_count {
		res << vproto.pack_uint32_field(o.count, 5)
	}
	return res
}

pub fn cmsgclientucmenumerateusersubscribedfiles_unpack(buf []byte) ?CMsgClientUCMEnumerateUserSubscribedFiles {
	mut res := CMsgClientUCMEnumerateUserSubscribedFiles{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_start_index = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_index = v
				i = ii
			}
			3 {
				res.has_list_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.list_type = v
				i = ii
			}
			4 {
				res.has_matching_file_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.matching_file_type = v
				i = ii
			}
			5 {
				res.has_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateusersubscribedfiles() CMsgClientUCMEnumerateUserSubscribedFiles {
	return CMsgClientUCMEnumerateUserSubscribedFiles{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfiles(o CMsgClientUCMEnumerateUserSubscribedFiles, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfiles(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMEnumerateUserSubscribedFiles) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmenumerateusersubscribedfiles_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	published_file_id      u64
	has_published_file_id  bool
	rtime32_subscribed     u32
	has_rtime32_subscribed bool
}

pub fn (o &CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_rtime32_subscribed {
		res << vproto.pack_32bit_field(o.rtime32_subscribed, 2)
	}
	return res
}

pub fn cmsgclientucmenumerateusersubscribedfilesresponse_publishedfileid_unpack(buf []byte) ?CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
	mut res := CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_rtime32_subscribed = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_subscribed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateusersubscribedfilesresponse_publishedfileid() CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId {
	return CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfilesresponse_publishedfileid(o CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfilesresponse_publishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmenumerateusersubscribedfilesresponse_publishedfileid_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMEnumerateUserSubscribedFilesResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	eresult           int
	has_eresult       bool
	subscribed_files  []CMsgClientUCMEnumerateUserSubscribedFilesResponse_PublishedFileId
	total_results     u32
	has_total_results bool
}

pub fn (o &CMsgClientUCMEnumerateUserSubscribedFilesResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	// [packed=false]
	for _, x in o.subscribed_files {
		res <<
			zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfilesresponse_publishedfileid(x, 2)
	}
	if o.has_total_results {
		res << vproto.pack_uint32_field(o.total_results, 3)
	}
	return res
}

pub fn cmsgclientucmenumerateusersubscribedfilesresponse_unpack(buf []byte) ?CMsgClientUCMEnumerateUserSubscribedFilesResponse {
	mut res := CMsgClientUCMEnumerateUserSubscribedFilesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfilesresponse_publishedfileid(cur_buf,
					tag_wiretype.wire_type)?
				res.subscribed_files << v
				i = ii
			}
			3 {
				res.has_total_results = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_results = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateusersubscribedfilesresponse() CMsgClientUCMEnumerateUserSubscribedFilesResponse {
	return CMsgClientUCMEnumerateUserSubscribedFilesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfilesresponse(o CMsgClientUCMEnumerateUserSubscribedFilesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfilesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMEnumerateUserSubscribedFilesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmenumerateusersubscribedfilesresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	app_id               u32
	has_app_id           bool
	start_index          u32
	has_start_index      bool
	start_time           u32
	has_start_time       bool
	desired_revision     u32
	has_desired_revision bool
}

pub fn (o &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_start_index {
		res << vproto.pack_uint32_field(o.start_index, 2)
	}
	if o.has_start_time {
		res << vproto.pack_32bit_field(o.start_time, 3)
	}
	if o.has_desired_revision {
		res << vproto.pack_uint32_field(o.desired_revision, 4)
	}
	return res
}

pub fn cmsgclientucmenumerateusersubscribedfileswithupdates_unpack(buf []byte) ?CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
	mut res := CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_start_index = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_index = v
				i = ii
			}
			3 {
				res.has_start_time = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.start_time = v
				i = ii
			}
			4 {
				res.has_desired_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.desired_revision = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateusersubscribedfileswithupdates() CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
	return CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfileswithupdates(o CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfileswithupdates(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmenumerateusersubscribedfileswithupdates_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	published_file_id        u64
	has_published_file_id    bool
	rtime32_subscribed       u32
	has_rtime32_subscribed   bool
	appid                    u32
	has_appid                bool
	file_hcontent            u64
	has_file_hcontent        bool
	file_size                u32
	has_file_size            bool
	rtime32_last_updated     u32
	has_rtime32_last_updated bool
	is_depot_content         bool
	has_is_depot_content     bool
}

pub fn (o &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_rtime32_subscribed {
		res << vproto.pack_32bit_field(o.rtime32_subscribed, 2)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 3)
	}
	if o.has_file_hcontent {
		res << vproto.pack_64bit_field(o.file_hcontent, 4)
	}
	if o.has_file_size {
		res << vproto.pack_uint32_field(o.file_size, 5)
	}
	if o.has_rtime32_last_updated {
		res << vproto.pack_32bit_field(o.rtime32_last_updated, 6)
	}
	if o.has_is_depot_content {
		res << vproto.pack_bool_field(o.is_depot_content, 7)
	}
	return res
}

pub fn cmsgclientucmenumerateusersubscribedfileswithupdatesresponse_publishedfileid_unpack(buf []byte) ?CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
	mut res := CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_rtime32_subscribed = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_subscribed = v
				i = ii
			}
			3 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			4 {
				res.has_file_hcontent = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.file_hcontent = v
				i = ii
			}
			5 {
				res.has_file_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			6 {
				res.has_rtime32_last_updated = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_last_updated = v
				i = ii
			}
			7 {
				res.has_is_depot_content = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_depot_content = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateusersubscribedfileswithupdatesresponse_publishedfileid() CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId {
	return CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfileswithupdatesresponse_publishedfileid(o CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfileswithupdatesresponse_publishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmenumerateusersubscribedfileswithupdatesresponse_publishedfileid_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	eresult           int
	has_eresult       bool
	subscribed_files  []CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse_PublishedFileId
	total_results     u32
	has_total_results bool
}

pub fn (o &CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	// [packed=false]
	for _, x in o.subscribed_files {
		res <<
			zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfileswithupdatesresponse_publishedfileid(x, 2)
	}
	if o.has_total_results {
		res << vproto.pack_uint32_field(o.total_results, 3)
	}
	return res
}

pub fn cmsgclientucmenumerateusersubscribedfileswithupdatesresponse_unpack(buf []byte) ?CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
	mut res := CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfileswithupdatesresponse_publishedfileid(cur_buf,
					tag_wiretype.wire_type)?
				res.subscribed_files << v
				i = ii
			}
			3 {
				res.has_total_results = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_results = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumerateusersubscribedfileswithupdatesresponse() CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
	return CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumerateusersubscribedfileswithupdatesresponse(o CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumerateusersubscribedfileswithupdatesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmenumerateusersubscribedfileswithupdatesresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMPublishedFileUpdated {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	app_id                u32
	has_app_id            bool
	time_updated          u32
	has_time_updated      bool
	hcontent              u64
	has_hcontent          bool
	file_size             u32
	has_file_size         bool
	is_depot_content      bool
	has_is_depot_content  bool
	revision              u32
	has_revision          bool
}

pub fn (o &CMsgClientUCMPublishedFileUpdated) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.has_time_updated {
		res << vproto.pack_uint32_field(o.time_updated, 3)
	}
	if o.has_hcontent {
		res << vproto.pack_64bit_field(o.hcontent, 4)
	}
	if o.has_file_size {
		res << vproto.pack_32bit_field(o.file_size, 5)
	}
	if o.has_is_depot_content {
		res << vproto.pack_bool_field(o.is_depot_content, 6)
	}
	if o.has_revision {
		res << vproto.pack_uint32_field(o.revision, 7)
	}
	return res
}

pub fn cmsgclientucmpublishedfileupdated_unpack(buf []byte) ?CMsgClientUCMPublishedFileUpdated {
	mut res := CMsgClientUCMPublishedFileUpdated{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			3 {
				res.has_time_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_updated = v
				i = ii
			}
			4 {
				res.has_hcontent = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.hcontent = v
				i = ii
			}
			5 {
				res.has_file_size = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.file_size = v
				i = ii
			}
			6 {
				res.has_is_depot_content = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_depot_content = v
				i = ii
			}
			7 {
				res.has_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.revision = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmpublishedfileupdated() CMsgClientUCMPublishedFileUpdated {
	return CMsgClientUCMPublishedFileUpdated{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmpublishedfileupdated(o CMsgClientUCMPublishedFileUpdated, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmpublishedfileupdated(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMPublishedFileUpdated) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmpublishedfileupdated_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientWorkshopItemChangesRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	app_id                u32
	has_app_id            bool
	last_time_updated     u32
	has_last_time_updated bool
	num_items_needed      u32
	has_num_items_needed  bool
}

pub fn (o &CMsgClientWorkshopItemChangesRequest) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_last_time_updated {
		res << vproto.pack_uint32_field(o.last_time_updated, 2)
	}
	if o.has_num_items_needed {
		res << vproto.pack_uint32_field(o.num_items_needed, 3)
	}
	return res
}

pub fn cmsgclientworkshopitemchangesrequest_unpack(buf []byte) ?CMsgClientWorkshopItemChangesRequest {
	mut res := CMsgClientWorkshopItemChangesRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_last_time_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_time_updated = v
				i = ii
			}
			3 {
				res.has_num_items_needed = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_items_needed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopitemchangesrequest() CMsgClientWorkshopItemChangesRequest {
	return CMsgClientWorkshopItemChangesRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopitemchangesrequest(o CMsgClientWorkshopItemChangesRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopitemchangesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemChangesRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientworkshopitemchangesrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	time_updated          u32
	has_time_updated      bool
	manifest_id           u64
	has_manifest_id       bool
}

pub fn (o &CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_time_updated {
		res << vproto.pack_uint32_field(o.time_updated, 2)
	}
	if o.has_manifest_id {
		res << vproto.pack_64bit_field(o.manifest_id, 3)
	}
	return res
}

pub fn cmsgclientworkshopitemchangesresponse_workshopiteminfo_unpack(buf []byte) ?CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
	mut res := CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_time_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_updated = v
				i = ii
			}
			3 {
				res.has_manifest_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.manifest_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopitemchangesresponse_workshopiteminfo() CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo {
	return CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopitemchangesresponse_workshopiteminfo(o CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopitemchangesresponse_workshopiteminfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientworkshopitemchangesresponse_workshopiteminfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientWorkshopItemChangesResponse {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	eresult         int
	has_eresult     bool
	update_time     u32
	has_update_time bool
	workshop_items  []CMsgClientWorkshopItemChangesResponse_WorkshopItemInfo
}

pub fn (o &CMsgClientWorkshopItemChangesResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_update_time {
		res << vproto.pack_uint32_field(o.update_time, 2)
	}
	// [packed=false]
	for _, x in o.workshop_items {
		res <<
			zzz_vproto_internal_pack_cmsgclientworkshopitemchangesresponse_workshopiteminfo(x, 5)
	}
	return res
}

pub fn cmsgclientworkshopitemchangesresponse_unpack(buf []byte) ?CMsgClientWorkshopItemChangesResponse {
	mut res := CMsgClientWorkshopItemChangesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_update_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.update_time = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientworkshopitemchangesresponse_workshopiteminfo(cur_buf,
					tag_wiretype.wire_type)?
				res.workshop_items << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopitemchangesresponse() CMsgClientWorkshopItemChangesResponse {
	return CMsgClientWorkshopItemChangesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopitemchangesresponse(o CMsgClientWorkshopItemChangesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopitemchangesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemChangesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientworkshopitemchangesresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientWorkshopItemInfoRequest_WorkshopItem {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	time_updated          u32
	has_time_updated      bool
}

pub fn (o &CMsgClientWorkshopItemInfoRequest_WorkshopItem) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_time_updated {
		res << vproto.pack_uint32_field(o.time_updated, 2)
	}
	return res
}

pub fn cmsgclientworkshopiteminforequest_workshopitem_unpack(buf []byte) ?CMsgClientWorkshopItemInfoRequest_WorkshopItem {
	mut res := CMsgClientWorkshopItemInfoRequest_WorkshopItem{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_time_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_updated = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopiteminforequest_workshopitem() CMsgClientWorkshopItemInfoRequest_WorkshopItem {
	return CMsgClientWorkshopItemInfoRequest_WorkshopItem{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopiteminforequest_workshopitem(o CMsgClientWorkshopItemInfoRequest_WorkshopItem, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopiteminforequest_workshopitem(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemInfoRequest_WorkshopItem) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientworkshopiteminforequest_workshopitem_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientWorkshopItemInfoRequest {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	app_id                u32
	has_app_id            bool
	last_time_updated     u32
	has_last_time_updated bool
	workshop_items        []CMsgClientWorkshopItemInfoRequest_WorkshopItem
}

pub fn (o &CMsgClientWorkshopItemInfoRequest) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_last_time_updated {
		res << vproto.pack_uint32_field(o.last_time_updated, 2)
	}
	// [packed=false]
	for _, x in o.workshop_items {
		res << zzz_vproto_internal_pack_cmsgclientworkshopiteminforequest_workshopitem(x, 3)
	}
	return res
}

pub fn cmsgclientworkshopiteminforequest_unpack(buf []byte) ?CMsgClientWorkshopItemInfoRequest {
	mut res := CMsgClientWorkshopItemInfoRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_last_time_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_time_updated = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientworkshopiteminforequest_workshopitem(cur_buf,
					tag_wiretype.wire_type)?
				res.workshop_items << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopiteminforequest() CMsgClientWorkshopItemInfoRequest {
	return CMsgClientWorkshopItemInfoRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopiteminforequest(o CMsgClientWorkshopItemInfoRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopiteminforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemInfoRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientworkshopiteminforequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	time_updated          u32
	has_time_updated      bool
	manifest_id           u64
	has_manifest_id       bool
	is_legacy             bool
	has_is_legacy         bool
}

pub fn (o &CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_time_updated {
		res << vproto.pack_uint32_field(o.time_updated, 2)
	}
	if o.has_manifest_id {
		res << vproto.pack_64bit_field(o.manifest_id, 3)
	}
	if o.has_is_legacy {
		res << vproto.pack_bool_field(o.is_legacy, 4)
	}
	return res
}

pub fn cmsgclientworkshopiteminforesponse_workshopiteminfo_unpack(buf []byte) ?CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
	mut res := CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_time_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_updated = v
				i = ii
			}
			3 {
				res.has_manifest_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.manifest_id = v
				i = ii
			}
			4 {
				res.has_is_legacy = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_legacy = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopiteminforesponse_workshopiteminfo() CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo {
	return CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopiteminforesponse_workshopiteminfo(o CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopiteminforesponse_workshopiteminfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientworkshopiteminforesponse_workshopiteminfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientWorkshopItemInfoResponse {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	eresult         int
	has_eresult     bool
	update_time     u32
	has_update_time bool
	workshop_items  []CMsgClientWorkshopItemInfoResponse_WorkshopItemInfo
	private_items   []u64
}

pub fn (o &CMsgClientWorkshopItemInfoResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_update_time {
		res << vproto.pack_uint32_field(o.update_time, 2)
	}
	// [packed=false]
	for _, x in o.workshop_items {
		res << zzz_vproto_internal_pack_cmsgclientworkshopiteminforesponse_workshopiteminfo(x, 3)
	}
	// [packed=false]
	for _, x in o.private_items {
		res << vproto.pack_64bit_field(x, 4)
	}
	return res
}

pub fn cmsgclientworkshopiteminforesponse_unpack(buf []byte) ?CMsgClientWorkshopItemInfoResponse {
	mut res := CMsgClientWorkshopItemInfoResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_update_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.update_time = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientworkshopiteminforesponse_workshopiteminfo(cur_buf,
					tag_wiretype.wire_type)?
				res.workshop_items << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.private_items << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientworkshopiteminforesponse() CMsgClientWorkshopItemInfoResponse {
	return CMsgClientWorkshopItemInfoResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientworkshopiteminforesponse(o CMsgClientWorkshopItemInfoResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientworkshopiteminforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientWorkshopItemInfoResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientworkshopiteminforesponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMGetPublishedFilesForUser {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	app_id               u32
	has_app_id           bool
	creator_steam_id     u64
	has_creator_steam_id bool
	required_tags        []string
	excluded_tags        []string
	start_index          u32
	has_start_index      bool
}

pub fn (o &CMsgClientUCMGetPublishedFilesForUser) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_creator_steam_id {
		res << vproto.pack_64bit_field(o.creator_steam_id, 2)
	}
	// [packed=false]
	for _, x in o.required_tags {
		res << vproto.pack_string_field(x, 3)
	}
	// [packed=false]
	for _, x in o.excluded_tags {
		res << vproto.pack_string_field(x, 4)
	}
	if o.has_start_index {
		res << vproto.pack_uint32_field(o.start_index, 5)
	}
	return res
}

pub fn cmsgclientucmgetpublishedfilesforuser_unpack(buf []byte) ?CMsgClientUCMGetPublishedFilesForUser {
	mut res := CMsgClientUCMGetPublishedFilesForUser{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_creator_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.creator_steam_id = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.required_tags << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.excluded_tags << v
				i = ii
			}
			5 {
				res.has_start_index = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_index = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmgetpublishedfilesforuser() CMsgClientUCMGetPublishedFilesForUser {
	return CMsgClientUCMGetPublishedFilesForUser{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmgetpublishedfilesforuser(o CMsgClientUCMGetPublishedFilesForUser, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmgetpublishedfilesforuser(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMGetPublishedFilesForUser) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmgetpublishedfilesforuser_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
}

pub fn (o &CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	return res
}

pub fn cmsgclientucmgetpublishedfilesforuserresponse_publishedfileid_unpack(buf []byte) ?CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
	mut res := CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmgetpublishedfilesforuserresponse_publishedfileid() CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId {
	return CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmgetpublishedfilesforuserresponse_publishedfileid(o CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmgetpublishedfilesforuserresponse_publishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmgetpublishedfilesforuserresponse_publishedfileid_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMGetPublishedFilesForUserResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	eresult           int
	has_eresult       bool
	published_files   []CMsgClientUCMGetPublishedFilesForUserResponse_PublishedFileId
	total_results     u32
	has_total_results bool
}

pub fn (o &CMsgClientUCMGetPublishedFilesForUserResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	// [packed=false]
	for _, x in o.published_files {
		res <<
			zzz_vproto_internal_pack_cmsgclientucmgetpublishedfilesforuserresponse_publishedfileid(x, 2)
	}
	if o.has_total_results {
		res << vproto.pack_uint32_field(o.total_results, 3)
	}
	return res
}

pub fn cmsgclientucmgetpublishedfilesforuserresponse_unpack(buf []byte) ?CMsgClientUCMGetPublishedFilesForUserResponse {
	mut res := CMsgClientUCMGetPublishedFilesForUserResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientucmgetpublishedfilesforuserresponse_publishedfileid(cur_buf,
					tag_wiretype.wire_type)?
				res.published_files << v
				i = ii
			}
			3 {
				res.has_total_results = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_results = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmgetpublishedfilesforuserresponse() CMsgClientUCMGetPublishedFilesForUserResponse {
	return CMsgClientUCMGetPublishedFilesForUserResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmgetpublishedfilesforuserresponse(o CMsgClientUCMGetPublishedFilesForUserResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmgetpublishedfilesforuserresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMGetPublishedFilesForUserResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmgetpublishedfilesforuserresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMSetUserPublishedFileAction {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	app_id                u32
	has_app_id            bool
	action                int
	has_action            bool
}

pub fn (o &CMsgClientUCMSetUserPublishedFileAction) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.has_action {
		res << vproto.pack_int32_field(o.action, 3)
	}
	return res
}

pub fn cmsgclientucmsetuserpublishedfileaction_unpack(buf []byte) ?CMsgClientUCMSetUserPublishedFileAction {
	mut res := CMsgClientUCMSetUserPublishedFileAction{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			3 {
				res.has_action = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.action = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmsetuserpublishedfileaction() CMsgClientUCMSetUserPublishedFileAction {
	return CMsgClientUCMSetUserPublishedFileAction{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmsetuserpublishedfileaction(o CMsgClientUCMSetUserPublishedFileAction, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmsetuserpublishedfileaction(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMSetUserPublishedFileAction) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmsetuserpublishedfileaction_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMSetUserPublishedFileActionResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
}

pub fn (o &CMsgClientUCMSetUserPublishedFileActionResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientucmsetuserpublishedfileactionresponse_unpack(buf []byte) ?CMsgClientUCMSetUserPublishedFileActionResponse {
	mut res := CMsgClientUCMSetUserPublishedFileActionResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmsetuserpublishedfileactionresponse() CMsgClientUCMSetUserPublishedFileActionResponse {
	return CMsgClientUCMSetUserPublishedFileActionResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmsetuserpublishedfileactionresponse(o CMsgClientUCMSetUserPublishedFileActionResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmsetuserpublishedfileactionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMSetUserPublishedFileActionResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmsetuserpublishedfileactionresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMEnumeratePublishedFilesByUserAction {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	app_id          u32
	has_app_id      bool
	start_index     u32
	has_start_index bool
	action          int
	has_action      bool
}

pub fn (o &CMsgClientUCMEnumeratePublishedFilesByUserAction) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_start_index {
		res << vproto.pack_uint32_field(o.start_index, 2)
	}
	if o.has_action {
		res << vproto.pack_int32_field(o.action, 3)
	}
	return res
}

pub fn cmsgclientucmenumeratepublishedfilesbyuseraction_unpack(buf []byte) ?CMsgClientUCMEnumeratePublishedFilesByUserAction {
	mut res := CMsgClientUCMEnumeratePublishedFilesByUserAction{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_start_index = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_index = v
				i = ii
			}
			3 {
				res.has_action = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.action = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumeratepublishedfilesbyuseraction() CMsgClientUCMEnumeratePublishedFilesByUserAction {
	return CMsgClientUCMEnumeratePublishedFilesByUserAction{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumeratepublishedfilesbyuseraction(o CMsgClientUCMEnumeratePublishedFilesByUserAction, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumeratepublishedfilesbyuseraction(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMEnumeratePublishedFilesByUserAction) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmenumeratepublishedfilesbyuseraction_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	rtime_time_stamp      u32
	has_rtime_time_stamp  bool
}

pub fn (o &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_rtime_time_stamp {
		res << vproto.pack_32bit_field(o.rtime_time_stamp, 2)
	}
	return res
}

pub fn cmsgclientucmenumeratepublishedfilesbyuseractionresponse_publishedfileid_unpack(buf []byte) ?CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
	mut res := CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_rtime_time_stamp = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime_time_stamp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumeratepublishedfilesbyuseractionresponse_publishedfileid() CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId {
	return CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumeratepublishedfilesbyuseractionresponse_publishedfileid(o CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumeratepublishedfilesbyuseractionresponse_publishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmenumeratepublishedfilesbyuseractionresponse_publishedfileid_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	eresult           int
	has_eresult       bool
	published_files   []CMsgClientUCMEnumeratePublishedFilesByUserActionResponse_PublishedFileId
	total_results     u32
	has_total_results bool
}

pub fn (o &CMsgClientUCMEnumeratePublishedFilesByUserActionResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	// [packed=false]
	for _, x in o.published_files {
		res <<
			zzz_vproto_internal_pack_cmsgclientucmenumeratepublishedfilesbyuseractionresponse_publishedfileid(x, 2)
	}
	if o.has_total_results {
		res << vproto.pack_uint32_field(o.total_results, 3)
	}
	return res
}

pub fn cmsgclientucmenumeratepublishedfilesbyuseractionresponse_unpack(buf []byte) ?CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
	mut res := CMsgClientUCMEnumeratePublishedFilesByUserActionResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientucmenumeratepublishedfilesbyuseractionresponse_publishedfileid(cur_buf,
					tag_wiretype.wire_type)?
				res.published_files << v
				i = ii
			}
			3 {
				res.has_total_results = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_results = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientucmenumeratepublishedfilesbyuseractionresponse() CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
	return CMsgClientUCMEnumeratePublishedFilesByUserActionResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientucmenumeratepublishedfilesbyuseractionresponse(o CMsgClientUCMEnumeratePublishedFilesByUserActionResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientucmenumeratepublishedfilesbyuseractionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUCMEnumeratePublishedFilesByUserActionResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientucmenumeratepublishedfilesbyuseractionresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientScreenshotsChanged {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientScreenshotsChanged) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientscreenshotschanged_unpack(buf []byte) ?CMsgClientScreenshotsChanged {
	res := CMsgClientScreenshotsChanged{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientscreenshotschanged() CMsgClientScreenshotsChanged {
	return CMsgClientScreenshotsChanged{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientscreenshotschanged(o CMsgClientScreenshotsChanged, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientscreenshotschanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientScreenshotsChanged) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientscreenshotschanged_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUpdateUserGameInfo {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid_idgs     u64
	has_steamid_idgs bool
	gameid           u64
	has_gameid       bool
	game_ip          u32
	has_game_ip      bool
	game_port        u32
	has_game_port    bool
	token            []byte
	has_token        bool
}

pub fn (o &CMsgClientUpdateUserGameInfo) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_idgs {
		res << vproto.pack_64bit_field(o.steamid_idgs, 1)
	}
	if o.has_gameid {
		res << vproto.pack_64bit_field(o.gameid, 2)
	}
	if o.has_game_ip {
		res << vproto.pack_uint32_field(o.game_ip, 3)
	}
	if o.has_game_port {
		res << vproto.pack_uint32_field(o.game_port, 4)
	}
	if o.has_token {
		res << vproto.pack_bytes_field(o.token, 5)
	}
	return res
}

pub fn cmsgclientupdateusergameinfo_unpack(buf []byte) ?CMsgClientUpdateUserGameInfo {
	mut res := CMsgClientUpdateUserGameInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_idgs = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_idgs = v
				i = ii
			}
			2 {
				res.has_gameid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			3 {
				res.has_game_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_ip = v
				i = ii
			}
			4 {
				res.has_game_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_port = v
				i = ii
			}
			5 {
				res.has_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientupdateusergameinfo() CMsgClientUpdateUserGameInfo {
	return CMsgClientUpdateUserGameInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientupdateusergameinfo(o CMsgClientUpdateUserGameInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientupdateusergameinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUpdateUserGameInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientupdateusergameinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRichPresenceUpload {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	rich_presence_kv     []byte
	has_rich_presence_kv bool
	steamid_broadcast    []u64
}

pub fn (o &CMsgClientRichPresenceUpload) pack() []byte {
	mut res := []byte{}
	if o.has_rich_presence_kv {
		res << vproto.pack_bytes_field(o.rich_presence_kv, 1)
	}
	// [packed=false]
	for _, x in o.steamid_broadcast {
		res << vproto.pack_64bit_field(x, 2)
	}
	return res
}

pub fn cmsgclientrichpresenceupload_unpack(buf []byte) ?CMsgClientRichPresenceUpload {
	mut res := CMsgClientRichPresenceUpload{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_rich_presence_kv = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.rich_presence_kv = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_broadcast << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrichpresenceupload() CMsgClientRichPresenceUpload {
	return CMsgClientRichPresenceUpload{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrichpresenceupload(o CMsgClientRichPresenceUpload, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrichpresenceupload(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRichPresenceUpload) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrichpresenceupload_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRichPresenceRequest {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	steamid_request []u64
}

pub fn (o &CMsgClientRichPresenceRequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.steamid_request {
		res << vproto.pack_64bit_field(x, 1)
	}
	return res
}

pub fn cmsgclientrichpresencerequest_unpack(buf []byte) ?CMsgClientRichPresenceRequest {
	mut res := CMsgClientRichPresenceRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_request << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrichpresencerequest() CMsgClientRichPresenceRequest {
	return CMsgClientRichPresenceRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrichpresencerequest(o CMsgClientRichPresenceRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrichpresencerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRichPresenceRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrichpresencerequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRichPresenceInfo_RichPresence {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	steamid_user         u64
	has_steamid_user     bool
	rich_presence_kv     []byte
	has_rich_presence_kv bool
}

pub fn (o &CMsgClientRichPresenceInfo_RichPresence) pack() []byte {
	mut res := []byte{}
	if o.has_steamid_user {
		res << vproto.pack_64bit_field(o.steamid_user, 1)
	}
	if o.has_rich_presence_kv {
		res << vproto.pack_bytes_field(o.rich_presence_kv, 2)
	}
	return res
}

pub fn cmsgclientrichpresenceinfo_richpresence_unpack(buf []byte) ?CMsgClientRichPresenceInfo_RichPresence {
	mut res := CMsgClientRichPresenceInfo_RichPresence{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid_user = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_user = v
				i = ii
			}
			2 {
				res.has_rich_presence_kv = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.rich_presence_kv = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrichpresenceinfo_richpresence() CMsgClientRichPresenceInfo_RichPresence {
	return CMsgClientRichPresenceInfo_RichPresence{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrichpresenceinfo_richpresence(o CMsgClientRichPresenceInfo_RichPresence, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrichpresenceinfo_richpresence(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRichPresenceInfo_RichPresence) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrichpresenceinfo_richpresence_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRichPresenceInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	rich_presence  []CMsgClientRichPresenceInfo_RichPresence
}

pub fn (o &CMsgClientRichPresenceInfo) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.rich_presence {
		res << zzz_vproto_internal_pack_cmsgclientrichpresenceinfo_richpresence(x, 1)
	}
	return res
}

pub fn cmsgclientrichpresenceinfo_unpack(buf []byte) ?CMsgClientRichPresenceInfo {
	mut res := CMsgClientRichPresenceInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientrichpresenceinfo_richpresence(cur_buf,
					tag_wiretype.wire_type)?
				res.rich_presence << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrichpresenceinfo() CMsgClientRichPresenceInfo {
	return CMsgClientRichPresenceInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrichpresenceinfo(o CMsgClientRichPresenceInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrichpresenceinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRichPresenceInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrichpresenceinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientCheckFileSignature {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	has_app_id     bool
}

pub fn (o &CMsgClientCheckFileSignature) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	return res
}

pub fn cmsgclientcheckfilesignature_unpack(buf []byte) ?CMsgClientCheckFileSignature {
	mut res := CMsgClientCheckFileSignature{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcheckfilesignature() CMsgClientCheckFileSignature {
	return CMsgClientCheckFileSignature{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcheckfilesignature(o CMsgClientCheckFileSignature, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcheckfilesignature(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCheckFileSignature) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientcheckfilesignature_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientCheckFileSignatureResponse {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	app_id                         u32
	has_app_id                     bool
	pid                            u32
	has_pid                        bool
	eresult                        u32
	has_eresult                    bool
	filename                       string
	has_filename                   bool
	esignatureresult               u32
	has_esignatureresult           bool
	sha_file                       []byte
	has_sha_file                   bool
	signatureheader                []byte
	has_signatureheader            bool
	filesize                       u32
	has_filesize                   bool
	getlasterror                   u32
	has_getlasterror               bool
	evalvesignaturecheckdetail     u32
	has_evalvesignaturecheckdetail bool
}

pub fn (o &CMsgClientCheckFileSignatureResponse) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_pid {
		res << vproto.pack_uint32_field(o.pid, 2)
	}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 3)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 4)
	}
	if o.has_esignatureresult {
		res << vproto.pack_uint32_field(o.esignatureresult, 5)
	}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 6)
	}
	if o.has_signatureheader {
		res << vproto.pack_bytes_field(o.signatureheader, 7)
	}
	if o.has_filesize {
		res << vproto.pack_uint32_field(o.filesize, 8)
	}
	if o.has_getlasterror {
		res << vproto.pack_uint32_field(o.getlasterror, 9)
	}
	if o.has_evalvesignaturecheckdetail {
		res << vproto.pack_uint32_field(o.evalvesignaturecheckdetail, 10)
	}
	return res
}

pub fn cmsgclientcheckfilesignatureresponse_unpack(buf []byte) ?CMsgClientCheckFileSignatureResponse {
	mut res := CMsgClientCheckFileSignatureResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_pid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.pid = v
				i = ii
			}
			3 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			4 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			5 {
				res.has_esignatureresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.esignatureresult = v
				i = ii
			}
			6 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			7 {
				res.has_signatureheader = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.signatureheader = v
				i = ii
			}
			8 {
				res.has_filesize = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.filesize = v
				i = ii
			}
			9 {
				res.has_getlasterror = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.getlasterror = v
				i = ii
			}
			10 {
				res.has_evalvesignaturecheckdetail = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.evalvesignaturecheckdetail = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcheckfilesignatureresponse() CMsgClientCheckFileSignatureResponse {
	return CMsgClientCheckFileSignatureResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcheckfilesignatureresponse(o CMsgClientCheckFileSignatureResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcheckfilesignatureresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCheckFileSignatureResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientcheckfilesignatureresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientReadMachineAuth {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	filename       string
	has_filename   bool
	offset         u32
	has_offset     bool
	cubtoread      u32
	has_cubtoread  bool
}

pub fn (o &CMsgClientReadMachineAuth) pack() []byte {
	mut res := []byte{}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 1)
	}
	if o.has_offset {
		res << vproto.pack_uint32_field(o.offset, 2)
	}
	if o.has_cubtoread {
		res << vproto.pack_uint32_field(o.cubtoread, 3)
	}
	return res
}

pub fn cmsgclientreadmachineauth_unpack(buf []byte) ?CMsgClientReadMachineAuth {
	mut res := CMsgClientReadMachineAuth{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			2 {
				res.has_offset = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.offset = v
				i = ii
			}
			3 {
				res.has_cubtoread = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cubtoread = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientreadmachineauth() CMsgClientReadMachineAuth {
	return CMsgClientReadMachineAuth{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientreadmachineauth(o CMsgClientReadMachineAuth, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientreadmachineauth(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientReadMachineAuth) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientreadmachineauth_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientReadMachineAuthResponse {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	filename            string
	has_filename        bool
	eresult             u32
	has_eresult         bool
	filesize            u32
	has_filesize        bool
	sha_file            []byte
	has_sha_file        bool
	getlasterror        u32
	has_getlasterror    bool
	offset              u32
	has_offset          bool
	cubread             u32
	has_cubread         bool
	bytes_read          []byte
	has_bytes_read      bool
	filename_sentry     string
	has_filename_sentry bool
}

pub fn (o &CMsgClientReadMachineAuthResponse) pack() []byte {
	mut res := []byte{}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 1)
	}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 2)
	}
	if o.has_filesize {
		res << vproto.pack_uint32_field(o.filesize, 3)
	}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 4)
	}
	if o.has_getlasterror {
		res << vproto.pack_uint32_field(o.getlasterror, 5)
	}
	if o.has_offset {
		res << vproto.pack_uint32_field(o.offset, 6)
	}
	if o.has_cubread {
		res << vproto.pack_uint32_field(o.cubread, 7)
	}
	if o.has_bytes_read {
		res << vproto.pack_bytes_field(o.bytes_read, 8)
	}
	if o.has_filename_sentry {
		res << vproto.pack_string_field(o.filename_sentry, 9)
	}
	return res
}

pub fn cmsgclientreadmachineauthresponse_unpack(buf []byte) ?CMsgClientReadMachineAuthResponse {
	mut res := CMsgClientReadMachineAuthResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			2 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			3 {
				res.has_filesize = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.filesize = v
				i = ii
			}
			4 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			5 {
				res.has_getlasterror = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.getlasterror = v
				i = ii
			}
			6 {
				res.has_offset = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.offset = v
				i = ii
			}
			7 {
				res.has_cubread = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cubread = v
				i = ii
			}
			8 {
				res.has_bytes_read = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_read = v
				i = ii
			}
			9 {
				res.has_filename_sentry = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename_sentry = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientreadmachineauthresponse() CMsgClientReadMachineAuthResponse {
	return CMsgClientReadMachineAuthResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientreadmachineauthresponse(o CMsgClientReadMachineAuthResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientreadmachineauthresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientReadMachineAuthResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientreadmachineauthresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUpdateMachineAuth {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	filename             string
	has_filename         bool
	offset               u32
	has_offset           bool
	cubtowrite           u32
	has_cubtowrite       bool
	bytes                []byte
	has_bytes            bool
	otp_type             u32
	has_otp_type         bool
	otp_identifier       string
	has_otp_identifier   bool
	otp_sharedsecret     []byte
	has_otp_sharedsecret bool
	otp_timedrift        u32
	has_otp_timedrift    bool
}

pub fn (o &CMsgClientUpdateMachineAuth) pack() []byte {
	mut res := []byte{}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 1)
	}
	if o.has_offset {
		res << vproto.pack_uint32_field(o.offset, 2)
	}
	if o.has_cubtowrite {
		res << vproto.pack_uint32_field(o.cubtowrite, 3)
	}
	if o.has_bytes {
		res << vproto.pack_bytes_field(o.bytes, 4)
	}
	if o.has_otp_type {
		res << vproto.pack_uint32_field(o.otp_type, 5)
	}
	if o.has_otp_identifier {
		res << vproto.pack_string_field(o.otp_identifier, 6)
	}
	if o.has_otp_sharedsecret {
		res << vproto.pack_bytes_field(o.otp_sharedsecret, 7)
	}
	if o.has_otp_timedrift {
		res << vproto.pack_uint32_field(o.otp_timedrift, 8)
	}
	return res
}

pub fn cmsgclientupdatemachineauth_unpack(buf []byte) ?CMsgClientUpdateMachineAuth {
	mut res := CMsgClientUpdateMachineAuth{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			2 {
				res.has_offset = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.offset = v
				i = ii
			}
			3 {
				res.has_cubtowrite = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cubtowrite = v
				i = ii
			}
			4 {
				res.has_bytes = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes = v
				i = ii
			}
			5 {
				res.has_otp_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_type = v
				i = ii
			}
			6 {
				res.has_otp_identifier = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_identifier = v
				i = ii
			}
			7 {
				res.has_otp_sharedsecret = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_sharedsecret = v
				i = ii
			}
			8 {
				res.has_otp_timedrift = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_timedrift = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientupdatemachineauth() CMsgClientUpdateMachineAuth {
	return CMsgClientUpdateMachineAuth{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientupdatemachineauth(o CMsgClientUpdateMachineAuth, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientupdatemachineauth(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUpdateMachineAuth) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientupdatemachineauth_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUpdateMachineAuthResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	filename           string
	has_filename       bool
	eresult            u32
	has_eresult        bool
	filesize           u32
	has_filesize       bool
	sha_file           []byte
	has_sha_file       bool
	getlasterror       u32
	has_getlasterror   bool
	offset             u32
	has_offset         bool
	cubwrote           u32
	has_cubwrote       bool
	otp_type           int
	has_otp_type       bool
	otp_value          u32
	has_otp_value      bool
	otp_identifier     string
	has_otp_identifier bool
}

pub fn (o &CMsgClientUpdateMachineAuthResponse) pack() []byte {
	mut res := []byte{}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 1)
	}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 2)
	}
	if o.has_filesize {
		res << vproto.pack_uint32_field(o.filesize, 3)
	}
	if o.has_sha_file {
		res << vproto.pack_bytes_field(o.sha_file, 4)
	}
	if o.has_getlasterror {
		res << vproto.pack_uint32_field(o.getlasterror, 5)
	}
	if o.has_offset {
		res << vproto.pack_uint32_field(o.offset, 6)
	}
	if o.has_cubwrote {
		res << vproto.pack_uint32_field(o.cubwrote, 7)
	}
	if o.has_otp_type {
		res << vproto.pack_int32_field(o.otp_type, 8)
	}
	if o.has_otp_value {
		res << vproto.pack_uint32_field(o.otp_value, 9)
	}
	if o.has_otp_identifier {
		res << vproto.pack_string_field(o.otp_identifier, 10)
	}
	return res
}

pub fn cmsgclientupdatemachineauthresponse_unpack(buf []byte) ?CMsgClientUpdateMachineAuthResponse {
	mut res := CMsgClientUpdateMachineAuthResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			2 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			3 {
				res.has_filesize = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.filesize = v
				i = ii
			}
			4 {
				res.has_sha_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_file = v
				i = ii
			}
			5 {
				res.has_getlasterror = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.getlasterror = v
				i = ii
			}
			6 {
				res.has_offset = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.offset = v
				i = ii
			}
			7 {
				res.has_cubwrote = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cubwrote = v
				i = ii
			}
			8 {
				res.has_otp_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_type = v
				i = ii
			}
			9 {
				res.has_otp_value = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_value = v
				i = ii
			}
			10 {
				res.has_otp_identifier = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_identifier = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientupdatemachineauthresponse() CMsgClientUpdateMachineAuthResponse {
	return CMsgClientUpdateMachineAuthResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientupdatemachineauthresponse(o CMsgClientUpdateMachineAuthResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientupdatemachineauthresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUpdateMachineAuthResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientupdatemachineauthresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestMachineAuth {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	filename                    string
	has_filename                bool
	eresult_sentryfile          u32
	has_eresult_sentryfile      bool
	filesize                    u32
	has_filesize                bool
	sha_sentryfile              []byte
	has_sha_sentryfile          bool
	lock_account_action         int
	has_lock_account_action     bool
	otp_type                    u32
	has_otp_type                bool
	otp_identifier              string
	has_otp_identifier          bool
	otp_sharedsecret            []byte
	has_otp_sharedsecret        bool
	otp_value                   u32
	has_otp_value               bool
	machine_name                string
	has_machine_name            bool
	machine_name_userchosen     string
	has_machine_name_userchosen bool
}

pub fn (o &CMsgClientRequestMachineAuth) pack() []byte {
	mut res := []byte{}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 1)
	}
	if o.has_eresult_sentryfile {
		res << vproto.pack_uint32_field(o.eresult_sentryfile, 2)
	}
	if o.has_filesize {
		res << vproto.pack_uint32_field(o.filesize, 3)
	}
	if o.has_sha_sentryfile {
		res << vproto.pack_bytes_field(o.sha_sentryfile, 4)
	}
	if o.has_lock_account_action {
		res << vproto.pack_int32_field(o.lock_account_action, 6)
	}
	if o.has_otp_type {
		res << vproto.pack_uint32_field(o.otp_type, 7)
	}
	if o.has_otp_identifier {
		res << vproto.pack_string_field(o.otp_identifier, 8)
	}
	if o.has_otp_sharedsecret {
		res << vproto.pack_bytes_field(o.otp_sharedsecret, 9)
	}
	if o.has_otp_value {
		res << vproto.pack_uint32_field(o.otp_value, 10)
	}
	if o.has_machine_name {
		res << vproto.pack_string_field(o.machine_name, 11)
	}
	if o.has_machine_name_userchosen {
		res << vproto.pack_string_field(o.machine_name_userchosen, 12)
	}
	return res
}

pub fn cmsgclientrequestmachineauth_unpack(buf []byte) ?CMsgClientRequestMachineAuth {
	mut res := CMsgClientRequestMachineAuth{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			2 {
				res.has_eresult_sentryfile = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult_sentryfile = v
				i = ii
			}
			3 {
				res.has_filesize = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.filesize = v
				i = ii
			}
			4 {
				res.has_sha_sentryfile = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_sentryfile = v
				i = ii
			}
			6 {
				res.has_lock_account_action = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.lock_account_action = v
				i = ii
			}
			7 {
				res.has_otp_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_type = v
				i = ii
			}
			8 {
				res.has_otp_identifier = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_identifier = v
				i = ii
			}
			9 {
				res.has_otp_sharedsecret = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_sharedsecret = v
				i = ii
			}
			10 {
				res.has_otp_value = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_value = v
				i = ii
			}
			11 {
				res.has_machine_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.machine_name = v
				i = ii
			}
			12 {
				res.has_machine_name_userchosen = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.machine_name_userchosen = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestmachineauth() CMsgClientRequestMachineAuth {
	return CMsgClientRequestMachineAuth{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestmachineauth(o CMsgClientRequestMachineAuth, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestmachineauth(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestMachineAuth) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestmachineauth_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestMachineAuthResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
	has_eresult    bool
}

pub fn (o &CMsgClientRequestMachineAuthResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientrequestmachineauthresponse_unpack(buf []byte) ?CMsgClientRequestMachineAuthResponse {
	mut res := CMsgClientRequestMachineAuthResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestmachineauthresponse() CMsgClientRequestMachineAuthResponse {
	return CMsgClientRequestMachineAuthResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestmachineauthresponse(o CMsgClientRequestMachineAuthResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestmachineauthresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestMachineAuthResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestmachineauthresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRegisterKey {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
}

pub fn (o &CMsgClientRegisterKey) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	return res
}

pub fn cmsgclientregisterkey_unpack(buf []byte) ?CMsgClientRegisterKey {
	mut res := CMsgClientRegisterKey{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientregisterkey() CMsgClientRegisterKey {
	return CMsgClientRegisterKey{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientregisterkey(o CMsgClientRegisterKey, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientregisterkey(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRegisterKey) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientregisterkey_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPurchaseResponse {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	eresult                     int
	has_eresult                 bool
	purchase_result_details     int
	has_purchase_result_details bool
	purchase_receipt_info       []byte
	has_purchase_receipt_info   bool
}

pub fn (o &CMsgClientPurchaseResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_purchase_result_details {
		res << vproto.pack_int32_field(o.purchase_result_details, 2)
	}
	if o.has_purchase_receipt_info {
		res << vproto.pack_bytes_field(o.purchase_receipt_info, 3)
	}
	return res
}

pub fn cmsgclientpurchaseresponse_unpack(buf []byte) ?CMsgClientPurchaseResponse {
	mut res := CMsgClientPurchaseResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_purchase_result_details = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.purchase_result_details = v
				i = ii
			}
			3 {
				res.has_purchase_receipt_info = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.purchase_receipt_info = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpurchaseresponse() CMsgClientPurchaseResponse {
	return CMsgClientPurchaseResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpurchaseresponse(o CMsgClientPurchaseResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpurchaseresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPurchaseResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpurchaseresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientActivateOEMLicense {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	bios_manufacturer          string
	has_bios_manufacturer      bool
	bios_serialnumber          string
	has_bios_serialnumber      bool
	license_file               []byte
	has_license_file           bool
	mainboard_manufacturer     string
	has_mainboard_manufacturer bool
	mainboard_product          string
	has_mainboard_product      bool
	mainboard_serialnumber     string
	has_mainboard_serialnumber bool
}

pub fn (o &CMsgClientActivateOEMLicense) pack() []byte {
	mut res := []byte{}
	if o.has_bios_manufacturer {
		res << vproto.pack_string_field(o.bios_manufacturer, 1)
	}
	if o.has_bios_serialnumber {
		res << vproto.pack_string_field(o.bios_serialnumber, 2)
	}
	if o.has_license_file {
		res << vproto.pack_bytes_field(o.license_file, 3)
	}
	if o.has_mainboard_manufacturer {
		res << vproto.pack_string_field(o.mainboard_manufacturer, 4)
	}
	if o.has_mainboard_product {
		res << vproto.pack_string_field(o.mainboard_product, 5)
	}
	if o.has_mainboard_serialnumber {
		res << vproto.pack_string_field(o.mainboard_serialnumber, 6)
	}
	return res
}

pub fn cmsgclientactivateoemlicense_unpack(buf []byte) ?CMsgClientActivateOEMLicense {
	mut res := CMsgClientActivateOEMLicense{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_bios_manufacturer = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.bios_manufacturer = v
				i = ii
			}
			2 {
				res.has_bios_serialnumber = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.bios_serialnumber = v
				i = ii
			}
			3 {
				res.has_license_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.license_file = v
				i = ii
			}
			4 {
				res.has_mainboard_manufacturer = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.mainboard_manufacturer = v
				i = ii
			}
			5 {
				res.has_mainboard_product = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.mainboard_product = v
				i = ii
			}
			6 {
				res.has_mainboard_serialnumber = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.mainboard_serialnumber = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientactivateoemlicense() CMsgClientActivateOEMLicense {
	return CMsgClientActivateOEMLicense{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientactivateoemlicense(o CMsgClientActivateOEMLicense, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientactivateoemlicense(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientActivateOEMLicense) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientactivateoemlicense_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRegisterOEMMachine {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	oem_register_file     []byte
	has_oem_register_file bool
}

pub fn (o &CMsgClientRegisterOEMMachine) pack() []byte {
	mut res := []byte{}
	if o.has_oem_register_file {
		res << vproto.pack_bytes_field(o.oem_register_file, 1)
	}
	return res
}

pub fn cmsgclientregisteroemmachine_unpack(buf []byte) ?CMsgClientRegisterOEMMachine {
	mut res := CMsgClientRegisterOEMMachine{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_oem_register_file = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.oem_register_file = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientregisteroemmachine() CMsgClientRegisterOEMMachine {
	return CMsgClientRegisterOEMMachine{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientregisteroemmachine(o CMsgClientRegisterOEMMachine, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientregisteroemmachine(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRegisterOEMMachine) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientregisteroemmachine_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRegisterOEMMachineResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
	has_eresult    bool
}

pub fn (o &CMsgClientRegisterOEMMachineResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientregisteroemmachineresponse_unpack(buf []byte) ?CMsgClientRegisterOEMMachineResponse {
	mut res := CMsgClientRegisterOEMMachineResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientregisteroemmachineresponse() CMsgClientRegisterOEMMachineResponse {
	return CMsgClientRegisterOEMMachineResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientregisteroemmachineresponse(o CMsgClientRegisterOEMMachineResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientregisteroemmachineresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRegisterOEMMachineResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientregisteroemmachineresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPurchaseWithMachineID {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	package_id       u32
	has_package_id   bool
	machine_info     []byte
	has_machine_info bool
}

pub fn (o &CMsgClientPurchaseWithMachineID) pack() []byte {
	mut res := []byte{}
	if o.has_package_id {
		res << vproto.pack_uint32_field(o.package_id, 1)
	}
	if o.has_machine_info {
		res << vproto.pack_bytes_field(o.machine_info, 2)
	}
	return res
}

pub fn cmsgclientpurchasewithmachineid_unpack(buf []byte) ?CMsgClientPurchaseWithMachineID {
	mut res := CMsgClientPurchaseWithMachineID{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_package_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.package_id = v
				i = ii
			}
			2 {
				res.has_machine_info = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.machine_info = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientpurchasewithmachineid() CMsgClientPurchaseWithMachineID {
	return CMsgClientPurchaseWithMachineID{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientpurchasewithmachineid(o CMsgClientPurchaseWithMachineID, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientpurchasewithmachineid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPurchaseWithMachineID) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientpurchasewithmachineid_unpack(v)?
	return i, unpacked
}

pub struct CMsgTrading_InitiateTradeRequest {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	trade_request_id     u32
	has_trade_request_id bool
	other_steamid        u64
	has_other_steamid    bool
	other_name           string
	has_other_name       bool
}

pub fn (o &CMsgTrading_InitiateTradeRequest) pack() []byte {
	mut res := []byte{}
	if o.has_trade_request_id {
		res << vproto.pack_uint32_field(o.trade_request_id, 1)
	}
	if o.has_other_steamid {
		res << vproto.pack_uint64_field(o.other_steamid, 2)
	}
	if o.has_other_name {
		res << vproto.pack_string_field(o.other_name, 3)
	}
	return res
}

pub fn cmsgtrading_initiatetraderequest_unpack(buf []byte) ?CMsgTrading_InitiateTradeRequest {
	mut res := CMsgTrading_InitiateTradeRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_trade_request_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.trade_request_id = v
				i = ii
			}
			2 {
				res.has_other_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.other_steamid = v
				i = ii
			}
			3 {
				res.has_other_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.other_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtrading_initiatetraderequest() CMsgTrading_InitiateTradeRequest {
	return CMsgTrading_InitiateTradeRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtrading_initiatetraderequest(o CMsgTrading_InitiateTradeRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtrading_initiatetraderequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTrading_InitiateTradeRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgtrading_initiatetraderequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgTrading_InitiateTradeResponse {
mut:
	unknown_fields                            []vproto.UnknownField
pub mut:
	response                                  u32
	has_response                              bool
	trade_request_id                          u32
	has_trade_request_id                      bool
	other_steamid                             u64
	has_other_steamid                         bool
	steamguard_required_days                  u32
	has_steamguard_required_days              bool
	new_device_cooldown_days                  u32
	has_new_device_cooldown_days              bool
	default_password_reset_probation_days     u32
	has_default_password_reset_probation_days bool
	password_reset_probation_days             u32
	has_password_reset_probation_days         bool
	default_email_change_probation_days       u32
	has_default_email_change_probation_days   bool
	email_change_probation_days               u32
	has_email_change_probation_days           bool
}

pub fn (o &CMsgTrading_InitiateTradeResponse) pack() []byte {
	mut res := []byte{}
	if o.has_response {
		res << vproto.pack_uint32_field(o.response, 1)
	}
	if o.has_trade_request_id {
		res << vproto.pack_uint32_field(o.trade_request_id, 2)
	}
	if o.has_other_steamid {
		res << vproto.pack_uint64_field(o.other_steamid, 3)
	}
	if o.has_steamguard_required_days {
		res << vproto.pack_uint32_field(o.steamguard_required_days, 4)
	}
	if o.has_new_device_cooldown_days {
		res << vproto.pack_uint32_field(o.new_device_cooldown_days, 5)
	}
	if o.has_default_password_reset_probation_days {
		res << vproto.pack_uint32_field(o.default_password_reset_probation_days, 6)
	}
	if o.has_password_reset_probation_days {
		res << vproto.pack_uint32_field(o.password_reset_probation_days, 7)
	}
	if o.has_default_email_change_probation_days {
		res << vproto.pack_uint32_field(o.default_email_change_probation_days, 8)
	}
	if o.has_email_change_probation_days {
		res << vproto.pack_uint32_field(o.email_change_probation_days, 9)
	}
	return res
}

pub fn cmsgtrading_initiatetraderesponse_unpack(buf []byte) ?CMsgTrading_InitiateTradeResponse {
	mut res := CMsgTrading_InitiateTradeResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_response = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.response = v
				i = ii
			}
			2 {
				res.has_trade_request_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.trade_request_id = v
				i = ii
			}
			3 {
				res.has_other_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.other_steamid = v
				i = ii
			}
			4 {
				res.has_steamguard_required_days = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.steamguard_required_days = v
				i = ii
			}
			5 {
				res.has_new_device_cooldown_days = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.new_device_cooldown_days = v
				i = ii
			}
			6 {
				res.has_default_password_reset_probation_days = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.default_password_reset_probation_days = v
				i = ii
			}
			7 {
				res.has_password_reset_probation_days = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.password_reset_probation_days = v
				i = ii
			}
			8 {
				res.has_default_email_change_probation_days = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.default_email_change_probation_days = v
				i = ii
			}
			9 {
				res.has_email_change_probation_days = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.email_change_probation_days = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtrading_initiatetraderesponse() CMsgTrading_InitiateTradeResponse {
	return CMsgTrading_InitiateTradeResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtrading_initiatetraderesponse(o CMsgTrading_InitiateTradeResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtrading_initiatetraderesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTrading_InitiateTradeResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgtrading_initiatetraderesponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgTrading_CancelTradeRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	other_steamid     u64
	has_other_steamid bool
}

pub fn (o &CMsgTrading_CancelTradeRequest) pack() []byte {
	mut res := []byte{}
	if o.has_other_steamid {
		res << vproto.pack_uint64_field(o.other_steamid, 1)
	}
	return res
}

pub fn cmsgtrading_canceltraderequest_unpack(buf []byte) ?CMsgTrading_CancelTradeRequest {
	mut res := CMsgTrading_CancelTradeRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_other_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.other_steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtrading_canceltraderequest() CMsgTrading_CancelTradeRequest {
	return CMsgTrading_CancelTradeRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtrading_canceltraderequest(o CMsgTrading_CancelTradeRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtrading_canceltraderequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTrading_CancelTradeRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgtrading_canceltraderequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgTrading_StartSession {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	other_steamid     u64
	has_other_steamid bool
}

pub fn (o &CMsgTrading_StartSession) pack() []byte {
	mut res := []byte{}
	if o.has_other_steamid {
		res << vproto.pack_uint64_field(o.other_steamid, 1)
	}
	return res
}

pub fn cmsgtrading_startsession_unpack(buf []byte) ?CMsgTrading_StartSession {
	mut res := CMsgTrading_StartSession{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_other_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.other_steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtrading_startsession() CMsgTrading_StartSession {
	return CMsgTrading_StartSession{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtrading_startsession(o CMsgTrading_StartSession, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtrading_startsession(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgTrading_StartSession) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgtrading_startsession_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetCDNAuthToken {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	depot_id       u32
	has_depot_id   bool
	host_name      string
	has_host_name  bool
	app_id         u32
	has_app_id     bool
}

pub fn (o &CMsgClientGetCDNAuthToken) pack() []byte {
	mut res := []byte{}
	if o.has_depot_id {
		res << vproto.pack_uint32_field(o.depot_id, 1)
	}
	if o.has_host_name {
		res << vproto.pack_string_field(o.host_name, 2)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 3)
	}
	return res
}

pub fn cmsgclientgetcdnauthtoken_unpack(buf []byte) ?CMsgClientGetCDNAuthToken {
	mut res := CMsgClientGetCDNAuthToken{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_depot_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depot_id = v
				i = ii
			}
			2 {
				res.has_host_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.host_name = v
				i = ii
			}
			3 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetcdnauthtoken() CMsgClientGetCDNAuthToken {
	return CMsgClientGetCDNAuthToken{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetcdnauthtoken(o CMsgClientGetCDNAuthToken, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetcdnauthtoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetCDNAuthToken) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetcdnauthtoken_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetDepotDecryptionKey {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	depot_id       u32
	has_depot_id   bool
	app_id         u32
	has_app_id     bool
}

pub fn (o &CMsgClientGetDepotDecryptionKey) pack() []byte {
	mut res := []byte{}
	if o.has_depot_id {
		res << vproto.pack_uint32_field(o.depot_id, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	return res
}

pub fn cmsgclientgetdepotdecryptionkey_unpack(buf []byte) ?CMsgClientGetDepotDecryptionKey {
	mut res := CMsgClientGetDepotDecryptionKey{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_depot_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depot_id = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetdepotdecryptionkey() CMsgClientGetDepotDecryptionKey {
	return CMsgClientGetDepotDecryptionKey{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetdepotdecryptionkey(o CMsgClientGetDepotDecryptionKey, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetdepotdecryptionkey(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetDepotDecryptionKey) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetdepotdecryptionkey_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetDepotDecryptionKeyResponse {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	eresult                  int
	has_eresult              bool
	depot_id                 u32
	has_depot_id             bool
	depot_encryption_key     []byte
	has_depot_encryption_key bool
}

pub fn (o &CMsgClientGetDepotDecryptionKeyResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_depot_id {
		res << vproto.pack_uint32_field(o.depot_id, 2)
	}
	if o.has_depot_encryption_key {
		res << vproto.pack_bytes_field(o.depot_encryption_key, 3)
	}
	return res
}

pub fn cmsgclientgetdepotdecryptionkeyresponse_unpack(buf []byte) ?CMsgClientGetDepotDecryptionKeyResponse {
	mut res := CMsgClientGetDepotDecryptionKeyResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_depot_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depot_id = v
				i = ii
			}
			3 {
				res.has_depot_encryption_key = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.depot_encryption_key = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetdepotdecryptionkeyresponse() CMsgClientGetDepotDecryptionKeyResponse {
	return CMsgClientGetDepotDecryptionKeyResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetdepotdecryptionkeyresponse(o CMsgClientGetDepotDecryptionKeyResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetdepotdecryptionkeyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetDepotDecryptionKeyResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetdepotdecryptionkeyresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientCheckAppBetaPassword {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	app_id           u32
	has_app_id       bool
	betapassword     string
	has_betapassword bool
}

pub fn (o &CMsgClientCheckAppBetaPassword) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_betapassword {
		res << vproto.pack_string_field(o.betapassword, 2)
	}
	return res
}

pub fn cmsgclientcheckappbetapassword_unpack(buf []byte) ?CMsgClientCheckAppBetaPassword {
	mut res := CMsgClientCheckAppBetaPassword{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_betapassword = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.betapassword = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcheckappbetapassword() CMsgClientCheckAppBetaPassword {
	return CMsgClientCheckAppBetaPassword{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcheckappbetapassword(o CMsgClientCheckAppBetaPassword, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcheckappbetapassword(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCheckAppBetaPassword) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientcheckappbetapassword_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	betaname         string
	has_betaname     bool
	betapassword     string
	has_betapassword bool
}

pub fn (o &CMsgClientCheckAppBetaPasswordResponse_BetaPassword) pack() []byte {
	mut res := []byte{}
	if o.has_betaname {
		res << vproto.pack_string_field(o.betaname, 1)
	}
	if o.has_betapassword {
		res << vproto.pack_string_field(o.betapassword, 2)
	}
	return res
}

pub fn cmsgclientcheckappbetapasswordresponse_betapassword_unpack(buf []byte) ?CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
	mut res := CMsgClientCheckAppBetaPasswordResponse_BetaPassword{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_betaname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.betaname = v
				i = ii
			}
			2 {
				res.has_betapassword = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.betapassword = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcheckappbetapasswordresponse_betapassword() CMsgClientCheckAppBetaPasswordResponse_BetaPassword {
	return CMsgClientCheckAppBetaPasswordResponse_BetaPassword{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcheckappbetapasswordresponse_betapassword(o CMsgClientCheckAppBetaPasswordResponse_BetaPassword, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcheckappbetapasswordresponse_betapassword(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCheckAppBetaPasswordResponse_BetaPassword) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientcheckappbetapasswordresponse_betapassword_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientCheckAppBetaPasswordResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
	betapasswords  []CMsgClientCheckAppBetaPasswordResponse_BetaPassword
}

pub fn (o &CMsgClientCheckAppBetaPasswordResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	// [packed=false]
	for _, x in o.betapasswords {
		res << zzz_vproto_internal_pack_cmsgclientcheckappbetapasswordresponse_betapassword(x, 4)
	}
	return res
}

pub fn cmsgclientcheckappbetapasswordresponse_unpack(buf []byte) ?CMsgClientCheckAppBetaPasswordResponse {
	mut res := CMsgClientCheckAppBetaPasswordResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientcheckappbetapasswordresponse_betapassword(cur_buf,
					tag_wiretype.wire_type)?
				res.betapasswords << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcheckappbetapasswordresponse() CMsgClientCheckAppBetaPasswordResponse {
	return CMsgClientCheckAppBetaPasswordResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcheckappbetapasswordresponse(o CMsgClientCheckAppBetaPasswordResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcheckappbetapasswordresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCheckAppBetaPasswordResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientcheckappbetapasswordresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUpdateAppJobReport {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	app_id                      u32
	has_app_id                  bool
	depot_ids                   []u32
	app_state                   u32
	has_app_state               bool
	job_app_error               u32
	has_job_app_error           bool
	error_details               string
	has_error_details           bool
	job_duration                u32
	has_job_duration            bool
	files_validation_failed     u32
	has_files_validation_failed bool
	job_bytes_downloaded        u64
	has_job_bytes_downloaded    bool
	job_bytes_staged            u64
	has_job_bytes_staged        bool
	bytes_comitted              u64
	has_bytes_comitted          bool
	start_app_state             u32
	has_start_app_state         bool
	stats_machine_id            u64
	has_stats_machine_id        bool
	branch_name                 string
	has_branch_name             bool
	total_bytes_downloaded      u64
	has_total_bytes_downloaded  bool
	total_bytes_staged          u64
	has_total_bytes_staged      bool
	total_bytes_restored        u64
	has_total_bytes_restored    bool
	is_borrowed                 bool
	has_is_borrowed             bool
	is_free_weekend             bool
	has_is_free_weekend         bool
	total_bytes_legacy          u64
	has_total_bytes_legacy      bool
	total_bytes_patched         u64
	has_total_bytes_patched     bool
	total_bytes_saved           u64
	has_total_bytes_saved       bool
	cell_id                     u32
	has_cell_id                 bool
}

pub fn (o &CMsgClientUpdateAppJobReport) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	// [packed=false]
	for _, x in o.depot_ids {
		res << vproto.pack_uint32_field(x, 2)
	}
	if o.has_app_state {
		res << vproto.pack_uint32_field(o.app_state, 3)
	}
	if o.has_job_app_error {
		res << vproto.pack_uint32_field(o.job_app_error, 4)
	}
	if o.has_error_details {
		res << vproto.pack_string_field(o.error_details, 5)
	}
	if o.has_job_duration {
		res << vproto.pack_uint32_field(o.job_duration, 6)
	}
	if o.has_files_validation_failed {
		res << vproto.pack_uint32_field(o.files_validation_failed, 7)
	}
	if o.has_job_bytes_downloaded {
		res << vproto.pack_uint64_field(o.job_bytes_downloaded, 8)
	}
	if o.has_job_bytes_staged {
		res << vproto.pack_uint64_field(o.job_bytes_staged, 9)
	}
	if o.has_bytes_comitted {
		res << vproto.pack_uint64_field(o.bytes_comitted, 10)
	}
	if o.has_start_app_state {
		res << vproto.pack_uint32_field(o.start_app_state, 11)
	}
	if o.has_stats_machine_id {
		res << vproto.pack_64bit_field(o.stats_machine_id, 12)
	}
	if o.has_branch_name {
		res << vproto.pack_string_field(o.branch_name, 13)
	}
	if o.has_total_bytes_downloaded {
		res << vproto.pack_uint64_field(o.total_bytes_downloaded, 14)
	}
	if o.has_total_bytes_staged {
		res << vproto.pack_uint64_field(o.total_bytes_staged, 15)
	}
	if o.has_total_bytes_restored {
		res << vproto.pack_uint64_field(o.total_bytes_restored, 16)
	}
	if o.has_is_borrowed {
		res << vproto.pack_bool_field(o.is_borrowed, 17)
	}
	if o.has_is_free_weekend {
		res << vproto.pack_bool_field(o.is_free_weekend, 18)
	}
	if o.has_total_bytes_legacy {
		res << vproto.pack_uint64_field(o.total_bytes_legacy, 19)
	}
	if o.has_total_bytes_patched {
		res << vproto.pack_uint64_field(o.total_bytes_patched, 20)
	}
	if o.has_total_bytes_saved {
		res << vproto.pack_uint64_field(o.total_bytes_saved, 21)
	}
	if o.has_cell_id {
		res << vproto.pack_uint32_field(o.cell_id, 22)
	}
	return res
}

pub fn cmsgclientupdateappjobreport_unpack(buf []byte) ?CMsgClientUpdateAppJobReport {
	mut res := CMsgClientUpdateAppJobReport{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depot_ids << v
				i = ii
			}
			3 {
				res.has_app_state = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_state = v
				i = ii
			}
			4 {
				res.has_job_app_error = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.job_app_error = v
				i = ii
			}
			5 {
				res.has_error_details = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.error_details = v
				i = ii
			}
			6 {
				res.has_job_duration = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.job_duration = v
				i = ii
			}
			7 {
				res.has_files_validation_failed = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.files_validation_failed = v
				i = ii
			}
			8 {
				res.has_job_bytes_downloaded = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.job_bytes_downloaded = v
				i = ii
			}
			9 {
				res.has_job_bytes_staged = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.job_bytes_staged = v
				i = ii
			}
			10 {
				res.has_bytes_comitted = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes_comitted = v
				i = ii
			}
			11 {
				res.has_start_app_state = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_app_state = v
				i = ii
			}
			12 {
				res.has_stats_machine_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.stats_machine_id = v
				i = ii
			}
			13 {
				res.has_branch_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.branch_name = v
				i = ii
			}
			14 {
				res.has_total_bytes_downloaded = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.total_bytes_downloaded = v
				i = ii
			}
			15 {
				res.has_total_bytes_staged = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.total_bytes_staged = v
				i = ii
			}
			16 {
				res.has_total_bytes_restored = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.total_bytes_restored = v
				i = ii
			}
			17 {
				res.has_is_borrowed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_borrowed = v
				i = ii
			}
			18 {
				res.has_is_free_weekend = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_free_weekend = v
				i = ii
			}
			19 {
				res.has_total_bytes_legacy = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.total_bytes_legacy = v
				i = ii
			}
			20 {
				res.has_total_bytes_patched = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.total_bytes_patched = v
				i = ii
			}
			21 {
				res.has_total_bytes_saved = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.total_bytes_saved = v
				i = ii
			}
			22 {
				res.has_cell_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientupdateappjobreport() CMsgClientUpdateAppJobReport {
	return CMsgClientUpdateAppJobReport{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientupdateappjobreport(o CMsgClientUpdateAppJobReport, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientupdateappjobreport(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUpdateAppJobReport) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientupdateappjobreport_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientDPContentStatsReport {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	stats_machine_id         u64
	has_stats_machine_id     bool
	country_code             string
	has_country_code         bool
	os_type                  int
	has_os_type              bool
	language                 int
	has_language             bool
	num_install_folders      u32
	has_num_install_folders  bool
	num_installed_games      u32
	has_num_installed_games  bool
	size_installed_games     u64
	has_size_installed_games bool
}

pub fn (o &CMsgClientDPContentStatsReport) pack() []byte {
	mut res := []byte{}
	if o.has_stats_machine_id {
		res << vproto.pack_64bit_field(o.stats_machine_id, 1)
	}
	if o.has_country_code {
		res << vproto.pack_string_field(o.country_code, 2)
	}
	if o.has_os_type {
		res << vproto.pack_int32_field(o.os_type, 3)
	}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 4)
	}
	if o.has_num_install_folders {
		res << vproto.pack_uint32_field(o.num_install_folders, 5)
	}
	if o.has_num_installed_games {
		res << vproto.pack_uint32_field(o.num_installed_games, 6)
	}
	if o.has_size_installed_games {
		res << vproto.pack_uint64_field(o.size_installed_games, 7)
	}
	return res
}

pub fn cmsgclientdpcontentstatsreport_unpack(buf []byte) ?CMsgClientDPContentStatsReport {
	mut res := CMsgClientDPContentStatsReport{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_stats_machine_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.stats_machine_id = v
				i = ii
			}
			2 {
				res.has_country_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.country_code = v
				i = ii
			}
			3 {
				res.has_os_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.os_type = v
				i = ii
			}
			4 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			5 {
				res.has_num_install_folders = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_install_folders = v
				i = ii
			}
			6 {
				res.has_num_installed_games = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.num_installed_games = v
				i = ii
			}
			7 {
				res.has_size_installed_games = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.size_installed_games = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdpcontentstatsreport() CMsgClientDPContentStatsReport {
	return CMsgClientDPContentStatsReport{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdpcontentstatsreport(o CMsgClientDPContentStatsReport, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdpcontentstatsreport(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDPContentStatsReport) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientdpcontentstatsreport_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetCDNAuthTokenResponse {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	eresult             u32
	has_eresult         bool
	token               string
	has_token           bool
	expiration_time     u32
	has_expiration_time bool
}

pub fn (o &CMsgClientGetCDNAuthTokenResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	if o.has_token {
		res << vproto.pack_string_field(o.token, 2)
	}
	if o.has_expiration_time {
		res << vproto.pack_uint32_field(o.expiration_time, 3)
	}
	return res
}

pub fn cmsgclientgetcdnauthtokenresponse_unpack(buf []byte) ?CMsgClientGetCDNAuthTokenResponse {
	mut res := CMsgClientGetCDNAuthTokenResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			3 {
				res.has_expiration_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.expiration_time = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetcdnauthtokenresponse() CMsgClientGetCDNAuthTokenResponse {
	return CMsgClientGetCDNAuthTokenResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetcdnauthtokenresponse(o CMsgClientGetCDNAuthTokenResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetcdnauthtokenresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetCDNAuthTokenResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetcdnauthtokenresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgDownloadRateStatistics_StatsInfo {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	source_type      u32
	has_source_type  bool
	source_id        u32
	has_source_id    bool
	seconds          u32
	has_seconds      bool
	bytes            u64
	has_bytes        bool
	host_name        string
	has_host_name    bool
	microseconds     u64
	has_microseconds bool
	used_ipv6        bool
	has_used_ipv6    bool
	proxied          bool
	has_proxied      bool
}

pub fn (o &CMsgDownloadRateStatistics_StatsInfo) pack() []byte {
	mut res := []byte{}
	if o.has_source_type {
		res << vproto.pack_uint32_field(o.source_type, 1)
	}
	if o.has_source_id {
		res << vproto.pack_uint32_field(o.source_id, 2)
	}
	if o.has_seconds {
		res << vproto.pack_uint32_field(o.seconds, 3)
	}
	if o.has_bytes {
		res << vproto.pack_uint64_field(o.bytes, 4)
	}
	if o.has_host_name {
		res << vproto.pack_string_field(o.host_name, 5)
	}
	if o.has_microseconds {
		res << vproto.pack_uint64_field(o.microseconds, 6)
	}
	if o.has_used_ipv6 {
		res << vproto.pack_bool_field(o.used_ipv6, 7)
	}
	if o.has_proxied {
		res << vproto.pack_bool_field(o.proxied, 8)
	}
	return res
}

pub fn cmsgdownloadratestatistics_statsinfo_unpack(buf []byte) ?CMsgDownloadRateStatistics_StatsInfo {
	mut res := CMsgDownloadRateStatistics_StatsInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_source_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.source_type = v
				i = ii
			}
			2 {
				res.has_source_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.source_id = v
				i = ii
			}
			3 {
				res.has_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds = v
				i = ii
			}
			4 {
				res.has_bytes = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bytes = v
				i = ii
			}
			5 {
				res.has_host_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.host_name = v
				i = ii
			}
			6 {
				res.has_microseconds = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.microseconds = v
				i = ii
			}
			7 {
				res.has_used_ipv6 = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.used_ipv6 = v
				i = ii
			}
			8 {
				res.has_proxied = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.proxied = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdownloadratestatistics_statsinfo() CMsgDownloadRateStatistics_StatsInfo {
	return CMsgDownloadRateStatistics_StatsInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdownloadratestatistics_statsinfo(o CMsgDownloadRateStatistics_StatsInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdownloadratestatistics_statsinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDownloadRateStatistics_StatsInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdownloadratestatistics_statsinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgDownloadRateStatistics {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	cell_id             u32
	has_cell_id         bool
	stats               []CMsgDownloadRateStatistics_StatsInfo
	throttling_kbps     u32
	has_throttling_kbps bool
}

pub fn (o &CMsgDownloadRateStatistics) pack() []byte {
	mut res := []byte{}
	if o.has_cell_id {
		res << vproto.pack_uint32_field(o.cell_id, 1)
	}
	// [packed=false]
	for _, x in o.stats {
		res << zzz_vproto_internal_pack_cmsgdownloadratestatistics_statsinfo(x, 2)
	}
	if o.has_throttling_kbps {
		res << vproto.pack_uint32_field(o.throttling_kbps, 3)
	}
	return res
}

pub fn cmsgdownloadratestatistics_unpack(buf []byte) ?CMsgDownloadRateStatistics {
	mut res := CMsgDownloadRateStatistics{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_cell_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgdownloadratestatistics_statsinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.stats << v
				i = ii
			}
			3 {
				res.has_throttling_kbps = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.throttling_kbps = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdownloadratestatistics() CMsgDownloadRateStatistics {
	return CMsgDownloadRateStatistics{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdownloadratestatistics(o CMsgDownloadRateStatistics, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdownloadratestatistics(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDownloadRateStatistics) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdownloadratestatistics_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestAccountData {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	account_or_email     string
	has_account_or_email bool
	action               u32
	has_action           bool
}

pub fn (o &CMsgClientRequestAccountData) pack() []byte {
	mut res := []byte{}
	if o.has_account_or_email {
		res << vproto.pack_string_field(o.account_or_email, 1)
	}
	if o.has_action {
		res << vproto.pack_uint32_field(o.action, 2)
	}
	return res
}

pub fn cmsgclientrequestaccountdata_unpack(buf []byte) ?CMsgClientRequestAccountData {
	mut res := CMsgClientRequestAccountData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_account_or_email = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.account_or_email = v
				i = ii
			}
			2 {
				res.has_action = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.action = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestaccountdata() CMsgClientRequestAccountData {
	return CMsgClientRequestAccountData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestaccountdata(o CMsgClientRequestAccountData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestaccountdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestAccountData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestaccountdata_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestAccountDataResponse {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	action                       u32
	has_action                   bool
	eresult                      u32
	has_eresult                  bool
	account_name                 string
	has_account_name             bool
	ct_matches                   u32
	has_ct_matches               bool
	account_name_suggestion1     string
	has_account_name_suggestion1 bool
	account_name_suggestion2     string
	has_account_name_suggestion2 bool
	account_name_suggestion3     string
	has_account_name_suggestion3 bool
}

pub fn (o &CMsgClientRequestAccountDataResponse) pack() []byte {
	mut res := []byte{}
	if o.has_action {
		res << vproto.pack_uint32_field(o.action, 1)
	}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 2)
	}
	if o.has_account_name {
		res << vproto.pack_string_field(o.account_name, 3)
	}
	if o.has_ct_matches {
		res << vproto.pack_uint32_field(o.ct_matches, 4)
	}
	if o.has_account_name_suggestion1 {
		res << vproto.pack_string_field(o.account_name_suggestion1, 5)
	}
	if o.has_account_name_suggestion2 {
		res << vproto.pack_string_field(o.account_name_suggestion2, 6)
	}
	if o.has_account_name_suggestion3 {
		res << vproto.pack_string_field(o.account_name_suggestion3, 7)
	}
	return res
}

pub fn cmsgclientrequestaccountdataresponse_unpack(buf []byte) ?CMsgClientRequestAccountDataResponse {
	mut res := CMsgClientRequestAccountDataResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_action = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.action = v
				i = ii
			}
			2 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			3 {
				res.has_account_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.account_name = v
				i = ii
			}
			4 {
				res.has_ct_matches = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ct_matches = v
				i = ii
			}
			5 {
				res.has_account_name_suggestion1 = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.account_name_suggestion1 = v
				i = ii
			}
			6 {
				res.has_account_name_suggestion2 = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.account_name_suggestion2 = v
				i = ii
			}
			7 {
				res.has_account_name_suggestion3 = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.account_name_suggestion3 = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestaccountdataresponse() CMsgClientRequestAccountDataResponse {
	return CMsgClientRequestAccountDataResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestaccountdataresponse(o CMsgClientRequestAccountDataResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestaccountdataresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestAccountDataResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestaccountdataresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUGSGetGlobalStats {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	gameid                     u64
	has_gameid                 bool
	history_days_requested     u32
	has_history_days_requested bool
	time_last_requested        u32
	has_time_last_requested    bool
	first_day_cached           u32
	has_first_day_cached       bool
	days_cached                u32
	has_days_cached            bool
}

pub fn (o &CMsgClientUGSGetGlobalStats) pack() []byte {
	mut res := []byte{}
	if o.has_gameid {
		res << vproto.pack_uint64_field(o.gameid, 1)
	}
	if o.has_history_days_requested {
		res << vproto.pack_uint32_field(o.history_days_requested, 2)
	}
	if o.has_time_last_requested {
		res << vproto.pack_32bit_field(o.time_last_requested, 3)
	}
	if o.has_first_day_cached {
		res << vproto.pack_uint32_field(o.first_day_cached, 4)
	}
	if o.has_days_cached {
		res << vproto.pack_uint32_field(o.days_cached, 5)
	}
	return res
}

pub fn cmsgclientugsgetglobalstats_unpack(buf []byte) ?CMsgClientUGSGetGlobalStats {
	mut res := CMsgClientUGSGetGlobalStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_gameid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			2 {
				res.has_history_days_requested = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.history_days_requested = v
				i = ii
			}
			3 {
				res.has_time_last_requested = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last_requested = v
				i = ii
			}
			4 {
				res.has_first_day_cached = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.first_day_cached = v
				i = ii
			}
			5 {
				res.has_days_cached = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.days_cached = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientugsgetglobalstats() CMsgClientUGSGetGlobalStats {
	return CMsgClientUGSGetGlobalStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientugsgetglobalstats(o CMsgClientUGSGetGlobalStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientugsgetglobalstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUGSGetGlobalStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientugsgetglobalstats_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUGSGetGlobalStatsResponseDay_Stat {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stat_id        int
	has_stat_id    bool
	data           i64
	has_data       bool
}

pub fn (o &CMsgClientUGSGetGlobalStatsResponseDay_Stat) pack() []byte {
	mut res := []byte{}
	if o.has_stat_id {
		res << vproto.pack_int32_field(o.stat_id, 1)
	}
	if o.has_data {
		res << vproto.pack_int64_field(o.data, 2)
	}
	return res
}

pub fn cmsgclientugsgetglobalstatsresponseday_stat_unpack(buf []byte) ?CMsgClientUGSGetGlobalStatsResponseDay_Stat {
	mut res := CMsgClientUGSGetGlobalStatsResponseDay_Stat{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_stat_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.stat_id = v
				i = ii
			}
			2 {
				res.has_data = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
				res.data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientugsgetglobalstatsresponseday_stat() CMsgClientUGSGetGlobalStatsResponseDay_Stat {
	return CMsgClientUGSGetGlobalStatsResponseDay_Stat{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientugsgetglobalstatsresponseday_stat(o CMsgClientUGSGetGlobalStatsResponseDay_Stat, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientugsgetglobalstatsresponseday_stat(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUGSGetGlobalStatsResponseDay_Stat) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientugsgetglobalstatsresponseday_stat_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUGSGetGlobalStatsResponse_Day {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	day_id         u32
	has_day_id     bool
	stats          []CMsgClientUGSGetGlobalStatsResponseDay_Stat
}

pub fn (o &CMsgClientUGSGetGlobalStatsResponse_Day) pack() []byte {
	mut res := []byte{}
	if o.has_day_id {
		res << vproto.pack_uint32_field(o.day_id, 1)
	}
	// [packed=false]
	for _, x in o.stats {
		res << zzz_vproto_internal_pack_cmsgclientugsgetglobalstatsresponseday_stat(x, 2)
	}
	return res
}

pub fn cmsgclientugsgetglobalstatsresponse_day_unpack(buf []byte) ?CMsgClientUGSGetGlobalStatsResponse_Day {
	mut res := CMsgClientUGSGetGlobalStatsResponse_Day{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_day_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.day_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientugsgetglobalstatsresponseday_stat(cur_buf,
					tag_wiretype.wire_type)?
				res.stats << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientugsgetglobalstatsresponse_day() CMsgClientUGSGetGlobalStatsResponse_Day {
	return CMsgClientUGSGetGlobalStatsResponse_Day{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientugsgetglobalstatsresponse_day(o CMsgClientUGSGetGlobalStatsResponse_Day, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientugsgetglobalstatsresponse_day(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUGSGetGlobalStatsResponse_Day) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientugsgetglobalstatsresponse_day_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUGSGetGlobalStatsResponse {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	eresult         int
	has_eresult     bool
	timestamp       u32
	has_timestamp   bool
	day_current     int
	has_day_current bool
	days            []CMsgClientUGSGetGlobalStatsResponse_Day
}

pub fn (o &CMsgClientUGSGetGlobalStatsResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_timestamp {
		res << vproto.pack_32bit_field(o.timestamp, 2)
	}
	if o.has_day_current {
		res << vproto.pack_int32_field(o.day_current, 3)
	}
	// [packed=false]
	for _, x in o.days {
		res << zzz_vproto_internal_pack_cmsgclientugsgetglobalstatsresponse_day(x, 4)
	}
	return res
}

pub fn cmsgclientugsgetglobalstatsresponse_unpack(buf []byte) ?CMsgClientUGSGetGlobalStatsResponse {
	mut res := CMsgClientUGSGetGlobalStatsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_timestamp = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			3 {
				res.has_day_current = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.day_current = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientugsgetglobalstatsresponse_day(cur_buf,
					tag_wiretype.wire_type)?
				res.days << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientugsgetglobalstatsresponse() CMsgClientUGSGetGlobalStatsResponse {
	return CMsgClientUGSGetGlobalStatsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientugsgetglobalstatsresponse(o CMsgClientUGSGetGlobalStatsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientugsgetglobalstatsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUGSGetGlobalStatsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientugsgetglobalstatsresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgGameServerData_Player {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	has_steam_id   bool
}

pub fn (o &CMsgGameServerData_Player) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	return res
}

pub fn cmsggameserverdata_player_unpack(buf []byte) ?CMsgGameServerData_Player {
	mut res := CMsgGameServerData_Player{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameserverdata_player() CMsgGameServerData_Player {
	return CMsgGameServerData_Player{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameserverdata_player(o CMsgGameServerData_Player, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameserverdata_player(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameServerData_Player) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggameserverdata_player_unpack(v)?
	return i, unpacked
}

pub struct CMsgGameServerData {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	steam_id_gs           u64
	has_steam_id_gs       bool
	deprecated_ip         u32
	has_deprecated_ip     bool
	query_port            u32
	has_query_port        bool
	game_port             u32
	has_game_port         bool
	sourcetv_port         u32
	has_sourcetv_port     bool
	name                  string
	has_name              bool
	game_ip_address       CMsgIPAddress
	has_game_ip_address   bool
	app_id                u32
	has_app_id            bool
	gamedir               string
	has_gamedir           bool
	version               string
	has_version           bool
	product               string
	has_product           bool
	region                string
	has_region            bool
	players               []CMsgGameServerData_Player
	max_players           u32
	has_max_players       bool
	bot_count             u32
	has_bot_count         bool
	password              bool
	has_password          bool
	secure                bool
	has_secure            bool
	dedicated             bool
	has_dedicated         bool
	os                    string
	has_os                bool
	game_data             string
	has_game_data         bool
	game_data_version     u32
	has_game_data_version bool
	game_type             string
	has_game_type         bool
	map                   string
	has_map               bool
}

pub fn (o &CMsgGameServerData) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id_gs {
		res << vproto.pack_64bit_field(o.steam_id_gs, 1)
	}
	if o.has_deprecated_ip {
		res << vproto.pack_uint32_field(o.deprecated_ip, 2)
	}
	if o.has_query_port {
		res << vproto.pack_uint32_field(o.query_port, 3)
	}
	if o.has_game_port {
		res << vproto.pack_uint32_field(o.game_port, 4)
	}
	if o.has_sourcetv_port {
		res << vproto.pack_uint32_field(o.sourcetv_port, 5)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 22)
	}
	if o.has_game_ip_address {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.game_ip_address, 23)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 6)
	}
	if o.has_gamedir {
		res << vproto.pack_string_field(o.gamedir, 7)
	}
	if o.has_version {
		res << vproto.pack_string_field(o.version, 8)
	}
	if o.has_product {
		res << vproto.pack_string_field(o.product, 9)
	}
	if o.has_region {
		res << vproto.pack_string_field(o.region, 10)
	}
	// [packed=false]
	for _, x in o.players {
		res << zzz_vproto_internal_pack_cmsggameserverdata_player(x, 11)
	}
	if o.has_max_players {
		res << vproto.pack_uint32_field(o.max_players, 12)
	}
	if o.has_bot_count {
		res << vproto.pack_uint32_field(o.bot_count, 13)
	}
	if o.has_password {
		res << vproto.pack_bool_field(o.password, 14)
	}
	if o.has_secure {
		res << vproto.pack_bool_field(o.secure, 15)
	}
	if o.has_dedicated {
		res << vproto.pack_bool_field(o.dedicated, 16)
	}
	if o.has_os {
		res << vproto.pack_string_field(o.os, 17)
	}
	if o.has_game_data {
		res << vproto.pack_string_field(o.game_data, 18)
	}
	if o.has_game_data_version {
		res << vproto.pack_uint32_field(o.game_data_version, 19)
	}
	if o.has_game_type {
		res << vproto.pack_string_field(o.game_type, 20)
	}
	if o.has_map {
		res << vproto.pack_string_field(o.map, 21)
	}
	return res
}

pub fn cmsggameserverdata_unpack(buf []byte) ?CMsgGameServerData {
	mut res := CMsgGameServerData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id_gs = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_gs = v
				i = ii
			}
			2 {
				res.has_deprecated_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_ip = v
				i = ii
			}
			3 {
				res.has_query_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.query_port = v
				i = ii
			}
			4 {
				res.has_game_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_port = v
				i = ii
			}
			5 {
				res.has_sourcetv_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sourcetv_port = v
				i = ii
			}
			22 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			23 {
				res.has_game_ip_address = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.game_ip_address = v
				i = ii
			}
			6 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			7 {
				res.has_gamedir = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.gamedir = v
				i = ii
			}
			8 {
				res.has_version = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.version = v
				i = ii
			}
			9 {
				res.has_product = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.product = v
				i = ii
			}
			10 {
				res.has_region = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.region = v
				i = ii
			}
			11 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsggameserverdata_player(cur_buf,
					tag_wiretype.wire_type)?
				res.players << v
				i = ii
			}
			12 {
				res.has_max_players = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_players = v
				i = ii
			}
			13 {
				res.has_bot_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.bot_count = v
				i = ii
			}
			14 {
				res.has_password = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.password = v
				i = ii
			}
			15 {
				res.has_secure = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.secure = v
				i = ii
			}
			16 {
				res.has_dedicated = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.dedicated = v
				i = ii
			}
			17 {
				res.has_os = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.os = v
				i = ii
			}
			18 {
				res.has_game_data = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_data = v
				i = ii
			}
			19 {
				res.has_game_data_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_data_version = v
				i = ii
			}
			20 {
				res.has_game_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_type = v
				i = ii
			}
			21 {
				res.has_map = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.map = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameserverdata() CMsgGameServerData {
	return CMsgGameServerData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameserverdata(o CMsgGameServerData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameserverdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameServerData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggameserverdata_unpack(v)?
	return i, unpacked
}

pub struct CMsgGameServerRemove {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	steam_id          u64
	has_steam_id      bool
	deprecated_ip     u32
	has_deprecated_ip bool
	query_port        u32
	has_query_port    bool
	ip                CMsgIPAddress
	has_ip            bool
}

pub fn (o &CMsgGameServerRemove) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	if o.has_deprecated_ip {
		res << vproto.pack_uint32_field(o.deprecated_ip, 2)
	}
	if o.has_query_port {
		res << vproto.pack_uint32_field(o.query_port, 3)
	}
	if o.has_ip {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.ip, 4)
	}
	return res
}

pub fn cmsggameserverremove_unpack(buf []byte) ?CMsgGameServerRemove {
	mut res := CMsgGameServerRemove{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			2 {
				res.has_deprecated_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_ip = v
				i = ii
			}
			3 {
				res.has_query_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.query_port = v
				i = ii
			}
			4 {
				res.has_ip = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.ip = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameserverremove() CMsgGameServerRemove {
	return CMsgGameServerRemove{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameserverremove(o CMsgGameServerRemove, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameserverremove(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameServerRemove) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggameserverremove_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGMSServerQuery {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	app_id              u32
	has_app_id          bool
	geo_location_ip     u32
	has_geo_location_ip bool
	region_code         u32
	has_region_code     bool
	filter_text         string
	has_filter_text     bool
	max_servers         u32
	has_max_servers     bool
}

pub fn (o &CMsgClientGMSServerQuery) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_geo_location_ip {
		res << vproto.pack_uint32_field(o.geo_location_ip, 2)
	}
	if o.has_region_code {
		res << vproto.pack_uint32_field(o.region_code, 3)
	}
	if o.has_filter_text {
		res << vproto.pack_string_field(o.filter_text, 4)
	}
	if o.has_max_servers {
		res << vproto.pack_uint32_field(o.max_servers, 5)
	}
	return res
}

pub fn cmsgclientgmsserverquery_unpack(buf []byte) ?CMsgClientGMSServerQuery {
	mut res := CMsgClientGMSServerQuery{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_geo_location_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.geo_location_ip = v
				i = ii
			}
			3 {
				res.has_region_code = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.region_code = v
				i = ii
			}
			4 {
				res.has_filter_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filter_text = v
				i = ii
			}
			5 {
				res.has_max_servers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_servers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgmsserverquery() CMsgClientGMSServerQuery {
	return CMsgClientGMSServerQuery{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgmsserverquery(o CMsgClientGMSServerQuery, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgmsserverquery(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGMSServerQuery) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgmsserverquery_unpack(v)?
	return i, unpacked
}

pub struct CMsgGMSClientServerQueryResponse_Server {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	deprecated_server_ip     u32
	has_deprecated_server_ip bool
	server_port              u32
	has_server_port          bool
	auth_players             u32
	has_auth_players         bool
	server_ip                CMsgIPAddress
	has_server_ip            bool
}

pub fn (o &CMsgGMSClientServerQueryResponse_Server) pack() []byte {
	mut res := []byte{}
	if o.has_deprecated_server_ip {
		res << vproto.pack_uint32_field(o.deprecated_server_ip, 1)
	}
	if o.has_server_port {
		res << vproto.pack_uint32_field(o.server_port, 2)
	}
	if o.has_auth_players {
		res << vproto.pack_uint32_field(o.auth_players, 3)
	}
	if o.has_server_ip {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.server_ip, 4)
	}
	return res
}

pub fn cmsggmsclientserverqueryresponse_server_unpack(buf []byte) ?CMsgGMSClientServerQueryResponse_Server {
	mut res := CMsgGMSClientServerQueryResponse_Server{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_deprecated_server_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_server_ip = v
				i = ii
			}
			2 {
				res.has_server_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.server_port = v
				i = ii
			}
			3 {
				res.has_auth_players = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_players = v
				i = ii
			}
			4 {
				res.has_server_ip = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.server_ip = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggmsclientserverqueryresponse_server() CMsgGMSClientServerQueryResponse_Server {
	return CMsgGMSClientServerQueryResponse_Server{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggmsclientserverqueryresponse_server(o CMsgGMSClientServerQueryResponse_Server, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggmsclientserverqueryresponse_server(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGMSClientServerQueryResponse_Server) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggmsclientserverqueryresponse_server_unpack(v)?
	return i, unpacked
}

pub struct CMsgGMSClientServerQueryResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	servers        []CMsgGMSClientServerQueryResponse_Server
	error          string
	has_error      bool
}

pub fn (o &CMsgGMSClientServerQueryResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.servers {
		res << zzz_vproto_internal_pack_cmsggmsclientserverqueryresponse_server(x, 1)
	}
	if o.has_error {
		res << vproto.pack_string_field(o.error, 2)
	}
	return res
}

pub fn cmsggmsclientserverqueryresponse_unpack(buf []byte) ?CMsgGMSClientServerQueryResponse {
	mut res := CMsgGMSClientServerQueryResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsggmsclientserverqueryresponse_server(cur_buf,
					tag_wiretype.wire_type)?
				res.servers << v
				i = ii
			}
			2 {
				res.has_error = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.error = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggmsclientserverqueryresponse() CMsgGMSClientServerQueryResponse {
	return CMsgGMSClientServerQueryResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggmsclientserverqueryresponse(o CMsgGMSClientServerQueryResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggmsclientserverqueryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGMSClientServerQueryResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggmsclientserverqueryresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgGameServerOutOfDate {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	steam_id_gs     u64
	has_steam_id_gs bool
	reject          bool
	has_reject      bool
	message         string
	has_message     bool
}

pub fn (o &CMsgGameServerOutOfDate) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id_gs {
		res << vproto.pack_64bit_field(o.steam_id_gs, 1)
	}
	if o.has_reject {
		res << vproto.pack_bool_field(o.reject, 2)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 3)
	}
	return res
}

pub fn cmsggameserveroutofdate_unpack(buf []byte) ?CMsgGameServerOutOfDate {
	mut res := CMsgGameServerOutOfDate{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id_gs = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_gs = v
				i = ii
			}
			2 {
				res.has_reject = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.reject = v
				i = ii
			}
			3 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameserveroutofdate() CMsgGameServerOutOfDate {
	return CMsgGameServerOutOfDate{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameserveroutofdate(o CMsgGameServerOutOfDate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameserveroutofdate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameServerOutOfDate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggameserveroutofdate_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRedeemGuestPass {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	guest_pass_id     u64
	has_guest_pass_id bool
}

pub fn (o &CMsgClientRedeemGuestPass) pack() []byte {
	mut res := []byte{}
	if o.has_guest_pass_id {
		res << vproto.pack_64bit_field(o.guest_pass_id, 1)
	}
	return res
}

pub fn cmsgclientredeemguestpass_unpack(buf []byte) ?CMsgClientRedeemGuestPass {
	mut res := CMsgClientRedeemGuestPass{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_guest_pass_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.guest_pass_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientredeemguestpass() CMsgClientRedeemGuestPass {
	return CMsgClientRedeemGuestPass{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientredeemguestpass(o CMsgClientRedeemGuestPass, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientredeemguestpass(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRedeemGuestPass) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientredeemguestpass_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRedeemGuestPassResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	eresult            u32
	has_eresult        bool
	package_id         u32
	has_package_id     bool
	must_own_appid     u32
	has_must_own_appid bool
}

pub fn (o &CMsgClientRedeemGuestPassResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	if o.has_package_id {
		res << vproto.pack_uint32_field(o.package_id, 2)
	}
	if o.has_must_own_appid {
		res << vproto.pack_uint32_field(o.must_own_appid, 3)
	}
	return res
}

pub fn cmsgclientredeemguestpassresponse_unpack(buf []byte) ?CMsgClientRedeemGuestPassResponse {
	mut res := CMsgClientRedeemGuestPassResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_package_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.package_id = v
				i = ii
			}
			3 {
				res.has_must_own_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.must_own_appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientredeemguestpassresponse() CMsgClientRedeemGuestPassResponse {
	return CMsgClientRedeemGuestPassResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientredeemguestpassresponse(o CMsgClientRedeemGuestPassResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientredeemguestpassresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRedeemGuestPassResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientredeemguestpassresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetClanActivityCounts {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid_clans  []u64
}

pub fn (o &CMsgClientGetClanActivityCounts) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.steamid_clans {
		res << vproto.pack_uint64_field(x, 1)
	}
	return res
}

pub fn cmsgclientgetclanactivitycounts_unpack(buf []byte) ?CMsgClientGetClanActivityCounts {
	mut res := CMsgClientGetClanActivityCounts{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid_clans << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclanactivitycounts() CMsgClientGetClanActivityCounts {
	return CMsgClientGetClanActivityCounts{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclanactivitycounts(o CMsgClientGetClanActivityCounts, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclanactivitycounts(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClanActivityCounts) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetclanactivitycounts_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetClanActivityCountsResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
	has_eresult    bool
}

pub fn (o &CMsgClientGetClanActivityCountsResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientgetclanactivitycountsresponse_unpack(buf []byte) ?CMsgClientGetClanActivityCountsResponse {
	mut res := CMsgClientGetClanActivityCountsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetclanactivitycountsresponse() CMsgClientGetClanActivityCountsResponse {
	return CMsgClientGetClanActivityCountsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetclanactivitycountsresponse(o CMsgClientGetClanActivityCountsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetclanactivitycountsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetClanActivityCountsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetclanactivitycountsresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientOGSReportString {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	accumulated     bool
	has_accumulated bool
	sessionid       u64
	has_sessionid   bool
	severity        int
	has_severity    bool
	formatter       string
	has_formatter   bool
	varargs         []byte
	has_varargs     bool
}

pub fn (o &CMsgClientOGSReportString) pack() []byte {
	mut res := []byte{}
	if o.has_accumulated {
		res << vproto.pack_bool_field(o.accumulated, 1)
	}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 2)
	}
	if o.has_severity {
		res << vproto.pack_int32_field(o.severity, 3)
	}
	if o.has_formatter {
		res << vproto.pack_string_field(o.formatter, 4)
	}
	if o.has_varargs {
		res << vproto.pack_bytes_field(o.varargs, 5)
	}
	return res
}

pub fn cmsgclientogsreportstring_unpack(buf []byte) ?CMsgClientOGSReportString {
	mut res := CMsgClientOGSReportString{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accumulated = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.accumulated = v
				i = ii
			}
			2 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			3 {
				res.has_severity = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.severity = v
				i = ii
			}
			4 {
				res.has_formatter = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.formatter = v
				i = ii
			}
			5 {
				res.has_varargs = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.varargs = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientogsreportstring() CMsgClientOGSReportString {
	return CMsgClientOGSReportString{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientogsreportstring(o CMsgClientOGSReportString, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientogsreportstring(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientOGSReportString) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientogsreportstring_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientOGSReportBug {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessionid      u64
	has_sessionid  bool
	bugtext        string
	has_bugtext    bool
	screenshot     []byte
	has_screenshot bool
}

pub fn (o &CMsgClientOGSReportBug) pack() []byte {
	mut res := []byte{}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 1)
	}
	if o.has_bugtext {
		res << vproto.pack_string_field(o.bugtext, 2)
	}
	if o.has_screenshot {
		res << vproto.pack_bytes_field(o.screenshot, 3)
	}
	return res
}

pub fn cmsgclientogsreportbug_unpack(buf []byte) ?CMsgClientOGSReportBug {
	mut res := CMsgClientOGSReportBug{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			2 {
				res.has_bugtext = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.bugtext = v
				i = ii
			}
			3 {
				res.has_screenshot = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.screenshot = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientogsreportbug() CMsgClientOGSReportBug {
	return CMsgClientOGSReportBug{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientogsreportbug(o CMsgClientOGSReportBug, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientogsreportbug(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientOGSReportBug) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientogsreportbug_unpack(v)?
	return i, unpacked
}

pub struct CMsgGSAssociateWithClan {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	steam_id_clan     u64
	has_steam_id_clan bool
}

pub fn (o &CMsgGSAssociateWithClan) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id_clan {
		res << vproto.pack_64bit_field(o.steam_id_clan, 1)
	}
	return res
}

pub fn cmsggsassociatewithclan_unpack(buf []byte) ?CMsgGSAssociateWithClan {
	mut res := CMsgGSAssociateWithClan{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id_clan = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_clan = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsassociatewithclan() CMsgGSAssociateWithClan {
	return CMsgGSAssociateWithClan{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsassociatewithclan(o CMsgGSAssociateWithClan, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsassociatewithclan(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSAssociateWithClan) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggsassociatewithclan_unpack(v)?
	return i, unpacked
}

pub struct CMsgGSAssociateWithClanResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	steam_id_clan     u64
	has_steam_id_clan bool
	eresult           u32
	has_eresult       bool
}

pub fn (o &CMsgGSAssociateWithClanResponse) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id_clan {
		res << vproto.pack_64bit_field(o.steam_id_clan, 1)
	}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 2)
	}
	return res
}

pub fn cmsggsassociatewithclanresponse_unpack(buf []byte) ?CMsgGSAssociateWithClanResponse {
	mut res := CMsgGSAssociateWithClanResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id_clan = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_clan = v
				i = ii
			}
			2 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggsassociatewithclanresponse() CMsgGSAssociateWithClanResponse {
	return CMsgGSAssociateWithClanResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggsassociatewithclanresponse(o CMsgGSAssociateWithClanResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggsassociatewithclanresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSAssociateWithClanResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggsassociatewithclanresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgGSComputeNewPlayerCompatibility {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	steam_id_candidate     u64
	has_steam_id_candidate bool
}

pub fn (o &CMsgGSComputeNewPlayerCompatibility) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id_candidate {
		res << vproto.pack_64bit_field(o.steam_id_candidate, 1)
	}
	return res
}

pub fn cmsggscomputenewplayercompatibility_unpack(buf []byte) ?CMsgGSComputeNewPlayerCompatibility {
	mut res := CMsgGSComputeNewPlayerCompatibility{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id_candidate = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_candidate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggscomputenewplayercompatibility() CMsgGSComputeNewPlayerCompatibility {
	return CMsgGSComputeNewPlayerCompatibility{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggscomputenewplayercompatibility(o CMsgGSComputeNewPlayerCompatibility, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggscomputenewplayercompatibility(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSComputeNewPlayerCompatibility) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggscomputenewplayercompatibility_unpack(v)?
	return i, unpacked
}

pub struct CMsgGSComputeNewPlayerCompatibilityResponse {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	steam_id_candidate               u64
	has_steam_id_candidate           bool
	eresult                          u32
	has_eresult                      bool
	is_clan_member                   bool
	has_is_clan_member               bool
	ct_dont_like_you                 int
	has_ct_dont_like_you             bool
	ct_you_dont_like                 int
	has_ct_you_dont_like             bool
	ct_clanmembers_dont_like_you     int
	has_ct_clanmembers_dont_like_you bool
}

pub fn (o &CMsgGSComputeNewPlayerCompatibilityResponse) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id_candidate {
		res << vproto.pack_64bit_field(o.steam_id_candidate, 1)
	}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 2)
	}
	if o.has_is_clan_member {
		res << vproto.pack_bool_field(o.is_clan_member, 3)
	}
	if o.has_ct_dont_like_you {
		res << vproto.pack_int32_field(o.ct_dont_like_you, 4)
	}
	if o.has_ct_you_dont_like {
		res << vproto.pack_int32_field(o.ct_you_dont_like, 5)
	}
	if o.has_ct_clanmembers_dont_like_you {
		res << vproto.pack_int32_field(o.ct_clanmembers_dont_like_you, 6)
	}
	return res
}

pub fn cmsggscomputenewplayercompatibilityresponse_unpack(buf []byte) ?CMsgGSComputeNewPlayerCompatibilityResponse {
	mut res := CMsgGSComputeNewPlayerCompatibilityResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id_candidate = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id_candidate = v
				i = ii
			}
			2 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			3 {
				res.has_is_clan_member = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_clan_member = v
				i = ii
			}
			4 {
				res.has_ct_dont_like_you = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ct_dont_like_you = v
				i = ii
			}
			5 {
				res.has_ct_you_dont_like = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ct_you_dont_like = v
				i = ii
			}
			6 {
				res.has_ct_clanmembers_dont_like_you = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ct_clanmembers_dont_like_you = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggscomputenewplayercompatibilityresponse() CMsgGSComputeNewPlayerCompatibilityResponse {
	return CMsgGSComputeNewPlayerCompatibilityResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggscomputenewplayercompatibilityresponse(o CMsgGSComputeNewPlayerCompatibilityResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggscomputenewplayercompatibilityresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGSComputeNewPlayerCompatibilityResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggscomputenewplayercompatibilityresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientSentLogs {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientSentLogs) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientsentlogs_unpack(buf []byte) ?CMsgClientSentLogs {
	res := CMsgClientSentLogs{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsentlogs() CMsgClientSentLogs {
	return CMsgClientSentLogs{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsentlogs(o CMsgClientSentLogs, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsentlogs(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSentLogs) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientsentlogs_unpack(v)?
	return i, unpacked
}

pub struct CMsgGCClient {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	msgtype        u32
	has_msgtype    bool
	payload        []byte
	has_payload    bool
	steamid        u64
	has_steamid    bool
	gcname         string
	has_gcname     bool
	ip             u32
	has_ip         bool
}

pub fn (o &CMsgGCClient) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_msgtype {
		res << vproto.pack_uint32_field(o.msgtype, 2)
	}
	if o.has_payload {
		res << vproto.pack_bytes_field(o.payload, 3)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 4)
	}
	if o.has_gcname {
		res << vproto.pack_string_field(o.gcname, 5)
	}
	if o.has_ip {
		res << vproto.pack_uint32_field(o.ip, 6)
	}
	return res
}

pub fn cmsggcclient_unpack(buf []byte) ?CMsgGCClient {
	mut res := CMsgGCClient{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_msgtype = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.msgtype = v
				i = ii
			}
			3 {
				res.has_payload = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.payload = v
				i = ii
			}
			4 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			5 {
				res.has_gcname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.gcname = v
				i = ii
			}
			6 {
				res.has_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ip = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggcclient() CMsgGCClient {
	return CMsgGCClient{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggcclient(o CMsgGCClient, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggcclient(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGCClient) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggcclient_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestFreeLicense {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appids         []u32
}

pub fn (o &CMsgClientRequestFreeLicense) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.appids {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cmsgclientrequestfreelicense_unpack(buf []byte) ?CMsgClientRequestFreeLicense {
	mut res := CMsgClientRequestFreeLicense{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestfreelicense() CMsgClientRequestFreeLicense {
	return CMsgClientRequestFreeLicense{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestfreelicense(o CMsgClientRequestFreeLicense, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestfreelicense(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestFreeLicense) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestfreelicense_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestFreeLicenseResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	eresult            u32
	has_eresult        bool
	granted_packageids []u32
	granted_appids     []u32
}

pub fn (o &CMsgClientRequestFreeLicenseResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	// [packed=false]
	for _, x in o.granted_packageids {
		res << vproto.pack_uint32_field(x, 2)
	}
	// [packed=false]
	for _, x in o.granted_appids {
		res << vproto.pack_uint32_field(x, 3)
	}
	return res
}

pub fn cmsgclientrequestfreelicenseresponse_unpack(buf []byte) ?CMsgClientRequestFreeLicenseResponse {
	mut res := CMsgClientRequestFreeLicenseResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.granted_packageids << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.granted_appids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestfreelicenseresponse() CMsgClientRequestFreeLicenseResponse {
	return CMsgClientRequestFreeLicenseResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestfreelicenseresponse(o CMsgClientRequestFreeLicenseResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestfreelicenseresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestFreeLicenseResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestfreelicenseresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgDRMDownloadRequestWithCrashData {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	download_flags           u32
	has_download_flags       bool
	download_types_known     u32
	has_download_types_known bool
	guid_drm                 []byte
	has_guid_drm             bool
	guid_split               []byte
	has_guid_split           bool
	guid_merge               []byte
	has_guid_merge           bool
	module_name              string
	has_module_name          bool
	module_path              string
	has_module_path          bool
	crash_data               []byte
	has_crash_data           bool
}

pub fn (o &CMsgDRMDownloadRequestWithCrashData) pack() []byte {
	mut res := []byte{}
	if o.has_download_flags {
		res << vproto.pack_uint32_field(o.download_flags, 1)
	}
	if o.has_download_types_known {
		res << vproto.pack_uint32_field(o.download_types_known, 2)
	}
	if o.has_guid_drm {
		res << vproto.pack_bytes_field(o.guid_drm, 3)
	}
	if o.has_guid_split {
		res << vproto.pack_bytes_field(o.guid_split, 4)
	}
	if o.has_guid_merge {
		res << vproto.pack_bytes_field(o.guid_merge, 5)
	}
	if o.has_module_name {
		res << vproto.pack_string_field(o.module_name, 6)
	}
	if o.has_module_path {
		res << vproto.pack_string_field(o.module_path, 7)
	}
	if o.has_crash_data {
		res << vproto.pack_bytes_field(o.crash_data, 8)
	}
	return res
}

pub fn cmsgdrmdownloadrequestwithcrashdata_unpack(buf []byte) ?CMsgDRMDownloadRequestWithCrashData {
	mut res := CMsgDRMDownloadRequestWithCrashData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_download_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.download_flags = v
				i = ii
			}
			2 {
				res.has_download_types_known = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.download_types_known = v
				i = ii
			}
			3 {
				res.has_guid_drm = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.guid_drm = v
				i = ii
			}
			4 {
				res.has_guid_split = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.guid_split = v
				i = ii
			}
			5 {
				res.has_guid_merge = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.guid_merge = v
				i = ii
			}
			6 {
				res.has_module_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.module_name = v
				i = ii
			}
			7 {
				res.has_module_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.module_path = v
				i = ii
			}
			8 {
				res.has_crash_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.crash_data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdrmdownloadrequestwithcrashdata() CMsgDRMDownloadRequestWithCrashData {
	return CMsgDRMDownloadRequestWithCrashData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdrmdownloadrequestwithcrashdata(o CMsgDRMDownloadRequestWithCrashData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdrmdownloadrequestwithcrashdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDRMDownloadRequestWithCrashData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdrmdownloadrequestwithcrashdata_unpack(v)?
	return i, unpacked
}

pub struct CMsgDRMDownloadResponse {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	eresult                    u32
	has_eresult                bool
	app_id                     u32
	has_app_id                 bool
	blob_download_type         u32
	has_blob_download_type     bool
	merge_guid                 []byte
	has_merge_guid             bool
	download_file_dfs_ip       u32
	has_download_file_dfs_ip   bool
	download_file_dfs_port     u32
	has_download_file_dfs_port bool
	download_file_url          string
	has_download_file_url      bool
	module_path                string
	has_module_path            bool
}

pub fn (o &CMsgDRMDownloadResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.has_blob_download_type {
		res << vproto.pack_uint32_field(o.blob_download_type, 3)
	}
	if o.has_merge_guid {
		res << vproto.pack_bytes_field(o.merge_guid, 4)
	}
	if o.has_download_file_dfs_ip {
		res << vproto.pack_uint32_field(o.download_file_dfs_ip, 5)
	}
	if o.has_download_file_dfs_port {
		res << vproto.pack_uint32_field(o.download_file_dfs_port, 6)
	}
	if o.has_download_file_url {
		res << vproto.pack_string_field(o.download_file_url, 7)
	}
	if o.has_module_path {
		res << vproto.pack_string_field(o.module_path, 8)
	}
	return res
}

pub fn cmsgdrmdownloadresponse_unpack(buf []byte) ?CMsgDRMDownloadResponse {
	mut res := CMsgDRMDownloadResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			3 {
				res.has_blob_download_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.blob_download_type = v
				i = ii
			}
			4 {
				res.has_merge_guid = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.merge_guid = v
				i = ii
			}
			5 {
				res.has_download_file_dfs_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.download_file_dfs_ip = v
				i = ii
			}
			6 {
				res.has_download_file_dfs_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.download_file_dfs_port = v
				i = ii
			}
			7 {
				res.has_download_file_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.download_file_url = v
				i = ii
			}
			8 {
				res.has_module_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.module_path = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdrmdownloadresponse() CMsgDRMDownloadResponse {
	return CMsgDRMDownloadResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdrmdownloadresponse(o CMsgDRMDownloadResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdrmdownloadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDRMDownloadResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdrmdownloadresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgDRMFinalResult {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	eresult                    u32
	has_eresult                bool
	app_id                     u32
	has_app_id                 bool
	blob_download_type         u32
	has_blob_download_type     bool
	error_detail               u32
	has_error_detail           bool
	merge_guid                 []byte
	has_merge_guid             bool
	download_file_dfs_ip       u32
	has_download_file_dfs_ip   bool
	download_file_dfs_port     u32
	has_download_file_dfs_port bool
	download_file_url          string
	has_download_file_url      bool
}

pub fn (o &CMsgDRMFinalResult) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 2)
	}
	if o.has_blob_download_type {
		res << vproto.pack_uint32_field(o.blob_download_type, 3)
	}
	if o.has_error_detail {
		res << vproto.pack_uint32_field(o.error_detail, 4)
	}
	if o.has_merge_guid {
		res << vproto.pack_bytes_field(o.merge_guid, 5)
	}
	if o.has_download_file_dfs_ip {
		res << vproto.pack_uint32_field(o.download_file_dfs_ip, 6)
	}
	if o.has_download_file_dfs_port {
		res << vproto.pack_uint32_field(o.download_file_dfs_port, 7)
	}
	if o.has_download_file_url {
		res << vproto.pack_string_field(o.download_file_url, 8)
	}
	return res
}

pub fn cmsgdrmfinalresult_unpack(buf []byte) ?CMsgDRMFinalResult {
	mut res := CMsgDRMFinalResult{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			3 {
				res.has_blob_download_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.blob_download_type = v
				i = ii
			}
			4 {
				res.has_error_detail = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.error_detail = v
				i = ii
			}
			5 {
				res.has_merge_guid = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.merge_guid = v
				i = ii
			}
			6 {
				res.has_download_file_dfs_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.download_file_dfs_ip = v
				i = ii
			}
			7 {
				res.has_download_file_dfs_port = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.download_file_dfs_port = v
				i = ii
			}
			8 {
				res.has_download_file_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.download_file_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdrmfinalresult() CMsgDRMFinalResult {
	return CMsgDRMFinalResult{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdrmfinalresult(o CMsgDRMFinalResult, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdrmfinalresult(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDRMFinalResult) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdrmfinalresult_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientDPCheckSpecialSurvey {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	survey_id      u32
	has_survey_id  bool
}

pub fn (o &CMsgClientDPCheckSpecialSurvey) pack() []byte {
	mut res := []byte{}
	if o.has_survey_id {
		res << vproto.pack_uint32_field(o.survey_id, 1)
	}
	return res
}

pub fn cmsgclientdpcheckspecialsurvey_unpack(buf []byte) ?CMsgClientDPCheckSpecialSurvey {
	mut res := CMsgClientDPCheckSpecialSurvey{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_survey_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.survey_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdpcheckspecialsurvey() CMsgClientDPCheckSpecialSurvey {
	return CMsgClientDPCheckSpecialSurvey{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdpcheckspecialsurvey(o CMsgClientDPCheckSpecialSurvey, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdpcheckspecialsurvey(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDPCheckSpecialSurvey) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientdpcheckspecialsurvey_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientDPCheckSpecialSurveyResponse {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	eresult              u32
	has_eresult          bool
	state                u32
	has_state            bool
	name                 string
	has_name             bool
	custom_url           string
	has_custom_url       bool
	include_software     bool
	has_include_software bool
	token                []byte
	has_token            bool
}

pub fn (o &CMsgClientDPCheckSpecialSurveyResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	if o.has_state {
		res << vproto.pack_uint32_field(o.state, 2)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 3)
	}
	if o.has_custom_url {
		res << vproto.pack_string_field(o.custom_url, 4)
	}
	if o.has_include_software {
		res << vproto.pack_bool_field(o.include_software, 5)
	}
	if o.has_token {
		res << vproto.pack_bytes_field(o.token, 6)
	}
	return res
}

pub fn cmsgclientdpcheckspecialsurveyresponse_unpack(buf []byte) ?CMsgClientDPCheckSpecialSurveyResponse {
	mut res := CMsgClientDPCheckSpecialSurveyResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_state = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			3 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			4 {
				res.has_custom_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.custom_url = v
				i = ii
			}
			5 {
				res.has_include_software = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_software = v
				i = ii
			}
			6 {
				res.has_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdpcheckspecialsurveyresponse() CMsgClientDPCheckSpecialSurveyResponse {
	return CMsgClientDPCheckSpecialSurveyResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdpcheckspecialsurveyresponse(o CMsgClientDPCheckSpecialSurveyResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdpcheckspecialsurveyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDPCheckSpecialSurveyResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientdpcheckspecialsurveyresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientDPSendSpecialSurveyResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	survey_id      u32
	has_survey_id  bool
	data           []byte
	has_data       bool
}

pub fn (o &CMsgClientDPSendSpecialSurveyResponse) pack() []byte {
	mut res := []byte{}
	if o.has_survey_id {
		res << vproto.pack_uint32_field(o.survey_id, 1)
	}
	if o.has_data {
		res << vproto.pack_bytes_field(o.data, 2)
	}
	return res
}

pub fn cmsgclientdpsendspecialsurveyresponse_unpack(buf []byte) ?CMsgClientDPSendSpecialSurveyResponse {
	mut res := CMsgClientDPSendSpecialSurveyResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_survey_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.survey_id = v
				i = ii
			}
			2 {
				res.has_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdpsendspecialsurveyresponse() CMsgClientDPSendSpecialSurveyResponse {
	return CMsgClientDPSendSpecialSurveyResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdpsendspecialsurveyresponse(o CMsgClientDPSendSpecialSurveyResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdpsendspecialsurveyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDPSendSpecialSurveyResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientdpsendspecialsurveyresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientDPSendSpecialSurveyResponseReply {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        u32
	has_eresult    bool
	token          []byte
	has_token      bool
}

pub fn (o &CMsgClientDPSendSpecialSurveyResponseReply) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	if o.has_token {
		res << vproto.pack_bytes_field(o.token, 2)
	}
	return res
}

pub fn cmsgclientdpsendspecialsurveyresponsereply_unpack(buf []byte) ?CMsgClientDPSendSpecialSurveyResponseReply {
	mut res := CMsgClientDPSendSpecialSurveyResponseReply{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdpsendspecialsurveyresponsereply() CMsgClientDPSendSpecialSurveyResponseReply {
	return CMsgClientDPSendSpecialSurveyResponseReply{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdpsendspecialsurveyresponsereply(o CMsgClientDPSendSpecialSurveyResponseReply, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdpsendspecialsurveyresponsereply(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDPSendSpecialSurveyResponseReply) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientdpsendspecialsurveyresponsereply_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestForgottenPasswordEmail {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	account_name       string
	has_account_name   bool
	password_tried     string
	has_password_tried bool
}

pub fn (o &CMsgClientRequestForgottenPasswordEmail) pack() []byte {
	mut res := []byte{}
	if o.has_account_name {
		res << vproto.pack_string_field(o.account_name, 1)
	}
	if o.has_password_tried {
		res << vproto.pack_string_field(o.password_tried, 2)
	}
	return res
}

pub fn cmsgclientrequestforgottenpasswordemail_unpack(buf []byte) ?CMsgClientRequestForgottenPasswordEmail {
	mut res := CMsgClientRequestForgottenPasswordEmail{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_account_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.account_name = v
				i = ii
			}
			2 {
				res.has_password_tried = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.password_tried = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestforgottenpasswordemail() CMsgClientRequestForgottenPasswordEmail {
	return CMsgClientRequestForgottenPasswordEmail{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestforgottenpasswordemail(o CMsgClientRequestForgottenPasswordEmail, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestforgottenpasswordemail(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestForgottenPasswordEmail) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestforgottenpasswordemail_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestForgottenPasswordEmailResponse {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	eresult                 u32
	has_eresult             bool
	use_secret_question     bool
	has_use_secret_question bool
}

pub fn (o &CMsgClientRequestForgottenPasswordEmailResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 1)
	}
	if o.has_use_secret_question {
		res << vproto.pack_bool_field(o.use_secret_question, 2)
	}
	return res
}

pub fn cmsgclientrequestforgottenpasswordemailresponse_unpack(buf []byte) ?CMsgClientRequestForgottenPasswordEmailResponse {
	mut res := CMsgClientRequestForgottenPasswordEmailResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_use_secret_question = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_secret_question = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestforgottenpasswordemailresponse() CMsgClientRequestForgottenPasswordEmailResponse {
	return CMsgClientRequestForgottenPasswordEmailResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestforgottenpasswordemailresponse(o CMsgClientRequestForgottenPasswordEmailResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestforgottenpasswordemailresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestForgottenPasswordEmailResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestforgottenpasswordemailresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientItemAnnouncements_UnseenItem {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	appid              u32
	has_appid          bool
	context_id         u64
	has_context_id     bool
	asset_id           u64
	has_asset_id       bool
	amount             u64
	has_amount         bool
	rtime32_gained     u32
	has_rtime32_gained bool
	source_appid       u32
	has_source_appid   bool
}

pub fn (o &CMsgClientItemAnnouncements_UnseenItem) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_context_id {
		res << vproto.pack_uint64_field(o.context_id, 2)
	}
	if o.has_asset_id {
		res << vproto.pack_uint64_field(o.asset_id, 3)
	}
	if o.has_amount {
		res << vproto.pack_uint64_field(o.amount, 4)
	}
	if o.has_rtime32_gained {
		res << vproto.pack_32bit_field(o.rtime32_gained, 5)
	}
	if o.has_source_appid {
		res << vproto.pack_uint32_field(o.source_appid, 6)
	}
	return res
}

pub fn cmsgclientitemannouncements_unseenitem_unpack(buf []byte) ?CMsgClientItemAnnouncements_UnseenItem {
	mut res := CMsgClientItemAnnouncements_UnseenItem{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_context_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.context_id = v
				i = ii
			}
			3 {
				res.has_asset_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.asset_id = v
				i = ii
			}
			4 {
				res.has_amount = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.amount = v
				i = ii
			}
			5 {
				res.has_rtime32_gained = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_gained = v
				i = ii
			}
			6 {
				res.has_source_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.source_appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientitemannouncements_unseenitem() CMsgClientItemAnnouncements_UnseenItem {
	return CMsgClientItemAnnouncements_UnseenItem{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientitemannouncements_unseenitem(o CMsgClientItemAnnouncements_UnseenItem, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientitemannouncements_unseenitem(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientItemAnnouncements_UnseenItem) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientitemannouncements_unseenitem_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientItemAnnouncements {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	count_new_items     u32
	has_count_new_items bool
	unseen_items        []CMsgClientItemAnnouncements_UnseenItem
}

pub fn (o &CMsgClientItemAnnouncements) pack() []byte {
	mut res := []byte{}
	if o.has_count_new_items {
		res << vproto.pack_uint32_field(o.count_new_items, 1)
	}
	// [packed=false]
	for _, x in o.unseen_items {
		res << zzz_vproto_internal_pack_cmsgclientitemannouncements_unseenitem(x, 2)
	}
	return res
}

pub fn cmsgclientitemannouncements_unpack(buf []byte) ?CMsgClientItemAnnouncements {
	mut res := CMsgClientItemAnnouncements{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_count_new_items = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count_new_items = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientitemannouncements_unseenitem(cur_buf,
					tag_wiretype.wire_type)?
				res.unseen_items << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientitemannouncements() CMsgClientItemAnnouncements {
	return CMsgClientItemAnnouncements{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientitemannouncements(o CMsgClientItemAnnouncements, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientitemannouncements(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientItemAnnouncements) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientitemannouncements_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestItemAnnouncements {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientRequestItemAnnouncements) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientrequestitemannouncements_unpack(buf []byte) ?CMsgClientRequestItemAnnouncements {
	res := CMsgClientRequestItemAnnouncements{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestitemannouncements() CMsgClientRequestItemAnnouncements {
	return CMsgClientRequestItemAnnouncements{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestitemannouncements(o CMsgClientRequestItemAnnouncements, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestitemannouncements(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestItemAnnouncements) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestitemannouncements_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUserNotifications_Notification {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	user_notification_type     u32
	has_user_notification_type bool
	count                      u32
	has_count                  bool
}

pub fn (o &CMsgClientUserNotifications_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_user_notification_type {
		res << vproto.pack_uint32_field(o.user_notification_type, 1)
	}
	if o.has_count {
		res << vproto.pack_uint32_field(o.count, 2)
	}
	return res
}

pub fn cmsgclientusernotifications_notification_unpack(buf []byte) ?CMsgClientUserNotifications_Notification {
	mut res := CMsgClientUserNotifications_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_user_notification_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.user_notification_type = v
				i = ii
			}
			2 {
				res.has_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientusernotifications_notification() CMsgClientUserNotifications_Notification {
	return CMsgClientUserNotifications_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientusernotifications_notification(o CMsgClientUserNotifications_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientusernotifications_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUserNotifications_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientusernotifications_notification_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUserNotifications {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	notifications  []CMsgClientUserNotifications_Notification
}

pub fn (o &CMsgClientUserNotifications) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.notifications {
		res << zzz_vproto_internal_pack_cmsgclientusernotifications_notification(x, 1)
	}
	return res
}

pub fn cmsgclientusernotifications_unpack(buf []byte) ?CMsgClientUserNotifications {
	mut res := CMsgClientUserNotifications{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientusernotifications_notification(cur_buf,
					tag_wiretype.wire_type)?
				res.notifications << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientusernotifications() CMsgClientUserNotifications {
	return CMsgClientUserNotifications{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientusernotifications(o CMsgClientUserNotifications, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientusernotifications(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUserNotifications) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientusernotifications_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientCommentNotifications {
mut:
	unknown_fields                       []vproto.UnknownField
pub mut:
	count_new_comments                   u32
	has_count_new_comments               bool
	count_new_comments_owner             u32
	has_count_new_comments_owner         bool
	count_new_comments_subscriptions     u32
	has_count_new_comments_subscriptions bool
}

pub fn (o &CMsgClientCommentNotifications) pack() []byte {
	mut res := []byte{}
	if o.has_count_new_comments {
		res << vproto.pack_uint32_field(o.count_new_comments, 1)
	}
	if o.has_count_new_comments_owner {
		res << vproto.pack_uint32_field(o.count_new_comments_owner, 2)
	}
	if o.has_count_new_comments_subscriptions {
		res << vproto.pack_uint32_field(o.count_new_comments_subscriptions, 3)
	}
	return res
}

pub fn cmsgclientcommentnotifications_unpack(buf []byte) ?CMsgClientCommentNotifications {
	mut res := CMsgClientCommentNotifications{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_count_new_comments = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count_new_comments = v
				i = ii
			}
			2 {
				res.has_count_new_comments_owner = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count_new_comments_owner = v
				i = ii
			}
			3 {
				res.has_count_new_comments_subscriptions = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count_new_comments_subscriptions = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientcommentnotifications() CMsgClientCommentNotifications {
	return CMsgClientCommentNotifications{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientcommentnotifications(o CMsgClientCommentNotifications, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientcommentnotifications(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientCommentNotifications) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientcommentnotifications_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestCommentNotifications {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientRequestCommentNotifications) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientrequestcommentnotifications_unpack(buf []byte) ?CMsgClientRequestCommentNotifications {
	res := CMsgClientRequestCommentNotifications{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestcommentnotifications() CMsgClientRequestCommentNotifications {
	return CMsgClientRequestCommentNotifications{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestcommentnotifications(o CMsgClientRequestCommentNotifications, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestcommentnotifications(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestCommentNotifications) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestcommentnotifications_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientOfflineMessageNotification {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	offline_messages              u32
	has_offline_messages          bool
	friends_with_offline_messages []u32
}

pub fn (o &CMsgClientOfflineMessageNotification) pack() []byte {
	mut res := []byte{}
	if o.has_offline_messages {
		res << vproto.pack_uint32_field(o.offline_messages, 1)
	}
	// [packed=false]
	for _, x in o.friends_with_offline_messages {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cmsgclientofflinemessagenotification_unpack(buf []byte) ?CMsgClientOfflineMessageNotification {
	mut res := CMsgClientOfflineMessageNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_offline_messages = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.offline_messages = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.friends_with_offline_messages << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientofflinemessagenotification() CMsgClientOfflineMessageNotification {
	return CMsgClientOfflineMessageNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientofflinemessagenotification(o CMsgClientOfflineMessageNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientofflinemessagenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientOfflineMessageNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientofflinemessagenotification_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestOfflineMessageCount {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientRequestOfflineMessageCount) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientrequestofflinemessagecount_unpack(buf []byte) ?CMsgClientRequestOfflineMessageCount {
	res := CMsgClientRequestOfflineMessageCount{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestofflinemessagecount() CMsgClientRequestOfflineMessageCount {
	return CMsgClientRequestOfflineMessageCount{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestofflinemessagecount(o CMsgClientRequestOfflineMessageCount, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestofflinemessagecount(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestOfflineMessageCount) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestofflinemessagecount_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientChatGetFriendMessageHistory {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CMsgClientChatGetFriendMessageHistory) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cmsgclientchatgetfriendmessagehistory_unpack(buf []byte) ?CMsgClientChatGetFriendMessageHistory {
	mut res := CMsgClientChatGetFriendMessageHistory{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientchatgetfriendmessagehistory() CMsgClientChatGetFriendMessageHistory {
	return CMsgClientChatGetFriendMessageHistory{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientchatgetfriendmessagehistory(o CMsgClientChatGetFriendMessageHistory, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientchatgetfriendmessagehistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChatGetFriendMessageHistory) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientchatgetfriendmessagehistory_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	accountid      u32
	has_accountid  bool
	timestamp      u32
	has_timestamp  bool
	message        string
	has_message    bool
	unread         bool
	has_unread     bool
}

pub fn (o &CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 1)
	}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 2)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 3)
	}
	if o.has_unread {
		res << vproto.pack_bool_field(o.unread, 4)
	}
	return res
}

pub fn cmsgclientchatgetfriendmessagehistoryresponse_friendmessage_unpack(buf []byte) ?CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
	mut res := CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			3 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			4 {
				res.has_unread = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.unread = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientchatgetfriendmessagehistoryresponse_friendmessage() CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage {
	return CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientchatgetfriendmessagehistoryresponse_friendmessage(o CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientchatgetfriendmessagehistoryresponse_friendmessage(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientchatgetfriendmessagehistoryresponse_friendmessage_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientChatGetFriendMessageHistoryResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	success        u32
	has_success    bool
	messages       []CMsgClientChatGetFriendMessageHistoryResponse_FriendMessage
}

pub fn (o &CMsgClientChatGetFriendMessageHistoryResponse) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_success {
		res << vproto.pack_uint32_field(o.success, 2)
	}
	// [packed=false]
	for _, x in o.messages {
		res <<
			zzz_vproto_internal_pack_cmsgclientchatgetfriendmessagehistoryresponse_friendmessage(x, 3)
	}
	return res
}

pub fn cmsgclientchatgetfriendmessagehistoryresponse_unpack(buf []byte) ?CMsgClientChatGetFriendMessageHistoryResponse {
	mut res := CMsgClientChatGetFriendMessageHistoryResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_success = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.success = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientchatgetfriendmessagehistoryresponse_friendmessage(cur_buf,
					tag_wiretype.wire_type)?
				res.messages << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientchatgetfriendmessagehistoryresponse() CMsgClientChatGetFriendMessageHistoryResponse {
	return CMsgClientChatGetFriendMessageHistoryResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientchatgetfriendmessagehistoryresponse(o CMsgClientChatGetFriendMessageHistoryResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientchatgetfriendmessagehistoryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChatGetFriendMessageHistoryResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientchatgetfriendmessagehistoryresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientChatGetFriendMessageHistoryForOfflineMessages) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientchatgetfriendmessagehistoryforofflinemessages_unpack(buf []byte) ?CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
	res := CMsgClientChatGetFriendMessageHistoryForOfflineMessages{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientchatgetfriendmessagehistoryforofflinemessages() CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
	return CMsgClientChatGetFriendMessageHistoryForOfflineMessages{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientchatgetfriendmessagehistoryforofflinemessages(o CMsgClientChatGetFriendMessageHistoryForOfflineMessages, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientchatgetfriendmessagehistoryforofflinemessages(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChatGetFriendMessageHistoryForOfflineMessages) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientchatgetfriendmessagehistoryforofflinemessages_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientFSGetFriendsSteamLevels {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	accountids     []u32
}

pub fn (o &CMsgClientFSGetFriendsSteamLevels) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.accountids {
		res << vproto.pack_uint32_field(x, 1)
	}
	return res
}

pub fn cmsgclientfsgetfriendssteamlevels_unpack(buf []byte) ?CMsgClientFSGetFriendsSteamLevels {
	mut res := CMsgClientFSGetFriendsSteamLevels{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfsgetfriendssteamlevels() CMsgClientFSGetFriendsSteamLevels {
	return CMsgClientFSGetFriendsSteamLevels{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfsgetfriendssteamlevels(o CMsgClientFSGetFriendsSteamLevels, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfsgetfriendssteamlevels(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFSGetFriendsSteamLevels) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientfsgetfriendssteamlevels_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	accountid      u32
	has_accountid  bool
	level          u32
	has_level      bool
}

pub fn (o &CMsgClientFSGetFriendsSteamLevelsResponse_Friend) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 1)
	}
	if o.has_level {
		res << vproto.pack_uint32_field(o.level, 2)
	}
	return res
}

pub fn cmsgclientfsgetfriendssteamlevelsresponse_friend_unpack(buf []byte) ?CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
	mut res := CMsgClientFSGetFriendsSteamLevelsResponse_Friend{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_level = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.level = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfsgetfriendssteamlevelsresponse_friend() CMsgClientFSGetFriendsSteamLevelsResponse_Friend {
	return CMsgClientFSGetFriendsSteamLevelsResponse_Friend{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfsgetfriendssteamlevelsresponse_friend(o CMsgClientFSGetFriendsSteamLevelsResponse_Friend, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfsgetfriendssteamlevelsresponse_friend(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFSGetFriendsSteamLevelsResponse_Friend) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientfsgetfriendssteamlevelsresponse_friend_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientFSGetFriendsSteamLevelsResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	friends        []CMsgClientFSGetFriendsSteamLevelsResponse_Friend
}

pub fn (o &CMsgClientFSGetFriendsSteamLevelsResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.friends {
		res << zzz_vproto_internal_pack_cmsgclientfsgetfriendssteamlevelsresponse_friend(x, 1)
	}
	return res
}

pub fn cmsgclientfsgetfriendssteamlevelsresponse_unpack(buf []byte) ?CMsgClientFSGetFriendsSteamLevelsResponse {
	mut res := CMsgClientFSGetFriendsSteamLevelsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientfsgetfriendssteamlevelsresponse_friend(cur_buf,
					tag_wiretype.wire_type)?
				res.friends << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfsgetfriendssteamlevelsresponse() CMsgClientFSGetFriendsSteamLevelsResponse {
	return CMsgClientFSGetFriendsSteamLevelsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfsgetfriendssteamlevelsresponse(o CMsgClientFSGetFriendsSteamLevelsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfsgetfriendssteamlevelsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFSGetFriendsSteamLevelsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientfsgetfriendssteamlevelsresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientEmailAddrInfo {
mut:
	unknown_fields                                []vproto.UnknownField
pub mut:
	email_address                                 string
	has_email_address                             bool
	email_is_validated                            bool
	has_email_is_validated                        bool
	email_validation_changed                      bool
	has_email_validation_changed                  bool
	credential_change_requires_code               bool
	has_credential_change_requires_code           bool
	password_or_secretqa_change_requires_code     bool
	has_password_or_secretqa_change_requires_code bool
	remind_user_about_email                       bool
	has_remind_user_about_email                   bool
}

pub fn (o &CMsgClientEmailAddrInfo) pack() []byte {
	mut res := []byte{}
	if o.has_email_address {
		res << vproto.pack_string_field(o.email_address, 1)
	}
	if o.has_email_is_validated {
		res << vproto.pack_bool_field(o.email_is_validated, 2)
	}
	if o.has_email_validation_changed {
		res << vproto.pack_bool_field(o.email_validation_changed, 3)
	}
	if o.has_credential_change_requires_code {
		res << vproto.pack_bool_field(o.credential_change_requires_code, 4)
	}
	if o.has_password_or_secretqa_change_requires_code {
		res << vproto.pack_bool_field(o.password_or_secretqa_change_requires_code, 5)
	}
	if o.has_remind_user_about_email {
		res << vproto.pack_bool_field(o.remind_user_about_email, 6)
	}
	return res
}

pub fn cmsgclientemailaddrinfo_unpack(buf []byte) ?CMsgClientEmailAddrInfo {
	mut res := CMsgClientEmailAddrInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_email_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.email_address = v
				i = ii
			}
			2 {
				res.has_email_is_validated = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.email_is_validated = v
				i = ii
			}
			3 {
				res.has_email_validation_changed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.email_validation_changed = v
				i = ii
			}
			4 {
				res.has_credential_change_requires_code = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.credential_change_requires_code = v
				i = ii
			}
			5 {
				res.has_password_or_secretqa_change_requires_code = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.password_or_secretqa_change_requires_code = v
				i = ii
			}
			6 {
				res.has_remind_user_about_email = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.remind_user_about_email = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientemailaddrinfo() CMsgClientEmailAddrInfo {
	return CMsgClientEmailAddrInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientemailaddrinfo(o CMsgClientEmailAddrInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientemailaddrinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientEmailAddrInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientemailaddrinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgCREItemVoteSummary_PublishedFileId {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
}

pub fn (o &CMsgCREItemVoteSummary_PublishedFileId) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	return res
}

pub fn cmsgcreitemvotesummary_publishedfileid_unpack(buf []byte) ?CMsgCREItemVoteSummary_PublishedFileId {
	mut res := CMsgCREItemVoteSummary_PublishedFileId{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcreitemvotesummary_publishedfileid() CMsgCREItemVoteSummary_PublishedFileId {
	return CMsgCREItemVoteSummary_PublishedFileId{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcreitemvotesummary_publishedfileid(o CMsgCREItemVoteSummary_PublishedFileId, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcreitemvotesummary_publishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCREItemVoteSummary_PublishedFileId) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcreitemvotesummary_publishedfileid_unpack(v)?
	return i, unpacked
}

pub struct CMsgCREItemVoteSummary {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	published_file_ids []CMsgCREItemVoteSummary_PublishedFileId
}

pub fn (o &CMsgCREItemVoteSummary) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.published_file_ids {
		res << zzz_vproto_internal_pack_cmsgcreitemvotesummary_publishedfileid(x, 1)
	}
	return res
}

pub fn cmsgcreitemvotesummary_unpack(buf []byte) ?CMsgCREItemVoteSummary {
	mut res := CMsgCREItemVoteSummary{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgcreitemvotesummary_publishedfileid(cur_buf,
					tag_wiretype.wire_type)?
				res.published_file_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcreitemvotesummary() CMsgCREItemVoteSummary {
	return CMsgCREItemVoteSummary{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcreitemvotesummary(o CMsgCREItemVoteSummary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcreitemvotesummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCREItemVoteSummary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcreitemvotesummary_unpack(v)?
	return i, unpacked
}

pub struct CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	votes_for             int
	has_votes_for         bool
	votes_against         int
	has_votes_against     bool
	reports               int
	has_reports           bool
	score                 f32
	has_score             bool
}

pub fn (o &CMsgCREItemVoteSummaryResponse_ItemVoteSummary) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_votes_for {
		res << vproto.pack_int32_field(o.votes_for, 2)
	}
	if o.has_votes_against {
		res << vproto.pack_int32_field(o.votes_against, 3)
	}
	if o.has_reports {
		res << vproto.pack_int32_field(o.reports, 4)
	}
	if o.has_score {
		res << vproto.pack_float_field(o.score, 5)
	}
	return res
}

pub fn cmsgcreitemvotesummaryresponse_itemvotesummary_unpack(buf []byte) ?CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
	mut res := CMsgCREItemVoteSummaryResponse_ItemVoteSummary{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_votes_for = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.votes_for = v
				i = ii
			}
			3 {
				res.has_votes_against = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.votes_against = v
				i = ii
			}
			4 {
				res.has_reports = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.reports = v
				i = ii
			}
			5 {
				res.has_score = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.score = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcreitemvotesummaryresponse_itemvotesummary() CMsgCREItemVoteSummaryResponse_ItemVoteSummary {
	return CMsgCREItemVoteSummaryResponse_ItemVoteSummary{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcreitemvotesummaryresponse_itemvotesummary(o CMsgCREItemVoteSummaryResponse_ItemVoteSummary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcreitemvotesummaryresponse_itemvotesummary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCREItemVoteSummaryResponse_ItemVoteSummary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcreitemvotesummaryresponse_itemvotesummary_unpack(v)?
	return i, unpacked
}

pub struct CMsgCREItemVoteSummaryResponse {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	eresult             int
	has_eresult         bool
	item_vote_summaries []CMsgCREItemVoteSummaryResponse_ItemVoteSummary
}

pub fn (o &CMsgCREItemVoteSummaryResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	// [packed=false]
	for _, x in o.item_vote_summaries {
		res << zzz_vproto_internal_pack_cmsgcreitemvotesummaryresponse_itemvotesummary(x, 2)
	}
	return res
}

pub fn cmsgcreitemvotesummaryresponse_unpack(buf []byte) ?CMsgCREItemVoteSummaryResponse {
	mut res := CMsgCREItemVoteSummaryResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgcreitemvotesummaryresponse_itemvotesummary(cur_buf,
					tag_wiretype.wire_type)?
				res.item_vote_summaries << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcreitemvotesummaryresponse() CMsgCREItemVoteSummaryResponse {
	return CMsgCREItemVoteSummaryResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcreitemvotesummaryresponse(o CMsgCREItemVoteSummaryResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcreitemvotesummaryresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCREItemVoteSummaryResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcreitemvotesummaryresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgCREUpdateUserPublishedItemVote {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	vote_up               bool
	has_vote_up           bool
}

pub fn (o &CMsgCREUpdateUserPublishedItemVote) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_vote_up {
		res << vproto.pack_bool_field(o.vote_up, 2)
	}
	return res
}

pub fn cmsgcreupdateuserpublisheditemvote_unpack(buf []byte) ?CMsgCREUpdateUserPublishedItemVote {
	mut res := CMsgCREUpdateUserPublishedItemVote{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_vote_up = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.vote_up = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcreupdateuserpublisheditemvote() CMsgCREUpdateUserPublishedItemVote {
	return CMsgCREUpdateUserPublishedItemVote{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcreupdateuserpublisheditemvote(o CMsgCREUpdateUserPublishedItemVote, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcreupdateuserpublisheditemvote(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCREUpdateUserPublishedItemVote) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcreupdateuserpublisheditemvote_unpack(v)?
	return i, unpacked
}

pub struct CMsgCREUpdateUserPublishedItemVoteResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
}

pub fn (o &CMsgCREUpdateUserPublishedItemVoteResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgcreupdateuserpublisheditemvoteresponse_unpack(buf []byte) ?CMsgCREUpdateUserPublishedItemVoteResponse {
	mut res := CMsgCREUpdateUserPublishedItemVoteResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcreupdateuserpublisheditemvoteresponse() CMsgCREUpdateUserPublishedItemVoteResponse {
	return CMsgCREUpdateUserPublishedItemVoteResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcreupdateuserpublisheditemvoteresponse(o CMsgCREUpdateUserPublishedItemVoteResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcreupdateuserpublisheditemvoteresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCREUpdateUserPublishedItemVoteResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcreupdateuserpublisheditemvoteresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
}

pub fn (o &CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	return res
}

pub fn cmsgcregetuserpublisheditemvotedetails_publishedfileid_unpack(buf []byte) ?CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
	mut res := CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcregetuserpublisheditemvotedetails_publishedfileid() CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId {
	return CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcregetuserpublisheditemvotedetails_publishedfileid(o CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcregetuserpublisheditemvotedetails_publishedfileid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcregetuserpublisheditemvotedetails_publishedfileid_unpack(v)?
	return i, unpacked
}

pub struct CMsgCREGetUserPublishedItemVoteDetails {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	published_file_ids []CMsgCREGetUserPublishedItemVoteDetails_PublishedFileId
}

pub fn (o &CMsgCREGetUserPublishedItemVoteDetails) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.published_file_ids {
		res <<
			zzz_vproto_internal_pack_cmsgcregetuserpublisheditemvotedetails_publishedfileid(x, 1)
	}
	return res
}

pub fn cmsgcregetuserpublisheditemvotedetails_unpack(buf []byte) ?CMsgCREGetUserPublishedItemVoteDetails {
	mut res := CMsgCREGetUserPublishedItemVoteDetails{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgcregetuserpublisheditemvotedetails_publishedfileid(cur_buf,
					tag_wiretype.wire_type)?
				res.published_file_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcregetuserpublisheditemvotedetails() CMsgCREGetUserPublishedItemVoteDetails {
	return CMsgCREGetUserPublishedItemVoteDetails{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcregetuserpublisheditemvotedetails(o CMsgCREGetUserPublishedItemVoteDetails, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcregetuserpublisheditemvotedetails(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCREGetUserPublishedItemVoteDetails) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcregetuserpublisheditemvotedetails_unpack(v)?
	return i, unpacked
}

pub struct CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	published_file_id     u64
	has_published_file_id bool
	vote                  int
	has_vote              bool
}

pub fn (o &CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail) pack() []byte {
	mut res := []byte{}
	if o.has_published_file_id {
		res << vproto.pack_64bit_field(o.published_file_id, 1)
	}
	if o.has_vote {
		res << vproto.pack_int32_field(o.vote, 2)
	}
	return res
}

pub fn cmsgcregetuserpublisheditemvotedetailsresponse_useritemvotedetail_unpack(buf []byte) ?CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
	mut res := CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_published_file_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.published_file_id = v
				i = ii
			}
			2 {
				res.has_vote = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.vote = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcregetuserpublisheditemvotedetailsresponse_useritemvotedetail() CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail {
	return CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcregetuserpublisheditemvotedetailsresponse_useritemvotedetail(o CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcregetuserpublisheditemvotedetailsresponse_useritemvotedetail(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcregetuserpublisheditemvotedetailsresponse_useritemvotedetail_unpack(v)?
	return i, unpacked
}

pub struct CMsgCREGetUserPublishedItemVoteDetailsResponse {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	eresult                int
	has_eresult            bool
	user_item_vote_details []CMsgCREGetUserPublishedItemVoteDetailsResponse_UserItemVoteDetail
}

pub fn (o &CMsgCREGetUserPublishedItemVoteDetailsResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	// [packed=false]
	for _, x in o.user_item_vote_details {
		res <<
			zzz_vproto_internal_pack_cmsgcregetuserpublisheditemvotedetailsresponse_useritemvotedetail(x, 2)
	}
	return res
}

pub fn cmsgcregetuserpublisheditemvotedetailsresponse_unpack(buf []byte) ?CMsgCREGetUserPublishedItemVoteDetailsResponse {
	mut res := CMsgCREGetUserPublishedItemVoteDetailsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgcregetuserpublisheditemvotedetailsresponse_useritemvotedetail(cur_buf,
					tag_wiretype.wire_type)?
				res.user_item_vote_details << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcregetuserpublisheditemvotedetailsresponse() CMsgCREGetUserPublishedItemVoteDetailsResponse {
	return CMsgCREGetUserPublishedItemVoteDetailsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcregetuserpublisheditemvotedetailsresponse(o CMsgCREGetUserPublishedItemVoteDetailsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcregetuserpublisheditemvotedetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCREGetUserPublishedItemVoteDetailsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcregetuserpublisheditemvotedetailsresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgGameServerPingSample_Sample {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	ip                     u32
	has_ip                 bool
	avg_ping_ms            u32
	has_avg_ping_ms        bool
	stddev_ping_ms_x10     u32
	has_stddev_ping_ms_x10 bool
}

pub fn (o &CMsgGameServerPingSample_Sample) pack() []byte {
	mut res := []byte{}
	if o.has_ip {
		res << vproto.pack_32bit_field(o.ip, 1)
	}
	if o.has_avg_ping_ms {
		res << vproto.pack_uint32_field(o.avg_ping_ms, 2)
	}
	if o.has_stddev_ping_ms_x10 {
		res << vproto.pack_uint32_field(o.stddev_ping_ms_x10, 3)
	}
	return res
}

pub fn cmsggameserverpingsample_sample_unpack(buf []byte) ?CMsgGameServerPingSample_Sample {
	mut res := CMsgGameServerPingSample_Sample{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ip = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.ip = v
				i = ii
			}
			2 {
				res.has_avg_ping_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.avg_ping_ms = v
				i = ii
			}
			3 {
				res.has_stddev_ping_ms_x10 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.stddev_ping_ms_x10 = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameserverpingsample_sample() CMsgGameServerPingSample_Sample {
	return CMsgGameServerPingSample_Sample{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameserverpingsample_sample(o CMsgGameServerPingSample_Sample, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameserverpingsample_sample(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameServerPingSample_Sample) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggameserverpingsample_sample_unpack(v)?
	return i, unpacked
}

pub struct CMsgGameServerPingSample {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	my_ip          u32
	has_my_ip      bool
	gs_app_id      int
	has_gs_app_id  bool
	gs_samples     []CMsgGameServerPingSample_Sample
}

pub fn (o &CMsgGameServerPingSample) pack() []byte {
	mut res := []byte{}
	if o.has_my_ip {
		res << vproto.pack_32bit_field(o.my_ip, 1)
	}
	if o.has_gs_app_id {
		res << vproto.pack_int32_field(o.gs_app_id, 2)
	}
	// [packed=false]
	for _, x in o.gs_samples {
		res << zzz_vproto_internal_pack_cmsggameserverpingsample_sample(x, 3)
	}
	return res
}

pub fn cmsggameserverpingsample_unpack(buf []byte) ?CMsgGameServerPingSample {
	mut res := CMsgGameServerPingSample{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_my_ip = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.my_ip = v
				i = ii
			}
			2 {
				res.has_gs_app_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.gs_app_id = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsggameserverpingsample_sample(cur_buf,
					tag_wiretype.wire_type)?
				res.gs_samples << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameserverpingsample() CMsgGameServerPingSample {
	return CMsgGameServerPingSample{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameserverpingsample(o CMsgGameServerPingSample, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameserverpingsample(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameServerPingSample) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggameserverpingsample_unpack(v)?
	return i, unpacked
}

pub struct CMsgFSGetFollowerCount {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	has_steam_id   bool
}

pub fn (o &CMsgFSGetFollowerCount) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	return res
}

pub fn cmsgfsgetfollowercount_unpack(buf []byte) ?CMsgFSGetFollowerCount {
	mut res := CMsgFSGetFollowerCount{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfsgetfollowercount() CMsgFSGetFollowerCount {
	return CMsgFSGetFollowerCount{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfsgetfollowercount(o CMsgFSGetFollowerCount, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfsgetfollowercount(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFSGetFollowerCount) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfsgetfollowercount_unpack(v)?
	return i, unpacked
}

pub struct CMsgFSGetFollowerCountResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
	count          int
	has_count      bool
}

pub fn (o &CMsgFSGetFollowerCountResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_count {
		res << vproto.pack_int32_field(o.count, 2)
	}
	return res
}

pub fn cmsgfsgetfollowercountresponse_unpack(buf []byte) ?CMsgFSGetFollowerCountResponse {
	mut res := CMsgFSGetFollowerCountResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfsgetfollowercountresponse() CMsgFSGetFollowerCountResponse {
	return CMsgFSGetFollowerCountResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfsgetfollowercountresponse(o CMsgFSGetFollowerCountResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfsgetfollowercountresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFSGetFollowerCountResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfsgetfollowercountresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgFSGetIsFollowing {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_id       u64
	has_steam_id   bool
}

pub fn (o &CMsgFSGetIsFollowing) pack() []byte {
	mut res := []byte{}
	if o.has_steam_id {
		res << vproto.pack_64bit_field(o.steam_id, 1)
	}
	return res
}

pub fn cmsgfsgetisfollowing_unpack(buf []byte) ?CMsgFSGetIsFollowing {
	mut res := CMsgFSGetIsFollowing{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfsgetisfollowing() CMsgFSGetIsFollowing {
	return CMsgFSGetIsFollowing{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfsgetisfollowing(o CMsgFSGetIsFollowing, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfsgetisfollowing(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFSGetIsFollowing) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfsgetisfollowing_unpack(v)?
	return i, unpacked
}

pub struct CMsgFSGetIsFollowingResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	eresult          int
	has_eresult      bool
	is_following     bool
	has_is_following bool
}

pub fn (o &CMsgFSGetIsFollowingResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_is_following {
		res << vproto.pack_bool_field(o.is_following, 2)
	}
	return res
}

pub fn cmsgfsgetisfollowingresponse_unpack(buf []byte) ?CMsgFSGetIsFollowingResponse {
	mut res := CMsgFSGetIsFollowingResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_is_following = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_following = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfsgetisfollowingresponse() CMsgFSGetIsFollowingResponse {
	return CMsgFSGetIsFollowingResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfsgetisfollowingresponse(o CMsgFSGetIsFollowingResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfsgetisfollowingresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFSGetIsFollowingResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfsgetisfollowingresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgFSEnumerateFollowingList {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	start_index     u32
	has_start_index bool
}

pub fn (o &CMsgFSEnumerateFollowingList) pack() []byte {
	mut res := []byte{}
	if o.has_start_index {
		res << vproto.pack_uint32_field(o.start_index, 1)
	}
	return res
}

pub fn cmsgfsenumeratefollowinglist_unpack(buf []byte) ?CMsgFSEnumerateFollowingList {
	mut res := CMsgFSEnumerateFollowingList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_start_index = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.start_index = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfsenumeratefollowinglist() CMsgFSEnumerateFollowingList {
	return CMsgFSEnumerateFollowingList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfsenumeratefollowinglist(o CMsgFSEnumerateFollowingList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfsenumeratefollowinglist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFSEnumerateFollowingList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfsenumeratefollowinglist_unpack(v)?
	return i, unpacked
}

pub struct CMsgFSEnumerateFollowingListResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	eresult           int
	has_eresult       bool
	total_results     int
	has_total_results bool
	steam_ids         []u64
}

pub fn (o &CMsgFSEnumerateFollowingListResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_total_results {
		res << vproto.pack_int32_field(o.total_results, 2)
	}
	// [packed=false]
	for _, x in o.steam_ids {
		res << vproto.pack_64bit_field(x, 3)
	}
	return res
}

pub fn cmsgfsenumeratefollowinglistresponse_unpack(buf []byte) ?CMsgFSEnumerateFollowingListResponse {
	mut res := CMsgFSEnumerateFollowingListResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_total_results = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.total_results = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfsenumeratefollowinglistresponse() CMsgFSEnumerateFollowingListResponse {
	return CMsgFSEnumerateFollowingListResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfsenumeratefollowinglistresponse(o CMsgFSEnumerateFollowingListResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfsenumeratefollowinglistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFSEnumerateFollowingListResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfsenumeratefollowinglistresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgDPGetNumberOfCurrentPlayers {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
}

pub fn (o &CMsgDPGetNumberOfCurrentPlayers) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cmsgdpgetnumberofcurrentplayers_unpack(buf []byte) ?CMsgDPGetNumberOfCurrentPlayers {
	mut res := CMsgDPGetNumberOfCurrentPlayers{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdpgetnumberofcurrentplayers() CMsgDPGetNumberOfCurrentPlayers {
	return CMsgDPGetNumberOfCurrentPlayers{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdpgetnumberofcurrentplayers(o CMsgDPGetNumberOfCurrentPlayers, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdpgetnumberofcurrentplayers(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDPGetNumberOfCurrentPlayers) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdpgetnumberofcurrentplayers_unpack(v)?
	return i, unpacked
}

pub struct CMsgDPGetNumberOfCurrentPlayersResponse {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	eresult          int
	has_eresult      bool
	player_count     int
	has_player_count bool
}

pub fn (o &CMsgDPGetNumberOfCurrentPlayersResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_player_count {
		res << vproto.pack_int32_field(o.player_count, 2)
	}
	return res
}

pub fn cmsgdpgetnumberofcurrentplayersresponse_unpack(buf []byte) ?CMsgDPGetNumberOfCurrentPlayersResponse {
	mut res := CMsgDPGetNumberOfCurrentPlayersResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_player_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.player_count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdpgetnumberofcurrentplayersresponse() CMsgDPGetNumberOfCurrentPlayersResponse {
	return CMsgDPGetNumberOfCurrentPlayersResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdpgetnumberofcurrentplayersresponse(o CMsgDPGetNumberOfCurrentPlayersResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdpgetnumberofcurrentplayersresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDPGetNumberOfCurrentPlayersResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdpgetnumberofcurrentplayersresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientFriendUserStatusPublished {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	friend_steamid     u64
	has_friend_steamid bool
	appid              u32
	has_appid          bool
	status_text        string
	has_status_text    bool
}

pub fn (o &CMsgClientFriendUserStatusPublished) pack() []byte {
	mut res := []byte{}
	if o.has_friend_steamid {
		res << vproto.pack_64bit_field(o.friend_steamid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_status_text {
		res << vproto.pack_string_field(o.status_text, 3)
	}
	return res
}

pub fn cmsgclientfrienduserstatuspublished_unpack(buf []byte) ?CMsgClientFriendUserStatusPublished {
	mut res := CMsgClientFriendUserStatusPublished{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_friend_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.friend_steamid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_status_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.status_text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientfrienduserstatuspublished() CMsgClientFriendUserStatusPublished {
	return CMsgClientFriendUserStatusPublished{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientfrienduserstatuspublished(o CMsgClientFriendUserStatusPublished, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientfrienduserstatuspublished(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientFriendUserStatusPublished) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientfrienduserstatuspublished_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientServiceMethodLegacy {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	method_name           string
	has_method_name       bool
	serialized_method     []byte
	has_serialized_method bool
	is_notification       bool
	has_is_notification   bool
}

pub fn (o &CMsgClientServiceMethodLegacy) pack() []byte {
	mut res := []byte{}
	if o.has_method_name {
		res << vproto.pack_string_field(o.method_name, 1)
	}
	if o.has_serialized_method {
		res << vproto.pack_bytes_field(o.serialized_method, 2)
	}
	if o.has_is_notification {
		res << vproto.pack_bool_field(o.is_notification, 3)
	}
	return res
}

pub fn cmsgclientservicemethodlegacy_unpack(buf []byte) ?CMsgClientServiceMethodLegacy {
	mut res := CMsgClientServiceMethodLegacy{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_method_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.method_name = v
				i = ii
			}
			2 {
				res.has_serialized_method = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.serialized_method = v
				i = ii
			}
			3 {
				res.has_is_notification = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_notification = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientservicemethodlegacy() CMsgClientServiceMethodLegacy {
	return CMsgClientServiceMethodLegacy{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientservicemethodlegacy(o CMsgClientServiceMethodLegacy, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientservicemethodlegacy(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServiceMethodLegacy) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientservicemethodlegacy_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientServiceMethodLegacyResponse {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	method_name                    string
	has_method_name                bool
	serialized_method_response     []byte
	has_serialized_method_response bool
}

pub fn (o &CMsgClientServiceMethodLegacyResponse) pack() []byte {
	mut res := []byte{}
	if o.has_method_name {
		res << vproto.pack_string_field(o.method_name, 1)
	}
	if o.has_serialized_method_response {
		res << vproto.pack_bytes_field(o.serialized_method_response, 2)
	}
	return res
}

pub fn cmsgclientservicemethodlegacyresponse_unpack(buf []byte) ?CMsgClientServiceMethodLegacyResponse {
	mut res := CMsgClientServiceMethodLegacyResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_method_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.method_name = v
				i = ii
			}
			2 {
				res.has_serialized_method_response = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.serialized_method_response = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientservicemethodlegacyresponse() CMsgClientServiceMethodLegacyResponse {
	return CMsgClientServiceMethodLegacyResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientservicemethodlegacyresponse(o CMsgClientServiceMethodLegacyResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientservicemethodlegacyresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServiceMethodLegacyResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientservicemethodlegacyresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUIMode {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	uimode         u32
	has_uimode     bool
	chat_mode      u32
	has_chat_mode  bool
}

pub fn (o &CMsgClientUIMode) pack() []byte {
	mut res := []byte{}
	if o.has_uimode {
		res << vproto.pack_uint32_field(o.uimode, 1)
	}
	if o.has_chat_mode {
		res << vproto.pack_uint32_field(o.chat_mode, 2)
	}
	return res
}

pub fn cmsgclientuimode_unpack(buf []byte) ?CMsgClientUIMode {
	mut res := CMsgClientUIMode{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_uimode = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.uimode = v
				i = ii
			}
			2 {
				res.has_chat_mode = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_mode = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientuimode() CMsgClientUIMode {
	return CMsgClientUIMode{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientuimode(o CMsgClientUIMode, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientuimode(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUIMode) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientuimode_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientVanityURLChangedNotification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	vanity_url     string
	has_vanity_url bool
}

pub fn (o &CMsgClientVanityURLChangedNotification) pack() []byte {
	mut res := []byte{}
	if o.has_vanity_url {
		res << vproto.pack_string_field(o.vanity_url, 1)
	}
	return res
}

pub fn cmsgclientvanityurlchangednotification_unpack(buf []byte) ?CMsgClientVanityURLChangedNotification {
	mut res := CMsgClientVanityURLChangedNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_vanity_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.vanity_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientvanityurlchangednotification() CMsgClientVanityURLChangedNotification {
	return CMsgClientVanityURLChangedNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientvanityurlchangednotification(o CMsgClientVanityURLChangedNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientvanityurlchangednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientVanityURLChangedNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientvanityurlchangednotification_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAuthorizeLocalDeviceRequest {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	device_description     string
	has_device_description bool
	owner_account_id       u32
	has_owner_account_id   bool
	local_device_token     u64
	has_local_device_token bool
}

pub fn (o &CMsgClientAuthorizeLocalDeviceRequest) pack() []byte {
	mut res := []byte{}
	if o.has_device_description {
		res << vproto.pack_string_field(o.device_description, 1)
	}
	if o.has_owner_account_id {
		res << vproto.pack_uint32_field(o.owner_account_id, 2)
	}
	if o.has_local_device_token {
		res << vproto.pack_uint64_field(o.local_device_token, 3)
	}
	return res
}

pub fn cmsgclientauthorizelocaldevicerequest_unpack(buf []byte) ?CMsgClientAuthorizeLocalDeviceRequest {
	mut res := CMsgClientAuthorizeLocalDeviceRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_description = v
				i = ii
			}
			2 {
				res.has_owner_account_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_account_id = v
				i = ii
			}
			3 {
				res.has_local_device_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.local_device_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientauthorizelocaldevicerequest() CMsgClientAuthorizeLocalDeviceRequest {
	return CMsgClientAuthorizeLocalDeviceRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientauthorizelocaldevicerequest(o CMsgClientAuthorizeLocalDeviceRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientauthorizelocaldevicerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAuthorizeLocalDeviceRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientauthorizelocaldevicerequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAuthorizeLocalDevice {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	eresult                 int
	has_eresult             bool
	owner_account_id        u32
	has_owner_account_id    bool
	authed_device_token     u64
	has_authed_device_token bool
}

pub fn (o &CMsgClientAuthorizeLocalDevice) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_owner_account_id {
		res << vproto.pack_uint32_field(o.owner_account_id, 2)
	}
	if o.has_authed_device_token {
		res << vproto.pack_uint64_field(o.authed_device_token, 3)
	}
	return res
}

pub fn cmsgclientauthorizelocaldevice_unpack(buf []byte) ?CMsgClientAuthorizeLocalDevice {
	mut res := CMsgClientAuthorizeLocalDevice{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_owner_account_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_account_id = v
				i = ii
			}
			3 {
				res.has_authed_device_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.authed_device_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientauthorizelocaldevice() CMsgClientAuthorizeLocalDevice {
	return CMsgClientAuthorizeLocalDevice{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientauthorizelocaldevice(o CMsgClientAuthorizeLocalDevice, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientauthorizelocaldevice(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAuthorizeLocalDevice) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientauthorizelocaldevice_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAuthorizeLocalDeviceNotification {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	eresult                int
	has_eresult            bool
	owner_account_id       u32
	has_owner_account_id   bool
	local_device_token     u64
	has_local_device_token bool
}

pub fn (o &CMsgClientAuthorizeLocalDeviceNotification) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_owner_account_id {
		res << vproto.pack_uint32_field(o.owner_account_id, 2)
	}
	if o.has_local_device_token {
		res << vproto.pack_uint64_field(o.local_device_token, 3)
	}
	return res
}

pub fn cmsgclientauthorizelocaldevicenotification_unpack(buf []byte) ?CMsgClientAuthorizeLocalDeviceNotification {
	mut res := CMsgClientAuthorizeLocalDeviceNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_owner_account_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_account_id = v
				i = ii
			}
			3 {
				res.has_local_device_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.local_device_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientauthorizelocaldevicenotification() CMsgClientAuthorizeLocalDeviceNotification {
	return CMsgClientAuthorizeLocalDeviceNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientauthorizelocaldevicenotification(o CMsgClientAuthorizeLocalDeviceNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientauthorizelocaldevicenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAuthorizeLocalDeviceNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientauthorizelocaldevicenotification_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientDeauthorizeDeviceRequest {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	deauthorization_account_id       u32
	has_deauthorization_account_id   bool
	deauthorization_device_token     u64
	has_deauthorization_device_token bool
}

pub fn (o &CMsgClientDeauthorizeDeviceRequest) pack() []byte {
	mut res := []byte{}
	if o.has_deauthorization_account_id {
		res << vproto.pack_uint32_field(o.deauthorization_account_id, 1)
	}
	if o.has_deauthorization_device_token {
		res << vproto.pack_uint64_field(o.deauthorization_device_token, 2)
	}
	return res
}

pub fn cmsgclientdeauthorizedevicerequest_unpack(buf []byte) ?CMsgClientDeauthorizeDeviceRequest {
	mut res := CMsgClientDeauthorizeDeviceRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_deauthorization_account_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deauthorization_account_id = v
				i = ii
			}
			2 {
				res.has_deauthorization_device_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.deauthorization_device_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdeauthorizedevicerequest() CMsgClientDeauthorizeDeviceRequest {
	return CMsgClientDeauthorizeDeviceRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdeauthorizedevicerequest(o CMsgClientDeauthorizeDeviceRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdeauthorizedevicerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDeauthorizeDeviceRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientdeauthorizedevicerequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientDeauthorizeDevice {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	eresult                        int
	has_eresult                    bool
	deauthorization_account_id     u32
	has_deauthorization_account_id bool
}

pub fn (o &CMsgClientDeauthorizeDevice) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_deauthorization_account_id {
		res << vproto.pack_uint32_field(o.deauthorization_account_id, 2)
	}
	return res
}

pub fn cmsgclientdeauthorizedevice_unpack(buf []byte) ?CMsgClientDeauthorizeDevice {
	mut res := CMsgClientDeauthorizeDevice{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_deauthorization_account_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deauthorization_account_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientdeauthorizedevice() CMsgClientDeauthorizeDevice {
	return CMsgClientDeauthorizeDevice{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientdeauthorizedevice(o CMsgClientDeauthorizeDevice, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientdeauthorizedevice(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientDeauthorizeDevice) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientdeauthorizedevice_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	owner_account_id     u32
	has_owner_account_id bool
	token_id             u64
	has_token_id         bool
}

pub fn (o &CMsgClientUseLocalDeviceAuthorizations_DeviceToken) pack() []byte {
	mut res := []byte{}
	if o.has_owner_account_id {
		res << vproto.pack_uint32_field(o.owner_account_id, 1)
	}
	if o.has_token_id {
		res << vproto.pack_uint64_field(o.token_id, 2)
	}
	return res
}

pub fn cmsgclientuselocaldeviceauthorizations_devicetoken_unpack(buf []byte) ?CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
	mut res := CMsgClientUseLocalDeviceAuthorizations_DeviceToken{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_owner_account_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_account_id = v
				i = ii
			}
			2 {
				res.has_token_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.token_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientuselocaldeviceauthorizations_devicetoken() CMsgClientUseLocalDeviceAuthorizations_DeviceToken {
	return CMsgClientUseLocalDeviceAuthorizations_DeviceToken{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientuselocaldeviceauthorizations_devicetoken(o CMsgClientUseLocalDeviceAuthorizations_DeviceToken, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientuselocaldeviceauthorizations_devicetoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUseLocalDeviceAuthorizations_DeviceToken) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientuselocaldeviceauthorizations_devicetoken_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientUseLocalDeviceAuthorizations {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	authorization_account_id []u32
	device_tokens            []CMsgClientUseLocalDeviceAuthorizations_DeviceToken
}

pub fn (o &CMsgClientUseLocalDeviceAuthorizations) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.authorization_account_id {
		res << vproto.pack_uint32_field(x, 1)
	}
	// [packed=false]
	for _, x in o.device_tokens {
		res << zzz_vproto_internal_pack_cmsgclientuselocaldeviceauthorizations_devicetoken(x, 2)
	}
	return res
}

pub fn cmsgclientuselocaldeviceauthorizations_unpack(buf []byte) ?CMsgClientUseLocalDeviceAuthorizations {
	mut res := CMsgClientUseLocalDeviceAuthorizations{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.authorization_account_id << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientuselocaldeviceauthorizations_devicetoken(cur_buf,
					tag_wiretype.wire_type)?
				res.device_tokens << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientuselocaldeviceauthorizations() CMsgClientUseLocalDeviceAuthorizations {
	return CMsgClientUseLocalDeviceAuthorizations{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientuselocaldeviceauthorizations(o CMsgClientUseLocalDeviceAuthorizations, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientuselocaldeviceauthorizations(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientUseLocalDeviceAuthorizations) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientuselocaldeviceauthorizations_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetAuthorizedDevices {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientGetAuthorizedDevices) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientgetauthorizeddevices_unpack(buf []byte) ?CMsgClientGetAuthorizedDevices {
	res := CMsgClientGetAuthorizedDevices{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetauthorizeddevices() CMsgClientGetAuthorizedDevices {
	return CMsgClientGetAuthorizedDevices{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetauthorizeddevices(o CMsgClientGetAuthorizedDevices, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetauthorizeddevices(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetAuthorizedDevices) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetauthorizeddevices_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	auth_device_token     u64
	has_auth_device_token bool
	device_name           string
	has_device_name       bool
	last_access_time      u32
	has_last_access_time  bool
	borrower_id           u32
	has_borrower_id       bool
	is_pending            bool
	has_is_pending        bool
	app_played            u32
	has_app_played        bool
}

pub fn (o &CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice) pack() []byte {
	mut res := []byte{}
	if o.has_auth_device_token {
		res << vproto.pack_uint64_field(o.auth_device_token, 1)
	}
	if o.has_device_name {
		res << vproto.pack_string_field(o.device_name, 2)
	}
	if o.has_last_access_time {
		res << vproto.pack_uint32_field(o.last_access_time, 3)
	}
	if o.has_borrower_id {
		res << vproto.pack_uint32_field(o.borrower_id, 4)
	}
	if o.has_is_pending {
		res << vproto.pack_bool_field(o.is_pending, 5)
	}
	if o.has_app_played {
		res << vproto.pack_uint32_field(o.app_played, 6)
	}
	return res
}

pub fn cmsgclientgetauthorizeddevicesresponse_authorizeddevice_unpack(buf []byte) ?CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
	mut res := CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_auth_device_token = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_device_token = v
				i = ii
			}
			2 {
				res.has_device_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_name = v
				i = ii
			}
			3 {
				res.has_last_access_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_access_time = v
				i = ii
			}
			4 {
				res.has_borrower_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.borrower_id = v
				i = ii
			}
			5 {
				res.has_is_pending = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_pending = v
				i = ii
			}
			6 {
				res.has_app_played = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_played = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetauthorizeddevicesresponse_authorizeddevice() CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice {
	return CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetauthorizeddevicesresponse_authorizeddevice(o CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetauthorizeddevicesresponse_authorizeddevice(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetauthorizeddevicesresponse_authorizeddevice_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientGetAuthorizedDevicesResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	eresult           int
	has_eresult       bool
	authorized_device []CMsgClientGetAuthorizedDevicesResponse_AuthorizedDevice
}

pub fn (o &CMsgClientGetAuthorizedDevicesResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	// [packed=false]
	for _, x in o.authorized_device {
		res <<
			zzz_vproto_internal_pack_cmsgclientgetauthorizeddevicesresponse_authorizeddevice(x, 2)
	}
	return res
}

pub fn cmsgclientgetauthorizeddevicesresponse_unpack(buf []byte) ?CMsgClientGetAuthorizedDevicesResponse {
	mut res := CMsgClientGetAuthorizedDevicesResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientgetauthorizeddevicesresponse_authorizeddevice(cur_buf,
					tag_wiretype.wire_type)?
				res.authorized_device << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientgetauthorizeddevicesresponse() CMsgClientGetAuthorizedDevicesResponse {
	return CMsgClientGetAuthorizedDevicesResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientgetauthorizeddevicesresponse(o CMsgClientGetAuthorizedDevicesResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientgetauthorizeddevicesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientGetAuthorizedDevicesResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientgetauthorizeddevicesresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientSharedLibraryLockStatus_LockedLibrary {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	owner_id       u32
	has_owner_id   bool
	locked_by      u32
	has_locked_by  bool
}

pub fn (o &CMsgClientSharedLibraryLockStatus_LockedLibrary) pack() []byte {
	mut res := []byte{}
	if o.has_owner_id {
		res << vproto.pack_uint32_field(o.owner_id, 1)
	}
	if o.has_locked_by {
		res << vproto.pack_uint32_field(o.locked_by, 2)
	}
	return res
}

pub fn cmsgclientsharedlibrarylockstatus_lockedlibrary_unpack(buf []byte) ?CMsgClientSharedLibraryLockStatus_LockedLibrary {
	mut res := CMsgClientSharedLibraryLockStatus_LockedLibrary{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_owner_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_id = v
				i = ii
			}
			2 {
				res.has_locked_by = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.locked_by = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsharedlibrarylockstatus_lockedlibrary() CMsgClientSharedLibraryLockStatus_LockedLibrary {
	return CMsgClientSharedLibraryLockStatus_LockedLibrary{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsharedlibrarylockstatus_lockedlibrary(o CMsgClientSharedLibraryLockStatus_LockedLibrary, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsharedlibrarylockstatus_lockedlibrary(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSharedLibraryLockStatus_LockedLibrary) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientsharedlibrarylockstatus_lockedlibrary_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientSharedLibraryLockStatus {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	locked_library            []CMsgClientSharedLibraryLockStatus_LockedLibrary
	own_library_locked_by     u32
	has_own_library_locked_by bool
}

pub fn (o &CMsgClientSharedLibraryLockStatus) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.locked_library {
		res << zzz_vproto_internal_pack_cmsgclientsharedlibrarylockstatus_lockedlibrary(x, 1)
	}
	if o.has_own_library_locked_by {
		res << vproto.pack_uint32_field(o.own_library_locked_by, 2)
	}
	return res
}

pub fn cmsgclientsharedlibrarylockstatus_unpack(buf []byte) ?CMsgClientSharedLibraryLockStatus {
	mut res := CMsgClientSharedLibraryLockStatus{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientsharedlibrarylockstatus_lockedlibrary(cur_buf,
					tag_wiretype.wire_type)?
				res.locked_library << v
				i = ii
			}
			2 {
				res.has_own_library_locked_by = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.own_library_locked_by = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsharedlibrarylockstatus() CMsgClientSharedLibraryLockStatus {
	return CMsgClientSharedLibraryLockStatus{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsharedlibrarylockstatus(o CMsgClientSharedLibraryLockStatus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsharedlibrarylockstatus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSharedLibraryLockStatus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientsharedlibrarylockstatus_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientSharedLibraryStopPlaying_StopApp {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	app_id         u32
	has_app_id     bool
	owner_id       u32
	has_owner_id   bool
}

pub fn (o &CMsgClientSharedLibraryStopPlaying_StopApp) pack() []byte {
	mut res := []byte{}
	if o.has_app_id {
		res << vproto.pack_uint32_field(o.app_id, 1)
	}
	if o.has_owner_id {
		res << vproto.pack_uint32_field(o.owner_id, 2)
	}
	return res
}

pub fn cmsgclientsharedlibrarystopplaying_stopapp_unpack(buf []byte) ?CMsgClientSharedLibraryStopPlaying_StopApp {
	mut res := CMsgClientSharedLibraryStopPlaying_StopApp{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_app_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.app_id = v
				i = ii
			}
			2 {
				res.has_owner_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.owner_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsharedlibrarystopplaying_stopapp() CMsgClientSharedLibraryStopPlaying_StopApp {
	return CMsgClientSharedLibraryStopPlaying_StopApp{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsharedlibrarystopplaying_stopapp(o CMsgClientSharedLibraryStopPlaying_StopApp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsharedlibrarystopplaying_stopapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSharedLibraryStopPlaying_StopApp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientsharedlibrarystopplaying_stopapp_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientSharedLibraryStopPlaying {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	seconds_left     int
	has_seconds_left bool
	stop_apps        []CMsgClientSharedLibraryStopPlaying_StopApp
}

pub fn (o &CMsgClientSharedLibraryStopPlaying) pack() []byte {
	mut res := []byte{}
	if o.has_seconds_left {
		res << vproto.pack_int32_field(o.seconds_left, 1)
	}
	// [packed=false]
	for _, x in o.stop_apps {
		res << zzz_vproto_internal_pack_cmsgclientsharedlibrarystopplaying_stopapp(x, 2)
	}
	return res
}

pub fn cmsgclientsharedlibrarystopplaying_unpack(buf []byte) ?CMsgClientSharedLibraryStopPlaying {
	mut res := CMsgClientSharedLibraryStopPlaying{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_seconds_left = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_left = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgclientsharedlibrarystopplaying_stopapp(cur_buf,
					tag_wiretype.wire_type)?
				res.stop_apps << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsharedlibrarystopplaying() CMsgClientSharedLibraryStopPlaying {
	return CMsgClientSharedLibraryStopPlaying{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsharedlibrarystopplaying(o CMsgClientSharedLibraryStopPlaying, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsharedlibrarystopplaying(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSharedLibraryStopPlaying) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientsharedlibrarystopplaying_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientServiceCall {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	sysid_routing             []byte
	has_sysid_routing         bool
	call_handle               u32
	has_call_handle           bool
	module_crc                u32
	has_module_crc            bool
	module_hash               []byte
	has_module_hash           bool
	function_id               u32
	has_function_id           bool
	cub_output_max            u32
	has_cub_output_max        bool
	flags                     u32
	has_flags                 bool
	callparameter             []byte
	has_callparameter         bool
	ping_only                 bool
	has_ping_only             bool
	max_outstanding_calls     u32
	has_max_outstanding_calls bool
}

pub fn (o &CMsgClientServiceCall) pack() []byte {
	mut res := []byte{}
	if o.has_sysid_routing {
		res << vproto.pack_bytes_field(o.sysid_routing, 1)
	}
	if o.has_call_handle {
		res << vproto.pack_uint32_field(o.call_handle, 2)
	}
	if o.has_module_crc {
		res << vproto.pack_uint32_field(o.module_crc, 3)
	}
	if o.has_module_hash {
		res << vproto.pack_bytes_field(o.module_hash, 4)
	}
	if o.has_function_id {
		res << vproto.pack_uint32_field(o.function_id, 5)
	}
	if o.has_cub_output_max {
		res << vproto.pack_uint32_field(o.cub_output_max, 6)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 7)
	}
	if o.has_callparameter {
		res << vproto.pack_bytes_field(o.callparameter, 8)
	}
	if o.has_ping_only {
		res << vproto.pack_bool_field(o.ping_only, 9)
	}
	if o.has_max_outstanding_calls {
		res << vproto.pack_uint32_field(o.max_outstanding_calls, 10)
	}
	return res
}

pub fn cmsgclientservicecall_unpack(buf []byte) ?CMsgClientServiceCall {
	mut res := CMsgClientServiceCall{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sysid_routing = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sysid_routing = v
				i = ii
			}
			2 {
				res.has_call_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.call_handle = v
				i = ii
			}
			3 {
				res.has_module_crc = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.module_crc = v
				i = ii
			}
			4 {
				res.has_module_hash = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.module_hash = v
				i = ii
			}
			5 {
				res.has_function_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.function_id = v
				i = ii
			}
			6 {
				res.has_cub_output_max = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cub_output_max = v
				i = ii
			}
			7 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			8 {
				res.has_callparameter = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.callparameter = v
				i = ii
			}
			9 {
				res.has_ping_only = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_only = v
				i = ii
			}
			10 {
				res.has_max_outstanding_calls = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_outstanding_calls = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientservicecall() CMsgClientServiceCall {
	return CMsgClientServiceCall{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientservicecall(o CMsgClientServiceCall, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientservicecall(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServiceCall) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientservicecall_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientServiceModule {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	module_crc         u32
	has_module_crc     bool
	module_hash        []byte
	has_module_hash    bool
	module_content     []byte
	has_module_content bool
}

pub fn (o &CMsgClientServiceModule) pack() []byte {
	mut res := []byte{}
	if o.has_module_crc {
		res << vproto.pack_uint32_field(o.module_crc, 1)
	}
	if o.has_module_hash {
		res << vproto.pack_bytes_field(o.module_hash, 2)
	}
	if o.has_module_content {
		res << vproto.pack_bytes_field(o.module_content, 3)
	}
	return res
}

pub fn cmsgclientservicemodule_unpack(buf []byte) ?CMsgClientServiceModule {
	mut res := CMsgClientServiceModule{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_module_crc = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.module_crc = v
				i = ii
			}
			2 {
				res.has_module_hash = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.module_hash = v
				i = ii
			}
			3 {
				res.has_module_content = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.module_content = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientservicemodule() CMsgClientServiceModule {
	return CMsgClientServiceModule{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientservicemodule(o CMsgClientServiceModule, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientservicemodule(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServiceModule) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientservicemodule_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientServiceCallResponse {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	sysid_routing                []byte
	has_sysid_routing            bool
	call_handle                  u32
	has_call_handle              bool
	module_crc                   u32
	has_module_crc               bool
	module_hash                  []byte
	has_module_hash              bool
	ecallresult                  u32
	has_ecallresult              bool
	result_content               []byte
	has_result_content           bool
	os_version_info              []byte
	has_os_version_info          bool
	system_info                  []byte
	has_system_info              bool
	load_address                 u64
	has_load_address             bool
	exception_record             []byte
	has_exception_record         bool
	portable_os_version_info     []byte
	has_portable_os_version_info bool
	portable_system_info         []byte
	has_portable_system_info     bool
	was_converted                bool
	has_was_converted            bool
	internal_result              u32
	has_internal_result          bool
	current_count                u32
	has_current_count            bool
	last_call_handle             u32
	has_last_call_handle         bool
	last_call_module_crc         u32
	has_last_call_module_crc     bool
	last_call_sysid_routing      []byte
	has_last_call_sysid_routing  bool
	last_ecallresult             u32
	has_last_ecallresult         bool
	last_callissue_delta         u32
	has_last_callissue_delta     bool
	last_callcomplete_delta      u32
	has_last_callcomplete_delta  bool
}

pub fn (o &CMsgClientServiceCallResponse) pack() []byte {
	mut res := []byte{}
	if o.has_sysid_routing {
		res << vproto.pack_bytes_field(o.sysid_routing, 1)
	}
	if o.has_call_handle {
		res << vproto.pack_uint32_field(o.call_handle, 2)
	}
	if o.has_module_crc {
		res << vproto.pack_uint32_field(o.module_crc, 3)
	}
	if o.has_module_hash {
		res << vproto.pack_bytes_field(o.module_hash, 4)
	}
	if o.has_ecallresult {
		res << vproto.pack_uint32_field(o.ecallresult, 5)
	}
	if o.has_result_content {
		res << vproto.pack_bytes_field(o.result_content, 6)
	}
	if o.has_os_version_info {
		res << vproto.pack_bytes_field(o.os_version_info, 7)
	}
	if o.has_system_info {
		res << vproto.pack_bytes_field(o.system_info, 8)
	}
	if o.has_load_address {
		res << vproto.pack_64bit_field(o.load_address, 9)
	}
	if o.has_exception_record {
		res << vproto.pack_bytes_field(o.exception_record, 10)
	}
	if o.has_portable_os_version_info {
		res << vproto.pack_bytes_field(o.portable_os_version_info, 11)
	}
	if o.has_portable_system_info {
		res << vproto.pack_bytes_field(o.portable_system_info, 12)
	}
	if o.has_was_converted {
		res << vproto.pack_bool_field(o.was_converted, 13)
	}
	if o.has_internal_result {
		res << vproto.pack_uint32_field(o.internal_result, 14)
	}
	if o.has_current_count {
		res << vproto.pack_uint32_field(o.current_count, 15)
	}
	if o.has_last_call_handle {
		res << vproto.pack_uint32_field(o.last_call_handle, 16)
	}
	if o.has_last_call_module_crc {
		res << vproto.pack_uint32_field(o.last_call_module_crc, 17)
	}
	if o.has_last_call_sysid_routing {
		res << vproto.pack_bytes_field(o.last_call_sysid_routing, 18)
	}
	if o.has_last_ecallresult {
		res << vproto.pack_uint32_field(o.last_ecallresult, 19)
	}
	if o.has_last_callissue_delta {
		res << vproto.pack_uint32_field(o.last_callissue_delta, 20)
	}
	if o.has_last_callcomplete_delta {
		res << vproto.pack_uint32_field(o.last_callcomplete_delta, 21)
	}
	return res
}

pub fn cmsgclientservicecallresponse_unpack(buf []byte) ?CMsgClientServiceCallResponse {
	mut res := CMsgClientServiceCallResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sysid_routing = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sysid_routing = v
				i = ii
			}
			2 {
				res.has_call_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.call_handle = v
				i = ii
			}
			3 {
				res.has_module_crc = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.module_crc = v
				i = ii
			}
			4 {
				res.has_module_hash = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.module_hash = v
				i = ii
			}
			5 {
				res.has_ecallresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ecallresult = v
				i = ii
			}
			6 {
				res.has_result_content = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.result_content = v
				i = ii
			}
			7 {
				res.has_os_version_info = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.os_version_info = v
				i = ii
			}
			8 {
				res.has_system_info = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.system_info = v
				i = ii
			}
			9 {
				res.has_load_address = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.load_address = v
				i = ii
			}
			10 {
				res.has_exception_record = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.exception_record = v
				i = ii
			}
			11 {
				res.has_portable_os_version_info = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.portable_os_version_info = v
				i = ii
			}
			12 {
				res.has_portable_system_info = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.portable_system_info = v
				i = ii
			}
			13 {
				res.has_was_converted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.was_converted = v
				i = ii
			}
			14 {
				res.has_internal_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.internal_result = v
				i = ii
			}
			15 {
				res.has_current_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.current_count = v
				i = ii
			}
			16 {
				res.has_last_call_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_call_handle = v
				i = ii
			}
			17 {
				res.has_last_call_module_crc = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_call_module_crc = v
				i = ii
			}
			18 {
				res.has_last_call_sysid_routing = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.last_call_sysid_routing = v
				i = ii
			}
			19 {
				res.has_last_ecallresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_ecallresult = v
				i = ii
			}
			20 {
				res.has_last_callissue_delta = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_callissue_delta = v
				i = ii
			}
			21 {
				res.has_last_callcomplete_delta = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_callcomplete_delta = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientservicecallresponse() CMsgClientServiceCallResponse {
	return CMsgClientServiceCallResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientservicecallresponse(o CMsgClientServiceCallResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientservicecallresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServiceCallResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientservicecallresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgAMUnlockStreaming {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgAMUnlockStreaming) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgamunlockstreaming_unpack(buf []byte) ?CMsgAMUnlockStreaming {
	res := CMsgAMUnlockStreaming{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgamunlockstreaming() CMsgAMUnlockStreaming {
	return CMsgAMUnlockStreaming{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgamunlockstreaming(o CMsgAMUnlockStreaming, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgamunlockstreaming(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAMUnlockStreaming) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgamunlockstreaming_unpack(v)?
	return i, unpacked
}

pub struct CMsgAMUnlockStreamingResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	eresult            int
	has_eresult        bool
	encryption_key     []byte
	has_encryption_key bool
}

pub fn (o &CMsgAMUnlockStreamingResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_encryption_key {
		res << vproto.pack_bytes_field(o.encryption_key, 2)
	}
	return res
}

pub fn cmsgamunlockstreamingresponse_unpack(buf []byte) ?CMsgAMUnlockStreamingResponse {
	mut res := CMsgAMUnlockStreamingResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_encryption_key = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.encryption_key = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgamunlockstreamingresponse() CMsgAMUnlockStreamingResponse {
	return CMsgAMUnlockStreamingResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgamunlockstreamingresponse(o CMsgAMUnlockStreamingResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgamunlockstreamingresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAMUnlockStreamingResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgamunlockstreamingresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgAMUnlockHEVC {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgAMUnlockHEVC) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgamunlockhevc_unpack(buf []byte) ?CMsgAMUnlockHEVC {
	res := CMsgAMUnlockHEVC{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgamunlockhevc() CMsgAMUnlockHEVC {
	return CMsgAMUnlockHEVC{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgamunlockhevc(o CMsgAMUnlockHEVC, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgamunlockhevc(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAMUnlockHEVC) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgamunlockhevc_unpack(v)?
	return i, unpacked
}

pub struct CMsgAMUnlockHEVCResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
}

pub fn (o &CMsgAMUnlockHEVCResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgamunlockhevcresponse_unpack(buf []byte) ?CMsgAMUnlockHEVCResponse {
	mut res := CMsgAMUnlockHEVCResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgamunlockhevcresponse() CMsgAMUnlockHEVCResponse {
	return CMsgAMUnlockHEVCResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgamunlockhevcresponse(o CMsgAMUnlockHEVCResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgamunlockhevcresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAMUnlockHEVCResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgamunlockhevcresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientPlayingSessionState {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	playing_blocked     bool
	has_playing_blocked bool
	playing_app         u32
	has_playing_app     bool
}

pub fn (o &CMsgClientPlayingSessionState) pack() []byte {
	mut res := []byte{}
	if o.has_playing_blocked {
		res << vproto.pack_bool_field(o.playing_blocked, 2)
	}
	if o.has_playing_app {
		res << vproto.pack_uint32_field(o.playing_app, 3)
	}
	return res
}

pub fn cmsgclientplayingsessionstate_unpack(buf []byte) ?CMsgClientPlayingSessionState {
	mut res := CMsgClientPlayingSessionState{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				res.has_playing_blocked = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.playing_blocked = v
				i = ii
			}
			3 {
				res.has_playing_app = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.playing_app = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientplayingsessionstate() CMsgClientPlayingSessionState {
	return CMsgClientPlayingSessionState{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientplayingsessionstate(o CMsgClientPlayingSessionState, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientplayingsessionstate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientPlayingSessionState) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientplayingsessionstate_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientKickPlayingSession {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	only_stop_game     bool
	has_only_stop_game bool
}

pub fn (o &CMsgClientKickPlayingSession) pack() []byte {
	mut res := []byte{}
	if o.has_only_stop_game {
		res << vproto.pack_bool_field(o.only_stop_game, 1)
	}
	return res
}

pub fn cmsgclientkickplayingsession_unpack(buf []byte) ?CMsgClientKickPlayingSession {
	mut res := CMsgClientKickPlayingSession{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_only_stop_game = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.only_stop_game = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientkickplayingsession() CMsgClientKickPlayingSession {
	return CMsgClientKickPlayingSession{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientkickplayingsession(o CMsgClientKickPlayingSession, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientkickplayingsession(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientKickPlayingSession) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientkickplayingsession_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientVoiceCallPreAuthorize {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	caller_steamid       u64
	has_caller_steamid   bool
	receiver_steamid     u64
	has_receiver_steamid bool
	caller_id            int
	has_caller_id        bool
	hangup               bool
	has_hangup           bool
}

pub fn (o &CMsgClientVoiceCallPreAuthorize) pack() []byte {
	mut res := []byte{}
	if o.has_caller_steamid {
		res << vproto.pack_64bit_field(o.caller_steamid, 1)
	}
	if o.has_receiver_steamid {
		res << vproto.pack_64bit_field(o.receiver_steamid, 2)
	}
	if o.has_caller_id {
		res << vproto.pack_int32_field(o.caller_id, 3)
	}
	if o.has_hangup {
		res << vproto.pack_bool_field(o.hangup, 4)
	}
	return res
}

pub fn cmsgclientvoicecallpreauthorize_unpack(buf []byte) ?CMsgClientVoiceCallPreAuthorize {
	mut res := CMsgClientVoiceCallPreAuthorize{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_caller_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.caller_steamid = v
				i = ii
			}
			2 {
				res.has_receiver_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.receiver_steamid = v
				i = ii
			}
			3 {
				res.has_caller_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.caller_id = v
				i = ii
			}
			4 {
				res.has_hangup = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hangup = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientvoicecallpreauthorize() CMsgClientVoiceCallPreAuthorize {
	return CMsgClientVoiceCallPreAuthorize{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientvoicecallpreauthorize(o CMsgClientVoiceCallPreAuthorize, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientvoicecallpreauthorize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientVoiceCallPreAuthorize) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientvoicecallpreauthorize_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientVoiceCallPreAuthorizeResponse {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	caller_steamid       u64
	has_caller_steamid   bool
	receiver_steamid     u64
	has_receiver_steamid bool
	eresult              int
	has_eresult          bool
	caller_id            int
	has_caller_id        bool
}

pub fn (o &CMsgClientVoiceCallPreAuthorizeResponse) pack() []byte {
	mut res := []byte{}
	if o.has_caller_steamid {
		res << vproto.pack_64bit_field(o.caller_steamid, 1)
	}
	if o.has_receiver_steamid {
		res << vproto.pack_64bit_field(o.receiver_steamid, 2)
	}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 3)
	}
	if o.has_caller_id {
		res << vproto.pack_int32_field(o.caller_id, 4)
	}
	return res
}

pub fn cmsgclientvoicecallpreauthorizeresponse_unpack(buf []byte) ?CMsgClientVoiceCallPreAuthorizeResponse {
	mut res := CMsgClientVoiceCallPreAuthorizeResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_caller_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.caller_steamid = v
				i = ii
			}
			2 {
				res.has_receiver_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.receiver_steamid = v
				i = ii
			}
			3 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			4 {
				res.has_caller_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.caller_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientvoicecallpreauthorizeresponse() CMsgClientVoiceCallPreAuthorizeResponse {
	return CMsgClientVoiceCallPreAuthorizeResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientvoicecallpreauthorizeresponse(o CMsgClientVoiceCallPreAuthorizeResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientvoicecallpreauthorizeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientVoiceCallPreAuthorizeResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientvoicecallpreauthorizeresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgBadgeCraftedNotification {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	appid           u32
	has_appid       bool
	badge_level     u32
	has_badge_level bool
}

pub fn (o &CMsgBadgeCraftedNotification) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_badge_level {
		res << vproto.pack_uint32_field(o.badge_level, 2)
	}
	return res
}

pub fn cmsgbadgecraftednotification_unpack(buf []byte) ?CMsgBadgeCraftedNotification {
	mut res := CMsgBadgeCraftedNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_badge_level = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.badge_level = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgbadgecraftednotification() CMsgBadgeCraftedNotification {
	return CMsgBadgeCraftedNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgbadgecraftednotification(o CMsgBadgeCraftedNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgbadgecraftednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBadgeCraftedNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbadgecraftednotification_unpack(v)?
	return i, unpacked
}
