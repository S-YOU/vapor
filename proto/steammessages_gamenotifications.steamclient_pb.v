// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CGameNotificationsVariable {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &CGameNotificationsVariable) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn cgamenotificationsvariable_unpack(buf []byte) ?CGameNotificationsVariable {
	mut res := CGameNotificationsVariable{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsvariable() CGameNotificationsVariable {
	return CGameNotificationsVariable{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsvariable(o CGameNotificationsVariable, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsvariable(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsVariable) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsvariable_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsLocalizedText {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	token             string
	has_token         bool
	variables         []CGameNotificationsVariable
	rendered_text     string
	has_rendered_text bool
}

pub fn (o &CGameNotificationsLocalizedText) pack() []byte {
	mut res := []byte{}
	if o.has_token {
		res << vproto.pack_string_field(o.token, 1)
	}
	// [packed=false]
	for _, x in o.variables {
		res << zzz_vproto_internal_pack_cgamenotificationsvariable(x, 2)
	}
	if o.has_rendered_text {
		res << vproto.pack_string_field(o.rendered_text, 3)
	}
	return res
}

pub fn cgamenotificationslocalizedtext_unpack(buf []byte) ?CGameNotificationsLocalizedText {
	mut res := CGameNotificationsLocalizedText{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotificationsvariable(cur_buf,
					tag_wiretype.wire_type)?
				res.variables << v
				i = ii
			}
			3 {
				res.has_rendered_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.rendered_text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationslocalizedtext() CGameNotificationsLocalizedText {
	return CGameNotificationsLocalizedText{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationslocalizedtext(o CGameNotificationsLocalizedText, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationslocalizedtext(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsLocalizedText) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationslocalizedtext_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsUserStatus {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	state          string
	has_state      bool
	title          CGameNotificationsLocalizedText
	has_title      bool
	message        CGameNotificationsLocalizedText
	has_message    bool
}

pub fn (o &CGameNotificationsUserStatus) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_state {
		res << vproto.pack_string_field(o.state, 2)
	}
	if o.has_title {
		res << zzz_vproto_internal_pack_cgamenotificationslocalizedtext(o.title, 3)
	}
	if o.has_message {
		res << zzz_vproto_internal_pack_cgamenotificationslocalizedtext(o.message, 4)
	}
	return res
}

pub fn cgamenotificationsuserstatus_unpack(buf []byte) ?CGameNotificationsUserStatus {
	mut res := CGameNotificationsUserStatus{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_state = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			3 {
				res.has_title = true
				ii, v := zzz_vproto_internal_unpack_cgamenotificationslocalizedtext(cur_buf,
					tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			4 {
				res.has_message = true
				ii, v := zzz_vproto_internal_unpack_cgamenotificationslocalizedtext(cur_buf,
					tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsuserstatus() CGameNotificationsUserStatus {
	return CGameNotificationsUserStatus{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsuserstatus(o CGameNotificationsUserStatus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsuserstatus(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsUserStatus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsuserstatus_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsCreateSessionRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	context        u64
	has_context    bool
	title          CGameNotificationsLocalizedText
	has_title      bool
	users          []CGameNotificationsUserStatus
	steamid        u64
	has_steamid    bool
}

pub fn (o &CGameNotificationsCreateSessionRequest) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_context {
		res << vproto.pack_uint64_field(o.context, 2)
	}
	if o.has_title {
		res << zzz_vproto_internal_pack_cgamenotificationslocalizedtext(o.title, 3)
	}
	// [packed=false]
	for _, x in o.users {
		res << zzz_vproto_internal_pack_cgamenotificationsuserstatus(x, 4)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 5)
	}
	return res
}

pub fn cgamenotificationscreatesessionrequest_unpack(buf []byte) ?CGameNotificationsCreateSessionRequest {
	mut res := CGameNotificationsCreateSessionRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_context = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.context = v
				i = ii
			}
			3 {
				res.has_title = true
				ii, v := zzz_vproto_internal_unpack_cgamenotificationslocalizedtext(cur_buf,
					tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotificationsuserstatus(cur_buf,
					tag_wiretype.wire_type)?
				res.users << v
				i = ii
			}
			5 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationscreatesessionrequest() CGameNotificationsCreateSessionRequest {
	return CGameNotificationsCreateSessionRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationscreatesessionrequest(o CGameNotificationsCreateSessionRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationscreatesessionrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsCreateSessionRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationscreatesessionrequest_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsCreateSessionResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessionid      u64
	has_sessionid  bool
}

pub fn (o &CGameNotificationsCreateSessionResponse) pack() []byte {
	mut res := []byte{}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 1)
	}
	return res
}

pub fn cgamenotificationscreatesessionresponse_unpack(buf []byte) ?CGameNotificationsCreateSessionResponse {
	mut res := CGameNotificationsCreateSessionResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationscreatesessionresponse() CGameNotificationsCreateSessionResponse {
	return CGameNotificationsCreateSessionResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationscreatesessionresponse(o CGameNotificationsCreateSessionResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationscreatesessionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsCreateSessionResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationscreatesessionresponse_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsDeleteSessionRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessionid      u64
	has_sessionid  bool
	appid          u32
	has_appid      bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CGameNotificationsDeleteSessionRequest) pack() []byte {
	mut res := []byte{}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 3)
	}
	return res
}

pub fn cgamenotificationsdeletesessionrequest_unpack(buf []byte) ?CGameNotificationsDeleteSessionRequest {
	mut res := CGameNotificationsDeleteSessionRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsdeletesessionrequest() CGameNotificationsDeleteSessionRequest {
	return CGameNotificationsDeleteSessionRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsdeletesessionrequest(o CGameNotificationsDeleteSessionRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsdeletesessionrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsDeleteSessionRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsdeletesessionrequest_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsDeleteSessionResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CGameNotificationsDeleteSessionResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cgamenotificationsdeletesessionresponse_unpack(buf []byte) ?CGameNotificationsDeleteSessionResponse {
	res := CGameNotificationsDeleteSessionResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsdeletesessionresponse() CGameNotificationsDeleteSessionResponse {
	return CGameNotificationsDeleteSessionResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsdeletesessionresponse(o CGameNotificationsDeleteSessionResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsdeletesessionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsDeleteSessionResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsdeletesessionresponse_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsUpdateSessionRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessionid      u64
	has_sessionid  bool
	appid          u32
	has_appid      bool
	title          CGameNotificationsLocalizedText
	has_title      bool
	users          []CGameNotificationsUserStatus
	steamid        u64
	has_steamid    bool
}

pub fn (o &CGameNotificationsUpdateSessionRequest) pack() []byte {
	mut res := []byte{}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_title {
		res << zzz_vproto_internal_pack_cgamenotificationslocalizedtext(o.title, 3)
	}
	// [packed=false]
	for _, x in o.users {
		res << zzz_vproto_internal_pack_cgamenotificationsuserstatus(x, 4)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 6)
	}
	return res
}

pub fn cgamenotificationsupdatesessionrequest_unpack(buf []byte) ?CGameNotificationsUpdateSessionRequest {
	mut res := CGameNotificationsUpdateSessionRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_title = true
				ii, v := zzz_vproto_internal_unpack_cgamenotificationslocalizedtext(cur_buf,
					tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotificationsuserstatus(cur_buf,
					tag_wiretype.wire_type)?
				res.users << v
				i = ii
			}
			6 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsupdatesessionrequest() CGameNotificationsUpdateSessionRequest {
	return CGameNotificationsUpdateSessionRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsupdatesessionrequest(o CGameNotificationsUpdateSessionRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsupdatesessionrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsUpdateSessionRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsupdatesessionrequest_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsUpdateSessionResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CGameNotificationsUpdateSessionResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cgamenotificationsupdatesessionresponse_unpack(buf []byte) ?CGameNotificationsUpdateSessionResponse {
	res := CGameNotificationsUpdateSessionResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsupdatesessionresponse() CGameNotificationsUpdateSessionResponse {
	return CGameNotificationsUpdateSessionResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsupdatesessionresponse(o CGameNotificationsUpdateSessionResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsupdatesessionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsUpdateSessionResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsupdatesessionresponse_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsEnumerateSessionsRequest {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	appid                         u32
	has_appid                     bool
	include_all_user_messages     bool
	has_include_all_user_messages bool
	include_auth_user_message     bool
	has_include_auth_user_message bool
	language                      string
	has_language                  bool
}

pub fn (o &CGameNotificationsEnumerateSessionsRequest) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_include_all_user_messages {
		res << vproto.pack_bool_field(o.include_all_user_messages, 3)
	}
	if o.has_include_auth_user_message {
		res << vproto.pack_bool_field(o.include_auth_user_message, 4)
	}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 5)
	}
	return res
}

pub fn cgamenotificationsenumeratesessionsrequest_unpack(buf []byte) ?CGameNotificationsEnumerateSessionsRequest {
	mut res := CGameNotificationsEnumerateSessionsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_include_all_user_messages = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_all_user_messages = v
				i = ii
			}
			4 {
				res.has_include_auth_user_message = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_auth_user_message = v
				i = ii
			}
			5 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsenumeratesessionsrequest() CGameNotificationsEnumerateSessionsRequest {
	return CGameNotificationsEnumerateSessionsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsenumeratesessionsrequest(o CGameNotificationsEnumerateSessionsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsenumeratesessionsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsEnumerateSessionsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsenumeratesessionsrequest_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsSession {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	sessionid        u64
	has_sessionid    bool
	appid            u64
	has_appid        bool
	context          u64
	has_context      bool
	title            CGameNotificationsLocalizedText
	has_title        bool
	time_created     u32
	has_time_created bool
	time_updated     u32
	has_time_updated bool
	user_status      []CGameNotificationsUserStatus
}

pub fn (o &CGameNotificationsSession) pack() []byte {
	mut res := []byte{}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint64_field(o.appid, 2)
	}
	if o.has_context {
		res << vproto.pack_uint64_field(o.context, 3)
	}
	if o.has_title {
		res << zzz_vproto_internal_pack_cgamenotificationslocalizedtext(o.title, 4)
	}
	if o.has_time_created {
		res << vproto.pack_uint32_field(o.time_created, 5)
	}
	if o.has_time_updated {
		res << vproto.pack_uint32_field(o.time_updated, 6)
	}
	// [packed=false]
	for _, x in o.user_status {
		res << zzz_vproto_internal_pack_cgamenotificationsuserstatus(x, 7)
	}
	return res
}

pub fn cgamenotificationssession_unpack(buf []byte) ?CGameNotificationsSession {
	mut res := CGameNotificationsSession{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_context = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.context = v
				i = ii
			}
			4 {
				res.has_title = true
				ii, v := zzz_vproto_internal_unpack_cgamenotificationslocalizedtext(cur_buf,
					tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			5 {
				res.has_time_created = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			6 {
				res.has_time_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_updated = v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotificationsuserstatus(cur_buf,
					tag_wiretype.wire_type)?
				res.user_status << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationssession() CGameNotificationsSession {
	return CGameNotificationsSession{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationssession(o CGameNotificationsSession, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationssession(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsSession) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationssession_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsEnumerateSessionsResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessions       []CGameNotificationsSession
}

pub fn (o &CGameNotificationsEnumerateSessionsResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.sessions {
		res << zzz_vproto_internal_pack_cgamenotificationssession(x, 1)
	}
	return res
}

pub fn cgamenotificationsenumeratesessionsresponse_unpack(buf []byte) ?CGameNotificationsEnumerateSessionsResponse {
	mut res := CGameNotificationsEnumerateSessionsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotificationssession(cur_buf,
					tag_wiretype.wire_type)?
				res.sessions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsenumeratesessionsresponse() CGameNotificationsEnumerateSessionsResponse {
	return CGameNotificationsEnumerateSessionsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsenumeratesessionsresponse(o CGameNotificationsEnumerateSessionsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsenumeratesessionsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsEnumerateSessionsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsenumeratesessionsresponse_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsGetSessionDetailsRequestRequestedSession {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	sessionid                     u64
	has_sessionid                 bool
	include_auth_user_message     bool
	has_include_auth_user_message bool
}

pub fn (o &CGameNotificationsGetSessionDetailsRequestRequestedSession) pack() []byte {
	mut res := []byte{}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 1)
	}
	if o.has_include_auth_user_message {
		res << vproto.pack_bool_field(o.include_auth_user_message, 3)
	}
	return res
}

pub fn cgamenotificationsgetsessiondetailsrequestrequestedsession_unpack(buf []byte) ?CGameNotificationsGetSessionDetailsRequestRequestedSession {
	mut res := CGameNotificationsGetSessionDetailsRequestRequestedSession{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			3 {
				res.has_include_auth_user_message = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_auth_user_message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsgetsessiondetailsrequestrequestedsession() CGameNotificationsGetSessionDetailsRequestRequestedSession {
	return CGameNotificationsGetSessionDetailsRequestRequestedSession{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsgetsessiondetailsrequestrequestedsession(o CGameNotificationsGetSessionDetailsRequestRequestedSession, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsgetsessiondetailsrequestrequestedsession(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsGetSessionDetailsRequestRequestedSession) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsgetsessiondetailsrequestrequestedsession_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsGetSessionDetailsRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessions       []CGameNotificationsGetSessionDetailsRequestRequestedSession
	appid          u32
	has_appid      bool
	language       string
	has_language   bool
}

pub fn (o &CGameNotificationsGetSessionDetailsRequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.sessions {
		res <<
			zzz_vproto_internal_pack_cgamenotificationsgetsessiondetailsrequestrequestedsession(x, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 3)
	}
	return res
}

pub fn cgamenotificationsgetsessiondetailsrequest_unpack(buf []byte) ?CGameNotificationsGetSessionDetailsRequest {
	mut res := CGameNotificationsGetSessionDetailsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotificationsgetsessiondetailsrequestrequestedsession(cur_buf,
					tag_wiretype.wire_type)?
				res.sessions << v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsgetsessiondetailsrequest() CGameNotificationsGetSessionDetailsRequest {
	return CGameNotificationsGetSessionDetailsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsgetsessiondetailsrequest(o CGameNotificationsGetSessionDetailsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsgetsessiondetailsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsGetSessionDetailsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsgetsessiondetailsrequest_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsGetSessionDetailsResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessions       []CGameNotificationsSession
}

pub fn (o &CGameNotificationsGetSessionDetailsResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.sessions {
		res << zzz_vproto_internal_pack_cgamenotificationssession(x, 1)
	}
	return res
}

pub fn cgamenotificationsgetsessiondetailsresponse_unpack(buf []byte) ?CGameNotificationsGetSessionDetailsResponse {
	mut res := CGameNotificationsGetSessionDetailsResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotificationssession(cur_buf,
					tag_wiretype.wire_type)?
				res.sessions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsgetsessiondetailsresponse() CGameNotificationsGetSessionDetailsResponse {
	return CGameNotificationsGetSessionDetailsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsgetsessiondetailsresponse(o CGameNotificationsGetSessionDetailsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsgetsessiondetailsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsGetSessionDetailsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsgetsessiondetailsresponse_unpack(v)?
	return i, unpacked
}

pub struct GameNotificationSettings {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	appid                   u32
	has_appid               bool
	allow_notifications     bool
	has_allow_notifications bool
}

pub fn (o &GameNotificationSettings) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_allow_notifications {
		res << vproto.pack_bool_field(o.allow_notifications, 2)
	}
	return res
}

pub fn gamenotificationsettings_unpack(buf []byte) ?GameNotificationSettings {
	mut res := GameNotificationSettings{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_allow_notifications = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.allow_notifications = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_gamenotificationsettings() GameNotificationSettings {
	return GameNotificationSettings{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_gamenotificationsettings(o GameNotificationSettings, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_gamenotificationsettings(buf []byte, tag_wiretype vproto.WireType) ?(int, GameNotificationSettings) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := gamenotificationsettings_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsUpdateNotificationSettingsRequest {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	game_notification_settings []GameNotificationSettings
}

pub fn (o &CGameNotificationsUpdateNotificationSettingsRequest) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.game_notification_settings {
		res << zzz_vproto_internal_pack_gamenotificationsettings(x, 1)
	}
	return res
}

pub fn cgamenotificationsupdatenotificationsettingsrequest_unpack(buf []byte) ?CGameNotificationsUpdateNotificationSettingsRequest {
	mut res := CGameNotificationsUpdateNotificationSettingsRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_gamenotificationsettings(cur_buf,
					tag_wiretype.wire_type)?
				res.game_notification_settings << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsupdatenotificationsettingsrequest() CGameNotificationsUpdateNotificationSettingsRequest {
	return CGameNotificationsUpdateNotificationSettingsRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsupdatenotificationsettingsrequest(o CGameNotificationsUpdateNotificationSettingsRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsupdatenotificationsettingsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsUpdateNotificationSettingsRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsupdatenotificationsettingsrequest_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsUpdateNotificationSettingsResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CGameNotificationsUpdateNotificationSettingsResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cgamenotificationsupdatenotificationsettingsresponse_unpack(buf []byte) ?CGameNotificationsUpdateNotificationSettingsResponse {
	res := CGameNotificationsUpdateNotificationSettingsResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsupdatenotificationsettingsresponse() CGameNotificationsUpdateNotificationSettingsResponse {
	return CGameNotificationsUpdateNotificationSettingsResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsupdatenotificationsettingsresponse(o CGameNotificationsUpdateNotificationSettingsResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsupdatenotificationsettingsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsUpdateNotificationSettingsResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsupdatenotificationsettingsresponse_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsOnNotificationsRequestedNotification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	appid          u32
	has_appid      bool
}

pub fn (o &CGameNotificationsOnNotificationsRequestedNotification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	return res
}

pub fn cgamenotificationsonnotificationsrequestednotification_unpack(buf []byte) ?CGameNotificationsOnNotificationsRequestedNotification {
	mut res := CGameNotificationsOnNotificationsRequestedNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsonnotificationsrequestednotification() CGameNotificationsOnNotificationsRequestedNotification {
	return CGameNotificationsOnNotificationsRequestedNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsonnotificationsrequestednotification(o CGameNotificationsOnNotificationsRequestedNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsonnotificationsrequestednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsOnNotificationsRequestedNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsonnotificationsrequestednotification_unpack(v)?
	return i, unpacked
}

pub struct CGameNotificationsOnUserStatusChangedNotification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	sessionid      u64
	has_sessionid  bool
	appid          u32
	has_appid      bool
	status         CGameNotificationsUserStatus
	has_status     bool
	removed        bool
	has_removed    bool
}

pub fn (o &CGameNotificationsOnUserStatusChangedNotification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 2)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 3)
	}
	if o.has_status {
		res << zzz_vproto_internal_pack_cgamenotificationsuserstatus(o.status, 4)
	}
	if o.has_removed {
		res << vproto.pack_bool_field(o.removed, 5)
	}
	return res
}

pub fn cgamenotificationsonuserstatuschangednotification_unpack(buf []byte) ?CGameNotificationsOnUserStatusChangedNotification {
	mut res := CGameNotificationsOnUserStatusChangedNotification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			3 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			4 {
				res.has_status = true
				ii, v := zzz_vproto_internal_unpack_cgamenotificationsuserstatus(cur_buf,
					tag_wiretype.wire_type)?
				res.status = v
				i = ii
			}
			5 {
				res.has_removed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.removed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotificationsonuserstatuschangednotification() CGameNotificationsOnUserStatusChangedNotification {
	return CGameNotificationsOnUserStatusChangedNotification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotificationsonuserstatuschangednotification(o CGameNotificationsOnUserStatusChangedNotification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotificationsonuserstatuschangednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotificationsOnUserStatusChangedNotification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotificationsonuserstatuschangednotification_unpack(v)?
	return i, unpacked
}
