// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CGameNotifications_Variable {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &CGameNotifications_Variable) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn cgamenotifications_variable_unpack(buf []byte) ?CGameNotifications_Variable {
	mut res := CGameNotifications_Variable{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_variable() CGameNotifications_Variable {
	return CGameNotifications_Variable{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_variable(o CGameNotifications_Variable, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_variable(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_Variable) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_variable_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_LocalizedText {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	token             string
	has_token         bool
	variables         []CGameNotifications_Variable
	rendered_text     string
	has_rendered_text bool
}

pub fn (o &CGameNotifications_LocalizedText) pack() []byte {
	mut res := []byte{}
	if o.has_token {
		res << vproto.pack_string_field(o.token, 1)
	}
	// [packed=false]
	for _, x in o.variables {
		res << zzz_vproto_internal_pack_cgamenotifications_variable(x, 2)
	}
	if o.has_rendered_text {
		res << vproto.pack_string_field(o.rendered_text, 3)
	}
	return res
}

pub fn cgamenotifications_localizedtext_unpack(buf []byte) ?CGameNotifications_LocalizedText {
	mut res := CGameNotifications_LocalizedText{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotifications_variable(cur_buf,
					tag_wiretype.wire_type)?
				res.variables << v
				i = ii
			}
			3 {
				res.has_rendered_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.rendered_text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_localizedtext() CGameNotifications_LocalizedText {
	return CGameNotifications_LocalizedText{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_localizedtext(o CGameNotifications_LocalizedText, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_localizedtext(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_LocalizedText) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_localizedtext_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_UserStatus {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	state          string
	has_state      bool
	title          CGameNotifications_LocalizedText
	has_title      bool
	message        CGameNotifications_LocalizedText
	has_message    bool
}

pub fn (o &CGameNotifications_UserStatus) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_state {
		res << vproto.pack_string_field(o.state, 2)
	}
	if o.has_title {
		res << zzz_vproto_internal_pack_cgamenotifications_localizedtext(o.title, 3)
	}
	if o.has_message {
		res << zzz_vproto_internal_pack_cgamenotifications_localizedtext(o.message, 4)
	}
	return res
}

pub fn cgamenotifications_userstatus_unpack(buf []byte) ?CGameNotifications_UserStatus {
	mut res := CGameNotifications_UserStatus{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_state = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			3 {
				res.has_title = true
				ii, v := zzz_vproto_internal_unpack_cgamenotifications_localizedtext(cur_buf,
					tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			4 {
				res.has_message = true
				ii, v := zzz_vproto_internal_unpack_cgamenotifications_localizedtext(cur_buf,
					tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_userstatus() CGameNotifications_UserStatus {
	return CGameNotifications_UserStatus{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_userstatus(o CGameNotifications_UserStatus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_userstatus(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_UserStatus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_userstatus_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_CreateSession_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	context        u64
	has_context    bool
	title          CGameNotifications_LocalizedText
	has_title      bool
	users          []CGameNotifications_UserStatus
	steamid        u64
	has_steamid    bool
}

pub fn (o &CGameNotifications_CreateSession_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_context {
		res << vproto.pack_uint64_field(o.context, 2)
	}
	if o.has_title {
		res << zzz_vproto_internal_pack_cgamenotifications_localizedtext(o.title, 3)
	}
	// [packed=false]
	for _, x in o.users {
		res << zzz_vproto_internal_pack_cgamenotifications_userstatus(x, 4)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 5)
	}
	return res
}

pub fn cgamenotifications_createsession_request_unpack(buf []byte) ?CGameNotifications_CreateSession_Request {
	mut res := CGameNotifications_CreateSession_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_context = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.context = v
				i = ii
			}
			3 {
				res.has_title = true
				ii, v := zzz_vproto_internal_unpack_cgamenotifications_localizedtext(cur_buf,
					tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotifications_userstatus(cur_buf,
					tag_wiretype.wire_type)?
				res.users << v
				i = ii
			}
			5 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_createsession_request() CGameNotifications_CreateSession_Request {
	return CGameNotifications_CreateSession_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_createsession_request(o CGameNotifications_CreateSession_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_createsession_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_CreateSession_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_createsession_request_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_CreateSession_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessionid      u64
	has_sessionid  bool
}

pub fn (o &CGameNotifications_CreateSession_Response) pack() []byte {
	mut res := []byte{}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 1)
	}
	return res
}

pub fn cgamenotifications_createsession_response_unpack(buf []byte) ?CGameNotifications_CreateSession_Response {
	mut res := CGameNotifications_CreateSession_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_createsession_response() CGameNotifications_CreateSession_Response {
	return CGameNotifications_CreateSession_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_createsession_response(o CGameNotifications_CreateSession_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_createsession_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_CreateSession_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_createsession_response_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_DeleteSession_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessionid      u64
	has_sessionid  bool
	appid          u32
	has_appid      bool
	steamid        u64
	has_steamid    bool
}

pub fn (o &CGameNotifications_DeleteSession_Request) pack() []byte {
	mut res := []byte{}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 3)
	}
	return res
}

pub fn cgamenotifications_deletesession_request_unpack(buf []byte) ?CGameNotifications_DeleteSession_Request {
	mut res := CGameNotifications_DeleteSession_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_deletesession_request() CGameNotifications_DeleteSession_Request {
	return CGameNotifications_DeleteSession_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_deletesession_request(o CGameNotifications_DeleteSession_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_deletesession_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_DeleteSession_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_deletesession_request_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_DeleteSession_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CGameNotifications_DeleteSession_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cgamenotifications_deletesession_response_unpack(buf []byte) ?CGameNotifications_DeleteSession_Response {
	res := CGameNotifications_DeleteSession_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_deletesession_response() CGameNotifications_DeleteSession_Response {
	return CGameNotifications_DeleteSession_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_deletesession_response(o CGameNotifications_DeleteSession_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_deletesession_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_DeleteSession_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_deletesession_response_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_UpdateSession_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessionid      u64
	has_sessionid  bool
	appid          u32
	has_appid      bool
	title          CGameNotifications_LocalizedText
	has_title      bool
	users          []CGameNotifications_UserStatus
	steamid        u64
	has_steamid    bool
}

pub fn (o &CGameNotifications_UpdateSession_Request) pack() []byte {
	mut res := []byte{}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_title {
		res << zzz_vproto_internal_pack_cgamenotifications_localizedtext(o.title, 3)
	}
	// [packed=false]
	for _, x in o.users {
		res << zzz_vproto_internal_pack_cgamenotifications_userstatus(x, 4)
	}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 6)
	}
	return res
}

pub fn cgamenotifications_updatesession_request_unpack(buf []byte) ?CGameNotifications_UpdateSession_Request {
	mut res := CGameNotifications_UpdateSession_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_title = true
				ii, v := zzz_vproto_internal_unpack_cgamenotifications_localizedtext(cur_buf,
					tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotifications_userstatus(cur_buf,
					tag_wiretype.wire_type)?
				res.users << v
				i = ii
			}
			6 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_updatesession_request() CGameNotifications_UpdateSession_Request {
	return CGameNotifications_UpdateSession_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_updatesession_request(o CGameNotifications_UpdateSession_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_updatesession_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_UpdateSession_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_updatesession_request_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_UpdateSession_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CGameNotifications_UpdateSession_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cgamenotifications_updatesession_response_unpack(buf []byte) ?CGameNotifications_UpdateSession_Response {
	res := CGameNotifications_UpdateSession_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_updatesession_response() CGameNotifications_UpdateSession_Response {
	return CGameNotifications_UpdateSession_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_updatesession_response(o CGameNotifications_UpdateSession_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_updatesession_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_UpdateSession_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_updatesession_response_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_EnumerateSessions_Request {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	appid                         u32
	has_appid                     bool
	include_all_user_messages     bool
	has_include_all_user_messages bool
	include_auth_user_message     bool
	has_include_auth_user_message bool
	language                      string
	has_language                  bool
}

pub fn (o &CGameNotifications_EnumerateSessions_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_include_all_user_messages {
		res << vproto.pack_bool_field(o.include_all_user_messages, 3)
	}
	if o.has_include_auth_user_message {
		res << vproto.pack_bool_field(o.include_auth_user_message, 4)
	}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 5)
	}
	return res
}

pub fn cgamenotifications_enumeratesessions_request_unpack(buf []byte) ?CGameNotifications_EnumerateSessions_Request {
	mut res := CGameNotifications_EnumerateSessions_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_include_all_user_messages = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_all_user_messages = v
				i = ii
			}
			4 {
				res.has_include_auth_user_message = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_auth_user_message = v
				i = ii
			}
			5 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_enumeratesessions_request() CGameNotifications_EnumerateSessions_Request {
	return CGameNotifications_EnumerateSessions_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_enumeratesessions_request(o CGameNotifications_EnumerateSessions_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_enumeratesessions_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_EnumerateSessions_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_enumeratesessions_request_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_Session {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	sessionid        u64
	has_sessionid    bool
	appid            u64
	has_appid        bool
	context          u64
	has_context      bool
	title            CGameNotifications_LocalizedText
	has_title        bool
	time_created     u32
	has_time_created bool
	time_updated     u32
	has_time_updated bool
	user_status      []CGameNotifications_UserStatus
}

pub fn (o &CGameNotifications_Session) pack() []byte {
	mut res := []byte{}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint64_field(o.appid, 2)
	}
	if o.has_context {
		res << vproto.pack_uint64_field(o.context, 3)
	}
	if o.has_title {
		res << zzz_vproto_internal_pack_cgamenotifications_localizedtext(o.title, 4)
	}
	if o.has_time_created {
		res << vproto.pack_uint32_field(o.time_created, 5)
	}
	if o.has_time_updated {
		res << vproto.pack_uint32_field(o.time_updated, 6)
	}
	// [packed=false]
	for _, x in o.user_status {
		res << zzz_vproto_internal_pack_cgamenotifications_userstatus(x, 7)
	}
	return res
}

pub fn cgamenotifications_session_unpack(buf []byte) ?CGameNotifications_Session {
	mut res := CGameNotifications_Session{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_context = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.context = v
				i = ii
			}
			4 {
				res.has_title = true
				ii, v := zzz_vproto_internal_unpack_cgamenotifications_localizedtext(cur_buf,
					tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			5 {
				res.has_time_created = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			6 {
				res.has_time_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_updated = v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotifications_userstatus(cur_buf,
					tag_wiretype.wire_type)?
				res.user_status << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_session() CGameNotifications_Session {
	return CGameNotifications_Session{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_session(o CGameNotifications_Session, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_session(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_Session) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_session_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_EnumerateSessions_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessions       []CGameNotifications_Session
}

pub fn (o &CGameNotifications_EnumerateSessions_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.sessions {
		res << zzz_vproto_internal_pack_cgamenotifications_session(x, 1)
	}
	return res
}

pub fn cgamenotifications_enumeratesessions_response_unpack(buf []byte) ?CGameNotifications_EnumerateSessions_Response {
	mut res := CGameNotifications_EnumerateSessions_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotifications_session(cur_buf,
					tag_wiretype.wire_type)?
				res.sessions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_enumeratesessions_response() CGameNotifications_EnumerateSessions_Response {
	return CGameNotifications_EnumerateSessions_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_enumeratesessions_response(o CGameNotifications_EnumerateSessions_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_enumeratesessions_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_EnumerateSessions_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_enumeratesessions_response_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_GetSessionDetails_Request_RequestedSession {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	sessionid                     u64
	has_sessionid                 bool
	include_auth_user_message     bool
	has_include_auth_user_message bool
}

pub fn (o &CGameNotifications_GetSessionDetails_Request_RequestedSession) pack() []byte {
	mut res := []byte{}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 1)
	}
	if o.has_include_auth_user_message {
		res << vproto.pack_bool_field(o.include_auth_user_message, 3)
	}
	return res
}

pub fn cgamenotifications_getsessiondetails_request_requestedsession_unpack(buf []byte) ?CGameNotifications_GetSessionDetails_Request_RequestedSession {
	mut res := CGameNotifications_GetSessionDetails_Request_RequestedSession{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			3 {
				res.has_include_auth_user_message = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_auth_user_message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_getsessiondetails_request_requestedsession() CGameNotifications_GetSessionDetails_Request_RequestedSession {
	return CGameNotifications_GetSessionDetails_Request_RequestedSession{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_getsessiondetails_request_requestedsession(o CGameNotifications_GetSessionDetails_Request_RequestedSession, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_getsessiondetails_request_requestedsession(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_GetSessionDetails_Request_RequestedSession) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_getsessiondetails_request_requestedsession_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_GetSessionDetails_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessions       []CGameNotifications_GetSessionDetails_Request_RequestedSession
	appid          u32
	has_appid      bool
	language       string
	has_language   bool
}

pub fn (o &CGameNotifications_GetSessionDetails_Request) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.sessions {
		res <<
			zzz_vproto_internal_pack_cgamenotifications_getsessiondetails_request_requestedsession(x, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 3)
	}
	return res
}

pub fn cgamenotifications_getsessiondetails_request_unpack(buf []byte) ?CGameNotifications_GetSessionDetails_Request {
	mut res := CGameNotifications_GetSessionDetails_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotifications_getsessiondetails_request_requestedsession(cur_buf,
					tag_wiretype.wire_type)?
				res.sessions << v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_getsessiondetails_request() CGameNotifications_GetSessionDetails_Request {
	return CGameNotifications_GetSessionDetails_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_getsessiondetails_request(o CGameNotifications_GetSessionDetails_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_getsessiondetails_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_GetSessionDetails_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_getsessiondetails_request_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_GetSessionDetails_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	sessions       []CGameNotifications_Session
}

pub fn (o &CGameNotifications_GetSessionDetails_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.sessions {
		res << zzz_vproto_internal_pack_cgamenotifications_session(x, 1)
	}
	return res
}

pub fn cgamenotifications_getsessiondetails_response_unpack(buf []byte) ?CGameNotifications_GetSessionDetails_Response {
	mut res := CGameNotifications_GetSessionDetails_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cgamenotifications_session(cur_buf,
					tag_wiretype.wire_type)?
				res.sessions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_getsessiondetails_response() CGameNotifications_GetSessionDetails_Response {
	return CGameNotifications_GetSessionDetails_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_getsessiondetails_response(o CGameNotifications_GetSessionDetails_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_getsessiondetails_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_GetSessionDetails_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_getsessiondetails_response_unpack(v)?
	return i, unpacked
}

pub struct GameNotificationSettings {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	appid                   u32
	has_appid               bool
	allow_notifications     bool
	has_allow_notifications bool
}

pub fn (o &GameNotificationSettings) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_allow_notifications {
		res << vproto.pack_bool_field(o.allow_notifications, 2)
	}
	return res
}

pub fn gamenotificationsettings_unpack(buf []byte) ?GameNotificationSettings {
	mut res := GameNotificationSettings{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_allow_notifications = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.allow_notifications = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_gamenotificationsettings() GameNotificationSettings {
	return GameNotificationSettings{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_gamenotificationsettings(o GameNotificationSettings, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_gamenotificationsettings(buf []byte, tag_wiretype vproto.WireType) ?(int, GameNotificationSettings) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := gamenotificationsettings_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_UpdateNotificationSettings_Request {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	game_notification_settings []GameNotificationSettings
}

pub fn (o &CGameNotifications_UpdateNotificationSettings_Request) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.game_notification_settings {
		res << zzz_vproto_internal_pack_gamenotificationsettings(x, 1)
	}
	return res
}

pub fn cgamenotifications_updatenotificationsettings_request_unpack(buf []byte) ?CGameNotifications_UpdateNotificationSettings_Request {
	mut res := CGameNotifications_UpdateNotificationSettings_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_gamenotificationsettings(cur_buf,
					tag_wiretype.wire_type)?
				res.game_notification_settings << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_updatenotificationsettings_request() CGameNotifications_UpdateNotificationSettings_Request {
	return CGameNotifications_UpdateNotificationSettings_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_updatenotificationsettings_request(o CGameNotifications_UpdateNotificationSettings_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_updatenotificationsettings_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_UpdateNotificationSettings_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_updatenotificationsettings_request_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_UpdateNotificationSettings_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CGameNotifications_UpdateNotificationSettings_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cgamenotifications_updatenotificationsettings_response_unpack(buf []byte) ?CGameNotifications_UpdateNotificationSettings_Response {
	res := CGameNotifications_UpdateNotificationSettings_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_updatenotificationsettings_response() CGameNotifications_UpdateNotificationSettings_Response {
	return CGameNotifications_UpdateNotificationSettings_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_updatenotificationsettings_response(o CGameNotifications_UpdateNotificationSettings_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_updatenotificationsettings_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_UpdateNotificationSettings_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_updatenotificationsettings_response_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_OnNotificationsRequested_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	appid          u32
	has_appid      bool
}

pub fn (o &CGameNotifications_OnNotificationsRequested_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	return res
}

pub fn cgamenotifications_onnotificationsrequested_notification_unpack(buf []byte) ?CGameNotifications_OnNotificationsRequested_Notification {
	mut res := CGameNotifications_OnNotificationsRequested_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_onnotificationsrequested_notification() CGameNotifications_OnNotificationsRequested_Notification {
	return CGameNotifications_OnNotificationsRequested_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_onnotificationsrequested_notification(o CGameNotifications_OnNotificationsRequested_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_onnotificationsrequested_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_OnNotificationsRequested_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_onnotificationsrequested_notification_unpack(v)?
	return i, unpacked
}

pub struct CGameNotifications_OnUserStatusChanged_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	sessionid      u64
	has_sessionid  bool
	appid          u32
	has_appid      bool
	status         CGameNotifications_UserStatus
	has_status     bool
	removed        bool
	has_removed    bool
}

pub fn (o &CGameNotifications_OnUserStatusChanged_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_sessionid {
		res << vproto.pack_uint64_field(o.sessionid, 2)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 3)
	}
	if o.has_status {
		res << zzz_vproto_internal_pack_cgamenotifications_userstatus(o.status, 4)
	}
	if o.has_removed {
		res << vproto.pack_bool_field(o.removed, 5)
	}
	return res
}

pub fn cgamenotifications_onuserstatuschanged_notification_unpack(buf []byte) ?CGameNotifications_OnUserStatusChanged_Notification {
	mut res := CGameNotifications_OnUserStatusChanged_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_sessionid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.sessionid = v
				i = ii
			}
			3 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			4 {
				res.has_status = true
				ii, v := zzz_vproto_internal_unpack_cgamenotifications_userstatus(cur_buf,
					tag_wiretype.wire_type)?
				res.status = v
				i = ii
			}
			5 {
				res.has_removed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.removed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgamenotifications_onuserstatuschanged_notification() CGameNotifications_OnUserStatusChanged_Notification {
	return CGameNotifications_OnUserStatusChanged_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgamenotifications_onuserstatuschanged_notification(o CGameNotifications_OnUserStatusChanged_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgamenotifications_onuserstatuschanged_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CGameNotifications_OnUserStatusChanged_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgamenotifications_onuserstatuschanged_notification_unpack(v)?
	return i, unpacked
}
