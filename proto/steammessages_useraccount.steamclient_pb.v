
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


[_allow_multiple_values]
enum EInternalAccountType {
k_einternalsteamaccounttype = 1
k_einternalclantype = 2
k_einternalapptype = 3
k_einternalbroadcastchanneltype = 4
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_einternalaccounttype(e EInternalAccountType, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_einternalaccounttype(buf []byte, tag_wiretype vproto.WireType) ?(int, EInternalAccountType) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, EInternalAccountType(v)
}
[_allow_multiple_values]
enum EExternalAccountType {
k_eexternalnone = 0
k_eexternalsteamaccount = 1
k_eexternalgoogleaccount = 2
k_eexternalfacebookaccount = 3
k_eexternaltwitteraccount = 4
k_eexternaltwitchaccount = 5
k_eexternalyoutubechannelaccount = 6
k_eexternalfacebookpage = 7
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eexternalaccounttype(e EExternalAccountType, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eexternalaccounttype(buf []byte, tag_wiretype vproto.WireType) ?(int, EExternalAccountType) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, EExternalAccountType(v)
}
pub struct CUserAccountGetAvailableValveDiscountPromotionsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
country_code string
has_country_code bool
}
pub fn (o &CUserAccountGetAvailableValveDiscountPromotionsRequest) pack() []byte {
mut res := []byte{}
if o.has_country_code {
res << vproto.pack_string_field(o.country_code, 1)
}

return res
}

pub fn cuseraccountgetavailablevalvediscountpromotionsrequest_unpack(buf []byte) ?CUserAccountGetAvailableValveDiscountPromotionsRequest {
mut res := CUserAccountGetAvailableValveDiscountPromotionsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_country_code = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.country_code = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountgetavailablevalvediscountpromotionsrequest() CUserAccountGetAvailableValveDiscountPromotionsRequest {
return CUserAccountGetAvailableValveDiscountPromotionsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountgetavailablevalvediscountpromotionsrequest(o CUserAccountGetAvailableValveDiscountPromotionsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountgetavailablevalvediscountpromotionsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountGetAvailableValveDiscountPromotionsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountgetavailablevalvediscountpromotionsrequest_unpack(v)?
return i, unpacked
}
pub struct CUserAccountGetAvailableValveDiscountPromotionsResponseValveDiscountPromotionDetails {
mut:
unknown_fields []vproto.UnknownField
pub mut:
promotionid u32
has_promotionid bool
promotion_description string
has_promotion_description bool
minimum_cart_amount i64
has_minimum_cart_amount bool
minimum_cart_amount_for_display i64
has_minimum_cart_amount_for_display bool
discount_amount i64
has_discount_amount bool
currency_code int
has_currency_code bool
available_use_count int
has_available_use_count bool
promotional_discount_type int
has_promotional_discount_type bool
loyalty_reward_id int
has_loyalty_reward_id bool
localized_name_token string
has_localized_name_token bool
max_use_count int
has_max_use_count bool
}
pub fn (o &CUserAccountGetAvailableValveDiscountPromotionsResponseValveDiscountPromotionDetails) pack() []byte {
mut res := []byte{}
if o.has_promotionid {
res << vproto.pack_uint32_field(o.promotionid, 1)
}

if o.has_promotion_description {
res << vproto.pack_string_field(o.promotion_description, 2)
}

if o.has_minimum_cart_amount {
res << vproto.pack_int64_field(o.minimum_cart_amount, 3)
}

if o.has_minimum_cart_amount_for_display {
res << vproto.pack_int64_field(o.minimum_cart_amount_for_display, 4)
}

if o.has_discount_amount {
res << vproto.pack_int64_field(o.discount_amount, 5)
}

if o.has_currency_code {
res << vproto.pack_int32_field(o.currency_code, 6)
}

if o.has_available_use_count {
res << vproto.pack_int32_field(o.available_use_count, 7)
}

if o.has_promotional_discount_type {
res << vproto.pack_int32_field(o.promotional_discount_type, 8)
}

if o.has_loyalty_reward_id {
res << vproto.pack_int32_field(o.loyalty_reward_id, 9)
}

if o.has_localized_name_token {
res << vproto.pack_string_field(o.localized_name_token, 10)
}

if o.has_max_use_count {
res << vproto.pack_int32_field(o.max_use_count, 11)
}

return res
}

pub fn cuseraccountgetavailablevalvediscountpromotionsresponsevalvediscountpromotiondetails_unpack(buf []byte) ?CUserAccountGetAvailableValveDiscountPromotionsResponseValveDiscountPromotionDetails {
mut res := CUserAccountGetAvailableValveDiscountPromotionsResponseValveDiscountPromotionDetails{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_promotionid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.promotionid = v
i = ii
}

2 {
res.has_promotion_description = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.promotion_description = v
i = ii
}

3 {
res.has_minimum_cart_amount = true
ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
res.minimum_cart_amount = v
i = ii
}

4 {
res.has_minimum_cart_amount_for_display = true
ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
res.minimum_cart_amount_for_display = v
i = ii
}

5 {
res.has_discount_amount = true
ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
res.discount_amount = v
i = ii
}

6 {
res.has_currency_code = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.currency_code = v
i = ii
}

7 {
res.has_available_use_count = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.available_use_count = v
i = ii
}

8 {
res.has_promotional_discount_type = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.promotional_discount_type = v
i = ii
}

9 {
res.has_loyalty_reward_id = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.loyalty_reward_id = v
i = ii
}

10 {
res.has_localized_name_token = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.localized_name_token = v
i = ii
}

11 {
res.has_max_use_count = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.max_use_count = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountgetavailablevalvediscountpromotionsresponsevalvediscountpromotiondetails() CUserAccountGetAvailableValveDiscountPromotionsResponseValveDiscountPromotionDetails {
return CUserAccountGetAvailableValveDiscountPromotionsResponseValveDiscountPromotionDetails{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountgetavailablevalvediscountpromotionsresponsevalvediscountpromotiondetails(o CUserAccountGetAvailableValveDiscountPromotionsResponseValveDiscountPromotionDetails, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountgetavailablevalvediscountpromotionsresponsevalvediscountpromotiondetails(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountGetAvailableValveDiscountPromotionsResponseValveDiscountPromotionDetails) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountgetavailablevalvediscountpromotionsresponsevalvediscountpromotiondetails_unpack(v)?
return i, unpacked
}
pub struct CUserAccountGetAvailableValveDiscountPromotionsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
promotions []CUserAccountGetAvailableValveDiscountPromotionsResponseValveDiscountPromotionDetails
}
pub fn (o &CUserAccountGetAvailableValveDiscountPromotionsResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.promotions {
res << zzz_vproto_internal_pack_cuseraccountgetavailablevalvediscountpromotionsresponsevalvediscountpromotiondetails(x, 1)
}

return res
}

pub fn cuseraccountgetavailablevalvediscountpromotionsresponse_unpack(buf []byte) ?CUserAccountGetAvailableValveDiscountPromotionsResponse {
mut res := CUserAccountGetAvailableValveDiscountPromotionsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cuseraccountgetavailablevalvediscountpromotionsresponsevalvediscountpromotiondetails(cur_buf, tag_wiretype.wire_type)?
res.promotions << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountgetavailablevalvediscountpromotionsresponse() CUserAccountGetAvailableValveDiscountPromotionsResponse {
return CUserAccountGetAvailableValveDiscountPromotionsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountgetavailablevalvediscountpromotionsresponse(o CUserAccountGetAvailableValveDiscountPromotionsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountgetavailablevalvediscountpromotionsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountGetAvailableValveDiscountPromotionsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountgetavailablevalvediscountpromotionsresponse_unpack(v)?
return i, unpacked
}
pub struct CUserAccountGetAccountLinkStatusRequest {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CUserAccountGetAccountLinkStatusRequest) pack() []byte {
res := []byte{}
return res
}

pub fn cuseraccountgetaccountlinkstatusrequest_unpack(buf []byte) ?CUserAccountGetAccountLinkStatusRequest {
res := CUserAccountGetAccountLinkStatusRequest{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountgetaccountlinkstatusrequest() CUserAccountGetAccountLinkStatusRequest {
return CUserAccountGetAccountLinkStatusRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountgetaccountlinkstatusrequest(o CUserAccountGetAccountLinkStatusRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountgetaccountlinkstatusrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountGetAccountLinkStatusRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountgetaccountlinkstatusrequest_unpack(v)?
return i, unpacked
}
pub struct CUserAccountGetAccountLinkStatusResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
pwid u32
has_pwid bool
identity_verification u32
has_identity_verification bool
performed_age_verification bool
has_performed_age_verification bool
}
pub fn (o &CUserAccountGetAccountLinkStatusResponse) pack() []byte {
mut res := []byte{}
if o.has_pwid {
res << vproto.pack_uint32_field(o.pwid, 1)
}

if o.has_identity_verification {
res << vproto.pack_uint32_field(o.identity_verification, 2)
}

if o.has_performed_age_verification {
res << vproto.pack_bool_field(o.performed_age_verification, 3)
}

return res
}

pub fn cuseraccountgetaccountlinkstatusresponse_unpack(buf []byte) ?CUserAccountGetAccountLinkStatusResponse {
mut res := CUserAccountGetAccountLinkStatusResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_pwid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.pwid = v
i = ii
}

2 {
res.has_identity_verification = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.identity_verification = v
i = ii
}

3 {
res.has_performed_age_verification = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.performed_age_verification = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountgetaccountlinkstatusresponse() CUserAccountGetAccountLinkStatusResponse {
return CUserAccountGetAccountLinkStatusResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountgetaccountlinkstatusresponse(o CUserAccountGetAccountLinkStatusResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountgetaccountlinkstatusresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountGetAccountLinkStatusResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountgetaccountlinkstatusresponse_unpack(v)?
return i, unpacked
}
pub struct CUserAccountCancelLicenseForAppRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
}
pub fn (o &CUserAccountCancelLicenseForAppRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

return res
}

pub fn cuseraccountcancellicenseforapprequest_unpack(buf []byte) ?CUserAccountCancelLicenseForAppRequest {
mut res := CUserAccountCancelLicenseForAppRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountcancellicenseforapprequest() CUserAccountCancelLicenseForAppRequest {
return CUserAccountCancelLicenseForAppRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountcancellicenseforapprequest(o CUserAccountCancelLicenseForAppRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountcancellicenseforapprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountCancelLicenseForAppRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountcancellicenseforapprequest_unpack(v)?
return i, unpacked
}
pub struct CUserAccountCancelLicenseForAppResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CUserAccountCancelLicenseForAppResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cuseraccountcancellicenseforappresponse_unpack(buf []byte) ?CUserAccountCancelLicenseForAppResponse {
res := CUserAccountCancelLicenseForAppResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountcancellicenseforappresponse() CUserAccountCancelLicenseForAppResponse {
return CUserAccountCancelLicenseForAppResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountcancellicenseforappresponse(o CUserAccountCancelLicenseForAppResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountcancellicenseforappresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountCancelLicenseForAppResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountcancellicenseforappresponse_unpack(v)?
return i, unpacked
}
pub struct CUserAccountCreateFriendInviteTokenRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
invite_limit u32
has_invite_limit bool
invite_duration u32
has_invite_duration bool
invite_note string
has_invite_note bool
}
pub fn (o &CUserAccountCreateFriendInviteTokenRequest) pack() []byte {
mut res := []byte{}
if o.has_invite_limit {
res << vproto.pack_uint32_field(o.invite_limit, 1)
}

if o.has_invite_duration {
res << vproto.pack_uint32_field(o.invite_duration, 2)
}

if o.has_invite_note {
res << vproto.pack_string_field(o.invite_note, 3)
}

return res
}

pub fn cuseraccountcreatefriendinvitetokenrequest_unpack(buf []byte) ?CUserAccountCreateFriendInviteTokenRequest {
mut res := CUserAccountCreateFriendInviteTokenRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_invite_limit = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.invite_limit = v
i = ii
}

2 {
res.has_invite_duration = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.invite_duration = v
i = ii
}

3 {
res.has_invite_note = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.invite_note = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountcreatefriendinvitetokenrequest() CUserAccountCreateFriendInviteTokenRequest {
return CUserAccountCreateFriendInviteTokenRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountcreatefriendinvitetokenrequest(o CUserAccountCreateFriendInviteTokenRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountcreatefriendinvitetokenrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountCreateFriendInviteTokenRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountcreatefriendinvitetokenrequest_unpack(v)?
return i, unpacked
}
pub struct CUserAccountCreateFriendInviteTokenResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
invite_token string
has_invite_token bool
invite_limit u64
has_invite_limit bool
invite_duration u64
has_invite_duration bool
time_created u32
has_time_created bool
valid bool
has_valid bool
}
pub fn (o &CUserAccountCreateFriendInviteTokenResponse) pack() []byte {
mut res := []byte{}
if o.has_invite_token {
res << vproto.pack_string_field(o.invite_token, 1)
}

if o.has_invite_limit {
res << vproto.pack_uint64_field(o.invite_limit, 2)
}

if o.has_invite_duration {
res << vproto.pack_uint64_field(o.invite_duration, 3)
}

if o.has_time_created {
res << vproto.pack_32bit_field(o.time_created, 4)
}

if o.has_valid {
res << vproto.pack_bool_field(o.valid, 5)
}

return res
}

pub fn cuseraccountcreatefriendinvitetokenresponse_unpack(buf []byte) ?CUserAccountCreateFriendInviteTokenResponse {
mut res := CUserAccountCreateFriendInviteTokenResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_invite_token = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.invite_token = v
i = ii
}

2 {
res.has_invite_limit = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.invite_limit = v
i = ii
}

3 {
res.has_invite_duration = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.invite_duration = v
i = ii
}

4 {
res.has_time_created = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.time_created = v
i = ii
}

5 {
res.has_valid = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.valid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountcreatefriendinvitetokenresponse() CUserAccountCreateFriendInviteTokenResponse {
return CUserAccountCreateFriendInviteTokenResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountcreatefriendinvitetokenresponse(o CUserAccountCreateFriendInviteTokenResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountcreatefriendinvitetokenresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountCreateFriendInviteTokenResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountcreatefriendinvitetokenresponse_unpack(v)?
return i, unpacked
}
pub struct CUserAccountGetFriendInviteTokensRequest {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CUserAccountGetFriendInviteTokensRequest) pack() []byte {
res := []byte{}
return res
}

pub fn cuseraccountgetfriendinvitetokensrequest_unpack(buf []byte) ?CUserAccountGetFriendInviteTokensRequest {
res := CUserAccountGetFriendInviteTokensRequest{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountgetfriendinvitetokensrequest() CUserAccountGetFriendInviteTokensRequest {
return CUserAccountGetFriendInviteTokensRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountgetfriendinvitetokensrequest(o CUserAccountGetFriendInviteTokensRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountgetfriendinvitetokensrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountGetFriendInviteTokensRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountgetfriendinvitetokensrequest_unpack(v)?
return i, unpacked
}
pub struct CUserAccountGetFriendInviteTokensResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
tokens []CUserAccountCreateFriendInviteTokenResponse
}
pub fn (o &CUserAccountGetFriendInviteTokensResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.tokens {
res << zzz_vproto_internal_pack_cuseraccountcreatefriendinvitetokenresponse(x, 1)
}

return res
}

pub fn cuseraccountgetfriendinvitetokensresponse_unpack(buf []byte) ?CUserAccountGetFriendInviteTokensResponse {
mut res := CUserAccountGetFriendInviteTokensResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cuseraccountcreatefriendinvitetokenresponse(cur_buf, tag_wiretype.wire_type)?
res.tokens << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountgetfriendinvitetokensresponse() CUserAccountGetFriendInviteTokensResponse {
return CUserAccountGetFriendInviteTokensResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountgetfriendinvitetokensresponse(o CUserAccountGetFriendInviteTokensResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountgetfriendinvitetokensresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountGetFriendInviteTokensResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountgetfriendinvitetokensresponse_unpack(v)?
return i, unpacked
}
pub struct CUserAccountViewFriendInviteTokenRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
invite_token string
has_invite_token bool
}
pub fn (o &CUserAccountViewFriendInviteTokenRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_invite_token {
res << vproto.pack_string_field(o.invite_token, 2)
}

return res
}

pub fn cuseraccountviewfriendinvitetokenrequest_unpack(buf []byte) ?CUserAccountViewFriendInviteTokenRequest {
mut res := CUserAccountViewFriendInviteTokenRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_invite_token = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.invite_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountviewfriendinvitetokenrequest() CUserAccountViewFriendInviteTokenRequest {
return CUserAccountViewFriendInviteTokenRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountviewfriendinvitetokenrequest(o CUserAccountViewFriendInviteTokenRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountviewfriendinvitetokenrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountViewFriendInviteTokenRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountviewfriendinvitetokenrequest_unpack(v)?
return i, unpacked
}
pub struct CUserAccountViewFriendInviteTokenResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
valid bool
has_valid bool
steamid u64
has_steamid bool
invite_duration u64
has_invite_duration bool
}
pub fn (o &CUserAccountViewFriendInviteTokenResponse) pack() []byte {
mut res := []byte{}
if o.has_valid {
res << vproto.pack_bool_field(o.valid, 1)
}

if o.has_steamid {
res << vproto.pack_uint64_field(o.steamid, 2)
}

if o.has_invite_duration {
res << vproto.pack_uint64_field(o.invite_duration, 3)
}

return res
}

pub fn cuseraccountviewfriendinvitetokenresponse_unpack(buf []byte) ?CUserAccountViewFriendInviteTokenResponse {
mut res := CUserAccountViewFriendInviteTokenResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_valid = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.valid = v
i = ii
}

2 {
res.has_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

3 {
res.has_invite_duration = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.invite_duration = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountviewfriendinvitetokenresponse() CUserAccountViewFriendInviteTokenResponse {
return CUserAccountViewFriendInviteTokenResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountviewfriendinvitetokenresponse(o CUserAccountViewFriendInviteTokenResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountviewfriendinvitetokenresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountViewFriendInviteTokenResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountviewfriendinvitetokenresponse_unpack(v)?
return i, unpacked
}
pub struct CUserAccountRedeemFriendInviteTokenRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
invite_token string
has_invite_token bool
}
pub fn (o &CUserAccountRedeemFriendInviteTokenRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_invite_token {
res << vproto.pack_string_field(o.invite_token, 2)
}

return res
}

pub fn cuseraccountredeemfriendinvitetokenrequest_unpack(buf []byte) ?CUserAccountRedeemFriendInviteTokenRequest {
mut res := CUserAccountRedeemFriendInviteTokenRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_invite_token = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.invite_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountredeemfriendinvitetokenrequest() CUserAccountRedeemFriendInviteTokenRequest {
return CUserAccountRedeemFriendInviteTokenRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountredeemfriendinvitetokenrequest(o CUserAccountRedeemFriendInviteTokenRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountredeemfriendinvitetokenrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountRedeemFriendInviteTokenRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountredeemfriendinvitetokenrequest_unpack(v)?
return i, unpacked
}
pub struct CUserAccountRedeemFriendInviteTokenResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CUserAccountRedeemFriendInviteTokenResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cuseraccountredeemfriendinvitetokenresponse_unpack(buf []byte) ?CUserAccountRedeemFriendInviteTokenResponse {
res := CUserAccountRedeemFriendInviteTokenResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountredeemfriendinvitetokenresponse() CUserAccountRedeemFriendInviteTokenResponse {
return CUserAccountRedeemFriendInviteTokenResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountredeemfriendinvitetokenresponse(o CUserAccountRedeemFriendInviteTokenResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountredeemfriendinvitetokenresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountRedeemFriendInviteTokenResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountredeemfriendinvitetokenresponse_unpack(v)?
return i, unpacked
}
pub struct CUserAccountRevokeFriendInviteTokenRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
invite_token string
has_invite_token bool
}
pub fn (o &CUserAccountRevokeFriendInviteTokenRequest) pack() []byte {
mut res := []byte{}
if o.has_invite_token {
res << vproto.pack_string_field(o.invite_token, 1)
}

return res
}

pub fn cuseraccountrevokefriendinvitetokenrequest_unpack(buf []byte) ?CUserAccountRevokeFriendInviteTokenRequest {
mut res := CUserAccountRevokeFriendInviteTokenRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_invite_token = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.invite_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountrevokefriendinvitetokenrequest() CUserAccountRevokeFriendInviteTokenRequest {
return CUserAccountRevokeFriendInviteTokenRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountrevokefriendinvitetokenrequest(o CUserAccountRevokeFriendInviteTokenRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountrevokefriendinvitetokenrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountRevokeFriendInviteTokenRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountrevokefriendinvitetokenrequest_unpack(v)?
return i, unpacked
}
pub struct CUserAccountRevokeFriendInviteTokenResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CUserAccountRevokeFriendInviteTokenResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cuseraccountrevokefriendinvitetokenresponse_unpack(buf []byte) ?CUserAccountRevokeFriendInviteTokenResponse {
res := CUserAccountRevokeFriendInviteTokenResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountrevokefriendinvitetokenresponse() CUserAccountRevokeFriendInviteTokenResponse {
return CUserAccountRevokeFriendInviteTokenResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountrevokefriendinvitetokenresponse(o CUserAccountRevokeFriendInviteTokenResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountrevokefriendinvitetokenresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountRevokeFriendInviteTokenResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountrevokefriendinvitetokenresponse_unpack(v)?
return i, unpacked
}
pub struct CUserAccountRegisterCompatToolRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
compat_tool u32
has_compat_tool bool
}
pub fn (o &CUserAccountRegisterCompatToolRequest) pack() []byte {
mut res := []byte{}
if o.has_compat_tool {
res << vproto.pack_uint32_field(o.compat_tool, 1)
}

return res
}

pub fn cuseraccountregistercompattoolrequest_unpack(buf []byte) ?CUserAccountRegisterCompatToolRequest {
mut res := CUserAccountRegisterCompatToolRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_compat_tool = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.compat_tool = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountregistercompattoolrequest() CUserAccountRegisterCompatToolRequest {
return CUserAccountRegisterCompatToolRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountregistercompattoolrequest(o CUserAccountRegisterCompatToolRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountregistercompattoolrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountRegisterCompatToolRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountregistercompattoolrequest_unpack(v)?
return i, unpacked
}
pub struct CUserAccountRegisterCompatToolResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CUserAccountRegisterCompatToolResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cuseraccountregistercompattoolresponse_unpack(buf []byte) ?CUserAccountRegisterCompatToolResponse {
res := CUserAccountRegisterCompatToolResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccountregistercompattoolresponse() CUserAccountRegisterCompatToolResponse {
return CUserAccountRegisterCompatToolResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccountregistercompattoolresponse(o CUserAccountRegisterCompatToolResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccountregistercompattoolresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccountRegisterCompatToolResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cuseraccountregistercompattoolresponse_unpack(v)?
return i, unpacked
}
pub struct CAccountLinkingGetLinkedAccountInfoRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
account_type EInternalAccountType
has_account_type bool
account_id u64
has_account_id bool
filter EExternalAccountType
has_filter bool
return_access_token bool
has_return_access_token bool
}
pub fn (o &CAccountLinkingGetLinkedAccountInfoRequest) pack() []byte {
mut res := []byte{}
if o.has_account_type {
res << zzz_vproto_internal_pack_einternalaccounttype(o.account_type, 1)
}

if o.has_account_id {
res << vproto.pack_uint64_field(o.account_id, 2)
}

if o.has_filter {
res << zzz_vproto_internal_pack_eexternalaccounttype(o.filter, 3)
}

if o.has_return_access_token {
res << vproto.pack_bool_field(o.return_access_token, 4)
}

return res
}

pub fn caccountlinkinggetlinkedaccountinforequest_unpack(buf []byte) ?CAccountLinkingGetLinkedAccountInfoRequest {
mut res := CAccountLinkingGetLinkedAccountInfoRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_account_type = true
ii, v := zzz_vproto_internal_unpack_einternalaccounttype(cur_buf, tag_wiretype.wire_type)?
res.account_type = v
i = ii
}

2 {
res.has_account_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.account_id = v
i = ii
}

3 {
res.has_filter = true
ii, v := zzz_vproto_internal_unpack_eexternalaccounttype(cur_buf, tag_wiretype.wire_type)?
res.filter = v
i = ii
}

4 {
res.has_return_access_token = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.return_access_token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccountlinkinggetlinkedaccountinforequest() CAccountLinkingGetLinkedAccountInfoRequest {
return CAccountLinkingGetLinkedAccountInfoRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccountlinkinggetlinkedaccountinforequest(o CAccountLinkingGetLinkedAccountInfoRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccountlinkinggetlinkedaccountinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountLinkingGetLinkedAccountInfoRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := caccountlinkinggetlinkedaccountinforequest_unpack(v)?
return i, unpacked
}
pub struct CAccountLinkingGetLinkedAccountInfoResponseCExternalAccountTupleResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
external_type EExternalAccountType
has_external_type bool
external_id string
has_external_id bool
external_user_name string
has_external_user_name bool
external_url string
has_external_url bool
access_token string
has_access_token bool
access_token_secret string
has_access_token_secret bool
is_valid bool
has_is_valid bool
}
pub fn (o &CAccountLinkingGetLinkedAccountInfoResponseCExternalAccountTupleResponse) pack() []byte {
mut res := []byte{}
if o.has_external_type {
res << zzz_vproto_internal_pack_eexternalaccounttype(o.external_type, 1)
}

if o.has_external_id {
res << vproto.pack_string_field(o.external_id, 2)
}

if o.has_external_user_name {
res << vproto.pack_string_field(o.external_user_name, 3)
}

if o.has_external_url {
res << vproto.pack_string_field(o.external_url, 4)
}

if o.has_access_token {
res << vproto.pack_string_field(o.access_token, 5)
}

if o.has_access_token_secret {
res << vproto.pack_string_field(o.access_token_secret, 6)
}

if o.has_is_valid {
res << vproto.pack_bool_field(o.is_valid, 7)
}

return res
}

pub fn caccountlinkinggetlinkedaccountinforesponsecexternalaccounttupleresponse_unpack(buf []byte) ?CAccountLinkingGetLinkedAccountInfoResponseCExternalAccountTupleResponse {
mut res := CAccountLinkingGetLinkedAccountInfoResponseCExternalAccountTupleResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_external_type = true
ii, v := zzz_vproto_internal_unpack_eexternalaccounttype(cur_buf, tag_wiretype.wire_type)?
res.external_type = v
i = ii
}

2 {
res.has_external_id = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.external_id = v
i = ii
}

3 {
res.has_external_user_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.external_user_name = v
i = ii
}

4 {
res.has_external_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.external_url = v
i = ii
}

5 {
res.has_access_token = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.access_token = v
i = ii
}

6 {
res.has_access_token_secret = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.access_token_secret = v
i = ii
}

7 {
res.has_is_valid = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_valid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccountlinkinggetlinkedaccountinforesponsecexternalaccounttupleresponse() CAccountLinkingGetLinkedAccountInfoResponseCExternalAccountTupleResponse {
return CAccountLinkingGetLinkedAccountInfoResponseCExternalAccountTupleResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccountlinkinggetlinkedaccountinforesponsecexternalaccounttupleresponse(o CAccountLinkingGetLinkedAccountInfoResponseCExternalAccountTupleResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccountlinkinggetlinkedaccountinforesponsecexternalaccounttupleresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountLinkingGetLinkedAccountInfoResponseCExternalAccountTupleResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := caccountlinkinggetlinkedaccountinforesponsecexternalaccounttupleresponse_unpack(v)?
return i, unpacked
}
pub struct CAccountLinkingGetLinkedAccountInfoResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
external_accounts []CAccountLinkingGetLinkedAccountInfoResponseCExternalAccountTupleResponse
}
pub fn (o &CAccountLinkingGetLinkedAccountInfoResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.external_accounts {
res << zzz_vproto_internal_pack_caccountlinkinggetlinkedaccountinforesponsecexternalaccounttupleresponse(x, 1)
}

return res
}

pub fn caccountlinkinggetlinkedaccountinforesponse_unpack(buf []byte) ?CAccountLinkingGetLinkedAccountInfoResponse {
mut res := CAccountLinkingGetLinkedAccountInfoResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_caccountlinkinggetlinkedaccountinforesponsecexternalaccounttupleresponse(cur_buf, tag_wiretype.wire_type)?
res.external_accounts << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccountlinkinggetlinkedaccountinforesponse() CAccountLinkingGetLinkedAccountInfoResponse {
return CAccountLinkingGetLinkedAccountInfoResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccountlinkinggetlinkedaccountinforesponse(o CAccountLinkingGetLinkedAccountInfoResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccountlinkinggetlinkedaccountinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountLinkingGetLinkedAccountInfoResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := caccountlinkinggetlinkedaccountinforesponse_unpack(v)?
return i, unpacked
}
pub struct CEmbeddedClientAuthorizeCurrentDeviceRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
appid u32
has_appid bool
device_info string
has_device_info bool
deviceid u32
has_deviceid bool
}
pub fn (o &CEmbeddedClientAuthorizeCurrentDeviceRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 2)
}

if o.has_device_info {
res << vproto.pack_string_field(o.device_info, 3)
}

if o.has_deviceid {
res << vproto.pack_uint32_field(o.deviceid, 4)
}

return res
}

pub fn cembeddedclientauthorizecurrentdevicerequest_unpack(buf []byte) ?CEmbeddedClientAuthorizeCurrentDeviceRequest {
mut res := CEmbeddedClientAuthorizeCurrentDeviceRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

3 {
res.has_device_info = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.device_info = v
i = ii
}

4 {
res.has_deviceid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deviceid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cembeddedclientauthorizecurrentdevicerequest() CEmbeddedClientAuthorizeCurrentDeviceRequest {
return CEmbeddedClientAuthorizeCurrentDeviceRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cembeddedclientauthorizecurrentdevicerequest(o CEmbeddedClientAuthorizeCurrentDeviceRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cembeddedclientauthorizecurrentdevicerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CEmbeddedClientAuthorizeCurrentDeviceRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cembeddedclientauthorizecurrentdevicerequest_unpack(v)?
return i, unpacked
}
pub struct CEmbeddedClientToken {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
client_token []byte
has_client_token bool
expiry u32
has_expiry bool
deviceid u32
has_deviceid bool
}
pub fn (o &CEmbeddedClientToken) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_client_token {
res << vproto.pack_bytes_field(o.client_token, 2)
}

if o.has_expiry {
res << vproto.pack_uint32_field(o.expiry, 3)
}

if o.has_deviceid {
res << vproto.pack_uint32_field(o.deviceid, 4)
}

return res
}

pub fn cembeddedclienttoken_unpack(buf []byte) ?CEmbeddedClientToken {
mut res := CEmbeddedClientToken{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_client_token = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.client_token = v
i = ii
}

3 {
res.has_expiry = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.expiry = v
i = ii
}

4 {
res.has_deviceid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.deviceid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cembeddedclienttoken() CEmbeddedClientToken {
return CEmbeddedClientToken{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cembeddedclienttoken(o CEmbeddedClientToken, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cembeddedclienttoken(buf []byte, tag_wiretype vproto.WireType) ?(int, CEmbeddedClientToken) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cembeddedclienttoken_unpack(v)?
return i, unpacked
}
pub struct CEmbeddedClientAuthorizeDeviceResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
result u32
has_result bool
token CEmbeddedClientToken
has_token bool
}
pub fn (o &CEmbeddedClientAuthorizeDeviceResponse) pack() []byte {
mut res := []byte{}
if o.has_result {
res << vproto.pack_uint32_field(o.result, 1)
}

if o.has_token {
res << zzz_vproto_internal_pack_cembeddedclienttoken(o.token, 2)
}

return res
}

pub fn cembeddedclientauthorizedeviceresponse_unpack(buf []byte) ?CEmbeddedClientAuthorizeDeviceResponse {
mut res := CEmbeddedClientAuthorizeDeviceResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_result = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.result = v
i = ii
}

2 {
res.has_token = true
ii, v := zzz_vproto_internal_unpack_cembeddedclienttoken(cur_buf, tag_wiretype.wire_type)?
res.token = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cembeddedclientauthorizedeviceresponse() CEmbeddedClientAuthorizeDeviceResponse {
return CEmbeddedClientAuthorizeDeviceResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cembeddedclientauthorizedeviceresponse(o CEmbeddedClientAuthorizeDeviceResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cembeddedclientauthorizedeviceresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CEmbeddedClientAuthorizeDeviceResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cembeddedclientauthorizedeviceresponse_unpack(v)?
return i, unpacked
}
