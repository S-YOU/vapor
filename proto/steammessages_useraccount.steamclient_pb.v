// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EInternalAccountType {
	k_einternalsteamaccounttype = 1
	k_einternalclantype = 2
	k_einternalapptype = 3
	k_einternalbroadcastchanneltype = 4
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_einternalaccounttype(e EInternalAccountType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_einternalaccounttype_packed(e []EInternalAccountType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_einternalaccounttype(buf []byte, tag_wiretype vproto.WireType) ?(int, EInternalAccountType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EInternalAccountType(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_einternalaccounttype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EInternalAccountType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EExternalAccountType {
	k_eexternalnone = 0
	k_eexternalsteamaccount = 1
	k_eexternalgoogleaccount = 2
	k_eexternalfacebookaccount = 3
	k_eexternaltwitteraccount = 4
	k_eexternaltwitchaccount = 5
	k_eexternalyoutubechannelaccount = 6
	k_eexternalfacebookpage = 7
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eexternalaccounttype(e EExternalAccountType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eexternalaccounttype_packed(e []EExternalAccountType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eexternalaccounttype(buf []byte, tag_wiretype vproto.WireType) ?(int, EExternalAccountType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EExternalAccountType(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eexternalaccounttype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EExternalAccountType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CUserAccount_GetAvailableValveDiscountPromotions_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	country_code     string
	has_country_code bool
}

pub fn (o &CUserAccount_GetAvailableValveDiscountPromotions_Request) pack() []byte {
	mut res := []byte{}
	if o.has_country_code {
		res << vproto.pack_string_field(o.country_code, 1)
	}
	return res
}

pub fn cuseraccount_getavailablevalvediscountpromotions_request_unpack(buf []byte) ?CUserAccount_GetAvailableValveDiscountPromotions_Request {
	mut res := CUserAccount_GetAvailableValveDiscountPromotions_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_country_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.country_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_getavailablevalvediscountpromotions_request() CUserAccount_GetAvailableValveDiscountPromotions_Request {
	return CUserAccount_GetAvailableValveDiscountPromotions_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_getavailablevalvediscountpromotions_request(o CUserAccount_GetAvailableValveDiscountPromotions_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_getavailablevalvediscountpromotions_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_GetAvailableValveDiscountPromotions_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_getavailablevalvediscountpromotions_request_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_GetAvailableValveDiscountPromotions_Response_ValveDiscountPromotionDetails {
mut:
	unknown_fields                      []vproto.UnknownField
pub mut:
	promotionid                         u32
	has_promotionid                     bool
	promotion_description               string
	has_promotion_description           bool
	minimum_cart_amount                 i64
	has_minimum_cart_amount             bool
	minimum_cart_amount_for_display     i64
	has_minimum_cart_amount_for_display bool
	discount_amount                     i64
	has_discount_amount                 bool
	currency_code                       int
	has_currency_code                   bool
	available_use_count                 int
	has_available_use_count             bool
	promotional_discount_type           int
	has_promotional_discount_type       bool
	loyalty_reward_id                   int
	has_loyalty_reward_id               bool
	localized_name_token                string
	has_localized_name_token            bool
	max_use_count                       int
	has_max_use_count                   bool
}

pub fn (o &CUserAccount_GetAvailableValveDiscountPromotions_Response_ValveDiscountPromotionDetails) pack() []byte {
	mut res := []byte{}
	if o.has_promotionid {
		res << vproto.pack_uint32_field(o.promotionid, 1)
	}
	if o.has_promotion_description {
		res << vproto.pack_string_field(o.promotion_description, 2)
	}
	if o.has_minimum_cart_amount {
		res << vproto.pack_int64_field(o.minimum_cart_amount, 3)
	}
	if o.has_minimum_cart_amount_for_display {
		res << vproto.pack_int64_field(o.minimum_cart_amount_for_display, 4)
	}
	if o.has_discount_amount {
		res << vproto.pack_int64_field(o.discount_amount, 5)
	}
	if o.has_currency_code {
		res << vproto.pack_int32_field(o.currency_code, 6)
	}
	if o.has_available_use_count {
		res << vproto.pack_int32_field(o.available_use_count, 7)
	}
	if o.has_promotional_discount_type {
		res << vproto.pack_int32_field(o.promotional_discount_type, 8)
	}
	if o.has_loyalty_reward_id {
		res << vproto.pack_int32_field(o.loyalty_reward_id, 9)
	}
	if o.has_localized_name_token {
		res << vproto.pack_string_field(o.localized_name_token, 10)
	}
	if o.has_max_use_count {
		res << vproto.pack_int32_field(o.max_use_count, 11)
	}
	return res
}

pub fn cuseraccount_getavailablevalvediscountpromotions_response_valvediscountpromotiondetails_unpack(buf []byte) ?CUserAccount_GetAvailableValveDiscountPromotions_Response_ValveDiscountPromotionDetails {
	mut res := CUserAccount_GetAvailableValveDiscountPromotions_Response_ValveDiscountPromotionDetails{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_promotionid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.promotionid = v
				i = ii
			}
			2 {
				res.has_promotion_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.promotion_description = v
				i = ii
			}
			3 {
				res.has_minimum_cart_amount = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
				res.minimum_cart_amount = v
				i = ii
			}
			4 {
				res.has_minimum_cart_amount_for_display = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
				res.minimum_cart_amount_for_display = v
				i = ii
			}
			5 {
				res.has_discount_amount = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
				res.discount_amount = v
				i = ii
			}
			6 {
				res.has_currency_code = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.currency_code = v
				i = ii
			}
			7 {
				res.has_available_use_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.available_use_count = v
				i = ii
			}
			8 {
				res.has_promotional_discount_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.promotional_discount_type = v
				i = ii
			}
			9 {
				res.has_loyalty_reward_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.loyalty_reward_id = v
				i = ii
			}
			10 {
				res.has_localized_name_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.localized_name_token = v
				i = ii
			}
			11 {
				res.has_max_use_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_use_count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_getavailablevalvediscountpromotions_response_valvediscountpromotiondetails() CUserAccount_GetAvailableValveDiscountPromotions_Response_ValveDiscountPromotionDetails {
	return CUserAccount_GetAvailableValveDiscountPromotions_Response_ValveDiscountPromotionDetails{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_getavailablevalvediscountpromotions_response_valvediscountpromotiondetails(o CUserAccount_GetAvailableValveDiscountPromotions_Response_ValveDiscountPromotionDetails, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_getavailablevalvediscountpromotions_response_valvediscountpromotiondetails(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_GetAvailableValveDiscountPromotions_Response_ValveDiscountPromotionDetails) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_getavailablevalvediscountpromotions_response_valvediscountpromotiondetails_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_GetAvailableValveDiscountPromotions_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	promotions     []CUserAccount_GetAvailableValveDiscountPromotions_Response_ValveDiscountPromotionDetails
}

pub fn (o &CUserAccount_GetAvailableValveDiscountPromotions_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.promotions {
		res <<
			zzz_vproto_internal_pack_cuseraccount_getavailablevalvediscountpromotions_response_valvediscountpromotiondetails(x, 1)
	}
	return res
}

pub fn cuseraccount_getavailablevalvediscountpromotions_response_unpack(buf []byte) ?CUserAccount_GetAvailableValveDiscountPromotions_Response {
	mut res := CUserAccount_GetAvailableValveDiscountPromotions_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cuseraccount_getavailablevalvediscountpromotions_response_valvediscountpromotiondetails(cur_buf,
					tag_wiretype.wire_type)?
				res.promotions << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_getavailablevalvediscountpromotions_response() CUserAccount_GetAvailableValveDiscountPromotions_Response {
	return CUserAccount_GetAvailableValveDiscountPromotions_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_getavailablevalvediscountpromotions_response(o CUserAccount_GetAvailableValveDiscountPromotions_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_getavailablevalvediscountpromotions_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_GetAvailableValveDiscountPromotions_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_getavailablevalvediscountpromotions_response_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_GetAccountLinkStatus_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CUserAccount_GetAccountLinkStatus_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cuseraccount_getaccountlinkstatus_request_unpack(buf []byte) ?CUserAccount_GetAccountLinkStatus_Request {
	res := CUserAccount_GetAccountLinkStatus_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_getaccountlinkstatus_request() CUserAccount_GetAccountLinkStatus_Request {
	return CUserAccount_GetAccountLinkStatus_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_getaccountlinkstatus_request(o CUserAccount_GetAccountLinkStatus_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_getaccountlinkstatus_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_GetAccountLinkStatus_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_getaccountlinkstatus_request_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_GetAccountLinkStatus_Response {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	pwid                           u32
	has_pwid                       bool
	identity_verification          u32
	has_identity_verification      bool
	performed_age_verification     bool
	has_performed_age_verification bool
}

pub fn (o &CUserAccount_GetAccountLinkStatus_Response) pack() []byte {
	mut res := []byte{}
	if o.has_pwid {
		res << vproto.pack_uint32_field(o.pwid, 1)
	}
	if o.has_identity_verification {
		res << vproto.pack_uint32_field(o.identity_verification, 2)
	}
	if o.has_performed_age_verification {
		res << vproto.pack_bool_field(o.performed_age_verification, 3)
	}
	return res
}

pub fn cuseraccount_getaccountlinkstatus_response_unpack(buf []byte) ?CUserAccount_GetAccountLinkStatus_Response {
	mut res := CUserAccount_GetAccountLinkStatus_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_pwid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.pwid = v
				i = ii
			}
			2 {
				res.has_identity_verification = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.identity_verification = v
				i = ii
			}
			3 {
				res.has_performed_age_verification = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.performed_age_verification = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_getaccountlinkstatus_response() CUserAccount_GetAccountLinkStatus_Response {
	return CUserAccount_GetAccountLinkStatus_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_getaccountlinkstatus_response(o CUserAccount_GetAccountLinkStatus_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_getaccountlinkstatus_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_GetAccountLinkStatus_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_getaccountlinkstatus_response_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_CancelLicenseForApp_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
}

pub fn (o &CUserAccount_CancelLicenseForApp_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cuseraccount_cancellicenseforapp_request_unpack(buf []byte) ?CUserAccount_CancelLicenseForApp_Request {
	mut res := CUserAccount_CancelLicenseForApp_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_cancellicenseforapp_request() CUserAccount_CancelLicenseForApp_Request {
	return CUserAccount_CancelLicenseForApp_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_cancellicenseforapp_request(o CUserAccount_CancelLicenseForApp_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_cancellicenseforapp_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_CancelLicenseForApp_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_cancellicenseforapp_request_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_CancelLicenseForApp_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CUserAccount_CancelLicenseForApp_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cuseraccount_cancellicenseforapp_response_unpack(buf []byte) ?CUserAccount_CancelLicenseForApp_Response {
	res := CUserAccount_CancelLicenseForApp_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_cancellicenseforapp_response() CUserAccount_CancelLicenseForApp_Response {
	return CUserAccount_CancelLicenseForApp_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_cancellicenseforapp_response(o CUserAccount_CancelLicenseForApp_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_cancellicenseforapp_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_CancelLicenseForApp_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_cancellicenseforapp_response_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_CreateFriendInviteToken_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	invite_limit        u32
	has_invite_limit    bool
	invite_duration     u32
	has_invite_duration bool
	invite_note         string
	has_invite_note     bool
}

pub fn (o &CUserAccount_CreateFriendInviteToken_Request) pack() []byte {
	mut res := []byte{}
	if o.has_invite_limit {
		res << vproto.pack_uint32_field(o.invite_limit, 1)
	}
	if o.has_invite_duration {
		res << vproto.pack_uint32_field(o.invite_duration, 2)
	}
	if o.has_invite_note {
		res << vproto.pack_string_field(o.invite_note, 3)
	}
	return res
}

pub fn cuseraccount_createfriendinvitetoken_request_unpack(buf []byte) ?CUserAccount_CreateFriendInviteToken_Request {
	mut res := CUserAccount_CreateFriendInviteToken_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_invite_limit = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_limit = v
				i = ii
			}
			2 {
				res.has_invite_duration = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_duration = v
				i = ii
			}
			3 {
				res.has_invite_note = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_note = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_createfriendinvitetoken_request() CUserAccount_CreateFriendInviteToken_Request {
	return CUserAccount_CreateFriendInviteToken_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_createfriendinvitetoken_request(o CUserAccount_CreateFriendInviteToken_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_createfriendinvitetoken_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_CreateFriendInviteToken_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_createfriendinvitetoken_request_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_CreateFriendInviteToken_Response {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	invite_token        string
	has_invite_token    bool
	invite_limit        u64
	has_invite_limit    bool
	invite_duration     u64
	has_invite_duration bool
	time_created        u32
	has_time_created    bool
	valid               bool
	has_valid           bool
}

pub fn (o &CUserAccount_CreateFriendInviteToken_Response) pack() []byte {
	mut res := []byte{}
	if o.has_invite_token {
		res << vproto.pack_string_field(o.invite_token, 1)
	}
	if o.has_invite_limit {
		res << vproto.pack_uint64_field(o.invite_limit, 2)
	}
	if o.has_invite_duration {
		res << vproto.pack_uint64_field(o.invite_duration, 3)
	}
	if o.has_time_created {
		res << vproto.pack_32bit_field(o.time_created, 4)
	}
	if o.has_valid {
		res << vproto.pack_bool_field(o.valid, 5)
	}
	return res
}

pub fn cuseraccount_createfriendinvitetoken_response_unpack(buf []byte) ?CUserAccount_CreateFriendInviteToken_Response {
	mut res := CUserAccount_CreateFriendInviteToken_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_invite_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_token = v
				i = ii
			}
			2 {
				res.has_invite_limit = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_limit = v
				i = ii
			}
			3 {
				res.has_invite_duration = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_duration = v
				i = ii
			}
			4 {
				res.has_time_created = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			5 {
				res.has_valid = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.valid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_createfriendinvitetoken_response() CUserAccount_CreateFriendInviteToken_Response {
	return CUserAccount_CreateFriendInviteToken_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_createfriendinvitetoken_response(o CUserAccount_CreateFriendInviteToken_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_createfriendinvitetoken_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_CreateFriendInviteToken_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_createfriendinvitetoken_response_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_GetFriendInviteTokens_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CUserAccount_GetFriendInviteTokens_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cuseraccount_getfriendinvitetokens_request_unpack(buf []byte) ?CUserAccount_GetFriendInviteTokens_Request {
	res := CUserAccount_GetFriendInviteTokens_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_getfriendinvitetokens_request() CUserAccount_GetFriendInviteTokens_Request {
	return CUserAccount_GetFriendInviteTokens_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_getfriendinvitetokens_request(o CUserAccount_GetFriendInviteTokens_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_getfriendinvitetokens_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_GetFriendInviteTokens_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_getfriendinvitetokens_request_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_GetFriendInviteTokens_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	tokens         []CUserAccount_CreateFriendInviteToken_Response
}

pub fn (o &CUserAccount_GetFriendInviteTokens_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.tokens {
		res << zzz_vproto_internal_pack_cuseraccount_createfriendinvitetoken_response(x, 1)
	}
	return res
}

pub fn cuseraccount_getfriendinvitetokens_response_unpack(buf []byte) ?CUserAccount_GetFriendInviteTokens_Response {
	mut res := CUserAccount_GetFriendInviteTokens_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cuseraccount_createfriendinvitetoken_response(cur_buf,
					tag_wiretype.wire_type)?
				res.tokens << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_getfriendinvitetokens_response() CUserAccount_GetFriendInviteTokens_Response {
	return CUserAccount_GetFriendInviteTokens_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_getfriendinvitetokens_response(o CUserAccount_GetFriendInviteTokens_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_getfriendinvitetokens_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_GetFriendInviteTokens_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_getfriendinvitetokens_response_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_ViewFriendInviteToken_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	invite_token     string
	has_invite_token bool
}

pub fn (o &CUserAccount_ViewFriendInviteToken_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_invite_token {
		res << vproto.pack_string_field(o.invite_token, 2)
	}
	return res
}

pub fn cuseraccount_viewfriendinvitetoken_request_unpack(buf []byte) ?CUserAccount_ViewFriendInviteToken_Request {
	mut res := CUserAccount_ViewFriendInviteToken_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_invite_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_viewfriendinvitetoken_request() CUserAccount_ViewFriendInviteToken_Request {
	return CUserAccount_ViewFriendInviteToken_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_viewfriendinvitetoken_request(o CUserAccount_ViewFriendInviteToken_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_viewfriendinvitetoken_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_ViewFriendInviteToken_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_viewfriendinvitetoken_request_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_ViewFriendInviteToken_Response {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	valid               bool
	has_valid           bool
	steamid             u64
	has_steamid         bool
	invite_duration     u64
	has_invite_duration bool
}

pub fn (o &CUserAccount_ViewFriendInviteToken_Response) pack() []byte {
	mut res := []byte{}
	if o.has_valid {
		res << vproto.pack_bool_field(o.valid, 1)
	}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 2)
	}
	if o.has_invite_duration {
		res << vproto.pack_uint64_field(o.invite_duration, 3)
	}
	return res
}

pub fn cuseraccount_viewfriendinvitetoken_response_unpack(buf []byte) ?CUserAccount_ViewFriendInviteToken_Response {
	mut res := CUserAccount_ViewFriendInviteToken_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_valid = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.valid = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_invite_duration = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_duration = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_viewfriendinvitetoken_response() CUserAccount_ViewFriendInviteToken_Response {
	return CUserAccount_ViewFriendInviteToken_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_viewfriendinvitetoken_response(o CUserAccount_ViewFriendInviteToken_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_viewfriendinvitetoken_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_ViewFriendInviteToken_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_viewfriendinvitetoken_response_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_RedeemFriendInviteToken_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	invite_token     string
	has_invite_token bool
}

pub fn (o &CUserAccount_RedeemFriendInviteToken_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_invite_token {
		res << vproto.pack_string_field(o.invite_token, 2)
	}
	return res
}

pub fn cuseraccount_redeemfriendinvitetoken_request_unpack(buf []byte) ?CUserAccount_RedeemFriendInviteToken_Request {
	mut res := CUserAccount_RedeemFriendInviteToken_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_invite_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_redeemfriendinvitetoken_request() CUserAccount_RedeemFriendInviteToken_Request {
	return CUserAccount_RedeemFriendInviteToken_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_redeemfriendinvitetoken_request(o CUserAccount_RedeemFriendInviteToken_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_redeemfriendinvitetoken_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_RedeemFriendInviteToken_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_redeemfriendinvitetoken_request_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_RedeemFriendInviteToken_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CUserAccount_RedeemFriendInviteToken_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cuseraccount_redeemfriendinvitetoken_response_unpack(buf []byte) ?CUserAccount_RedeemFriendInviteToken_Response {
	res := CUserAccount_RedeemFriendInviteToken_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_redeemfriendinvitetoken_response() CUserAccount_RedeemFriendInviteToken_Response {
	return CUserAccount_RedeemFriendInviteToken_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_redeemfriendinvitetoken_response(o CUserAccount_RedeemFriendInviteToken_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_redeemfriendinvitetoken_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_RedeemFriendInviteToken_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_redeemfriendinvitetoken_response_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_RevokeFriendInviteToken_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	invite_token     string
	has_invite_token bool
}

pub fn (o &CUserAccount_RevokeFriendInviteToken_Request) pack() []byte {
	mut res := []byte{}
	if o.has_invite_token {
		res << vproto.pack_string_field(o.invite_token, 1)
	}
	return res
}

pub fn cuseraccount_revokefriendinvitetoken_request_unpack(buf []byte) ?CUserAccount_RevokeFriendInviteToken_Request {
	mut res := CUserAccount_RevokeFriendInviteToken_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_invite_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_revokefriendinvitetoken_request() CUserAccount_RevokeFriendInviteToken_Request {
	return CUserAccount_RevokeFriendInviteToken_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_revokefriendinvitetoken_request(o CUserAccount_RevokeFriendInviteToken_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_revokefriendinvitetoken_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_RevokeFriendInviteToken_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_revokefriendinvitetoken_request_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_RevokeFriendInviteToken_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CUserAccount_RevokeFriendInviteToken_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cuseraccount_revokefriendinvitetoken_response_unpack(buf []byte) ?CUserAccount_RevokeFriendInviteToken_Response {
	res := CUserAccount_RevokeFriendInviteToken_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_revokefriendinvitetoken_response() CUserAccount_RevokeFriendInviteToken_Response {
	return CUserAccount_RevokeFriendInviteToken_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_revokefriendinvitetoken_response(o CUserAccount_RevokeFriendInviteToken_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_revokefriendinvitetoken_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_RevokeFriendInviteToken_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_revokefriendinvitetoken_response_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_RegisterCompatTool_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	compat_tool     u32
	has_compat_tool bool
}

pub fn (o &CUserAccount_RegisterCompatTool_Request) pack() []byte {
	mut res := []byte{}
	if o.has_compat_tool {
		res << vproto.pack_uint32_field(o.compat_tool, 1)
	}
	return res
}

pub fn cuseraccount_registercompattool_request_unpack(buf []byte) ?CUserAccount_RegisterCompatTool_Request {
	mut res := CUserAccount_RegisterCompatTool_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_compat_tool = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.compat_tool = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_registercompattool_request() CUserAccount_RegisterCompatTool_Request {
	return CUserAccount_RegisterCompatTool_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_registercompattool_request(o CUserAccount_RegisterCompatTool_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_registercompattool_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_RegisterCompatTool_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_registercompattool_request_unpack(v)?
	return i, unpacked
}

pub struct CUserAccount_RegisterCompatTool_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CUserAccount_RegisterCompatTool_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cuseraccount_registercompattool_response_unpack(buf []byte) ?CUserAccount_RegisterCompatTool_Response {
	res := CUserAccount_RegisterCompatTool_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cuseraccount_registercompattool_response() CUserAccount_RegisterCompatTool_Response {
	return CUserAccount_RegisterCompatTool_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cuseraccount_registercompattool_response(o CUserAccount_RegisterCompatTool_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cuseraccount_registercompattool_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CUserAccount_RegisterCompatTool_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cuseraccount_registercompattool_response_unpack(v)?
	return i, unpacked
}

pub struct CAccountLinking_GetLinkedAccountInfo_Request {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	account_type            EInternalAccountType
	has_account_type        bool
	account_id              u64
	has_account_id          bool
	filter                  EExternalAccountType
	has_filter              bool
	return_access_token     bool
	has_return_access_token bool
}

pub fn (o &CAccountLinking_GetLinkedAccountInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.has_account_type {
		res << zzz_vproto_internal_pack_einternalaccounttype(o.account_type, 1)
	}
	if o.has_account_id {
		res << vproto.pack_uint64_field(o.account_id, 2)
	}
	if o.has_filter {
		res << zzz_vproto_internal_pack_eexternalaccounttype(o.filter, 3)
	}
	if o.has_return_access_token {
		res << vproto.pack_bool_field(o.return_access_token, 4)
	}
	return res
}

pub fn caccountlinking_getlinkedaccountinfo_request_unpack(buf []byte) ?CAccountLinking_GetLinkedAccountInfo_Request {
	mut res := CAccountLinking_GetLinkedAccountInfo_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_account_type = true
				ii, v := zzz_vproto_internal_unpack_einternalaccounttype(cur_buf, tag_wiretype.wire_type)?
				res.account_type = v
				i = ii
			}
			2 {
				res.has_account_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.account_id = v
				i = ii
			}
			3 {
				res.has_filter = true
				ii, v := zzz_vproto_internal_unpack_eexternalaccounttype(cur_buf, tag_wiretype.wire_type)?
				res.filter = v
				i = ii
			}
			4 {
				res.has_return_access_token = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.return_access_token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccountlinking_getlinkedaccountinfo_request() CAccountLinking_GetLinkedAccountInfo_Request {
	return CAccountLinking_GetLinkedAccountInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccountlinking_getlinkedaccountinfo_request(o CAccountLinking_GetLinkedAccountInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccountlinking_getlinkedaccountinfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountLinking_GetLinkedAccountInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccountlinking_getlinkedaccountinfo_request_unpack(v)?
	return i, unpacked
}

pub struct CAccountLinking_GetLinkedAccountInfo_Response_CExternalAccountTuple_Response {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	external_type           EExternalAccountType
	has_external_type       bool
	external_id             string
	has_external_id         bool
	external_user_name      string
	has_external_user_name  bool
	external_url            string
	has_external_url        bool
	access_token            string
	has_access_token        bool
	access_token_secret     string
	has_access_token_secret bool
	is_valid                bool
	has_is_valid            bool
}

pub fn (o &CAccountLinking_GetLinkedAccountInfo_Response_CExternalAccountTuple_Response) pack() []byte {
	mut res := []byte{}
	if o.has_external_type {
		res << zzz_vproto_internal_pack_eexternalaccounttype(o.external_type, 1)
	}
	if o.has_external_id {
		res << vproto.pack_string_field(o.external_id, 2)
	}
	if o.has_external_user_name {
		res << vproto.pack_string_field(o.external_user_name, 3)
	}
	if o.has_external_url {
		res << vproto.pack_string_field(o.external_url, 4)
	}
	if o.has_access_token {
		res << vproto.pack_string_field(o.access_token, 5)
	}
	if o.has_access_token_secret {
		res << vproto.pack_string_field(o.access_token_secret, 6)
	}
	if o.has_is_valid {
		res << vproto.pack_bool_field(o.is_valid, 7)
	}
	return res
}

pub fn caccountlinking_getlinkedaccountinfo_response_cexternalaccounttuple_response_unpack(buf []byte) ?CAccountLinking_GetLinkedAccountInfo_Response_CExternalAccountTuple_Response {
	mut res := CAccountLinking_GetLinkedAccountInfo_Response_CExternalAccountTuple_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_external_type = true
				ii, v := zzz_vproto_internal_unpack_eexternalaccounttype(cur_buf, tag_wiretype.wire_type)?
				res.external_type = v
				i = ii
			}
			2 {
				res.has_external_id = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.external_id = v
				i = ii
			}
			3 {
				res.has_external_user_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.external_user_name = v
				i = ii
			}
			4 {
				res.has_external_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.external_url = v
				i = ii
			}
			5 {
				res.has_access_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.access_token = v
				i = ii
			}
			6 {
				res.has_access_token_secret = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.access_token_secret = v
				i = ii
			}
			7 {
				res.has_is_valid = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_valid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccountlinking_getlinkedaccountinfo_response_cexternalaccounttuple_response() CAccountLinking_GetLinkedAccountInfo_Response_CExternalAccountTuple_Response {
	return CAccountLinking_GetLinkedAccountInfo_Response_CExternalAccountTuple_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccountlinking_getlinkedaccountinfo_response_cexternalaccounttuple_response(o CAccountLinking_GetLinkedAccountInfo_Response_CExternalAccountTuple_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccountlinking_getlinkedaccountinfo_response_cexternalaccounttuple_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountLinking_GetLinkedAccountInfo_Response_CExternalAccountTuple_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccountlinking_getlinkedaccountinfo_response_cexternalaccounttuple_response_unpack(v)?
	return i, unpacked
}

pub struct CAccountLinking_GetLinkedAccountInfo_Response {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	external_accounts []CAccountLinking_GetLinkedAccountInfo_Response_CExternalAccountTuple_Response
}

pub fn (o &CAccountLinking_GetLinkedAccountInfo_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.external_accounts {
		res <<
			zzz_vproto_internal_pack_caccountlinking_getlinkedaccountinfo_response_cexternalaccounttuple_response(x, 1)
	}
	return res
}

pub fn caccountlinking_getlinkedaccountinfo_response_unpack(buf []byte) ?CAccountLinking_GetLinkedAccountInfo_Response {
	mut res := CAccountLinking_GetLinkedAccountInfo_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_caccountlinking_getlinkedaccountinfo_response_cexternalaccounttuple_response(cur_buf,
					tag_wiretype.wire_type)?
				res.external_accounts << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccountlinking_getlinkedaccountinfo_response() CAccountLinking_GetLinkedAccountInfo_Response {
	return CAccountLinking_GetLinkedAccountInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccountlinking_getlinkedaccountinfo_response(o CAccountLinking_GetLinkedAccountInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccountlinking_getlinkedaccountinfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountLinking_GetLinkedAccountInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccountlinking_getlinkedaccountinfo_response_unpack(v)?
	return i, unpacked
}

pub struct CEmbeddedClient_AuthorizeCurrentDevice_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	steamid         u64
	has_steamid     bool
	appid           u32
	has_appid       bool
	device_info     string
	has_device_info bool
	deviceid        u32
	has_deviceid    bool
}

pub fn (o &CEmbeddedClient_AuthorizeCurrentDevice_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_device_info {
		res << vproto.pack_string_field(o.device_info, 3)
	}
	if o.has_deviceid {
		res << vproto.pack_uint32_field(o.deviceid, 4)
	}
	return res
}

pub fn cembeddedclient_authorizecurrentdevice_request_unpack(buf []byte) ?CEmbeddedClient_AuthorizeCurrentDevice_Request {
	mut res := CEmbeddedClient_AuthorizeCurrentDevice_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_device_info = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_info = v
				i = ii
			}
			4 {
				res.has_deviceid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deviceid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cembeddedclient_authorizecurrentdevice_request() CEmbeddedClient_AuthorizeCurrentDevice_Request {
	return CEmbeddedClient_AuthorizeCurrentDevice_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cembeddedclient_authorizecurrentdevice_request(o CEmbeddedClient_AuthorizeCurrentDevice_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cembeddedclient_authorizecurrentdevice_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CEmbeddedClient_AuthorizeCurrentDevice_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cembeddedclient_authorizecurrentdevice_request_unpack(v)?
	return i, unpacked
}

pub struct CEmbeddedClient_Token {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	client_token     []byte
	has_client_token bool
	expiry           u32
	has_expiry       bool
	deviceid         u32
	has_deviceid     bool
}

pub fn (o &CEmbeddedClient_Token) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_client_token {
		res << vproto.pack_bytes_field(o.client_token, 2)
	}
	if o.has_expiry {
		res << vproto.pack_uint32_field(o.expiry, 3)
	}
	if o.has_deviceid {
		res << vproto.pack_uint32_field(o.deviceid, 4)
	}
	return res
}

pub fn cembeddedclient_token_unpack(buf []byte) ?CEmbeddedClient_Token {
	mut res := CEmbeddedClient_Token{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_client_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.client_token = v
				i = ii
			}
			3 {
				res.has_expiry = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.expiry = v
				i = ii
			}
			4 {
				res.has_deviceid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deviceid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cembeddedclient_token() CEmbeddedClient_Token {
	return CEmbeddedClient_Token{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cembeddedclient_token(o CEmbeddedClient_Token, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cembeddedclient_token(buf []byte, tag_wiretype vproto.WireType) ?(int, CEmbeddedClient_Token) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cembeddedclient_token_unpack(v)?
	return i, unpacked
}

pub struct CEmbeddedClient_AuthorizeDevice_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         u32
	has_result     bool
	token          CEmbeddedClient_Token
	has_token      bool
}

pub fn (o &CEmbeddedClient_AuthorizeDevice_Response) pack() []byte {
	mut res := []byte{}
	if o.has_result {
		res << vproto.pack_uint32_field(o.result, 1)
	}
	if o.has_token {
		res << zzz_vproto_internal_pack_cembeddedclient_token(o.token, 2)
	}
	return res
}

pub fn cembeddedclient_authorizedevice_response_unpack(buf []byte) ?CEmbeddedClient_AuthorizeDevice_Response {
	mut res := CEmbeddedClient_AuthorizeDevice_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_result = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			2 {
				res.has_token = true
				ii, v := zzz_vproto_internal_unpack_cembeddedclient_token(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cembeddedclient_authorizedevice_response() CEmbeddedClient_AuthorizeDevice_Response {
	return CEmbeddedClient_AuthorizeDevice_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cembeddedclient_authorizedevice_response(o CEmbeddedClient_AuthorizeDevice_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cembeddedclient_authorizedevice_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CEmbeddedClient_AuthorizeDevice_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cembeddedclient_authorizedevice_response_unpack(v)?
	return i, unpacked
}
