// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EJSRegisterMethodType {
	k_ejsregistermethodtype_invalid = 0
	k_ejsregistermethodtype_function = 1
	k_ejsregistermethodtype_callback = 2
	k_ejsregistermethodtype_promise = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_ejsregistermethodtype(e EJSRegisterMethodType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_ejsregistermethodtype_packed(e []EJSRegisterMethodType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_ejsregistermethodtype(buf []byte, tag_wiretype vproto.WireType) ?(int, EJSRegisterMethodType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EJSRegisterMethodType(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_ejsregistermethodtype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EJSRegisterMethodType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CMsgKeyUp {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	keycode            u32
	has_keycode        bool
	modifiers          u32
	has_modifiers      bool
	nativekeycode      u32
	has_nativekeycode  bool
}

pub fn (o &CMsgKeyUp) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_keycode {
		res << vproto.pack_uint32_field(o.keycode, 2)
	}
	if o.has_modifiers {
		res << vproto.pack_uint32_field(o.modifiers, 3)
	}
	if o.has_nativekeycode {
		res << vproto.pack_uint32_field(o.nativekeycode, 4)
	}
	return res
}

pub fn cmsgkeyup_unpack(buf []byte) ?CMsgKeyUp {
	mut res := CMsgKeyUp{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_keycode = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.keycode = v
				i = ii
			}
			3 {
				res.has_modifiers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			4 {
				res.has_nativekeycode = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.nativekeycode = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgkeyup() CMsgKeyUp {
	return CMsgKeyUp{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgkeyup(o CMsgKeyUp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgkeyup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgKeyUp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgkeyup_unpack(v)?
	return i, unpacked
}

pub struct CMsgKeyDown {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	keycode            u32
	has_keycode        bool
	modifiers          u32
	has_modifiers      bool
	is_system_key      bool
	has_is_system_key  bool
	nativekeycode      u32
	has_nativekeycode  bool
}

pub fn (o &CMsgKeyDown) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_keycode {
		res << vproto.pack_uint32_field(o.keycode, 2)
	}
	if o.has_modifiers {
		res << vproto.pack_uint32_field(o.modifiers, 3)
	}
	if o.has_is_system_key {
		res << vproto.pack_bool_field(o.is_system_key, 4)
	}
	if o.has_nativekeycode {
		res << vproto.pack_uint32_field(o.nativekeycode, 5)
	}
	return res
}

pub fn cmsgkeydown_unpack(buf []byte) ?CMsgKeyDown {
	mut res := CMsgKeyDown{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_keycode = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.keycode = v
				i = ii
			}
			3 {
				res.has_modifiers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			4 {
				res.has_is_system_key = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_system_key = v
				i = ii
			}
			5 {
				res.has_nativekeycode = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.nativekeycode = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgkeydown() CMsgKeyDown {
	return CMsgKeyDown{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgkeydown(o CMsgKeyDown, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgkeydown(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgKeyDown) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgkeydown_unpack(v)?
	return i, unpacked
}

pub struct CMsgKeyChar {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	unichar            u32
	has_unichar        bool
	modifiers          u32
	has_modifiers      bool
	keycode            u32
	has_keycode        bool
	nativekeycode      u32
	has_nativekeycode  bool
}

pub fn (o &CMsgKeyChar) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_unichar {
		res << vproto.pack_uint32_field(o.unichar, 2)
	}
	if o.has_modifiers {
		res << vproto.pack_uint32_field(o.modifiers, 3)
	}
	if o.has_keycode {
		res << vproto.pack_uint32_field(o.keycode, 4)
	}
	if o.has_nativekeycode {
		res << vproto.pack_uint32_field(o.nativekeycode, 5)
	}
	return res
}

pub fn cmsgkeychar_unpack(buf []byte) ?CMsgKeyChar {
	mut res := CMsgKeyChar{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_unichar = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.unichar = v
				i = ii
			}
			3 {
				res.has_modifiers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			4 {
				res.has_keycode = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.keycode = v
				i = ii
			}
			5 {
				res.has_nativekeycode = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.nativekeycode = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgkeychar() CMsgKeyChar {
	return CMsgKeyChar{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgkeychar(o CMsgKeyChar, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgkeychar(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgKeyChar) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgkeychar_unpack(v)?
	return i, unpacked
}

pub struct CMsgMouseDown {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	mouse_button       u32
	has_mouse_button   bool
	modifiers          u32
	has_modifiers      bool
}

pub fn (o &CMsgMouseDown) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_mouse_button {
		res << vproto.pack_uint32_field(o.mouse_button, 2)
	}
	if o.has_modifiers {
		res << vproto.pack_uint32_field(o.modifiers, 3)
	}
	return res
}

pub fn cmsgmousedown_unpack(buf []byte) ?CMsgMouseDown {
	mut res := CMsgMouseDown{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_mouse_button = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.mouse_button = v
				i = ii
			}
			3 {
				res.has_modifiers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgmousedown() CMsgMouseDown {
	return CMsgMouseDown{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgmousedown(o CMsgMouseDown, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgmousedown(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseDown) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmousedown_unpack(v)?
	return i, unpacked
}

pub struct CMsgMouseUp {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	mouse_button       u32
	has_mouse_button   bool
	modifiers          u32
	has_modifiers      bool
	is_off_panel       bool
	has_is_off_panel   bool
	x                  int
	has_x              bool
	y                  int
	has_y              bool
}

pub fn (o &CMsgMouseUp) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_mouse_button {
		res << vproto.pack_uint32_field(o.mouse_button, 2)
	}
	if o.has_modifiers {
		res << vproto.pack_uint32_field(o.modifiers, 3)
	}
	if o.has_is_off_panel {
		res << vproto.pack_bool_field(o.is_off_panel, 4)
	}
	if o.has_x {
		res << vproto.pack_int32_field(o.x, 5)
	}
	if o.has_y {
		res << vproto.pack_int32_field(o.y, 6)
	}
	return res
}

pub fn cmsgmouseup_unpack(buf []byte) ?CMsgMouseUp {
	mut res := CMsgMouseUp{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_mouse_button = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.mouse_button = v
				i = ii
			}
			3 {
				res.has_modifiers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			4 {
				res.has_is_off_panel = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_off_panel = v
				i = ii
			}
			5 {
				res.has_x = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			6 {
				res.has_y = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgmouseup() CMsgMouseUp {
	return CMsgMouseUp{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgmouseup(o CMsgMouseUp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgmouseup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseUp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmouseup_unpack(v)?
	return i, unpacked
}

pub struct CMsgMouseDblClick {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	mouse_button       u32
	has_mouse_button   bool
	modifiers          u32
	has_modifiers      bool
}

pub fn (o &CMsgMouseDblClick) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_mouse_button {
		res << vproto.pack_uint32_field(o.mouse_button, 2)
	}
	if o.has_modifiers {
		res << vproto.pack_uint32_field(o.modifiers, 3)
	}
	return res
}

pub fn cmsgmousedblclick_unpack(buf []byte) ?CMsgMouseDblClick {
	mut res := CMsgMouseDblClick{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_mouse_button = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.mouse_button = v
				i = ii
			}
			3 {
				res.has_modifiers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgmousedblclick() CMsgMouseDblClick {
	return CMsgMouseDblClick{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgmousedblclick(o CMsgMouseDblClick, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgmousedblclick(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseDblClick) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmousedblclick_unpack(v)?
	return i, unpacked
}

pub struct CMsgMouseWheel {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	deltax             int
	has_deltax         bool
	deltay             int
	has_deltay         bool
	modifiers          u32
	has_modifiers      bool
}

pub fn (o &CMsgMouseWheel) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_deltax {
		res << vproto.pack_int32_field(o.deltax, 2)
	}
	if o.has_deltay {
		res << vproto.pack_int32_field(o.deltay, 3)
	}
	if o.has_modifiers {
		res << vproto.pack_uint32_field(o.modifiers, 4)
	}
	return res
}

pub fn cmsgmousewheel_unpack(buf []byte) ?CMsgMouseWheel {
	mut res := CMsgMouseWheel{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_deltax = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.deltax = v
				i = ii
			}
			3 {
				res.has_deltay = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.deltay = v
				i = ii
			}
			4 {
				res.has_modifiers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgmousewheel() CMsgMouseWheel {
	return CMsgMouseWheel{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgmousewheel(o CMsgMouseWheel, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgmousewheel(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseWheel) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmousewheel_unpack(v)?
	return i, unpacked
}

pub struct CMsgMouseMove {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	x                  int
	has_x              bool
	y                  int
	has_y              bool
	modifiers          u32
	has_modifiers      bool
}

pub fn (o &CMsgMouseMove) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_x {
		res << vproto.pack_int32_field(o.x, 2)
	}
	if o.has_y {
		res << vproto.pack_int32_field(o.y, 3)
	}
	if o.has_modifiers {
		res << vproto.pack_uint32_field(o.modifiers, 4)
	}
	return res
}

pub fn cmsgmousemove_unpack(buf []byte) ?CMsgMouseMove {
	mut res := CMsgMouseMove{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_x = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				res.has_y = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			4 {
				res.has_modifiers = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.modifiers = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgmousemove() CMsgMouseMove {
	return CMsgMouseMove{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgmousemove(o CMsgMouseMove, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgmousemove(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseMove) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmousemove_unpack(v)?
	return i, unpacked
}

pub struct CMsgMouseLeave {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgMouseLeave) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgmouseleave_unpack(buf []byte) ?CMsgMouseLeave {
	mut res := CMsgMouseLeave{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgmouseleave() CMsgMouseLeave {
	return CMsgMouseLeave{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgmouseleave(o CMsgMouseLeave, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgmouseleave(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMouseLeave) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmouseleave_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserCreate {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	request_id                    u32
	has_request_id                bool
	useragent                     string
	has_useragent                 bool
	user_css                      string
	has_user_css                  bool
	native_dropdowns              bool
	has_native_dropdowns          bool
	dpi_scaling                   f32
	has_dpi_scaling               bool
	offscreen                     bool
	has_offscreen                 bool
	initial_width                 u32
	has_initial_width             bool
	initial_height                u32
	has_initial_height            bool
	window_icon                   string
	has_window_icon               bool
	borderless                    bool
	has_borderless                bool
	vroverlay_key                 string
	has_vroverlay_key             bool
	browser_type                  u32
	has_browser_type              bool
	initial_top                   int
	has_initial_top               bool
	initial_left                  int
	has_initial_left              bool
	only_allow_trusted_popups     bool
	has_only_allow_trusted_popups bool
	initial_url                   string
	has_initial_url               bool
	hwnd_parent                   u64
	has_hwnd_parent               bool
}

pub fn (o &CMsgBrowserCreate) pack() []byte {
	mut res := []byte{}
	if o.has_request_id {
		res << vproto.pack_uint32_field(o.request_id, 1)
	}
	if o.has_useragent {
		res << vproto.pack_string_field(o.useragent, 3)
	}
	if o.has_user_css {
		res << vproto.pack_string_field(o.user_css, 5)
	}
	if o.has_native_dropdowns {
		res << vproto.pack_bool_field(o.native_dropdowns, 6)
	}
	if o.has_dpi_scaling {
		res << vproto.pack_float_field(o.dpi_scaling, 7)
	}
	if o.has_offscreen {
		res << vproto.pack_bool_field(o.offscreen, 8)
	}
	if o.has_initial_width {
		res << vproto.pack_uint32_field(o.initial_width, 9)
	}
	if o.has_initial_height {
		res << vproto.pack_uint32_field(o.initial_height, 10)
	}
	if o.has_window_icon {
		res << vproto.pack_string_field(o.window_icon, 11)
	}
	if o.has_borderless {
		res << vproto.pack_bool_field(o.borderless, 12)
	}
	if o.has_vroverlay_key {
		res << vproto.pack_string_field(o.vroverlay_key, 13)
	}
	if o.has_browser_type {
		res << vproto.pack_uint32_field(o.browser_type, 14)
	}
	if o.has_initial_top {
		res << vproto.pack_int32_field(o.initial_top, 15)
	}
	if o.has_initial_left {
		res << vproto.pack_int32_field(o.initial_left, 16)
	}
	if o.has_only_allow_trusted_popups {
		res << vproto.pack_bool_field(o.only_allow_trusted_popups, 17)
	}
	if o.has_initial_url {
		res << vproto.pack_string_field(o.initial_url, 18)
	}
	if o.has_hwnd_parent {
		res << vproto.pack_64bit_field(o.hwnd_parent, 19)
	}
	return res
}

pub fn cmsgbrowsercreate_unpack(buf []byte) ?CMsgBrowserCreate {
	mut res := CMsgBrowserCreate{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_request_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.request_id = v
				i = ii
			}
			3 {
				res.has_useragent = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.useragent = v
				i = ii
			}
			5 {
				res.has_user_css = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.user_css = v
				i = ii
			}
			6 {
				res.has_native_dropdowns = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.native_dropdowns = v
				i = ii
			}
			7 {
				res.has_dpi_scaling = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.dpi_scaling = v
				i = ii
			}
			8 {
				res.has_offscreen = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.offscreen = v
				i = ii
			}
			9 {
				res.has_initial_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_width = v
				i = ii
			}
			10 {
				res.has_initial_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_height = v
				i = ii
			}
			11 {
				res.has_window_icon = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.window_icon = v
				i = ii
			}
			12 {
				res.has_borderless = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.borderless = v
				i = ii
			}
			13 {
				res.has_vroverlay_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.vroverlay_key = v
				i = ii
			}
			14 {
				res.has_browser_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_type = v
				i = ii
			}
			15 {
				res.has_initial_top = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_top = v
				i = ii
			}
			16 {
				res.has_initial_left = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_left = v
				i = ii
			}
			17 {
				res.has_only_allow_trusted_popups = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.only_allow_trusted_popups = v
				i = ii
			}
			18 {
				res.has_initial_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.initial_url = v
				i = ii
			}
			19 {
				res.has_hwnd_parent = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.hwnd_parent = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgbrowsercreate() CMsgBrowserCreate {
	return CMsgBrowserCreate{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgbrowsercreate(o CMsgBrowserCreate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgbrowsercreate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserCreate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowsercreate_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserCreateResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	request_id         u32
	has_request_id     bool
}

pub fn (o &CMsgBrowserCreateResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_request_id {
		res << vproto.pack_uint32_field(o.request_id, 2)
	}
	return res
}

pub fn cmsgbrowsercreateresponse_unpack(buf []byte) ?CMsgBrowserCreateResponse {
	mut res := CMsgBrowserCreateResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_request_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.request_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgbrowsercreateresponse() CMsgBrowserCreateResponse {
	return CMsgBrowserCreateResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgbrowsercreateresponse(o CMsgBrowserCreateResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgbrowsercreateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserCreateResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowsercreateresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserRemove {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgBrowserRemove) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgbrowserremove_unpack(buf []byte) ?CMsgBrowserRemove {
	mut res := CMsgBrowserRemove{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgbrowserremove() CMsgBrowserRemove {
	return CMsgBrowserRemove{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgbrowserremove(o CMsgBrowserRemove, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgbrowserremove(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserRemove) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowserremove_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetLocalFileRequestMapping_AdditionalRoute {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	relative_url           string
	has_relative_url       bool
	local_path             string
	has_local_path         bool
	allowed_extensions     string
	has_allowed_extensions bool
}

pub fn (o &CMsgSetLocalFileRequestMapping_AdditionalRoute) pack() []byte {
	mut res := []byte{}
	if o.has_relative_url {
		res << vproto.pack_string_field(o.relative_url, 1)
	}
	if o.has_local_path {
		res << vproto.pack_string_field(o.local_path, 2)
	}
	if o.has_allowed_extensions {
		res << vproto.pack_string_field(o.allowed_extensions, 3)
	}
	return res
}

pub fn cmsgsetlocalfilerequestmapping_additionalroute_unpack(buf []byte) ?CMsgSetLocalFileRequestMapping_AdditionalRoute {
	mut res := CMsgSetLocalFileRequestMapping_AdditionalRoute{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_relative_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.relative_url = v
				i = ii
			}
			2 {
				res.has_local_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.local_path = v
				i = ii
			}
			3 {
				res.has_allowed_extensions = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.allowed_extensions = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsetlocalfilerequestmapping_additionalroute() CMsgSetLocalFileRequestMapping_AdditionalRoute {
	return CMsgSetLocalFileRequestMapping_AdditionalRoute{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsetlocalfilerequestmapping_additionalroute(o CMsgSetLocalFileRequestMapping_AdditionalRoute, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsetlocalfilerequestmapping_additionalroute(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetLocalFileRequestMapping_AdditionalRoute) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetlocalfilerequestmapping_additionalroute_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetLocalFileRequestMapping {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	browser_handle         u32
	has_browser_handle     bool
	request_url            string
	has_request_url        bool
	default_local_path     string
	has_default_local_path bool
	routes                 []CMsgSetLocalFileRequestMapping_AdditionalRoute
}

pub fn (o &CMsgSetLocalFileRequestMapping) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_request_url {
		res << vproto.pack_string_field(o.request_url, 2)
	}
	if o.has_default_local_path {
		res << vproto.pack_string_field(o.default_local_path, 3)
	}
	// [packed=false]
	for _, x in o.routes {
		res << zzz_vproto_internal_pack_cmsgsetlocalfilerequestmapping_additionalroute(x, 4)
	}
	return res
}

pub fn cmsgsetlocalfilerequestmapping_unpack(buf []byte) ?CMsgSetLocalFileRequestMapping {
	mut res := CMsgSetLocalFileRequestMapping{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_request_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.request_url = v
				i = ii
			}
			3 {
				res.has_default_local_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.default_local_path = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgsetlocalfilerequestmapping_additionalroute(cur_buf,
					tag_wiretype.wire_type)?
				res.routes << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsetlocalfilerequestmapping() CMsgSetLocalFileRequestMapping {
	return CMsgSetLocalFileRequestMapping{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsetlocalfilerequestmapping(o CMsgSetLocalFileRequestMapping, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsetlocalfilerequestmapping(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetLocalFileRequestMapping) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetlocalfilerequestmapping_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserErrorStrings {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	browser_handle         u32
	has_browser_handle     bool
	title                  string
	has_title              bool
	header                 string
	has_header             bool
	cache_miss             string
	has_cache_miss         bool
	bad_url                string
	has_bad_url            bool
	connection_problem     string
	has_connection_problem bool
	proxy_problem          string
	has_proxy_problem      bool
	unknown                string
	has_unknown            bool
}

pub fn (o &CMsgBrowserErrorStrings) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 2)
	}
	if o.has_header {
		res << vproto.pack_string_field(o.header, 3)
	}
	if o.has_cache_miss {
		res << vproto.pack_string_field(o.cache_miss, 4)
	}
	if o.has_bad_url {
		res << vproto.pack_string_field(o.bad_url, 5)
	}
	if o.has_connection_problem {
		res << vproto.pack_string_field(o.connection_problem, 6)
	}
	if o.has_proxy_problem {
		res << vproto.pack_string_field(o.proxy_problem, 7)
	}
	if o.has_unknown {
		res << vproto.pack_string_field(o.unknown, 8)
	}
	return res
}

pub fn cmsgbrowsererrorstrings_unpack(buf []byte) ?CMsgBrowserErrorStrings {
	mut res := CMsgBrowserErrorStrings{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			3 {
				res.has_header = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.header = v
				i = ii
			}
			4 {
				res.has_cache_miss = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_miss = v
				i = ii
			}
			5 {
				res.has_bad_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.bad_url = v
				i = ii
			}
			6 {
				res.has_connection_problem = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_problem = v
				i = ii
			}
			7 {
				res.has_proxy_problem = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.proxy_problem = v
				i = ii
			}
			8 {
				res.has_unknown = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.unknown = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgbrowsererrorstrings() CMsgBrowserErrorStrings {
	return CMsgBrowserErrorStrings{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgbrowsererrorstrings(o CMsgBrowserErrorStrings, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgbrowsererrorstrings(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserErrorStrings) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowsererrorstrings_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserSize {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	width              u32
	has_width          bool
	height             u32
	has_height         bool
}

pub fn (o &CMsgBrowserSize) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_width {
		res << vproto.pack_uint32_field(o.width, 2)
	}
	if o.has_height {
		res << vproto.pack_uint32_field(o.height, 3)
	}
	return res
}

pub fn cmsgbrowsersize_unpack(buf []byte) ?CMsgBrowserSize {
	mut res := CMsgBrowserSize{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			3 {
				res.has_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgbrowsersize() CMsgBrowserSize {
	return CMsgBrowserSize{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgbrowsersize(o CMsgBrowserSize, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgbrowsersize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserSize) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowsersize_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserSetMinSize {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	width              u32
	has_width          bool
	height             u32
	has_height         bool
}

pub fn (o &CMsgBrowserSetMinSize) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_width {
		res << vproto.pack_uint32_field(o.width, 2)
	}
	if o.has_height {
		res << vproto.pack_uint32_field(o.height, 3)
	}
	return res
}

pub fn cmsgbrowsersetminsize_unpack(buf []byte) ?CMsgBrowserSetMinSize {
	mut res := CMsgBrowserSetMinSize{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			3 {
				res.has_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgbrowsersetminsize() CMsgBrowserSetMinSize {
	return CMsgBrowserSetMinSize{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgbrowsersetminsize(o CMsgBrowserSetMinSize, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgbrowsersetminsize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserSetMinSize) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowsersetminsize_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserPosition {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	x                  int
	has_x              bool
	y                  int
	has_y              bool
	x_local            int
	has_x_local        bool
	y_local            int
	has_y_local        bool
}

pub fn (o &CMsgBrowserPosition) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_x {
		res << vproto.pack_int32_field(o.x, 2)
	}
	if o.has_y {
		res << vproto.pack_int32_field(o.y, 3)
	}
	if o.has_x_local {
		res << vproto.pack_int32_field(o.x_local, 4)
	}
	if o.has_y_local {
		res << vproto.pack_int32_field(o.y_local, 5)
	}
	return res
}

pub fn cmsgbrowserposition_unpack(buf []byte) ?CMsgBrowserPosition {
	mut res := CMsgBrowserPosition{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_x = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				res.has_y = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			4 {
				res.has_x_local = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x_local = v
				i = ii
			}
			5 {
				res.has_y_local = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y_local = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgbrowserposition() CMsgBrowserPosition {
	return CMsgBrowserPosition{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgbrowserposition(o CMsgBrowserPosition, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgbrowserposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserPosition) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowserposition_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserResized {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	x                  int
	has_x              bool
	y                  int
	has_y              bool
	width              u32
	has_width          bool
	height             u32
	has_height         bool
}

pub fn (o &CMsgBrowserResized) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_x {
		res << vproto.pack_int32_field(o.x, 2)
	}
	if o.has_y {
		res << vproto.pack_int32_field(o.y, 3)
	}
	if o.has_width {
		res << vproto.pack_uint32_field(o.width, 4)
	}
	if o.has_height {
		res << vproto.pack_uint32_field(o.height, 5)
	}
	return res
}

pub fn cmsgbrowserresized_unpack(buf []byte) ?CMsgBrowserResized {
	mut res := CMsgBrowserResized{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_x = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				res.has_y = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			4 {
				res.has_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			5 {
				res.has_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgbrowserresized() CMsgBrowserResized {
	return CMsgBrowserResized{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgbrowserresized(o CMsgBrowserResized, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgbrowserresized(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserResized) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowserresized_unpack(v)?
	return i, unpacked
}

pub struct CMsgPostURL {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
	post               string
	has_post           bool
	pageserial         u32
	has_pageserial     bool
}

pub fn (o &CMsgPostURL) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_post {
		res << vproto.pack_string_field(o.post, 3)
	}
	if o.has_pageserial {
		res << vproto.pack_uint32_field(o.pageserial, 4)
	}
	return res
}

pub fn cmsgposturl_unpack(buf []byte) ?CMsgPostURL {
	mut res := CMsgPostURL{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_post = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.post = v
				i = ii
			}
			4 {
				res.has_pageserial = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.pageserial = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgposturl() CMsgPostURL {
	return CMsgPostURL{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgposturl(o CMsgPostURL, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgposturl(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPostURL) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgposturl_unpack(v)?
	return i, unpacked
}

pub struct CMsgAddHeader {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	key                string
	has_key            bool
	value              string
	has_value          bool
}

pub fn (o &CMsgAddHeader) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 2)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 3)
	}
	return res
}

pub fn cmsgaddheader_unpack(buf []byte) ?CMsgAddHeader {
	mut res := CMsgAddHeader{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			3 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgaddheader() CMsgAddHeader {
	return CMsgAddHeader{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgaddheader(o CMsgAddHeader, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgaddheader(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAddHeader) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgaddheader_unpack(v)?
	return i, unpacked
}

pub struct CMsgStopLoad {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgStopLoad) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgstopload_unpack(buf []byte) ?CMsgStopLoad {
	mut res := CMsgStopLoad{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgstopload() CMsgStopLoad {
	return CMsgStopLoad{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgstopload(o CMsgStopLoad, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgstopload(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStopLoad) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgstopload_unpack(v)?
	return i, unpacked
}

pub struct CMsgReload {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgReload) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgreload_unpack(buf []byte) ?CMsgReload {
	mut res := CMsgReload{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgreload() CMsgReload {
	return CMsgReload{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgreload(o CMsgReload, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgreload(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgReload) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgreload_unpack(v)?
	return i, unpacked
}

pub struct CMsgGoForward {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgGoForward) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsggoforward_unpack(buf []byte) ?CMsgGoForward {
	mut res := CMsgGoForward{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggoforward() CMsgGoForward {
	return CMsgGoForward{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggoforward(o CMsgGoForward, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggoforward(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGoForward) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggoforward_unpack(v)?
	return i, unpacked
}

pub struct CMsgGoBack {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgGoBack) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsggoback_unpack(buf []byte) ?CMsgGoBack {
	mut res := CMsgGoBack{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggoback() CMsgGoBack {
	return CMsgGoBack{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggoback(o CMsgGoBack, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggoback(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGoBack) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggoback_unpack(v)?
	return i, unpacked
}

pub struct CMsgWasHidden {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	hidden             bool
	has_hidden         bool
}

pub fn (o &CMsgWasHidden) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_hidden {
		res << vproto.pack_bool_field(o.hidden, 2)
	}
	return res
}

pub fn cmsgwashidden_unpack(buf []byte) ?CMsgWasHidden {
	mut res := CMsgWasHidden{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_hidden = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hidden = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgwashidden() CMsgWasHidden {
	return CMsgWasHidden{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgwashidden(o CMsgWasHidden, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgwashidden(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgWasHidden) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgwashidden_unpack(v)?
	return i, unpacked
}

pub struct CMsgClearHistory {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgClearHistory) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgclearhistory_unpack(buf []byte) ?CMsgClearHistory {
	mut res := CMsgClearHistory{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclearhistory() CMsgClearHistory {
	return CMsgClearHistory{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclearhistory(o CMsgClearHistory, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclearhistory(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClearHistory) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclearhistory_unpack(v)?
	return i, unpacked
}

pub struct CMsgClearAllBrowsingData {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgClearAllBrowsingData) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgclearallbrowsingdata_unpack(buf []byte) ?CMsgClearAllBrowsingData {
	mut res := CMsgClearAllBrowsingData{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclearallbrowsingdata() CMsgClearAllBrowsingData {
	return CMsgClearAllBrowsingData{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclearallbrowsingdata(o CMsgClearAllBrowsingData, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclearallbrowsingdata(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClearAllBrowsingData) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclearallbrowsingdata_unpack(v)?
	return i, unpacked
}

pub struct CMsgCopy {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgCopy) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgcopy_unpack(buf []byte) ?CMsgCopy {
	mut res := CMsgCopy{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcopy() CMsgCopy {
	return CMsgCopy{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcopy(o CMsgCopy, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcopy(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCopy) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcopy_unpack(v)?
	return i, unpacked
}

pub struct CMsgPaste {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgPaste) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgpaste_unpack(buf []byte) ?CMsgPaste {
	mut res := CMsgPaste{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgpaste() CMsgPaste {
	return CMsgPaste{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgpaste(o CMsgPaste, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgpaste(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPaste) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgpaste_unpack(v)?
	return i, unpacked
}

pub struct CMsgExecuteJavaScript {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	script             string
	has_script         bool
}

pub fn (o &CMsgExecuteJavaScript) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_script {
		res << vproto.pack_string_field(o.script, 2)
	}
	return res
}

pub fn cmsgexecutejavascript_unpack(buf []byte) ?CMsgExecuteJavaScript {
	mut res := CMsgExecuteJavaScript{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_script = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.script = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgexecutejavascript() CMsgExecuteJavaScript {
	return CMsgExecuteJavaScript{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgexecutejavascript(o CMsgExecuteJavaScript, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgexecutejavascript(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgExecuteJavaScript) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgexecutejavascript_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetFocus {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	focus              bool
	has_focus          bool
}

pub fn (o &CMsgSetFocus) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_focus {
		res << vproto.pack_bool_field(o.focus, 2)
	}
	return res
}

pub fn cmsgsetfocus_unpack(buf []byte) ?CMsgSetFocus {
	mut res := CMsgSetFocus{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_focus = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.focus = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsetfocus() CMsgSetFocus {
	return CMsgSetFocus{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsetfocus(o CMsgSetFocus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsetfocus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetFocus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetfocus_unpack(v)?
	return i, unpacked
}

pub struct CMsgHorizontalScrollBarSize {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgHorizontalScrollBarSize) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsghorizontalscrollbarsize_unpack(buf []byte) ?CMsgHorizontalScrollBarSize {
	mut res := CMsgHorizontalScrollBarSize{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsghorizontalscrollbarsize() CMsgHorizontalScrollBarSize {
	return CMsgHorizontalScrollBarSize{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsghorizontalscrollbarsize(o CMsgHorizontalScrollBarSize, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsghorizontalscrollbarsize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHorizontalScrollBarSize) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsghorizontalscrollbarsize_unpack(v)?
	return i, unpacked
}

pub struct CMsgHorizontalScrollBarSizeResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	scroll_max         u32
	has_scroll_max     bool
	scroll             u32
	has_scroll         bool
	zoom               f32
	has_zoom           bool
	visible            bool
	has_visible        bool
	page_size          u32
	has_page_size      bool
}

pub fn (o &CMsgHorizontalScrollBarSizeResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_scroll_max {
		res << vproto.pack_uint32_field(o.scroll_max, 6)
	}
	if o.has_scroll {
		res << vproto.pack_uint32_field(o.scroll, 7)
	}
	if o.has_zoom {
		res << vproto.pack_float_field(o.zoom, 8)
	}
	if o.has_visible {
		res << vproto.pack_bool_field(o.visible, 9)
	}
	if o.has_page_size {
		res << vproto.pack_uint32_field(o.page_size, 10)
	}
	return res
}

pub fn cmsghorizontalscrollbarsizeresponse_unpack(buf []byte) ?CMsgHorizontalScrollBarSizeResponse {
	mut res := CMsgHorizontalScrollBarSizeResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			6 {
				res.has_scroll_max = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scroll_max = v
				i = ii
			}
			7 {
				res.has_scroll = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scroll = v
				i = ii
			}
			8 {
				res.has_zoom = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.zoom = v
				i = ii
			}
			9 {
				res.has_visible = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.visible = v
				i = ii
			}
			10 {
				res.has_page_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.page_size = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsghorizontalscrollbarsizeresponse() CMsgHorizontalScrollBarSizeResponse {
	return CMsgHorizontalScrollBarSizeResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsghorizontalscrollbarsizeresponse(o CMsgHorizontalScrollBarSizeResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsghorizontalscrollbarsizeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHorizontalScrollBarSizeResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsghorizontalscrollbarsizeresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgVerticalScrollBarSize {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgVerticalScrollBarSize) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgverticalscrollbarsize_unpack(buf []byte) ?CMsgVerticalScrollBarSize {
	mut res := CMsgVerticalScrollBarSize{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgverticalscrollbarsize() CMsgVerticalScrollBarSize {
	return CMsgVerticalScrollBarSize{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgverticalscrollbarsize(o CMsgVerticalScrollBarSize, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgverticalscrollbarsize(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgVerticalScrollBarSize) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgverticalscrollbarsize_unpack(v)?
	return i, unpacked
}

pub struct CMsgVerticalScrollBarSizeResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	scroll_max         u32
	has_scroll_max     bool
	scroll             u32
	has_scroll         bool
	zoom               f32
	has_zoom           bool
	visible            bool
	has_visible        bool
	page_size          u32
	has_page_size      bool
}

pub fn (o &CMsgVerticalScrollBarSizeResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_scroll_max {
		res << vproto.pack_uint32_field(o.scroll_max, 6)
	}
	if o.has_scroll {
		res << vproto.pack_uint32_field(o.scroll, 7)
	}
	if o.has_zoom {
		res << vproto.pack_float_field(o.zoom, 8)
	}
	if o.has_visible {
		res << vproto.pack_bool_field(o.visible, 9)
	}
	if o.has_page_size {
		res << vproto.pack_uint32_field(o.page_size, 10)
	}
	return res
}

pub fn cmsgverticalscrollbarsizeresponse_unpack(buf []byte) ?CMsgVerticalScrollBarSizeResponse {
	mut res := CMsgVerticalScrollBarSizeResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			6 {
				res.has_scroll_max = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scroll_max = v
				i = ii
			}
			7 {
				res.has_scroll = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scroll = v
				i = ii
			}
			8 {
				res.has_zoom = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.zoom = v
				i = ii
			}
			9 {
				res.has_visible = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.visible = v
				i = ii
			}
			10 {
				res.has_page_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.page_size = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgverticalscrollbarsizeresponse() CMsgVerticalScrollBarSizeResponse {
	return CMsgVerticalScrollBarSizeResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgverticalscrollbarsizeresponse(o CMsgVerticalScrollBarSizeResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgverticalscrollbarsizeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgVerticalScrollBarSizeResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgverticalscrollbarsizeresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgFind {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	find               string
	has_find           bool
	infind             bool
	has_infind         bool
	reverse            bool
	has_reverse        bool
}

pub fn (o &CMsgFind) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_find {
		res << vproto.pack_string_field(o.find, 2)
	}
	if o.has_infind {
		res << vproto.pack_bool_field(o.infind, 3)
	}
	if o.has_reverse {
		res << vproto.pack_bool_field(o.reverse, 4)
	}
	return res
}

pub fn cmsgfind_unpack(buf []byte) ?CMsgFind {
	mut res := CMsgFind{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_find = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.find = v
				i = ii
			}
			3 {
				res.has_infind = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.infind = v
				i = ii
			}
			4 {
				res.has_reverse = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.reverse = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfind() CMsgFind {
	return CMsgFind{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfind(o CMsgFind, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfind(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFind) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfind_unpack(v)?
	return i, unpacked
}

pub struct CMsgStopFind {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgStopFind) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgstopfind_unpack(buf []byte) ?CMsgStopFind {
	mut res := CMsgStopFind{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgstopfind() CMsgStopFind {
	return CMsgStopFind{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgstopfind(o CMsgStopFind, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgstopfind(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStopFind) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgstopfind_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetHorizontalScroll {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	scroll             u32
	has_scroll         bool
}

pub fn (o &CMsgSetHorizontalScroll) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_scroll {
		res << vproto.pack_uint32_field(o.scroll, 2)
	}
	return res
}

pub fn cmsgsethorizontalscroll_unpack(buf []byte) ?CMsgSetHorizontalScroll {
	mut res := CMsgSetHorizontalScroll{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_scroll = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scroll = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsethorizontalscroll() CMsgSetHorizontalScroll {
	return CMsgSetHorizontalScroll{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsethorizontalscroll(o CMsgSetHorizontalScroll, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsethorizontalscroll(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetHorizontalScroll) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsethorizontalscroll_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetVerticalScroll {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	scroll             u32
	has_scroll         bool
}

pub fn (o &CMsgSetVerticalScroll) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_scroll {
		res << vproto.pack_uint32_field(o.scroll, 2)
	}
	return res
}

pub fn cmsgsetverticalscroll_unpack(buf []byte) ?CMsgSetVerticalScroll {
	mut res := CMsgSetVerticalScroll{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_scroll = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scroll = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsetverticalscroll() CMsgSetVerticalScroll {
	return CMsgSetVerticalScroll{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsetverticalscroll(o CMsgSetVerticalScroll, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsetverticalscroll(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetVerticalScroll) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetverticalscroll_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetZoomLevel {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	zoom               f64
	has_zoom           bool
}

pub fn (o &CMsgSetZoomLevel) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_zoom {
		res << vproto.pack_double_field(o.zoom, 2)
	}
	return res
}

pub fn cmsgsetzoomlevel_unpack(buf []byte) ?CMsgSetZoomLevel {
	mut res := CMsgSetZoomLevel{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_zoom = true
				ii, v := vproto.unpack_double_field(cur_buf, tag_wiretype.wire_type)?
				res.zoom = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsetzoomlevel() CMsgSetZoomLevel {
	return CMsgSetZoomLevel{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsetzoomlevel(o CMsgSetZoomLevel, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsetzoomlevel(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetZoomLevel) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetzoomlevel_unpack(v)?
	return i, unpacked
}

pub struct CMsgViewSource {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgViewSource) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgviewsource_unpack(buf []byte) ?CMsgViewSource {
	mut res := CMsgViewSource{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgviewsource() CMsgViewSource {
	return CMsgViewSource{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgviewsource(o CMsgViewSource, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgviewsource(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgViewSource) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgviewsource_unpack(v)?
	return i, unpacked
}

pub struct CMsgBrowserReady {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	vr_overlay_key     string
	has_vr_overlay_key bool
	hwnd_browser       u64
	has_hwnd_browser   bool
}

pub fn (o &CMsgBrowserReady) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_vr_overlay_key {
		res << vproto.pack_string_field(o.vr_overlay_key, 2)
	}
	if o.has_hwnd_browser {
		res << vproto.pack_64bit_field(o.hwnd_browser, 3)
	}
	return res
}

pub fn cmsgbrowserready_unpack(buf []byte) ?CMsgBrowserReady {
	mut res := CMsgBrowserReady{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_vr_overlay_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.vr_overlay_key = v
				i = ii
			}
			3 {
				res.has_hwnd_browser = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.hwnd_browser = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgbrowserready() CMsgBrowserReady {
	return CMsgBrowserReady{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgbrowserready(o CMsgBrowserReady, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgbrowserready(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBrowserReady) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbrowserready_unpack(v)?
	return i, unpacked
}

pub struct CMsgURLChanged {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
	postdata           string
	has_postdata       bool
	bisredirect        bool
	has_bisredirect    bool
	pagetitle          string
	has_pagetitle      bool
	bnewnavigation     bool
	has_bnewnavigation bool
}

pub fn (o &CMsgURLChanged) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_postdata {
		res << vproto.pack_string_field(o.postdata, 3)
	}
	if o.has_bisredirect {
		res << vproto.pack_bool_field(o.bisredirect, 4)
	}
	if o.has_pagetitle {
		res << vproto.pack_string_field(o.pagetitle, 5)
	}
	if o.has_bnewnavigation {
		res << vproto.pack_bool_field(o.bnewnavigation, 6)
	}
	return res
}

pub fn cmsgurlchanged_unpack(buf []byte) ?CMsgURLChanged {
	mut res := CMsgURLChanged{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_postdata = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.postdata = v
				i = ii
			}
			4 {
				res.has_bisredirect = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bisredirect = v
				i = ii
			}
			5 {
				res.has_pagetitle = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.pagetitle = v
				i = ii
			}
			6 {
				res.has_bnewnavigation = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bnewnavigation = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgurlchanged() CMsgURLChanged {
	return CMsgURLChanged{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgurlchanged(o CMsgURLChanged, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgurlchanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgURLChanged) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgurlchanged_unpack(v)?
	return i, unpacked
}

pub struct CHTMLHeader {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &CHTMLHeader) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn chtmlheader_unpack(buf []byte) ?CHTMLHeader {
	mut res := CHTMLHeader{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chtmlheader() CHTMLHeader {
	return CHTMLHeader{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chtmlheader(o CHTMLHeader, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chtmlheader(buf []byte, tag_wiretype vproto.WireType) ?(int, CHTMLHeader) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chtmlheader_unpack(v)?
	return i, unpacked
}

pub struct CHTMLPageSecurityInfo {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	bissecure         bool
	has_bissecure     bool
	bhascerterror     bool
	has_bhascerterror bool
	issuername        string
	has_issuername    bool
	certname          string
	has_certname      bool
	certexpiry        int
	has_certexpiry    bool
	ncertbits         int
	has_ncertbits     bool
	bisevcert         bool
	has_bisevcert     bool
}

pub fn (o &CHTMLPageSecurityInfo) pack() []byte {
	mut res := []byte{}
	if o.has_bissecure {
		res << vproto.pack_bool_field(o.bissecure, 1)
	}
	if o.has_bhascerterror {
		res << vproto.pack_bool_field(o.bhascerterror, 2)
	}
	if o.has_issuername {
		res << vproto.pack_string_field(o.issuername, 3)
	}
	if o.has_certname {
		res << vproto.pack_string_field(o.certname, 4)
	}
	if o.has_certexpiry {
		res << vproto.pack_int32_field(o.certexpiry, 5)
	}
	if o.has_ncertbits {
		res << vproto.pack_int32_field(o.ncertbits, 6)
	}
	if o.has_bisevcert {
		res << vproto.pack_bool_field(o.bisevcert, 7)
	}
	return res
}

pub fn chtmlpagesecurityinfo_unpack(buf []byte) ?CHTMLPageSecurityInfo {
	mut res := CHTMLPageSecurityInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_bissecure = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bissecure = v
				i = ii
			}
			2 {
				res.has_bhascerterror = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bhascerterror = v
				i = ii
			}
			3 {
				res.has_issuername = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.issuername = v
				i = ii
			}
			4 {
				res.has_certname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.certname = v
				i = ii
			}
			5 {
				res.has_certexpiry = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.certexpiry = v
				i = ii
			}
			6 {
				res.has_ncertbits = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ncertbits = v
				i = ii
			}
			7 {
				res.has_bisevcert = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bisevcert = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chtmlpagesecurityinfo() CHTMLPageSecurityInfo {
	return CHTMLPageSecurityInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chtmlpagesecurityinfo(o CHTMLPageSecurityInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chtmlpagesecurityinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CHTMLPageSecurityInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chtmlpagesecurityinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgFinishedRequest {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
	pagetitle          string
	has_pagetitle      bool
}

pub fn (o &CMsgFinishedRequest) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_pagetitle {
		res << vproto.pack_string_field(o.pagetitle, 3)
	}
	return res
}

pub fn cmsgfinishedrequest_unpack(buf []byte) ?CMsgFinishedRequest {
	mut res := CMsgFinishedRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_pagetitle = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.pagetitle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfinishedrequest() CMsgFinishedRequest {
	return CMsgFinishedRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfinishedrequest(o CMsgFinishedRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfinishedrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFinishedRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfinishedrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgLoadedRequest {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
	pagetitle          string
	has_pagetitle      bool
	headers            []CHTMLHeader
}

pub fn (o &CMsgLoadedRequest) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_pagetitle {
		res << vproto.pack_string_field(o.pagetitle, 3)
	}
	// [packed=false]
	for _, x in o.headers {
		res << zzz_vproto_internal_pack_chtmlheader(x, 5)
	}
	return res
}

pub fn cmsgloadedrequest_unpack(buf []byte) ?CMsgLoadedRequest {
	mut res := CMsgLoadedRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_pagetitle = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.pagetitle = v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_chtmlheader(cur_buf, tag_wiretype.wire_type)?
				res.headers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgloadedrequest() CMsgLoadedRequest {
	return CMsgLoadedRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgloadedrequest(o CMsgLoadedRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgloadedrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLoadedRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgloadedrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgPageSecurity {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
	security_info      CHTMLPageSecurityInfo
	has_security_info  bool
}

pub fn (o &CMsgPageSecurity) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_security_info {
		res << zzz_vproto_internal_pack_chtmlpagesecurityinfo(o.security_info, 3)
	}
	return res
}

pub fn cmsgpagesecurity_unpack(buf []byte) ?CMsgPageSecurity {
	mut res := CMsgPageSecurity{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_security_info = true
				ii, v := zzz_vproto_internal_unpack_chtmlpagesecurityinfo(cur_buf, tag_wiretype.wire_type)?
				res.security_info = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgpagesecurity() CMsgPageSecurity {
	return CMsgPageSecurity{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgpagesecurity(o CMsgPageSecurity, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgpagesecurity(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPageSecurity) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgpagesecurity_unpack(v)?
	return i, unpacked
}

pub struct CMsgStartRequest {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
	target             string
	has_target         bool
	postdata           string
	has_postdata       bool
	bisredirect        bool
	has_bisredirect    bool
}

pub fn (o &CMsgStartRequest) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_target {
		res << vproto.pack_string_field(o.target, 3)
	}
	if o.has_postdata {
		res << vproto.pack_string_field(o.postdata, 4)
	}
	if o.has_bisredirect {
		res << vproto.pack_bool_field(o.bisredirect, 5)
	}
	return res
}

pub fn cmsgstartrequest_unpack(buf []byte) ?CMsgStartRequest {
	mut res := CMsgStartRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_target = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.target = v
				i = ii
			}
			4 {
				res.has_postdata = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.postdata = v
				i = ii
			}
			5 {
				res.has_bisredirect = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bisredirect = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgstartrequest() CMsgStartRequest {
	return CMsgStartRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgstartrequest(o CMsgStartRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgstartrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStartRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgstartrequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgStartRequestResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	ballow             bool
	has_ballow         bool
}

pub fn (o &CMsgStartRequestResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_ballow {
		res << vproto.pack_bool_field(o.ballow, 2)
	}
	return res
}

pub fn cmsgstartrequestresponse_unpack(buf []byte) ?CMsgStartRequestResponse {
	mut res := CMsgStartRequestResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_ballow = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ballow = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgstartrequestresponse() CMsgStartRequestResponse {
	return CMsgStartRequestResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgstartrequestresponse(o CMsgStartRequestResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgstartrequestresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStartRequestResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgstartrequestresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgShowPopup {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgShowPopup) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgshowpopup_unpack(buf []byte) ?CMsgShowPopup {
	mut res := CMsgShowPopup{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgshowpopup() CMsgShowPopup {
	return CMsgShowPopup{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgshowpopup(o CMsgShowPopup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgshowpopup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgShowPopup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgshowpopup_unpack(v)?
	return i, unpacked
}

pub struct CMsgHidePopup {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgHidePopup) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsghidepopup_unpack(buf []byte) ?CMsgHidePopup {
	mut res := CMsgHidePopup{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsghidepopup() CMsgHidePopup {
	return CMsgHidePopup{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsghidepopup(o CMsgHidePopup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsghidepopup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHidePopup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsghidepopup_unpack(v)?
	return i, unpacked
}

pub struct CMsgSizePopup {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	x                  int
	has_x              bool
	y                  int
	has_y              bool
	wide               u32
	has_wide           bool
	tall               u32
	has_tall           bool
}

pub fn (o &CMsgSizePopup) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_x {
		res << vproto.pack_int32_field(o.x, 2)
	}
	if o.has_y {
		res << vproto.pack_int32_field(o.y, 3)
	}
	if o.has_wide {
		res << vproto.pack_uint32_field(o.wide, 4)
	}
	if o.has_tall {
		res << vproto.pack_uint32_field(o.tall, 5)
	}
	return res
}

pub fn cmsgsizepopup_unpack(buf []byte) ?CMsgSizePopup {
	mut res := CMsgSizePopup{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_x = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				res.has_y = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			4 {
				res.has_wide = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.wide = v
				i = ii
			}
			5 {
				res.has_tall = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tall = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsizepopup() CMsgSizePopup {
	return CMsgSizePopup{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsizepopup(o CMsgSizePopup, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsizepopup(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSizePopup) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsizepopup_unpack(v)?
	return i, unpacked
}

pub struct CMsgOpenNewTab {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
	bforeground        bool
	has_bforeground    bool
}

pub fn (o &CMsgOpenNewTab) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_bforeground {
		res << vproto.pack_bool_field(o.bforeground, 3)
	}
	return res
}

pub fn cmsgopennewtab_unpack(buf []byte) ?CMsgOpenNewTab {
	mut res := CMsgOpenNewTab{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_bforeground = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bforeground = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgopennewtab() CMsgOpenNewTab {
	return CMsgOpenNewTab{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgopennewtab(o CMsgOpenNewTab, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgopennewtab(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgOpenNewTab) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgopennewtab_unpack(v)?
	return i, unpacked
}

pub struct CMsgPopupHTMLWindow {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	browser_handle      u32
	has_browser_handle  bool
	url                 string
	has_url             bool
	x                   int
	has_x               bool
	y                   int
	has_y               bool
	wide                u32
	has_wide            bool
	tall                u32
	has_tall            bool
	popup_index         u32
	has_popup_index     bool
	trusted_creator     bool
	has_trusted_creator bool
}

pub fn (o &CMsgPopupHTMLWindow) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_x {
		res << vproto.pack_int32_field(o.x, 3)
	}
	if o.has_y {
		res << vproto.pack_int32_field(o.y, 4)
	}
	if o.has_wide {
		res << vproto.pack_uint32_field(o.wide, 5)
	}
	if o.has_tall {
		res << vproto.pack_uint32_field(o.tall, 6)
	}
	if o.has_popup_index {
		res << vproto.pack_uint32_field(o.popup_index, 7)
	}
	if o.has_trusted_creator {
		res << vproto.pack_bool_field(o.trusted_creator, 8)
	}
	return res
}

pub fn cmsgpopuphtmlwindow_unpack(buf []byte) ?CMsgPopupHTMLWindow {
	mut res := CMsgPopupHTMLWindow{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_x = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			4 {
				res.has_y = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			5 {
				res.has_wide = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.wide = v
				i = ii
			}
			6 {
				res.has_tall = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tall = v
				i = ii
			}
			7 {
				res.has_popup_index = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.popup_index = v
				i = ii
			}
			8 {
				res.has_trusted_creator = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.trusted_creator = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgpopuphtmlwindow() CMsgPopupHTMLWindow {
	return CMsgPopupHTMLWindow{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgpopuphtmlwindow(o CMsgPopupHTMLWindow, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgpopuphtmlwindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPopupHTMLWindow) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgpopuphtmlwindow_unpack(v)?
	return i, unpacked
}

pub struct CMsgPopupHTMLWindowResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	ballow             bool
	has_ballow         bool
}

pub fn (o &CMsgPopupHTMLWindowResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_ballow {
		res << vproto.pack_bool_field(o.ballow, 2)
	}
	return res
}

pub fn cmsgpopuphtmlwindowresponse_unpack(buf []byte) ?CMsgPopupHTMLWindowResponse {
	mut res := CMsgPopupHTMLWindowResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_ballow = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.ballow = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgpopuphtmlwindowresponse() CMsgPopupHTMLWindowResponse {
	return CMsgPopupHTMLWindowResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgpopuphtmlwindowresponse(o CMsgPopupHTMLWindowResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgpopuphtmlwindowresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPopupHTMLWindowResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgpopuphtmlwindowresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetHTMLTitle {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	title              string
	has_title          bool
}

pub fn (o &CMsgSetHTMLTitle) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 2)
	}
	return res
}

pub fn cmsgsethtmltitle_unpack(buf []byte) ?CMsgSetHTMLTitle {
	mut res := CMsgSetHTMLTitle{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsethtmltitle() CMsgSetHTMLTitle {
	return CMsgSetHTMLTitle{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsethtmltitle(o CMsgSetHTMLTitle, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsethtmltitle(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetHTMLTitle) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsethtmltitle_unpack(v)?
	return i, unpacked
}

pub struct CMsgLoadingResource {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
}

pub fn (o &CMsgLoadingResource) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	return res
}

pub fn cmsgloadingresource_unpack(buf []byte) ?CMsgLoadingResource {
	mut res := CMsgLoadingResource{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgloadingresource() CMsgLoadingResource {
	return CMsgLoadingResource{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgloadingresource(o CMsgLoadingResource, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgloadingresource(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLoadingResource) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgloadingresource_unpack(v)?
	return i, unpacked
}

pub struct CMsgStatusText {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	text               string
	has_text           bool
}

pub fn (o &CMsgStatusText) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_text {
		res << vproto.pack_string_field(o.text, 2)
	}
	return res
}

pub fn cmsgstatustext_unpack(buf []byte) ?CMsgStatusText {
	mut res := CMsgStatusText{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgstatustext() CMsgStatusText {
	return CMsgStatusText{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgstatustext(o CMsgStatusText, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgstatustext(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStatusText) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgstatustext_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetCursor {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	cursor             u32
	has_cursor         bool
	custom_data        []byte
	has_custom_data    bool
	wide               u32
	has_wide           bool
	tall               u32
	has_tall           bool
	xhotspot           u32
	has_xhotspot       bool
	yhotspot           u32
	has_yhotspot       bool
}

pub fn (o &CMsgSetCursor) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_cursor {
		res << vproto.pack_uint32_field(o.cursor, 2)
	}
	if o.has_custom_data {
		res << vproto.pack_bytes_field(o.custom_data, 3)
	}
	if o.has_wide {
		res << vproto.pack_uint32_field(o.wide, 4)
	}
	if o.has_tall {
		res << vproto.pack_uint32_field(o.tall, 5)
	}
	if o.has_xhotspot {
		res << vproto.pack_uint32_field(o.xhotspot, 6)
	}
	if o.has_yhotspot {
		res << vproto.pack_uint32_field(o.yhotspot, 7)
	}
	return res
}

pub fn cmsgsetcursor_unpack(buf []byte) ?CMsgSetCursor {
	mut res := CMsgSetCursor{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_cursor = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cursor = v
				i = ii
			}
			3 {
				res.has_custom_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.custom_data = v
				i = ii
			}
			4 {
				res.has_wide = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.wide = v
				i = ii
			}
			5 {
				res.has_tall = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tall = v
				i = ii
			}
			6 {
				res.has_xhotspot = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.xhotspot = v
				i = ii
			}
			7 {
				res.has_yhotspot = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.yhotspot = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsetcursor() CMsgSetCursor {
	return CMsgSetCursor{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsetcursor(o CMsgSetCursor, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsetcursor(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetCursor) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetcursor_unpack(v)?
	return i, unpacked
}

pub struct CMsgFileLoadDialog {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	title              string
	has_title          bool
	initialfile        string
	has_initialfile    bool
	accept_types       []string
	is_save            bool
	has_is_save        bool
}

pub fn (o &CMsgFileLoadDialog) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_title {
		res << vproto.pack_string_field(o.title, 2)
	}
	if o.has_initialfile {
		res << vproto.pack_string_field(o.initialfile, 3)
	}
	// [packed=false]
	for _, x in o.accept_types {
		res << vproto.pack_string_field(x, 4)
	}
	if o.has_is_save {
		res << vproto.pack_bool_field(o.is_save, 5)
	}
	return res
}

pub fn cmsgfileloaddialog_unpack(buf []byte) ?CMsgFileLoadDialog {
	mut res := CMsgFileLoadDialog{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.title = v
				i = ii
			}
			3 {
				res.has_initialfile = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.initialfile = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.accept_types << v
				i = ii
			}
			5 {
				res.has_is_save = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_save = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfileloaddialog() CMsgFileLoadDialog {
	return CMsgFileLoadDialog{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfileloaddialog(o CMsgFileLoadDialog, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfileloaddialog(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFileLoadDialog) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfileloaddialog_unpack(v)?
	return i, unpacked
}

pub struct CMsgFileLoadDialogResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	files              []string
}

pub fn (o &CMsgFileLoadDialogResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	// [packed=false]
	for _, x in o.files {
		res << vproto.pack_string_field(x, 2)
	}
	return res
}

pub fn cmsgfileloaddialogresponse_unpack(buf []byte) ?CMsgFileLoadDialogResponse {
	mut res := CMsgFileLoadDialogResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.files << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfileloaddialogresponse() CMsgFileLoadDialogResponse {
	return CMsgFileLoadDialogResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfileloaddialogresponse(o CMsgFileLoadDialogResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfileloaddialogresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFileLoadDialogResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfileloaddialogresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgShowToolTip {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	text               string
	has_text           bool
}

pub fn (o &CMsgShowToolTip) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_text {
		res << vproto.pack_string_field(o.text, 2)
	}
	return res
}

pub fn cmsgshowtooltip_unpack(buf []byte) ?CMsgShowToolTip {
	mut res := CMsgShowToolTip{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgshowtooltip() CMsgShowToolTip {
	return CMsgShowToolTip{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgshowtooltip(o CMsgShowToolTip, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgshowtooltip(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgShowToolTip) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgshowtooltip_unpack(v)?
	return i, unpacked
}

pub struct CMsgUpdateToolTip {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	text               string
	has_text           bool
}

pub fn (o &CMsgUpdateToolTip) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_text {
		res << vproto.pack_string_field(o.text, 2)
	}
	return res
}

pub fn cmsgupdatetooltip_unpack(buf []byte) ?CMsgUpdateToolTip {
	mut res := CMsgUpdateToolTip{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgupdatetooltip() CMsgUpdateToolTip {
	return CMsgUpdateToolTip{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgupdatetooltip(o CMsgUpdateToolTip, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgupdatetooltip(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgUpdateToolTip) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgupdatetooltip_unpack(v)?
	return i, unpacked
}

pub struct CMsgHideToolTip {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgHideToolTip) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsghidetooltip_unpack(buf []byte) ?CMsgHideToolTip {
	mut res := CMsgHideToolTip{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsghidetooltip() CMsgHideToolTip {
	return CMsgHideToolTip{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsghidetooltip(o CMsgHideToolTip, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsghidetooltip(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHideToolTip) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsghidetooltip_unpack(v)?
	return i, unpacked
}

pub struct CMsgSearchResults {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	activematch        int
	has_activematch    bool
	results            int
	has_results        bool
}

pub fn (o &CMsgSearchResults) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_activematch {
		res << vproto.pack_int32_field(o.activematch, 2)
	}
	if o.has_results {
		res << vproto.pack_int32_field(o.results, 3)
	}
	return res
}

pub fn cmsgsearchresults_unpack(buf []byte) ?CMsgSearchResults {
	mut res := CMsgSearchResults{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_activematch = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.activematch = v
				i = ii
			}
			3 {
				res.has_results = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.results = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsearchresults() CMsgSearchResults {
	return CMsgSearchResults{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsearchresults(o CMsgSearchResults, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsearchresults(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSearchResults) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsearchresults_unpack(v)?
	return i, unpacked
}

pub struct CMsgClose {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgClose) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgclose_unpack(buf []byte) ?CMsgClose {
	mut res := CMsgClose{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclose() CMsgClose {
	return CMsgClose{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclose(o CMsgClose, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclose(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClose) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclose_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetSharedPaintBuffers {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	wide               u32
	has_wide           bool
	tall               u32
	has_tall           bool
	source_pid         u64
	has_source_pid     bool
	source_handle      u64
	has_source_handle  bool
	handle             u64
	has_handle         bool
}

pub fn (o &CMsgSetSharedPaintBuffers) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_wide {
		res << vproto.pack_uint32_field(o.wide, 2)
	}
	if o.has_tall {
		res << vproto.pack_uint32_field(o.tall, 3)
	}
	if o.has_source_pid {
		res << vproto.pack_uint64_field(o.source_pid, 4)
	}
	if o.has_source_handle {
		res << vproto.pack_uint64_field(o.source_handle, 5)
	}
	if o.has_handle {
		res << vproto.pack_uint64_field(o.handle, 6)
	}
	return res
}

pub fn cmsgsetsharedpaintbuffers_unpack(buf []byte) ?CMsgSetSharedPaintBuffers {
	mut res := CMsgSetSharedPaintBuffers{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_wide = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.wide = v
				i = ii
			}
			3 {
				res.has_tall = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.tall = v
				i = ii
			}
			4 {
				res.has_source_pid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.source_pid = v
				i = ii
			}
			5 {
				res.has_source_handle = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.source_handle = v
				i = ii
			}
			6 {
				res.has_handle = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsetsharedpaintbuffers() CMsgSetSharedPaintBuffers {
	return CMsgSetSharedPaintBuffers{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsetsharedpaintbuffers(o CMsgSetSharedPaintBuffers, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsetsharedpaintbuffers(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetSharedPaintBuffers) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetsharedpaintbuffers_unpack(v)?
	return i, unpacked
}

pub struct CMsgAckSharedPaintBuffers {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgAckSharedPaintBuffers) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgacksharedpaintbuffers_unpack(buf []byte) ?CMsgAckSharedPaintBuffers {
	mut res := CMsgAckSharedPaintBuffers{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgacksharedpaintbuffers() CMsgAckSharedPaintBuffers {
	return CMsgAckSharedPaintBuffers{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgacksharedpaintbuffers(o CMsgAckSharedPaintBuffers, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgacksharedpaintbuffers(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAckSharedPaintBuffers) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgacksharedpaintbuffers_unpack(v)?
	return i, unpacked
}

pub struct CMsgNeedsPaint {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	scrollx            u32
	has_scrollx        bool
	scrolly            u32
	has_scrolly        bool
	pagescale          f32
	has_pagescale      bool
	pageserial         u32
	has_pageserial     bool
}

pub fn (o &CMsgNeedsPaint) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_scrollx {
		res << vproto.pack_uint32_field(o.scrollx, 10)
	}
	if o.has_scrolly {
		res << vproto.pack_uint32_field(o.scrolly, 11)
	}
	if o.has_pagescale {
		res << vproto.pack_float_field(o.pagescale, 12)
	}
	if o.has_pageserial {
		res << vproto.pack_uint32_field(o.pageserial, 15)
	}
	return res
}

pub fn cmsgneedspaint_unpack(buf []byte) ?CMsgNeedsPaint {
	mut res := CMsgNeedsPaint{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			10 {
				res.has_scrollx = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scrollx = v
				i = ii
			}
			11 {
				res.has_scrolly = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scrolly = v
				i = ii
			}
			12 {
				res.has_pagescale = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.pagescale = v
				i = ii
			}
			15 {
				res.has_pageserial = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.pageserial = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgneedspaint() CMsgNeedsPaint {
	return CMsgNeedsPaint{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgneedspaint(o CMsgNeedsPaint, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgneedspaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgNeedsPaint) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgneedspaint_unpack(v)?
	return i, unpacked
}

pub struct CMsgComboNeedsPaint {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	browser_handle           u32
	has_browser_handle       bool
	rgba                     u64
	has_rgba                 bool
	combobox_wide            u32
	has_combobox_wide        bool
	combobox_tall            u32
	has_combobox_tall        bool
	shared_memory_handle     u64
	has_shared_memory_handle bool
	shared_memory_size       u64
	has_shared_memory_size   bool
}

pub fn (o &CMsgComboNeedsPaint) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_rgba {
		res << vproto.pack_uint64_field(o.rgba, 2)
	}
	if o.has_combobox_wide {
		res << vproto.pack_uint32_field(o.combobox_wide, 3)
	}
	if o.has_combobox_tall {
		res << vproto.pack_uint32_field(o.combobox_tall, 4)
	}
	if o.has_shared_memory_handle {
		res << vproto.pack_uint64_field(o.shared_memory_handle, 5)
	}
	if o.has_shared_memory_size {
		res << vproto.pack_uint64_field(o.shared_memory_size, 7)
	}
	return res
}

pub fn cmsgcomboneedspaint_unpack(buf []byte) ?CMsgComboNeedsPaint {
	mut res := CMsgComboNeedsPaint{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_rgba = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.rgba = v
				i = ii
			}
			3 {
				res.has_combobox_wide = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.combobox_wide = v
				i = ii
			}
			4 {
				res.has_combobox_tall = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.combobox_tall = v
				i = ii
			}
			5 {
				res.has_shared_memory_handle = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.shared_memory_handle = v
				i = ii
			}
			7 {
				res.has_shared_memory_size = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.shared_memory_size = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcomboneedspaint() CMsgComboNeedsPaint {
	return CMsgComboNeedsPaint{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcomboneedspaint(o CMsgComboNeedsPaint, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcomboneedspaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgComboNeedsPaint) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcomboneedspaint_unpack(v)?
	return i, unpacked
}

pub struct CMsgNeedsSharedTexturePaint {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	share_handle       u32
	has_share_handle   bool
	width              u32
	has_width          bool
	height             u32
	has_height         bool
	scrollx            u32
	has_scrollx        bool
	scrolly            u32
	has_scrolly        bool
	pagescale          f32
	has_pagescale      bool
	pageserial         u32
	has_pageserial     bool
}

pub fn (o &CMsgNeedsSharedTexturePaint) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_share_handle {
		res << vproto.pack_uint32_field(o.share_handle, 2)
	}
	if o.has_width {
		res << vproto.pack_uint32_field(o.width, 3)
	}
	if o.has_height {
		res << vproto.pack_uint32_field(o.height, 4)
	}
	if o.has_scrollx {
		res << vproto.pack_uint32_field(o.scrollx, 5)
	}
	if o.has_scrolly {
		res << vproto.pack_uint32_field(o.scrolly, 6)
	}
	if o.has_pagescale {
		res << vproto.pack_float_field(o.pagescale, 7)
	}
	if o.has_pageserial {
		res << vproto.pack_uint32_field(o.pageserial, 8)
	}
	return res
}

pub fn cmsgneedssharedtexturepaint_unpack(buf []byte) ?CMsgNeedsSharedTexturePaint {
	mut res := CMsgNeedsSharedTexturePaint{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_share_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.share_handle = v
				i = ii
			}
			3 {
				res.has_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			4 {
				res.has_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			5 {
				res.has_scrollx = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scrollx = v
				i = ii
			}
			6 {
				res.has_scrolly = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scrolly = v
				i = ii
			}
			7 {
				res.has_pagescale = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.pagescale = v
				i = ii
			}
			8 {
				res.has_pageserial = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.pageserial = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgneedssharedtexturepaint() CMsgNeedsSharedTexturePaint {
	return CMsgNeedsSharedTexturePaint{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgneedssharedtexturepaint(o CMsgNeedsSharedTexturePaint, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgneedssharedtexturepaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgNeedsSharedTexturePaint) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgneedssharedtexturepaint_unpack(v)?
	return i, unpacked
}

pub struct CMsgGameOverlayTexturePaint {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	width              u32
	has_width          bool
	height             u32
	has_height         bool
	scrollx            u32
	has_scrollx        bool
	scrolly            u32
	has_scrolly        bool
	pagescale          f32
	has_pagescale      bool
	pageserial         u32
	has_pageserial     bool
}

pub fn (o &CMsgGameOverlayTexturePaint) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_width {
		res << vproto.pack_uint32_field(o.width, 3)
	}
	if o.has_height {
		res << vproto.pack_uint32_field(o.height, 4)
	}
	if o.has_scrollx {
		res << vproto.pack_uint32_field(o.scrollx, 5)
	}
	if o.has_scrolly {
		res << vproto.pack_uint32_field(o.scrolly, 6)
	}
	if o.has_pagescale {
		res << vproto.pack_float_field(o.pagescale, 7)
	}
	if o.has_pageserial {
		res << vproto.pack_uint32_field(o.pageserial, 8)
	}
	return res
}

pub fn cmsggameoverlaytexturepaint_unpack(buf []byte) ?CMsgGameOverlayTexturePaint {
	mut res := CMsgGameOverlayTexturePaint{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			3 {
				res.has_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			4 {
				res.has_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			5 {
				res.has_scrollx = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scrollx = v
				i = ii
			}
			6 {
				res.has_scrolly = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scrolly = v
				i = ii
			}
			7 {
				res.has_pagescale = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.pagescale = v
				i = ii
			}
			8 {
				res.has_pageserial = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.pageserial = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameoverlaytexturepaint() CMsgGameOverlayTexturePaint {
	return CMsgGameOverlayTexturePaint{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameoverlaytexturepaint(o CMsgGameOverlayTexturePaint, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameoverlaytexturepaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameOverlayTexturePaint) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggameoverlaytexturepaint_unpack(v)?
	return i, unpacked
}

pub struct CMsgGetZoom {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgGetZoom) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsggetzoom_unpack(buf []byte) ?CMsgGetZoom {
	mut res := CMsgGetZoom{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggetzoom() CMsgGetZoom {
	return CMsgGetZoom{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggetzoom(o CMsgGetZoom, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggetzoom(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGetZoom) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggetzoom_unpack(v)?
	return i, unpacked
}

pub struct CMsgGetZoomResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	zoom               f32
	has_zoom           bool
}

pub fn (o &CMsgGetZoomResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_zoom {
		res << vproto.pack_float_field(o.zoom, 2)
	}
	return res
}

pub fn cmsggetzoomresponse_unpack(buf []byte) ?CMsgGetZoomResponse {
	mut res := CMsgGetZoomResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_zoom = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.zoom = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggetzoomresponse() CMsgGetZoomResponse {
	return CMsgGetZoomResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggetzoomresponse(o CMsgGetZoomResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggetzoomresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGetZoomResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggetzoomresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgLinkAtPosition {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	x                  u32
	has_x              bool
	y                  u32
	has_y              bool
}

pub fn (o &CMsgLinkAtPosition) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_x {
		res << vproto.pack_uint32_field(o.x, 2)
	}
	if o.has_y {
		res << vproto.pack_uint32_field(o.y, 3)
	}
	return res
}

pub fn cmsglinkatposition_unpack(buf []byte) ?CMsgLinkAtPosition {
	mut res := CMsgLinkAtPosition{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_x = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				res.has_y = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsglinkatposition() CMsgLinkAtPosition {
	return CMsgLinkAtPosition{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsglinkatposition(o CMsgLinkAtPosition, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsglinkatposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLinkAtPosition) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsglinkatposition_unpack(v)?
	return i, unpacked
}

pub struct CMsgLinkAtPositionResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	x                  u32
	has_x              bool
	y                  u32
	has_y              bool
	url                string
	has_url            bool
	blivelink          bool
	has_blivelink      bool
	binput             bool
	has_binput         bool
}

pub fn (o &CMsgLinkAtPositionResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_x {
		res << vproto.pack_uint32_field(o.x, 2)
	}
	if o.has_y {
		res << vproto.pack_uint32_field(o.y, 3)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 4)
	}
	if o.has_blivelink {
		res << vproto.pack_bool_field(o.blivelink, 5)
	}
	if o.has_binput {
		res << vproto.pack_bool_field(o.binput, 6)
	}
	return res
}

pub fn cmsglinkatpositionresponse_unpack(buf []byte) ?CMsgLinkAtPositionResponse {
	mut res := CMsgLinkAtPositionResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_x = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				res.has_y = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			4 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			5 {
				res.has_blivelink = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.blivelink = v
				i = ii
			}
			6 {
				res.has_binput = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.binput = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsglinkatpositionresponse() CMsgLinkAtPositionResponse {
	return CMsgLinkAtPositionResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsglinkatpositionresponse(o CMsgLinkAtPositionResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsglinkatpositionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLinkAtPositionResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsglinkatpositionresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgZoomToElementAtPosition {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	x                  u32
	has_x              bool
	y                  u32
	has_y              bool
}

pub fn (o &CMsgZoomToElementAtPosition) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_x {
		res << vproto.pack_uint32_field(o.x, 2)
	}
	if o.has_y {
		res << vproto.pack_uint32_field(o.y, 3)
	}
	return res
}

pub fn cmsgzoomtoelementatposition_unpack(buf []byte) ?CMsgZoomToElementAtPosition {
	mut res := CMsgZoomToElementAtPosition{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_x = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				res.has_y = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgzoomtoelementatposition() CMsgZoomToElementAtPosition {
	return CMsgZoomToElementAtPosition{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgzoomtoelementatposition(o CMsgZoomToElementAtPosition, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgzoomtoelementatposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgZoomToElementAtPosition) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgzoomtoelementatposition_unpack(v)?
	return i, unpacked
}

pub struct CMsgZoomToElementAtPositionResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	scale              f32
	has_scale          bool
	duration           f32
	has_duration       bool
}

pub fn (o &CMsgZoomToElementAtPositionResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_scale {
		res << vproto.pack_float_field(o.scale, 2)
	}
	if o.has_duration {
		res << vproto.pack_float_field(o.duration, 3)
	}
	return res
}

pub fn cmsgzoomtoelementatpositionresponse_unpack(buf []byte) ?CMsgZoomToElementAtPositionResponse {
	mut res := CMsgZoomToElementAtPositionResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_scale = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.scale = v
				i = ii
			}
			3 {
				res.has_duration = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.duration = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgzoomtoelementatpositionresponse() CMsgZoomToElementAtPositionResponse {
	return CMsgZoomToElementAtPositionResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgzoomtoelementatpositionresponse(o CMsgZoomToElementAtPositionResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgzoomtoelementatpositionresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgZoomToElementAtPositionResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgzoomtoelementatpositionresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgScalePageToValue {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	scale              f32
	has_scale          bool
	x                  f32
	has_x              bool
	y                  f32
	has_y              bool
}

pub fn (o &CMsgScalePageToValue) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_scale {
		res << vproto.pack_float_field(o.scale, 2)
	}
	if o.has_x {
		res << vproto.pack_float_field(o.x, 3)
	}
	if o.has_y {
		res << vproto.pack_float_field(o.y, 4)
	}
	return res
}

pub fn cmsgscalepagetovalue_unpack(buf []byte) ?CMsgScalePageToValue {
	mut res := CMsgScalePageToValue{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_scale = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.scale = v
				i = ii
			}
			3 {
				res.has_x = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			4 {
				res.has_y = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgscalepagetovalue() CMsgScalePageToValue {
	return CMsgScalePageToValue{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgscalepagetovalue(o CMsgScalePageToValue, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgscalepagetovalue(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgScalePageToValue) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgscalepagetovalue_unpack(v)?
	return i, unpacked
}

pub struct CMsgForcePopupsToDirectHWND {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	browser_handle               u32
	has_browser_handle           bool
	force_direct_hwnd_popups     bool
	has_force_direct_hwnd_popups bool
}

pub fn (o &CMsgForcePopupsToDirectHWND) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_force_direct_hwnd_popups {
		res << vproto.pack_bool_field(o.force_direct_hwnd_popups, 2)
	}
	return res
}

pub fn cmsgforcepopupstodirecthwnd_unpack(buf []byte) ?CMsgForcePopupsToDirectHWND {
	mut res := CMsgForcePopupsToDirectHWND{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_force_direct_hwnd_popups = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.force_direct_hwnd_popups = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgforcepopupstodirecthwnd() CMsgForcePopupsToDirectHWND {
	return CMsgForcePopupsToDirectHWND{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgforcepopupstodirecthwnd(o CMsgForcePopupsToDirectHWND, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgforcepopupstodirecthwnd(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgForcePopupsToDirectHWND) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgforcepopupstodirecthwnd_unpack(v)?
	return i, unpacked
}

pub struct CMsgScalePageToValueResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	zoom               f32
	has_zoom           bool
}

pub fn (o &CMsgScalePageToValueResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_zoom {
		res << vproto.pack_float_field(o.zoom, 2)
	}
	return res
}

pub fn cmsgscalepagetovalueresponse_unpack(buf []byte) ?CMsgScalePageToValueResponse {
	mut res := CMsgScalePageToValueResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_zoom = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.zoom = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgscalepagetovalueresponse() CMsgScalePageToValueResponse {
	return CMsgScalePageToValueResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgscalepagetovalueresponse(o CMsgScalePageToValueResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgscalepagetovalueresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgScalePageToValueResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgscalepagetovalueresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgSavePageToJPEG {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
	filename           string
	has_filename       bool
	width              u32
	has_width          bool
	height             u32
	has_height         bool
}

pub fn (o &CMsgSavePageToJPEG) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 3)
	}
	if o.has_width {
		res << vproto.pack_uint32_field(o.width, 4)
	}
	if o.has_height {
		res << vproto.pack_uint32_field(o.height, 5)
	}
	return res
}

pub fn cmsgsavepagetojpeg_unpack(buf []byte) ?CMsgSavePageToJPEG {
	mut res := CMsgSavePageToJPEG{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			4 {
				res.has_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			5 {
				res.has_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsavepagetojpeg() CMsgSavePageToJPEG {
	return CMsgSavePageToJPEG{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsavepagetojpeg(o CMsgSavePageToJPEG, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsavepagetojpeg(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSavePageToJPEG) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsavepagetojpeg_unpack(v)?
	return i, unpacked
}

pub struct CMsgSavePageToJPEGResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
	filename           string
	has_filename       bool
}

pub fn (o &CMsgSavePageToJPEGResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_filename {
		res << vproto.pack_string_field(o.filename, 3)
	}
	return res
}

pub fn cmsgsavepagetojpegresponse_unpack(buf []byte) ?CMsgSavePageToJPEGResponse {
	mut res := CMsgSavePageToJPEGResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_filename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.filename = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsavepagetojpegresponse() CMsgSavePageToJPEGResponse {
	return CMsgSavePageToJPEGResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsavepagetojpegresponse(o CMsgSavePageToJPEGResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsavepagetojpegresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSavePageToJPEGResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsavepagetojpegresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSAlert {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	message            string
	has_message        bool
}

pub fn (o &CMsgJSAlert) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 2)
	}
	return res
}

pub fn cmsgjsalert_unpack(buf []byte) ?CMsgJSAlert {
	mut res := CMsgJSAlert{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgjsalert() CMsgJSAlert {
	return CMsgJSAlert{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgjsalert(o CMsgJSAlert, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgjsalert(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSAlert) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsalert_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSConfirm {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	message            string
	has_message        bool
}

pub fn (o &CMsgJSConfirm) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 2)
	}
	return res
}

pub fn cmsgjsconfirm_unpack(buf []byte) ?CMsgJSConfirm {
	mut res := CMsgJSConfirm{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgjsconfirm() CMsgJSConfirm {
	return CMsgJSConfirm{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgjsconfirm(o CMsgJSConfirm, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgjsconfirm(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSConfirm) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsconfirm_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSDialogResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	result             bool
	has_result         bool
}

pub fn (o &CMsgJSDialogResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_result {
		res << vproto.pack_bool_field(o.result, 2)
	}
	return res
}

pub fn cmsgjsdialogresponse_unpack(buf []byte) ?CMsgJSDialogResponse {
	mut res := CMsgJSDialogResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_result = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgjsdialogresponse() CMsgJSDialogResponse {
	return CMsgJSDialogResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgjsdialogresponse(o CMsgJSDialogResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgjsdialogresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSDialogResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsdialogresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgCanGoBackAndForward {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	bgoback            bool
	has_bgoback        bool
	bgoforward         bool
	has_bgoforward     bool
}

pub fn (o &CMsgCanGoBackAndForward) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_bgoback {
		res << vproto.pack_bool_field(o.bgoback, 2)
	}
	if o.has_bgoforward {
		res << vproto.pack_bool_field(o.bgoforward, 3)
	}
	return res
}

pub fn cmsgcangobackandforward_unpack(buf []byte) ?CMsgCanGoBackAndForward {
	mut res := CMsgCanGoBackAndForward{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_bgoback = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bgoback = v
				i = ii
			}
			3 {
				res.has_bgoforward = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bgoforward = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgcangobackandforward() CMsgCanGoBackAndForward {
	return CMsgCanGoBackAndForward{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgcangobackandforward(o CMsgCanGoBackAndForward, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgcangobackandforward(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCanGoBackAndForward) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgcangobackandforward_unpack(v)?
	return i, unpacked
}

pub struct CMsgOpenSteamURL {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
	referrer           string
	has_referrer       bool
}

pub fn (o &CMsgOpenSteamURL) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	if o.has_referrer {
		res << vproto.pack_string_field(o.referrer, 3)
	}
	return res
}

pub fn cmsgopensteamurl_unpack(buf []byte) ?CMsgOpenSteamURL {
	mut res := CMsgOpenSteamURL{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				res.has_referrer = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.referrer = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgopensteamurl() CMsgOpenSteamURL {
	return CMsgOpenSteamURL{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgopensteamurl(o CMsgOpenSteamURL, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgopensteamurl(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgOpenSteamURL) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgopensteamurl_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetCookie {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
	path           string
	has_path       bool
	host           string
	has_host       bool
	expires        u32
	has_expires    bool
	secure         bool
	has_secure     bool
	httponly       bool
	has_httponly   bool
}

pub fn (o &CMsgSetCookie) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	if o.has_path {
		res << vproto.pack_string_field(o.path, 3)
	}
	if o.has_host {
		res << vproto.pack_string_field(o.host, 4)
	}
	if o.has_expires {
		res << vproto.pack_uint32_field(o.expires, 5)
	}
	if o.has_secure {
		res << vproto.pack_bool_field(o.secure, 6)
	}
	if o.has_httponly {
		res << vproto.pack_bool_field(o.httponly, 7)
	}
	return res
}

pub fn cmsgsetcookie_unpack(buf []byte) ?CMsgSetCookie {
	mut res := CMsgSetCookie{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			3 {
				res.has_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.path = v
				i = ii
			}
			4 {
				res.has_host = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.host = v
				i = ii
			}
			5 {
				res.has_expires = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.expires = v
				i = ii
			}
			6 {
				res.has_secure = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.secure = v
				i = ii
			}
			7 {
				res.has_httponly = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.httponly = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsetcookie() CMsgSetCookie {
	return CMsgSetCookie{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsetcookie(o CMsgSetCookie, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsetcookie(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetCookie) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetcookie_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetTargetFrameRate {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	browser_handle       u32
	has_browser_handle   bool
	ntargetframerate     u32
	has_ntargetframerate bool
}

pub fn (o &CMsgSetTargetFrameRate) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_ntargetframerate {
		res << vproto.pack_uint32_field(o.ntargetframerate, 2)
	}
	return res
}

pub fn cmsgsettargetframerate_unpack(buf []byte) ?CMsgSetTargetFrameRate {
	mut res := CMsgSetTargetFrameRate{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_ntargetframerate = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ntargetframerate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsettargetframerate() CMsgSetTargetFrameRate {
	return CMsgSetTargetFrameRate{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsettargetframerate(o CMsgSetTargetFrameRate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsettargetframerate(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetTargetFrameRate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsettargetframerate_unpack(v)?
	return i, unpacked
}

pub struct CMsgPauseRepaint {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgPauseRepaint) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgpauserepaint_unpack(buf []byte) ?CMsgPauseRepaint {
	mut res := CMsgPauseRepaint{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgpauserepaint() CMsgPauseRepaint {
	return CMsgPauseRepaint{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgpauserepaint(o CMsgPauseRepaint, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgpauserepaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPauseRepaint) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgpauserepaint_unpack(v)?
	return i, unpacked
}

pub struct CMsgFullRepaint {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgFullRepaint) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgfullrepaint_unpack(buf []byte) ?CMsgFullRepaint {
	mut res := CMsgFullRepaint{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfullrepaint() CMsgFullRepaint {
	return CMsgFullRepaint{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfullrepaint(o CMsgFullRepaint, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfullrepaint(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFullRepaint) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfullrepaint_unpack(v)?
	return i, unpacked
}

pub struct CMsgRequestFullScreen {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgRequestFullScreen) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgrequestfullscreen_unpack(buf []byte) ?CMsgRequestFullScreen {
	mut res := CMsgRequestFullScreen{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgrequestfullscreen() CMsgRequestFullScreen {
	return CMsgRequestFullScreen{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgrequestfullscreen(o CMsgRequestFullScreen, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgrequestfullscreen(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgRequestFullScreen) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgrequestfullscreen_unpack(v)?
	return i, unpacked
}

pub struct CMsgExitFullScreen {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgExitFullScreen) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgexitfullscreen_unpack(buf []byte) ?CMsgExitFullScreen {
	mut res := CMsgExitFullScreen{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgexitfullscreen() CMsgExitFullScreen {
	return CMsgExitFullScreen{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgexitfullscreen(o CMsgExitFullScreen, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgexitfullscreen(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgExitFullScreen) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgexitfullscreen_unpack(v)?
	return i, unpacked
}

pub struct CMsgToggleFindInPageDialog {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgToggleFindInPageDialog) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgtogglefindinpagedialog_unpack(buf []byte) ?CMsgToggleFindInPageDialog {
	mut res := CMsgToggleFindInPageDialog{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgtogglefindinpagedialog() CMsgToggleFindInPageDialog {
	return CMsgToggleFindInPageDialog{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgtogglefindinpagedialog(o CMsgToggleFindInPageDialog, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgtogglefindinpagedialog(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgToggleFindInPageDialog) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgtogglefindinpagedialog_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetPIDShuttingDown {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgSetPIDShuttingDown) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgsetpidshuttingdown_unpack(buf []byte) ?CMsgSetPIDShuttingDown {
	mut res := CMsgSetPIDShuttingDown{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsetpidshuttingdown() CMsgSetPIDShuttingDown {
	return CMsgSetPIDShuttingDown{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsetpidshuttingdown(o CMsgSetPIDShuttingDown, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsetpidshuttingdown(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetPIDShuttingDown) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetpidshuttingdown_unpack(v)?
	return i, unpacked
}

pub struct CMsgDisableBackgroundThrottling {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgDisableBackgroundThrottling) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgdisablebackgroundthrottling_unpack(buf []byte) ?CMsgDisableBackgroundThrottling {
	mut res := CMsgDisableBackgroundThrottling{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdisablebackgroundthrottling() CMsgDisableBackgroundThrottling {
	return CMsgDisableBackgroundThrottling{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdisablebackgroundthrottling(o CMsgDisableBackgroundThrottling, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdisablebackgroundthrottling(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDisableBackgroundThrottling) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdisablebackgroundthrottling_unpack(v)?
	return i, unpacked
}

pub struct CMsgAckPIDShuttingDown {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgAckPIDShuttingDown) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgackpidshuttingdown_unpack(buf []byte) ?CMsgAckPIDShuttingDown {
	mut res := CMsgAckPIDShuttingDown{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgackpidshuttingdown() CMsgAckPIDShuttingDown {
	return CMsgAckPIDShuttingDown{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgackpidshuttingdown(o CMsgAckPIDShuttingDown, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgackpidshuttingdown(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAckPIDShuttingDown) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgackpidshuttingdown_unpack(v)?
	return i, unpacked
}

pub struct CMsgGetCookiesForURL {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
}

pub fn (o &CMsgGetCookiesForURL) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	return res
}

pub fn cmsggetcookiesforurl_unpack(buf []byte) ?CMsgGetCookiesForURL {
	mut res := CMsgGetCookiesForURL{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggetcookiesforurl() CMsgGetCookiesForURL {
	return CMsgGetCookiesForURL{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggetcookiesforurl(o CMsgGetCookiesForURL, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggetcookiesforurl(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGetCookiesForURL) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggetcookiesforurl_unpack(v)?
	return i, unpacked
}

pub struct CCookie {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	value          string
	has_value      bool
	domain         string
	has_domain     bool
	path           string
	has_path       bool
}

pub fn (o &CCookie) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	if o.has_domain {
		res << vproto.pack_string_field(o.domain, 3)
	}
	if o.has_path {
		res << vproto.pack_string_field(o.path, 4)
	}
	return res
}

pub fn ccookie_unpack(buf []byte) ?CCookie {
	mut res := CCookie{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			3 {
				res.has_domain = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.domain = v
				i = ii
			}
			4 {
				res.has_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.path = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ccookie() CCookie {
	return CCookie{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ccookie(o CCookie, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ccookie(buf []byte, tag_wiretype vproto.WireType) ?(int, CCookie) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ccookie_unpack(v)?
	return i, unpacked
}

pub struct CMsgGetCookiesForURLResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
	cookies            []CCookie
}

pub fn (o &CMsgGetCookiesForURLResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	// [packed=false]
	for _, x in o.cookies {
		res << zzz_vproto_internal_pack_ccookie(x, 3)
	}
	return res
}

pub fn cmsggetcookiesforurlresponse_unpack(buf []byte) ?CMsgGetCookiesForURLResponse {
	mut res := CMsgGetCookiesForURLResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_ccookie(cur_buf, tag_wiretype.wire_type)?
				res.cookies << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggetcookiesforurlresponse() CMsgGetCookiesForURLResponse {
	return CMsgGetCookiesForURLResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggetcookiesforurlresponse(o CMsgGetCookiesForURLResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggetcookiesforurlresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGetCookiesForURLResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggetcookiesforurlresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgNodeHasFocus {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	browser_handle         u32
	has_browser_handle     bool
	binput                 bool
	has_binput             bool
	name                   string
	has_name               bool
	elementtagname         string
	has_elementtagname     bool
	searchbuttontext       string
	has_searchbuttontext   bool
	bhasmultipleinputs     bool
	has_bhasmultipleinputs bool
	input_type             string
	has_input_type         bool
}

pub fn (o &CMsgNodeHasFocus) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_binput {
		res << vproto.pack_bool_field(o.binput, 2)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 3)
	}
	if o.has_elementtagname {
		res << vproto.pack_string_field(o.elementtagname, 4)
	}
	if o.has_searchbuttontext {
		res << vproto.pack_string_field(o.searchbuttontext, 5)
	}
	if o.has_bhasmultipleinputs {
		res << vproto.pack_bool_field(o.bhasmultipleinputs, 6)
	}
	if o.has_input_type {
		res << vproto.pack_string_field(o.input_type, 7)
	}
	return res
}

pub fn cmsgnodehasfocus_unpack(buf []byte) ?CMsgNodeHasFocus {
	mut res := CMsgNodeHasFocus{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_binput = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.binput = v
				i = ii
			}
			3 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			4 {
				res.has_elementtagname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.elementtagname = v
				i = ii
			}
			5 {
				res.has_searchbuttontext = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.searchbuttontext = v
				i = ii
			}
			6 {
				res.has_bhasmultipleinputs = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bhasmultipleinputs = v
				i = ii
			}
			7 {
				res.has_input_type = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.input_type = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgnodehasfocus() CMsgNodeHasFocus {
	return CMsgNodeHasFocus{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgnodehasfocus(o CMsgNodeHasFocus, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgnodehasfocus(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgNodeHasFocus) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgnodehasfocus_unpack(v)?
	return i, unpacked
}

pub struct CMsgZoomToFocusedElement {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgZoomToFocusedElement) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgzoomtofocusedelement_unpack(buf []byte) ?CMsgZoomToFocusedElement {
	mut res := CMsgZoomToFocusedElement{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgzoomtofocusedelement() CMsgZoomToFocusedElement {
	return CMsgZoomToFocusedElement{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgzoomtofocusedelement(o CMsgZoomToFocusedElement, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgzoomtofocusedelement(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgZoomToFocusedElement) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgzoomtofocusedelement_unpack(v)?
	return i, unpacked
}

pub struct CMsgCloseFullScreenFlashIfOpen {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgCloseFullScreenFlashIfOpen) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgclosefullscreenflashifopen_unpack(buf []byte) ?CMsgCloseFullScreenFlashIfOpen {
	mut res := CMsgCloseFullScreenFlashIfOpen{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclosefullscreenflashifopen() CMsgCloseFullScreenFlashIfOpen {
	return CMsgCloseFullScreenFlashIfOpen{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclosefullscreenflashifopen(o CMsgCloseFullScreenFlashIfOpen, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclosefullscreenflashifopen(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCloseFullScreenFlashIfOpen) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclosefullscreenflashifopen_unpack(v)?
	return i, unpacked
}

pub struct CMsgPauseFullScreenFlashMovieIfOpen {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgPauseFullScreenFlashMovieIfOpen) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgpausefullscreenflashmovieifopen_unpack(buf []byte) ?CMsgPauseFullScreenFlashMovieIfOpen {
	mut res := CMsgPauseFullScreenFlashMovieIfOpen{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgpausefullscreenflashmovieifopen() CMsgPauseFullScreenFlashMovieIfOpen {
	return CMsgPauseFullScreenFlashMovieIfOpen{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgpausefullscreenflashmovieifopen(o CMsgPauseFullScreenFlashMovieIfOpen, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgpausefullscreenflashmovieifopen(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgPauseFullScreenFlashMovieIfOpen) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgpausefullscreenflashmovieifopen_unpack(v)?
	return i, unpacked
}

pub struct CMsgFocusedNodeText {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgFocusedNodeText) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgfocusednodetext_unpack(buf []byte) ?CMsgFocusedNodeText {
	mut res := CMsgFocusedNodeText{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfocusednodetext() CMsgFocusedNodeText {
	return CMsgFocusedNodeText{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfocusednodetext(o CMsgFocusedNodeText, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfocusednodetext(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFocusedNodeText) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfocusednodetext_unpack(v)?
	return i, unpacked
}

pub struct CMsgFocusedNodeTextResponse {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	value              string
	has_value          bool
}

pub fn (o &CMsgFocusedNodeTextResponse) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn cmsgfocusednodetextresponse_unpack(buf []byte) ?CMsgFocusedNodeTextResponse {
	mut res := CMsgFocusedNodeTextResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgfocusednodetextresponse() CMsgFocusedNodeTextResponse {
	return CMsgFocusedNodeTextResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgfocusednodetextresponse(o CMsgFocusedNodeTextResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgfocusednodetextresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgFocusedNodeTextResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgfocusednodetextresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgBuildID {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	build_id       u64
	has_build_id   bool
}

pub fn (o &CMsgBuildID) pack() []byte {
	mut res := []byte{}
	if o.has_build_id {
		res << vproto.pack_uint64_field(o.build_id, 1)
	}
	return res
}

pub fn cmsgbuildid_unpack(buf []byte) ?CMsgBuildID {
	mut res := CMsgBuildID{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_build_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.build_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgbuildid() CMsgBuildID {
	return CMsgBuildID{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgbuildid(o CMsgBuildID, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgbuildid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBuildID) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbuildid_unpack(v)?
	return i, unpacked
}

pub struct CMsgOpenDevTools {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgOpenDevTools) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgopendevtools_unpack(buf []byte) ?CMsgOpenDevTools {
	mut res := CMsgOpenDevTools{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgopendevtools() CMsgOpenDevTools {
	return CMsgOpenDevTools{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgopendevtools(o CMsgOpenDevTools, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgopendevtools(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgOpenDevTools) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgopendevtools_unpack(v)?
	return i, unpacked
}

pub struct CMsgCloseDevTools {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgCloseDevTools) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgclosedevtools_unpack(buf []byte) ?CMsgCloseDevTools {
	mut res := CMsgCloseDevTools{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclosedevtools() CMsgCloseDevTools {
	return CMsgCloseDevTools{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclosedevtools(o CMsgCloseDevTools, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclosedevtools(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgCloseDevTools) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclosedevtools_unpack(v)?
	return i, unpacked
}

pub struct CMsgUnlockH264 {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	unlock_code        string
	has_unlock_code    bool
}

pub fn (o &CMsgUnlockH264) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_unlock_code {
		res << vproto.pack_string_field(o.unlock_code, 2)
	}
	return res
}

pub fn cmsgunlockh264_unpack(buf []byte) ?CMsgUnlockH264 {
	mut res := CMsgUnlockH264{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_unlock_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.unlock_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgunlockh264() CMsgUnlockH264 {
	return CMsgUnlockH264{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgunlockh264(o CMsgUnlockH264, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgunlockh264(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgUnlockH264) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgunlockh264_unpack(v)?
	return i, unpacked
}

pub struct CMsgScreenInformationChanged {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	browser_handle      u32
	has_browser_handle  bool
	override_width      u32
	has_override_width  bool
	override_height     u32
	has_override_height bool
	monitor_left        u32
	has_monitor_left    bool
	monitor_top         u32
	has_monitor_top     bool
	monitor_right       u32
	has_monitor_right   bool
	monitor_bottom      u32
	has_monitor_bottom  bool
	usable_left         u32
	has_usable_left     bool
	usable_top          u32
	has_usable_top      bool
	usable_right        u32
	has_usable_right    bool
	usable_bottom       u32
	has_usable_bottom   bool
}

pub fn (o &CMsgScreenInformationChanged) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_override_width {
		res << vproto.pack_uint32_field(o.override_width, 2)
	}
	if o.has_override_height {
		res << vproto.pack_uint32_field(o.override_height, 3)
	}
	if o.has_monitor_left {
		res << vproto.pack_uint32_field(o.monitor_left, 4)
	}
	if o.has_monitor_top {
		res << vproto.pack_uint32_field(o.monitor_top, 5)
	}
	if o.has_monitor_right {
		res << vproto.pack_uint32_field(o.monitor_right, 6)
	}
	if o.has_monitor_bottom {
		res << vproto.pack_uint32_field(o.monitor_bottom, 7)
	}
	if o.has_usable_left {
		res << vproto.pack_uint32_field(o.usable_left, 8)
	}
	if o.has_usable_top {
		res << vproto.pack_uint32_field(o.usable_top, 9)
	}
	if o.has_usable_right {
		res << vproto.pack_uint32_field(o.usable_right, 10)
	}
	if o.has_usable_bottom {
		res << vproto.pack_uint32_field(o.usable_bottom, 11)
	}
	return res
}

pub fn cmsgscreeninformationchanged_unpack(buf []byte) ?CMsgScreenInformationChanged {
	mut res := CMsgScreenInformationChanged{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_override_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.override_width = v
				i = ii
			}
			3 {
				res.has_override_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.override_height = v
				i = ii
			}
			4 {
				res.has_monitor_left = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.monitor_left = v
				i = ii
			}
			5 {
				res.has_monitor_top = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.monitor_top = v
				i = ii
			}
			6 {
				res.has_monitor_right = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.monitor_right = v
				i = ii
			}
			7 {
				res.has_monitor_bottom = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.monitor_bottom = v
				i = ii
			}
			8 {
				res.has_usable_left = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.usable_left = v
				i = ii
			}
			9 {
				res.has_usable_top = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.usable_top = v
				i = ii
			}
			10 {
				res.has_usable_right = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.usable_right = v
				i = ii
			}
			11 {
				res.has_usable_bottom = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.usable_bottom = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgscreeninformationchanged() CMsgScreenInformationChanged {
	return CMsgScreenInformationChanged{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgscreeninformationchanged(o CMsgScreenInformationChanged, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgscreeninformationchanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgScreenInformationChanged) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgscreeninformationchanged_unpack(v)?
	return i, unpacked
}

pub struct CMsgClearAllCookies {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgClearAllCookies) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgclearallcookies_unpack(buf []byte) ?CMsgClearAllCookies {
	mut res := CMsgClearAllCookies{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclearallcookies() CMsgClearAllCookies {
	return CMsgClearAllCookies{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclearallcookies(o CMsgClearAllCookies, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclearallcookies(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClearAllCookies) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclearallcookies_unpack(v)?
	return i, unpacked
}

pub struct CMsgScreenDPI {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	dpi_scaling        f32
	has_dpi_scaling    bool
}

pub fn (o &CMsgScreenDPI) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_dpi_scaling {
		res << vproto.pack_float_field(o.dpi_scaling, 2)
	}
	return res
}

pub fn cmsgscreendpi_unpack(buf []byte) ?CMsgScreenDPI {
	mut res := CMsgScreenDPI{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_dpi_scaling = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.dpi_scaling = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgscreendpi() CMsgScreenDPI {
	return CMsgScreenDPI{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgscreendpi(o CMsgScreenDPI, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgscreendpi(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgScreenDPI) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgscreendpi_unpack(v)?
	return i, unpacked
}

pub struct CMsgAuthedSteamDomains {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	domains        []string
}

pub fn (o &CMsgAuthedSteamDomains) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.domains {
		res << vproto.pack_string_field(x, 1)
	}
	return res
}

pub fn cmsgauthedsteamdomains_unpack(buf []byte) ?CMsgAuthedSteamDomains {
	mut res := CMsgAuthedSteamDomains{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.domains << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgauthedsteamdomains() CMsgAuthedSteamDomains {
	return CMsgAuthedSteamDomains{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgauthedsteamdomains(o CMsgAuthedSteamDomains, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgauthedsteamdomains(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgAuthedSteamDomains) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgauthedsteamdomains_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamAuthNeeded {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	filler         bool
	has_filler     bool
}

pub fn (o &CMsgSteamAuthNeeded) pack() []byte {
	mut res := []byte{}
	if o.has_filler {
		res << vproto.pack_bool_field(o.filler, 1)
	}
	return res
}

pub fn cmsgsteamauthneeded_unpack(buf []byte) ?CMsgSteamAuthNeeded {
	mut res := CMsgSteamAuthNeeded{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_filler = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.filler = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamauthneeded() CMsgSteamAuthNeeded {
	return CMsgSteamAuthNeeded{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamauthneeded(o CMsgSteamAuthNeeded, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamauthneeded(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamAuthNeeded) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamauthneeded_unpack(v)?
	return i, unpacked
}

pub struct CMsgSteamAuthCookiesSet {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	success        bool
	has_success    bool
}

pub fn (o &CMsgSteamAuthCookiesSet) pack() []byte {
	mut res := []byte{}
	if o.has_success {
		res << vproto.pack_bool_field(o.success, 1)
	}
	return res
}

pub fn cmsgsteamauthcookiesset_unpack(buf []byte) ?CMsgSteamAuthCookiesSet {
	mut res := CMsgSteamAuthCookiesSet{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_success = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.success = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsteamauthcookiesset() CMsgSteamAuthCookiesSet {
	return CMsgSteamAuthCookiesSet{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsteamauthcookiesset(o CMsgSteamAuthCookiesSet, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsteamauthcookiesset(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSteamAuthCookiesSet) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsteamauthcookiesset_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSRegisterMethod {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	name               string
	has_name           bool
	method_type        EJSRegisterMethodType
	has_method_type    bool
}

pub fn (o &CMsgJSRegisterMethod) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	if o.has_method_type {
		res << zzz_vproto_internal_pack_ejsregistermethodtype(o.method_type, 3)
	}
	return res
}

pub fn cmsgjsregistermethod_unpack(buf []byte) ?CMsgJSRegisterMethod {
	mut res := CMsgJSRegisterMethod{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				res.has_method_type = true
				ii, v := zzz_vproto_internal_unpack_ejsregistermethodtype(cur_buf, tag_wiretype.wire_type)?
				res.method_type = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgjsregistermethod() CMsgJSRegisterMethod {
	return CMsgJSRegisterMethod{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgjsregistermethod(o CMsgJSRegisterMethod, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgjsregistermethod(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSRegisterMethod) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsregistermethod_unpack(v)?
	return i, unpacked
}

pub struct CJSMethodArgument {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	json_data           string
	has_json_data       bool
	function_handle     u64
	has_function_handle bool
}

pub fn (o &CJSMethodArgument) pack() []byte {
	mut res := []byte{}
	if o.has_json_data {
		res << vproto.pack_string_field(o.json_data, 1)
	}
	if o.has_function_handle {
		res << vproto.pack_uint64_field(o.function_handle, 2)
	}
	return res
}

pub fn cjsmethodargument_unpack(buf []byte) ?CJSMethodArgument {
	mut res := CJSMethodArgument{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_json_data = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.json_data = v
				i = ii
			}
			2 {
				res.has_function_handle = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.function_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cjsmethodargument() CJSMethodArgument {
	return CJSMethodArgument{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cjsmethodargument(o CJSMethodArgument, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cjsmethodargument(buf []byte, tag_wiretype vproto.WireType) ?(int, CJSMethodArgument) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cjsmethodargument_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSValue_JSObjectProperty {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	value          CMsgJSValue
	has_value      bool
}

pub fn (o &CMsgJSValue_JSObjectProperty) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_value {
		res << zzz_vproto_internal_pack_cmsgjsvalue(o.value, 2)
	}
	return res
}

pub fn cmsgjsvalue_jsobjectproperty_unpack(buf []byte) ?CMsgJSValue_JSObjectProperty {
	mut res := CMsgJSValue_JSObjectProperty{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := zzz_vproto_internal_unpack_cmsgjsvalue(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgjsvalue_jsobjectproperty() CMsgJSValue_JSObjectProperty {
	return CMsgJSValue_JSObjectProperty{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgjsvalue_jsobjectproperty(o CMsgJSValue_JSObjectProperty, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgjsvalue_jsobjectproperty(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSValue_JSObjectProperty) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsvalue_jsobjectproperty_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSValue {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	bool_value          bool
	has_bool_value      bool
	int_value           int
	has_int_value       bool
	uint_value          u32
	has_uint_value      bool
	double_value        f64
	has_double_value    bool
	string_value        string
	has_string_value    bool
	function_handle     u64
	has_function_handle bool
	is_array            bool
	has_is_array        bool
	array_values        []CMsgJSValue
	is_object           bool
	has_is_object       bool
	object_properties   []CMsgJSValue_JSObjectProperty
}

pub fn (o &CMsgJSValue) pack() []byte {
	mut res := []byte{}
	if o.has_bool_value {
		res << vproto.pack_bool_field(o.bool_value, 1)
	}
	if o.has_int_value {
		res << vproto.pack_int32_field(o.int_value, 2)
	}
	if o.has_uint_value {
		res << vproto.pack_uint32_field(o.uint_value, 3)
	}
	if o.has_double_value {
		res << vproto.pack_double_field(o.double_value, 4)
	}
	if o.has_string_value {
		res << vproto.pack_string_field(o.string_value, 5)
	}
	if o.has_function_handle {
		res << vproto.pack_uint64_field(o.function_handle, 6)
	}
	if o.has_is_array {
		res << vproto.pack_bool_field(o.is_array, 8)
	}
	// [packed=false]
	for _, x in o.array_values {
		res << zzz_vproto_internal_pack_cmsgjsvalue(x, 9)
	}
	if o.has_is_object {
		res << vproto.pack_bool_field(o.is_object, 10)
	}
	// [packed=false]
	for _, x in o.object_properties {
		res << zzz_vproto_internal_pack_cmsgjsvalue_jsobjectproperty(x, 11)
	}
	return res
}

pub fn cmsgjsvalue_unpack(buf []byte) ?CMsgJSValue {
	mut res := CMsgJSValue{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_bool_value = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bool_value = v
				i = ii
			}
			2 {
				res.has_int_value = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.int_value = v
				i = ii
			}
			3 {
				res.has_uint_value = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.uint_value = v
				i = ii
			}
			4 {
				res.has_double_value = true
				ii, v := vproto.unpack_double_field(cur_buf, tag_wiretype.wire_type)?
				res.double_value = v
				i = ii
			}
			5 {
				res.has_string_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.string_value = v
				i = ii
			}
			6 {
				res.has_function_handle = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.function_handle = v
				i = ii
			}
			8 {
				res.has_is_array = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_array = v
				i = ii
			}
			9 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgjsvalue(cur_buf, tag_wiretype.wire_type)?
				res.array_values << v
				i = ii
			}
			10 {
				res.has_is_object = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_object = v
				i = ii
			}
			11 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgjsvalue_jsobjectproperty(cur_buf,
					tag_wiretype.wire_type)?
				res.object_properties << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgjsvalue() CMsgJSValue {
	return CMsgJSValue{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgjsvalue(o CMsgJSValue, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgjsvalue(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSValue) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsvalue_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSMethodCall {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	name               string
	has_name           bool
	arguments          []CMsgJSValue
}

pub fn (o &CMsgJSMethodCall) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	// [packed=false]
	for _, x in o.arguments {
		res << zzz_vproto_internal_pack_cmsgjsvalue(x, 3)
	}
	return res
}

pub fn cmsgjsmethodcall_unpack(buf []byte) ?CMsgJSMethodCall {
	mut res := CMsgJSMethodCall{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgjsvalue(cur_buf, tag_wiretype.wire_type)?
				res.arguments << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgjsmethodcall() CMsgJSMethodCall {
	return CMsgJSMethodCall{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgjsmethodcall(o CMsgJSMethodCall, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgjsmethodcall(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSMethodCall) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsmethodcall_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSExecuteCallback {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	browser_handle      u32
	has_browser_handle  bool
	function_handle     u64
	has_function_handle bool
	arguments           []CMsgJSValue
}

pub fn (o &CMsgJSExecuteCallback) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_function_handle {
		res << vproto.pack_uint64_field(o.function_handle, 2)
	}
	// [packed=false]
	for _, x in o.arguments {
		res << zzz_vproto_internal_pack_cmsgjsvalue(x, 3)
	}
	return res
}

pub fn cmsgjsexecutecallback_unpack(buf []byte) ?CMsgJSExecuteCallback {
	mut res := CMsgJSExecuteCallback{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_function_handle = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.function_handle = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgjsvalue(cur_buf, tag_wiretype.wire_type)?
				res.arguments << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgjsexecutecallback() CMsgJSExecuteCallback {
	return CMsgJSExecuteCallback{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgjsexecutecallback(o CMsgJSExecuteCallback, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgjsexecutecallback(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSExecuteCallback) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsexecutecallback_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSReleaseCallback {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	browser_handle      u32
	has_browser_handle  bool
	function_handle     u64
	has_function_handle bool
}

pub fn (o &CMsgJSReleaseCallback) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_function_handle {
		res << vproto.pack_uint64_field(o.function_handle, 2)
	}
	return res
}

pub fn cmsgjsreleasecallback_unpack(buf []byte) ?CMsgJSReleaseCallback {
	mut res := CMsgJSReleaseCallback{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_function_handle = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.function_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgjsreleasecallback() CMsgJSReleaseCallback {
	return CMsgJSReleaseCallback{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgjsreleasecallback(o CMsgJSReleaseCallback, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgjsreleasecallback(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSReleaseCallback) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsreleasecallback_unpack(v)?
	return i, unpacked
}

pub struct CMsgJSRaiseException {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	exception          string
	has_exception      bool
}

pub fn (o &CMsgJSRaiseException) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_exception {
		res << vproto.pack_string_field(o.exception, 2)
	}
	return res
}

pub fn cmsgjsraiseexception_unpack(buf []byte) ?CMsgJSRaiseException {
	mut res := CMsgJSRaiseException{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_exception = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.exception = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgjsraiseexception() CMsgJSRaiseException {
	return CMsgJSRaiseException{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgjsraiseexception(o CMsgJSRaiseException, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgjsraiseexception(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJSRaiseException) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjsraiseexception_unpack(v)?
	return i, unpacked
}

pub struct CMsgLoadLocalization {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	browser_handle        u32
	has_browser_handle    bool
	localization_path     string
	has_localization_path bool
	language              string
	has_language          bool
}

pub fn (o &CMsgLoadLocalization) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_localization_path {
		res << vproto.pack_string_field(o.localization_path, 2)
	}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 3)
	}
	return res
}

pub fn cmsgloadlocalization_unpack(buf []byte) ?CMsgLoadLocalization {
	mut res := CMsgLoadLocalization{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_localization_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.localization_path = v
				i = ii
			}
			3 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgloadlocalization() CMsgLoadLocalization {
	return CMsgLoadLocalization{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgloadlocalization(o CMsgLoadLocalization, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgloadlocalization(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgLoadLocalization) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgloadlocalization_unpack(v)?
	return i, unpacked
}

pub struct CMsgJumpListLink {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	display_name     string
	has_display_name bool
	url_link         string
	has_url_link     bool
	icon_path        string
	has_icon_path    bool
}

pub fn (o &CMsgJumpListLink) pack() []byte {
	mut res := []byte{}
	if o.has_display_name {
		res << vproto.pack_string_field(o.display_name, 1)
	}
	if o.has_url_link {
		res << vproto.pack_string_field(o.url_link, 2)
	}
	if o.has_icon_path {
		res << vproto.pack_string_field(o.icon_path, 3)
	}
	return res
}

pub fn cmsgjumplistlink_unpack(buf []byte) ?CMsgJumpListLink {
	mut res := CMsgJumpListLink{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_display_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.display_name = v
				i = ii
			}
			2 {
				res.has_url_link = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_link = v
				i = ii
			}
			3 {
				res.has_icon_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon_path = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgjumplistlink() CMsgJumpListLink {
	return CMsgJumpListLink{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgjumplistlink(o CMsgJumpListLink, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgjumplistlink(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgJumpListLink) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjumplistlink_unpack(v)?
	return i, unpacked
}

pub struct CMSgJumpListMRUApp {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	has_appid        bool
	display_name     string
	has_display_name bool
	url_link         string
	has_url_link     bool
	icon_path        string
	has_icon_path    bool
}

pub fn (o &CMSgJumpListMRUApp) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_display_name {
		res << vproto.pack_string_field(o.display_name, 2)
	}
	if o.has_url_link {
		res << vproto.pack_string_field(o.url_link, 3)
	}
	if o.has_icon_path {
		res << vproto.pack_string_field(o.icon_path, 4)
	}
	return res
}

pub fn cmsgjumplistmruapp_unpack(buf []byte) ?CMSgJumpListMRUApp {
	mut res := CMSgJumpListMRUApp{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_display_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.display_name = v
				i = ii
			}
			3 {
				res.has_url_link = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url_link = v
				i = ii
			}
			4 {
				res.has_icon_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon_path = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgjumplistmruapp() CMSgJumpListMRUApp {
	return CMSgJumpListMRUApp{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgjumplistmruapp(o CMSgJumpListMRUApp, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgjumplistmruapp(buf []byte, tag_wiretype vproto.WireType) ?(int, CMSgJumpListMRUApp) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgjumplistmruapp_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetJumpList {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steam_path     string
	has_steam_path bool
	mru_title      string
	has_mru_title  bool
	apps           []CMSgJumpListMRUApp
	links          []CMsgJumpListLink
}

pub fn (o &CMsgSetJumpList) pack() []byte {
	mut res := []byte{}
	if o.has_steam_path {
		res << vproto.pack_string_field(o.steam_path, 1)
	}
	if o.has_mru_title {
		res << vproto.pack_string_field(o.mru_title, 2)
	}
	// [packed=false]
	for _, x in o.apps {
		res << zzz_vproto_internal_pack_cmsgjumplistmruapp(x, 3)
	}
	// [packed=false]
	for _, x in o.links {
		res << zzz_vproto_internal_pack_cmsgjumplistlink(x, 4)
	}
	return res
}

pub fn cmsgsetjumplist_unpack(buf []byte) ?CMsgSetJumpList {
	mut res := CMsgSetJumpList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steam_path = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.steam_path = v
				i = ii
			}
			2 {
				res.has_mru_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.mru_title = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgjumplistmruapp(cur_buf, tag_wiretype.wire_type)?
				res.apps << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgjumplistlink(cur_buf, tag_wiretype.wire_type)?
				res.links << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsetjumplist() CMsgSetJumpList {
	return CMsgSetJumpList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsetjumplist(o CMsgSetJumpList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsetjumplist(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetJumpList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetjumplist_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetGameOverlayTargetPIDs {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	target_pid         []u32
}

pub fn (o &CMsgSetGameOverlayTargetPIDs) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	// [packed=false]
	for _, x in o.target_pid {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cmsgsetgameoverlaytargetpids_unpack(buf []byte) ?CMsgSetGameOverlayTargetPIDs {
	mut res := CMsgSetGameOverlayTargetPIDs{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.target_pid << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsetgameoverlaytargetpids() CMsgSetGameOverlayTargetPIDs {
	return CMsgSetGameOverlayTargetPIDs{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsetgameoverlaytargetpids(o CMsgSetGameOverlayTargetPIDs, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsetgameoverlaytargetpids(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetGameOverlayTargetPIDs) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetgameoverlaytargetpids_unpack(v)?
	return i, unpacked
}

pub struct CMsgGameOverlayTargetTextureID {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	target_pid         u32
	has_target_pid     bool
	texture_handle     u32
	has_texture_handle bool
}

pub fn (o &CMsgGameOverlayTargetTextureID) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_target_pid {
		res << vproto.pack_uint32_field(o.target_pid, 2)
	}
	if o.has_texture_handle {
		res << vproto.pack_uint32_field(o.texture_handle, 3)
	}
	return res
}

pub fn cmsggameoverlaytargettextureid_unpack(buf []byte) ?CMsgGameOverlayTargetTextureID {
	mut res := CMsgGameOverlayTargetTextureID{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_target_pid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.target_pid = v
				i = ii
			}
			3 {
				res.has_texture_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.texture_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsggameoverlaytargettextureid() CMsgGameOverlayTargetTextureID {
	return CMsgGameOverlayTargetTextureID{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsggameoverlaytargettextureid(o CMsgGameOverlayTargetTextureID, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsggameoverlaytargettextureid(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgGameOverlayTargetTextureID) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsggameoverlaytargettextureid_unpack(v)?
	return i, unpacked
}

pub struct CMsgDraggableRegionsChanged_DraggableRects {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	x              int
	has_x          bool
	y              int
	has_y          bool
	width          int
	has_width      bool
	height         int
	has_height     bool
	draggable      bool
	has_draggable  bool
}

pub fn (o &CMsgDraggableRegionsChanged_DraggableRects) pack() []byte {
	mut res := []byte{}
	if o.has_x {
		res << vproto.pack_int32_field(o.x, 1)
	}
	if o.has_y {
		res << vproto.pack_int32_field(o.y, 2)
	}
	if o.has_width {
		res << vproto.pack_int32_field(o.width, 3)
	}
	if o.has_height {
		res << vproto.pack_int32_field(o.height, 4)
	}
	if o.has_draggable {
		res << vproto.pack_bool_field(o.draggable, 5)
	}
	return res
}

pub fn cmsgdraggableregionschanged_draggablerects_unpack(buf []byte) ?CMsgDraggableRegionsChanged_DraggableRects {
	mut res := CMsgDraggableRegionsChanged_DraggableRects{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_x = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			2 {
				res.has_y = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			3 {
				res.has_width = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			4 {
				res.has_height = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			5 {
				res.has_draggable = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.draggable = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdraggableregionschanged_draggablerects() CMsgDraggableRegionsChanged_DraggableRects {
	return CMsgDraggableRegionsChanged_DraggableRects{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdraggableregionschanged_draggablerects(o CMsgDraggableRegionsChanged_DraggableRects, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdraggableregionschanged_draggablerects(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDraggableRegionsChanged_DraggableRects) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdraggableregionschanged_draggablerects_unpack(v)?
	return i, unpacked
}

pub struct CMsgDraggableRegionsChanged {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	rects              []CMsgDraggableRegionsChanged_DraggableRects
}

pub fn (o &CMsgDraggableRegionsChanged) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	// [packed=false]
	for _, x in o.rects {
		res << zzz_vproto_internal_pack_cmsgdraggableregionschanged_draggablerects(x, 2)
	}
	return res
}

pub fn cmsgdraggableregionschanged_unpack(buf []byte) ?CMsgDraggableRegionsChanged {
	mut res := CMsgDraggableRegionsChanged{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cmsgdraggableregionschanged_draggablerects(cur_buf,
					tag_wiretype.wire_type)?
				res.rects << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdraggableregionschanged() CMsgDraggableRegionsChanged {
	return CMsgDraggableRegionsChanged{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdraggableregionschanged(o CMsgDraggableRegionsChanged, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdraggableregionschanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDraggableRegionsChanged) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdraggableregionschanged_unpack(v)?
	return i, unpacked
}

pub struct CMsgResizeGripChanged {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	width              int
	has_width          bool
	height             int
	has_height         bool
}

pub fn (o &CMsgResizeGripChanged) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_width {
		res << vproto.pack_int32_field(o.width, 2)
	}
	if o.has_height {
		res << vproto.pack_int32_field(o.height, 3)
	}
	return res
}

pub fn cmsgresizegripchanged_unpack(buf []byte) ?CMsgResizeGripChanged {
	mut res := CMsgResizeGripChanged{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_width = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			3 {
				res.has_height = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgresizegripchanged() CMsgResizeGripChanged {
	return CMsgResizeGripChanged{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgresizegripchanged(o CMsgResizeGripChanged, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgresizegripchanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgResizeGripChanged) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgresizegripchanged_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetWindowPosition {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	x                  int
	has_x              bool
	y                  int
	has_y              bool
	width              int
	has_width          bool
	height             int
	has_height         bool
	min_width          int
	has_min_width      bool
	min_height         int
	has_min_height     bool
}

pub fn (o &CMsgSetWindowPosition) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_x {
		res << vproto.pack_int32_field(o.x, 2)
	}
	if o.has_y {
		res << vproto.pack_int32_field(o.y, 3)
	}
	if o.has_width {
		res << vproto.pack_int32_field(o.width, 4)
	}
	if o.has_height {
		res << vproto.pack_int32_field(o.height, 5)
	}
	if o.has_min_width {
		res << vproto.pack_int32_field(o.min_width, 6)
	}
	if o.has_min_height {
		res << vproto.pack_int32_field(o.min_height, 7)
	}
	return res
}

pub fn cmsgsetwindowposition_unpack(buf []byte) ?CMsgSetWindowPosition {
	mut res := CMsgSetWindowPosition{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_x = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				res.has_y = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			4 {
				res.has_width = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			5 {
				res.has_height = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			6 {
				res.has_min_width = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.min_width = v
				i = ii
			}
			7 {
				res.has_min_height = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.min_height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsetwindowposition() CMsgSetWindowPosition {
	return CMsgSetWindowPosition{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsetwindowposition(o CMsgSetWindowPosition, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsetwindowposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetWindowPosition) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetwindowposition_unpack(v)?
	return i, unpacked
}

pub struct CMsgShowWindow {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgShowWindow) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgshowwindow_unpack(buf []byte) ?CMsgShowWindow {
	mut res := CMsgShowWindow{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgshowwindow() CMsgShowWindow {
	return CMsgShowWindow{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgshowwindow(o CMsgShowWindow, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgshowwindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgShowWindow) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgshowwindow_unpack(v)?
	return i, unpacked
}

pub struct CMsgHideWindow {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgHideWindow) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsghidewindow_unpack(buf []byte) ?CMsgHideWindow {
	mut res := CMsgHideWindow{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsghidewindow() CMsgHideWindow {
	return CMsgHideWindow{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsghidewindow(o CMsgHideWindow, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsghidewindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgHideWindow) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsghidewindow_unpack(v)?
	return i, unpacked
}

pub struct CMsgBringWindowToFront {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgBringWindowToFront) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgbringwindowtofront_unpack(buf []byte) ?CMsgBringWindowToFront {
	mut res := CMsgBringWindowToFront{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgbringwindowtofront() CMsgBringWindowToFront {
	return CMsgBringWindowToFront{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgbringwindowtofront(o CMsgBringWindowToFront, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgbringwindowtofront(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgBringWindowToFront) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgbringwindowtofront_unpack(v)?
	return i, unpacked
}

pub struct CMsgSetForegroundWindow {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgSetForegroundWindow) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgsetforegroundwindow_unpack(buf []byte) ?CMsgSetForegroundWindow {
	mut res := CMsgSetForegroundWindow{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgsetforegroundwindow() CMsgSetForegroundWindow {
	return CMsgSetForegroundWindow{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgsetforegroundwindow(o CMsgSetForegroundWindow, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgsetforegroundwindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgSetForegroundWindow) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgsetforegroundwindow_unpack(v)?
	return i, unpacked
}

pub struct CMsgMaximizeRestoreWindow {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgMaximizeRestoreWindow) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgmaximizerestorewindow_unpack(buf []byte) ?CMsgMaximizeRestoreWindow {
	mut res := CMsgMaximizeRestoreWindow{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgmaximizerestorewindow() CMsgMaximizeRestoreWindow {
	return CMsgMaximizeRestoreWindow{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgmaximizerestorewindow(o CMsgMaximizeRestoreWindow, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgmaximizerestorewindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMaximizeRestoreWindow) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgmaximizerestorewindow_unpack(v)?
	return i, unpacked
}

pub struct CMsgMinimizeWindow {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgMinimizeWindow) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgminimizewindow_unpack(buf []byte) ?CMsgMinimizeWindow {
	mut res := CMsgMinimizeWindow{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgminimizewindow() CMsgMinimizeWindow {
	return CMsgMinimizeWindow{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgminimizewindow(o CMsgMinimizeWindow, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgminimizewindow(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgMinimizeWindow) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgminimizewindow_unpack(v)?
	return i, unpacked
}

pub struct CMsgShowBrowserContextMenu {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgShowBrowserContextMenu) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgshowbrowsercontextmenu_unpack(buf []byte) ?CMsgShowBrowserContextMenu {
	mut res := CMsgShowBrowserContextMenu{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgshowbrowsercontextmenu() CMsgShowBrowserContextMenu {
	return CMsgShowBrowserContextMenu{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgshowbrowsercontextmenu(o CMsgShowBrowserContextMenu, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgshowbrowsercontextmenu(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgShowBrowserContextMenu) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgshowbrowsercontextmenu_unpack(v)?
	return i, unpacked
}

pub struct CMsgImeSetComposition {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	text               string
	has_text           bool
}

pub fn (o &CMsgImeSetComposition) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_text {
		res << vproto.pack_string_field(o.text, 2)
	}
	return res
}

pub fn cmsgimesetcomposition_unpack(buf []byte) ?CMsgImeSetComposition {
	mut res := CMsgImeSetComposition{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgimesetcomposition() CMsgImeSetComposition {
	return CMsgImeSetComposition{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgimesetcomposition(o CMsgImeSetComposition, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgimesetcomposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgImeSetComposition) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgimesetcomposition_unpack(v)?
	return i, unpacked
}

pub struct CMsgImeCommitText {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	text               string
	has_text           bool
}

pub fn (o &CMsgImeCommitText) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_text {
		res << vproto.pack_string_field(o.text, 2)
	}
	return res
}

pub fn cmsgimecommittext_unpack(buf []byte) ?CMsgImeCommitText {
	mut res := CMsgImeCommitText{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgimecommittext() CMsgImeCommitText {
	return CMsgImeCommitText{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgimecommittext(o CMsgImeCommitText, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgimecommittext(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgImeCommitText) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgimecommittext_unpack(v)?
	return i, unpacked
}

pub struct CMsgImeCancelComposition {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
}

pub fn (o &CMsgImeCancelComposition) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	return res
}

pub fn cmsgimecancelcomposition_unpack(buf []byte) ?CMsgImeCancelComposition {
	mut res := CMsgImeCancelComposition{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgimecancelcomposition() CMsgImeCancelComposition {
	return CMsgImeCancelComposition{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgimecancelcomposition(o CMsgImeCancelComposition, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgimecancelcomposition(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgImeCancelComposition) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgimecancelcomposition_unpack(v)?
	return i, unpacked
}

pub struct CMsgImeCompositionRangeChanged {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	x                  u32
	has_x              bool
	y                  u32
	has_y              bool
}

pub fn (o &CMsgImeCompositionRangeChanged) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_x {
		res << vproto.pack_uint32_field(o.x, 2)
	}
	if o.has_y {
		res << vproto.pack_uint32_field(o.y, 3)
	}
	return res
}

pub fn cmsgimecompositionrangechanged_unpack(buf []byte) ?CMsgImeCompositionRangeChanged {
	mut res := CMsgImeCompositionRangeChanged{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_x = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				res.has_y = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgimecompositionrangechanged() CMsgImeCompositionRangeChanged {
	return CMsgImeCompositionRangeChanged{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgimecompositionrangechanged(o CMsgImeCompositionRangeChanged, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgimecompositionrangechanged(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgImeCompositionRangeChanged) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgimecompositionrangechanged_unpack(v)?
	return i, unpacked
}

pub struct CMsgInspectElement {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	x                  u32
	has_x              bool
	y                  u32
	has_y              bool
}

pub fn (o &CMsgInspectElement) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_x {
		res << vproto.pack_uint32_field(o.x, 2)
	}
	if o.has_y {
		res << vproto.pack_uint32_field(o.y, 3)
	}
	return res
}

pub fn cmsginspectelement_unpack(buf []byte) ?CMsgInspectElement {
	mut res := CMsgInspectElement{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_x = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.x = v
				i = ii
			}
			3 {
				res.has_y = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.y = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsginspectelement() CMsgInspectElement {
	return CMsgInspectElement{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsginspectelement(o CMsgInspectElement, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsginspectelement(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgInspectElement) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsginspectelement_unpack(v)?
	return i, unpacked
}

pub struct CMsgDisableF5 {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	disable            bool
	has_disable        bool
}

pub fn (o &CMsgDisableF5) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_disable {
		res << vproto.pack_bool_field(o.disable, 2)
	}
	return res
}

pub fn cmsgdisablef5_unpack(buf []byte) ?CMsgDisableF5 {
	mut res := CMsgDisableF5{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_disable = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.disable = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgdisablef5() CMsgDisableF5 {
	return CMsgDisableF5{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgdisablef5(o CMsgDisableF5, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgdisablef5(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgDisableF5) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgdisablef5_unpack(v)?
	return i, unpacked
}

pub struct CMsgStartDownload {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	browser_handle     u32
	has_browser_handle bool
	url                string
	has_url            bool
}

pub fn (o &CMsgStartDownload) pack() []byte {
	mut res := []byte{}
	if o.has_browser_handle {
		res << vproto.pack_uint32_field(o.browser_handle, 1)
	}
	if o.has_url {
		res << vproto.pack_string_field(o.url, 2)
	}
	return res
}

pub fn cmsgstartdownload_unpack(buf []byte) ?CMsgStartDownload {
	mut res := CMsgStartDownload{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_browser_handle = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.browser_handle = v
				i = ii
			}
			2 {
				res.has_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgstartdownload() CMsgStartDownload {
	return CMsgStartDownload{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgstartdownload(o CMsgStartDownload, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgstartdownload(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgStartDownload) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgstartdownload_unpack(v)?
	return i, unpacked
}
