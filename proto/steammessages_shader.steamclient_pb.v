// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CShaderRegisterShaderRequestShader {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	cache_key_sha       []byte
	has_cache_key_sha   bool
	shader_code_sha     []byte
	has_shader_code_sha bool
}

pub fn (o &CShaderRegisterShaderRequestShader) pack() []byte {
	mut res := []byte{}
	if o.has_cache_key_sha {
		res << vproto.pack_bytes_field(o.cache_key_sha, 1)
	}
	if o.has_shader_code_sha {
		res << vproto.pack_bytes_field(o.shader_code_sha, 2)
	}
	return res
}

pub fn cshaderregistershaderrequestshader_unpack(buf []byte) ?CShaderRegisterShaderRequestShader {
	mut res := CShaderRegisterShaderRequestShader{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_cache_key_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_key_sha = v
				i = ii
			}
			2 {
				res.has_shader_code_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.shader_code_sha = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cshaderregistershaderrequestshader() CShaderRegisterShaderRequestShader {
	return CShaderRegisterShaderRequestShader{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cshaderregistershaderrequestshader(o CShaderRegisterShaderRequestShader, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cshaderregistershaderrequestshader(buf []byte, tag_wiretype vproto.WireType) ?(int, CShaderRegisterShaderRequestShader) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cshaderregistershaderrequestshader_unpack(v)?
	return i, unpacked
}

pub struct CShaderRegisterShaderRequest {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	appid           u32
	has_appid       bool
	gpu_desc        string
	has_gpu_desc    bool
	driver_desc     string
	has_driver_desc bool
	shaders         []CShaderRegisterShaderRequestShader
}

pub fn (o &CShaderRegisterShaderRequest) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_gpu_desc {
		res << vproto.pack_string_field(o.gpu_desc, 2)
	}
	if o.has_driver_desc {
		res << vproto.pack_string_field(o.driver_desc, 3)
	}
	// [packed=false]
	for _, x in o.shaders {
		res << zzz_vproto_internal_pack_cshaderregistershaderrequestshader(x, 4)
	}
	return res
}

pub fn cshaderregistershaderrequest_unpack(buf []byte) ?CShaderRegisterShaderRequest {
	mut res := CShaderRegisterShaderRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_gpu_desc = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.gpu_desc = v
				i = ii
			}
			3 {
				res.has_driver_desc = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.driver_desc = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cshaderregistershaderrequestshader(cur_buf,
					tag_wiretype.wire_type)?
				res.shaders << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cshaderregistershaderrequest() CShaderRegisterShaderRequest {
	return CShaderRegisterShaderRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cshaderregistershaderrequest(o CShaderRegisterShaderRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cshaderregistershaderrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CShaderRegisterShaderRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cshaderregistershaderrequest_unpack(v)?
	return i, unpacked
}

pub struct CShaderRegisterShaderResponse {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	requested_codeids []u32
}

pub fn (o &CShaderRegisterShaderResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.requested_codeids {
		res << vproto.pack_uint32_field(x, 1)
	}
	return res
}

pub fn cshaderregistershaderresponse_unpack(buf []byte) ?CShaderRegisterShaderResponse {
	mut res := CShaderRegisterShaderResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.requested_codeids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cshaderregistershaderresponse() CShaderRegisterShaderResponse {
	return CShaderRegisterShaderResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cshaderregistershaderresponse(o CShaderRegisterShaderResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cshaderregistershaderresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CShaderRegisterShaderResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cshaderregistershaderresponse_unpack(v)?
	return i, unpacked
}

pub struct CShaderSendShaderRequestShaderCode {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	shader_code_sha     []byte
	has_shader_code_sha bool
	shader_code         []byte
	has_shader_code     bool
}

pub fn (o &CShaderSendShaderRequestShaderCode) pack() []byte {
	mut res := []byte{}
	if o.has_shader_code_sha {
		res << vproto.pack_bytes_field(o.shader_code_sha, 1)
	}
	if o.has_shader_code {
		res << vproto.pack_bytes_field(o.shader_code, 2)
	}
	return res
}

pub fn cshadersendshaderrequestshadercode_unpack(buf []byte) ?CShaderSendShaderRequestShaderCode {
	mut res := CShaderSendShaderRequestShaderCode{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_shader_code_sha = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.shader_code_sha = v
				i = ii
			}
			2 {
				res.has_shader_code = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.shader_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cshadersendshaderrequestshadercode() CShaderSendShaderRequestShaderCode {
	return CShaderSendShaderRequestShaderCode{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cshadersendshaderrequestshadercode(o CShaderSendShaderRequestShaderCode, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cshadersendshaderrequestshadercode(buf []byte, tag_wiretype vproto.WireType) ?(int, CShaderSendShaderRequestShaderCode) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cshadersendshaderrequestshadercode_unpack(v)?
	return i, unpacked
}

pub struct CShaderSendShaderRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	shaders        []CShaderSendShaderRequestShaderCode
}

pub fn (o &CShaderSendShaderRequest) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.shaders {
		res << zzz_vproto_internal_pack_cshadersendshaderrequestshadercode(x, 2)
	}
	return res
}

pub fn cshadersendshaderrequest_unpack(buf []byte) ?CShaderSendShaderRequest {
	mut res := CShaderSendShaderRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cshadersendshaderrequestshadercode(cur_buf,
					tag_wiretype.wire_type)?
				res.shaders << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cshadersendshaderrequest() CShaderSendShaderRequest {
	return CShaderSendShaderRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cshadersendshaderrequest(o CShaderSendShaderRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cshadersendshaderrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CShaderSendShaderRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cshadersendshaderrequest_unpack(v)?
	return i, unpacked
}

pub struct CShaderSendShaderResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CShaderSendShaderResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn cshadersendshaderresponse_unpack(buf []byte) ?CShaderSendShaderResponse {
	res := CShaderSendShaderResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cshadersendshaderresponse() CShaderSendShaderResponse {
	return CShaderSendShaderResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cshadersendshaderresponse(o CShaderSendShaderResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cshadersendshaderresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CShaderSendShaderResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cshadersendshaderresponse_unpack(v)?
	return i, unpacked
}

pub struct CShaderGetBucketManifestRequest {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	appid           u32
	has_appid       bool
	gpu_desc        string
	has_gpu_desc    bool
	driver_desc     string
	has_driver_desc bool
}

pub fn (o &CShaderGetBucketManifestRequest) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_gpu_desc {
		res << vproto.pack_string_field(o.gpu_desc, 2)
	}
	if o.has_driver_desc {
		res << vproto.pack_string_field(o.driver_desc, 3)
	}
	return res
}

pub fn cshadergetbucketmanifestrequest_unpack(buf []byte) ?CShaderGetBucketManifestRequest {
	mut res := CShaderGetBucketManifestRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_gpu_desc = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.gpu_desc = v
				i = ii
			}
			3 {
				res.has_driver_desc = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.driver_desc = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cshadergetbucketmanifestrequest() CShaderGetBucketManifestRequest {
	return CShaderGetBucketManifestRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cshadergetbucketmanifestrequest(o CShaderGetBucketManifestRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cshadergetbucketmanifestrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CShaderGetBucketManifestRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cshadergetbucketmanifestrequest_unpack(v)?
	return i, unpacked
}

pub struct CShaderGetBucketManifestResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	manifestid     u64
	has_manifestid bool
	depotsize      u32
	has_depotsize  bool
	bucketid       u64
	has_bucketid   bool
}

pub fn (o &CShaderGetBucketManifestResponse) pack() []byte {
	mut res := []byte{}
	if o.has_manifestid {
		res << vproto.pack_uint64_field(o.manifestid, 1)
	}
	if o.has_depotsize {
		res << vproto.pack_uint32_field(o.depotsize, 2)
	}
	if o.has_bucketid {
		res << vproto.pack_uint64_field(o.bucketid, 3)
	}
	return res
}

pub fn cshadergetbucketmanifestresponse_unpack(buf []byte) ?CShaderGetBucketManifestResponse {
	mut res := CShaderGetBucketManifestResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_manifestid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.manifestid = v
				i = ii
			}
			2 {
				res.has_depotsize = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.depotsize = v
				i = ii
			}
			3 {
				res.has_bucketid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.bucketid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cshadergetbucketmanifestresponse() CShaderGetBucketManifestResponse {
	return CShaderGetBucketManifestResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cshadergetbucketmanifestresponse(o CShaderGetBucketManifestResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cshadergetbucketmanifestresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CShaderGetBucketManifestResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cshadergetbucketmanifestresponse_unpack(v)?
	return i, unpacked
}
