// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CMsgClientHeartBeat {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientHeartBeat) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientheartbeat_unpack(buf []byte) ?CMsgClientHeartBeat {
	res := CMsgClientHeartBeat{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientheartbeat() CMsgClientHeartBeat {
	return CMsgClientHeartBeat{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientheartbeat(o CMsgClientHeartBeat, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientheartbeat(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientHeartBeat) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientheartbeat_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientServerTimestampRequest {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	client_request_timestamp     u64
	has_client_request_timestamp bool
}

pub fn (o &CMsgClientServerTimestampRequest) pack() []byte {
	mut res := []byte{}
	if o.has_client_request_timestamp {
		res << vproto.pack_uint64_field(o.client_request_timestamp, 1)
	}
	return res
}

pub fn cmsgclientservertimestamprequest_unpack(buf []byte) ?CMsgClientServerTimestampRequest {
	mut res := CMsgClientServerTimestampRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_client_request_timestamp = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.client_request_timestamp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientservertimestamprequest() CMsgClientServerTimestampRequest {
	return CMsgClientServerTimestampRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientservertimestamprequest(o CMsgClientServerTimestampRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientservertimestamprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServerTimestampRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientservertimestamprequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientServerTimestampResponse {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	client_request_timestamp     u64
	has_client_request_timestamp bool
	server_timestamp_ms          u64
	has_server_timestamp_ms      bool
}

pub fn (o &CMsgClientServerTimestampResponse) pack() []byte {
	mut res := []byte{}
	if o.has_client_request_timestamp {
		res << vproto.pack_uint64_field(o.client_request_timestamp, 1)
	}
	if o.has_server_timestamp_ms {
		res << vproto.pack_uint64_field(o.server_timestamp_ms, 2)
	}
	return res
}

pub fn cmsgclientservertimestampresponse_unpack(buf []byte) ?CMsgClientServerTimestampResponse {
	mut res := CMsgClientServerTimestampResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_client_request_timestamp = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.client_request_timestamp = v
				i = ii
			}
			2 {
				res.has_server_timestamp_ms = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.server_timestamp_ms = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientservertimestampresponse() CMsgClientServerTimestampResponse {
	return CMsgClientServerTimestampResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientservertimestampresponse(o CMsgClientServerTimestampResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientservertimestampresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientServerTimestampResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientservertimestampresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientSecret {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	version        u32
	has_version    bool
	appid          u32
	has_appid      bool
	deviceid       u32
	has_deviceid   bool
	nonce          u64
	has_nonce      bool
	hmac           []byte
	has_hmac       bool
}

pub fn (o &CMsgClientSecret) pack() []byte {
	mut res := []byte{}
	if o.has_version {
		res << vproto.pack_uint32_field(o.version, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_deviceid {
		res << vproto.pack_uint32_field(o.deviceid, 3)
	}
	if o.has_nonce {
		res << vproto.pack_64bit_field(o.nonce, 4)
	}
	if o.has_hmac {
		res << vproto.pack_bytes_field(o.hmac, 5)
	}
	return res
}

pub fn cmsgclientsecret_unpack(buf []byte) ?CMsgClientSecret {
	mut res := CMsgClientSecret{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.version = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_deviceid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deviceid = v
				i = ii
			}
			4 {
				res.has_nonce = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.nonce = v
				i = ii
			}
			5 {
				res.has_hmac = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.hmac = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientsecret() CMsgClientSecret {
	return CMsgClientSecret{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientsecret(o CMsgClientSecret, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientsecret(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientSecret) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientsecret_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLogon {
mut:
	unknown_fields                              []vproto.UnknownField
pub mut:
	protocol_version                            u32
	has_protocol_version                        bool
	deprecated_obfustucated_private_ip          u32
	has_deprecated_obfustucated_private_ip      bool
	cell_id                                     u32
	has_cell_id                                 bool
	last_session_id                             u32
	has_last_session_id                         bool
	client_package_version                      u32
	has_client_package_version                  bool
	client_language                             string
	has_client_language                         bool
	client_os_type                              u32
	has_client_os_type                          bool
	should_remember_password                    bool
	has_should_remember_password                bool
	wine_version                                string
	has_wine_version                            bool
	deprecated_10                               u32
	has_deprecated_10                           bool
	obfuscated_private_ip                       CMsgIPAddress
	has_obfuscated_private_ip                   bool
	deprecated_public_ip                        u32
	has_deprecated_public_ip                    bool
	qos_level                                   u32
	has_qos_level                               bool
	client_supplied_steam_id                    u64
	has_client_supplied_steam_id                bool
	public_ip                                   CMsgIPAddress
	has_public_ip                               bool
	machine_id                                  []byte
	has_machine_id                              bool
	launcher_type                               u32
	has_launcher_type                           bool
	ui_mode                                     u32
	has_ui_mode                                 bool
	chat_mode                                   u32
	has_chat_mode                               bool
	steam2_auth_ticket                          []byte
	has_steam2_auth_ticket                      bool
	email_address                               string
	has_email_address                           bool
	rtime32_account_creation                    u32
	has_rtime32_account_creation                bool
	account_name                                string
	has_account_name                            bool
	password                                    string
	has_password                                bool
	game_server_token                           string
	has_game_server_token                       bool
	login_key                                   string
	has_login_key                               bool
	was_converted_deprecated_msg                bool
	has_was_converted_deprecated_msg            bool
	anon_user_target_account_name               string
	has_anon_user_target_account_name           bool
	resolved_user_steam_id                      u64
	has_resolved_user_steam_id                  bool
	eresult_sentryfile                          int
	has_eresult_sentryfile                      bool
	sha_sentryfile                              []byte
	has_sha_sentryfile                          bool
	auth_code                                   string
	has_auth_code                               bool
	otp_type                                    int
	has_otp_type                                bool
	otp_value                                   u32
	has_otp_value                               bool
	otp_identifier                              string
	has_otp_identifier                          bool
	steam2_ticket_request                       bool
	has_steam2_ticket_request                   bool
	sony_psn_ticket                             []byte
	has_sony_psn_ticket                         bool
	sony_psn_service_id                         string
	has_sony_psn_service_id                     bool
	create_new_psn_linked_account_if_needed     bool
	has_create_new_psn_linked_account_if_needed bool
	sony_psn_name                               string
	has_sony_psn_name                           bool
	game_server_app_id                          int
	has_game_server_app_id                      bool
	steamguard_dont_remember_computer           bool
	has_steamguard_dont_remember_computer       bool
	machine_name                                string
	has_machine_name                            bool
	machine_name_userchosen                     string
	has_machine_name_userchosen                 bool
	country_override                            string
	has_country_override                        bool
	is_steam_box                                bool
	has_is_steam_box                            bool
	client_instance_id                          u64
	has_client_instance_id                      bool
	two_factor_code                             string
	has_two_factor_code                         bool
	supports_rate_limit_response                bool
	has_supports_rate_limit_response            bool
	web_logon_nonce                             string
	has_web_logon_nonce                         bool
	priority_reason                             int
	has_priority_reason                         bool
	embedded_client_secret                      CMsgClientSecret
	has_embedded_client_secret                  bool
	disable_partner_autogrants                  bool
	has_disable_partner_autogrants              bool
}

pub fn (o &CMsgClientLogon) pack() []byte {
	mut res := []byte{}
	if o.has_protocol_version {
		res << vproto.pack_uint32_field(o.protocol_version, 1)
	}
	if o.has_deprecated_obfustucated_private_ip {
		res << vproto.pack_uint32_field(o.deprecated_obfustucated_private_ip, 2)
	}
	if o.has_cell_id {
		res << vproto.pack_uint32_field(o.cell_id, 3)
	}
	if o.has_last_session_id {
		res << vproto.pack_uint32_field(o.last_session_id, 4)
	}
	if o.has_client_package_version {
		res << vproto.pack_uint32_field(o.client_package_version, 5)
	}
	if o.has_client_language {
		res << vproto.pack_string_field(o.client_language, 6)
	}
	if o.has_client_os_type {
		res << vproto.pack_uint32_field(o.client_os_type, 7)
	}
	if o.has_should_remember_password {
		res << vproto.pack_bool_field(o.should_remember_password, 8)
	}
	if o.has_wine_version {
		res << vproto.pack_string_field(o.wine_version, 9)
	}
	if o.has_deprecated_10 {
		res << vproto.pack_uint32_field(o.deprecated_10, 10)
	}
	if o.has_obfuscated_private_ip {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.obfuscated_private_ip, 11)
	}
	if o.has_deprecated_public_ip {
		res << vproto.pack_uint32_field(o.deprecated_public_ip, 20)
	}
	if o.has_qos_level {
		res << vproto.pack_uint32_field(o.qos_level, 21)
	}
	if o.has_client_supplied_steam_id {
		res << vproto.pack_64bit_field(o.client_supplied_steam_id, 22)
	}
	if o.has_public_ip {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 23)
	}
	if o.has_machine_id {
		res << vproto.pack_bytes_field(o.machine_id, 30)
	}
	if o.has_launcher_type {
		res << vproto.pack_uint32_field(o.launcher_type, 31)
	}
	if o.has_ui_mode {
		res << vproto.pack_uint32_field(o.ui_mode, 32)
	}
	if o.has_chat_mode {
		res << vproto.pack_uint32_field(o.chat_mode, 33)
	}
	if o.has_steam2_auth_ticket {
		res << vproto.pack_bytes_field(o.steam2_auth_ticket, 41)
	}
	if o.has_email_address {
		res << vproto.pack_string_field(o.email_address, 42)
	}
	if o.has_rtime32_account_creation {
		res << vproto.pack_32bit_field(o.rtime32_account_creation, 43)
	}
	if o.has_account_name {
		res << vproto.pack_string_field(o.account_name, 50)
	}
	if o.has_password {
		res << vproto.pack_string_field(o.password, 51)
	}
	if o.has_game_server_token {
		res << vproto.pack_string_field(o.game_server_token, 52)
	}
	if o.has_login_key {
		res << vproto.pack_string_field(o.login_key, 60)
	}
	if o.has_was_converted_deprecated_msg {
		res << vproto.pack_bool_field(o.was_converted_deprecated_msg, 70)
	}
	if o.has_anon_user_target_account_name {
		res << vproto.pack_string_field(o.anon_user_target_account_name, 80)
	}
	if o.has_resolved_user_steam_id {
		res << vproto.pack_64bit_field(o.resolved_user_steam_id, 81)
	}
	if o.has_eresult_sentryfile {
		res << vproto.pack_int32_field(o.eresult_sentryfile, 82)
	}
	if o.has_sha_sentryfile {
		res << vproto.pack_bytes_field(o.sha_sentryfile, 83)
	}
	if o.has_auth_code {
		res << vproto.pack_string_field(o.auth_code, 84)
	}
	if o.has_otp_type {
		res << vproto.pack_int32_field(o.otp_type, 85)
	}
	if o.has_otp_value {
		res << vproto.pack_uint32_field(o.otp_value, 86)
	}
	if o.has_otp_identifier {
		res << vproto.pack_string_field(o.otp_identifier, 87)
	}
	if o.has_steam2_ticket_request {
		res << vproto.pack_bool_field(o.steam2_ticket_request, 88)
	}
	if o.has_sony_psn_ticket {
		res << vproto.pack_bytes_field(o.sony_psn_ticket, 90)
	}
	if o.has_sony_psn_service_id {
		res << vproto.pack_string_field(o.sony_psn_service_id, 91)
	}
	if o.has_create_new_psn_linked_account_if_needed {
		res << vproto.pack_bool_field(o.create_new_psn_linked_account_if_needed, 92)
	}
	if o.has_sony_psn_name {
		res << vproto.pack_string_field(o.sony_psn_name, 93)
	}
	if o.has_game_server_app_id {
		res << vproto.pack_int32_field(o.game_server_app_id, 94)
	}
	if o.has_steamguard_dont_remember_computer {
		res << vproto.pack_bool_field(o.steamguard_dont_remember_computer, 95)
	}
	if o.has_machine_name {
		res << vproto.pack_string_field(o.machine_name, 96)
	}
	if o.has_machine_name_userchosen {
		res << vproto.pack_string_field(o.machine_name_userchosen, 97)
	}
	if o.has_country_override {
		res << vproto.pack_string_field(o.country_override, 98)
	}
	if o.has_is_steam_box {
		res << vproto.pack_bool_field(o.is_steam_box, 99)
	}
	if o.has_client_instance_id {
		res << vproto.pack_uint64_field(o.client_instance_id, 100)
	}
	if o.has_two_factor_code {
		res << vproto.pack_string_field(o.two_factor_code, 101)
	}
	if o.has_supports_rate_limit_response {
		res << vproto.pack_bool_field(o.supports_rate_limit_response, 102)
	}
	if o.has_web_logon_nonce {
		res << vproto.pack_string_field(o.web_logon_nonce, 103)
	}
	if o.has_priority_reason {
		res << vproto.pack_int32_field(o.priority_reason, 104)
	}
	if o.has_embedded_client_secret {
		res << zzz_vproto_internal_pack_cmsgclientsecret(o.embedded_client_secret, 105)
	}
	if o.has_disable_partner_autogrants {
		res << vproto.pack_bool_field(o.disable_partner_autogrants, 106)
	}
	return res
}

pub fn cmsgclientlogon_unpack(buf []byte) ?CMsgClientLogon {
	mut res := CMsgClientLogon{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_protocol_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.protocol_version = v
				i = ii
			}
			2 {
				res.has_deprecated_obfustucated_private_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_obfustucated_private_ip = v
				i = ii
			}
			3 {
				res.has_cell_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			4 {
				res.has_last_session_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_session_id = v
				i = ii
			}
			5 {
				res.has_client_package_version = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_package_version = v
				i = ii
			}
			6 {
				res.has_client_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.client_language = v
				i = ii
			}
			7 {
				res.has_client_os_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.client_os_type = v
				i = ii
			}
			8 {
				res.has_should_remember_password = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.should_remember_password = v
				i = ii
			}
			9 {
				res.has_wine_version = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.wine_version = v
				i = ii
			}
			10 {
				res.has_deprecated_10 = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_10 = v
				i = ii
			}
			11 {
				res.has_obfuscated_private_ip = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.obfuscated_private_ip = v
				i = ii
			}
			20 {
				res.has_deprecated_public_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_public_ip = v
				i = ii
			}
			21 {
				res.has_qos_level = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.qos_level = v
				i = ii
			}
			22 {
				res.has_client_supplied_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_supplied_steam_id = v
				i = ii
			}
			23 {
				res.has_public_ip = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.public_ip = v
				i = ii
			}
			30 {
				res.has_machine_id = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.machine_id = v
				i = ii
			}
			31 {
				res.has_launcher_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.launcher_type = v
				i = ii
			}
			32 {
				res.has_ui_mode = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ui_mode = v
				i = ii
			}
			33 {
				res.has_chat_mode = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.chat_mode = v
				i = ii
			}
			41 {
				res.has_steam2_auth_ticket = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.steam2_auth_ticket = v
				i = ii
			}
			42 {
				res.has_email_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.email_address = v
				i = ii
			}
			43 {
				res.has_rtime32_account_creation = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_account_creation = v
				i = ii
			}
			50 {
				res.has_account_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.account_name = v
				i = ii
			}
			51 {
				res.has_password = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.password = v
				i = ii
			}
			52 {
				res.has_game_server_token = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.game_server_token = v
				i = ii
			}
			60 {
				res.has_login_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.login_key = v
				i = ii
			}
			70 {
				res.has_was_converted_deprecated_msg = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.was_converted_deprecated_msg = v
				i = ii
			}
			80 {
				res.has_anon_user_target_account_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.anon_user_target_account_name = v
				i = ii
			}
			81 {
				res.has_resolved_user_steam_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.resolved_user_steam_id = v
				i = ii
			}
			82 {
				res.has_eresult_sentryfile = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult_sentryfile = v
				i = ii
			}
			83 {
				res.has_sha_sentryfile = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sha_sentryfile = v
				i = ii
			}
			84 {
				res.has_auth_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.auth_code = v
				i = ii
			}
			85 {
				res.has_otp_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_type = v
				i = ii
			}
			86 {
				res.has_otp_value = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_value = v
				i = ii
			}
			87 {
				res.has_otp_identifier = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.otp_identifier = v
				i = ii
			}
			88 {
				res.has_steam2_ticket_request = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.steam2_ticket_request = v
				i = ii
			}
			90 {
				res.has_sony_psn_ticket = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sony_psn_ticket = v
				i = ii
			}
			91 {
				res.has_sony_psn_service_id = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sony_psn_service_id = v
				i = ii
			}
			92 {
				res.has_create_new_psn_linked_account_if_needed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.create_new_psn_linked_account_if_needed = v
				i = ii
			}
			93 {
				res.has_sony_psn_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sony_psn_name = v
				i = ii
			}
			94 {
				res.has_game_server_app_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_server_app_id = v
				i = ii
			}
			95 {
				res.has_steamguard_dont_remember_computer = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.steamguard_dont_remember_computer = v
				i = ii
			}
			96 {
				res.has_machine_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.machine_name = v
				i = ii
			}
			97 {
				res.has_machine_name_userchosen = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.machine_name_userchosen = v
				i = ii
			}
			98 {
				res.has_country_override = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.country_override = v
				i = ii
			}
			99 {
				res.has_is_steam_box = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_steam_box = v
				i = ii
			}
			100 {
				res.has_client_instance_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.client_instance_id = v
				i = ii
			}
			101 {
				res.has_two_factor_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.two_factor_code = v
				i = ii
			}
			102 {
				res.has_supports_rate_limit_response = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.supports_rate_limit_response = v
				i = ii
			}
			103 {
				res.has_web_logon_nonce = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.web_logon_nonce = v
				i = ii
			}
			104 {
				res.has_priority_reason = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.priority_reason = v
				i = ii
			}
			105 {
				res.has_embedded_client_secret = true
				ii, v := zzz_vproto_internal_unpack_cmsgclientsecret(cur_buf, tag_wiretype.wire_type)?
				res.embedded_client_secret = v
				i = ii
			}
			106 {
				res.has_disable_partner_autogrants = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.disable_partner_autogrants = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlogon() CMsgClientLogon {
	return CMsgClientLogon{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlogon(o CMsgClientLogon, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlogon(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLogon) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlogon_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLogonResponse {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	eresult                            int
	has_eresult                        bool
	out_of_game_heartbeat_seconds      int
	has_out_of_game_heartbeat_seconds  bool
	in_game_heartbeat_seconds          int
	has_in_game_heartbeat_seconds      bool
	deprecated_public_ip               u32
	has_deprecated_public_ip           bool
	rtime32_server_time                u32
	has_rtime32_server_time            bool
	account_flags                      u32
	has_account_flags                  bool
	cell_id                            u32
	has_cell_id                        bool
	email_domain                       string
	has_email_domain                   bool
	steam2_ticket                      []byte
	has_steam2_ticket                  bool
	eresult_extended                   int
	has_eresult_extended               bool
	webapi_authenticate_user_nonce     string
	has_webapi_authenticate_user_nonce bool
	cell_id_ping_threshold             u32
	has_cell_id_ping_threshold         bool
	deprecated_use_pics                bool
	has_deprecated_use_pics            bool
	vanity_url                         string
	has_vanity_url                     bool
	public_ip                          CMsgIPAddress
	has_public_ip                      bool
	client_supplied_steamid            u64
	has_client_supplied_steamid        bool
	ip_country_code                    string
	has_ip_country_code                bool
	parental_settings                  []byte
	has_parental_settings              bool
	parental_setting_signature         []byte
	has_parental_setting_signature     bool
	count_loginfailures_to_migrate     int
	has_count_loginfailures_to_migrate bool
	count_disconnects_to_migrate       int
	has_count_disconnects_to_migrate   bool
	ogs_data_report_time_window        int
	has_ogs_data_report_time_window    bool
	client_instance_id                 u64
	has_client_instance_id             bool
	force_client_update_check          bool
	has_force_client_update_check      bool
}

pub fn (o &CMsgClientLogonResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_out_of_game_heartbeat_seconds {
		res << vproto.pack_int32_field(o.out_of_game_heartbeat_seconds, 2)
	}
	if o.has_in_game_heartbeat_seconds {
		res << vproto.pack_int32_field(o.in_game_heartbeat_seconds, 3)
	}
	if o.has_deprecated_public_ip {
		res << vproto.pack_uint32_field(o.deprecated_public_ip, 4)
	}
	if o.has_rtime32_server_time {
		res << vproto.pack_32bit_field(o.rtime32_server_time, 5)
	}
	if o.has_account_flags {
		res << vproto.pack_uint32_field(o.account_flags, 6)
	}
	if o.has_cell_id {
		res << vproto.pack_uint32_field(o.cell_id, 7)
	}
	if o.has_email_domain {
		res << vproto.pack_string_field(o.email_domain, 8)
	}
	if o.has_steam2_ticket {
		res << vproto.pack_bytes_field(o.steam2_ticket, 9)
	}
	if o.has_eresult_extended {
		res << vproto.pack_int32_field(o.eresult_extended, 10)
	}
	if o.has_webapi_authenticate_user_nonce {
		res << vproto.pack_string_field(o.webapi_authenticate_user_nonce, 11)
	}
	if o.has_cell_id_ping_threshold {
		res << vproto.pack_uint32_field(o.cell_id_ping_threshold, 12)
	}
	if o.has_deprecated_use_pics {
		res << vproto.pack_bool_field(o.deprecated_use_pics, 13)
	}
	if o.has_vanity_url {
		res << vproto.pack_string_field(o.vanity_url, 14)
	}
	if o.has_public_ip {
		res << zzz_vproto_internal_pack_cmsgipaddress(o.public_ip, 15)
	}
	if o.has_client_supplied_steamid {
		res << vproto.pack_64bit_field(o.client_supplied_steamid, 20)
	}
	if o.has_ip_country_code {
		res << vproto.pack_string_field(o.ip_country_code, 21)
	}
	if o.has_parental_settings {
		res << vproto.pack_bytes_field(o.parental_settings, 22)
	}
	if o.has_parental_setting_signature {
		res << vproto.pack_bytes_field(o.parental_setting_signature, 23)
	}
	if o.has_count_loginfailures_to_migrate {
		res << vproto.pack_int32_field(o.count_loginfailures_to_migrate, 24)
	}
	if o.has_count_disconnects_to_migrate {
		res << vproto.pack_int32_field(o.count_disconnects_to_migrate, 25)
	}
	if o.has_ogs_data_report_time_window {
		res << vproto.pack_int32_field(o.ogs_data_report_time_window, 26)
	}
	if o.has_client_instance_id {
		res << vproto.pack_uint64_field(o.client_instance_id, 27)
	}
	if o.has_force_client_update_check {
		res << vproto.pack_bool_field(o.force_client_update_check, 28)
	}
	return res
}

pub fn cmsgclientlogonresponse_unpack(buf []byte) ?CMsgClientLogonResponse {
	mut res := CMsgClientLogonResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			2 {
				res.has_out_of_game_heartbeat_seconds = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.out_of_game_heartbeat_seconds = v
				i = ii
			}
			3 {
				res.has_in_game_heartbeat_seconds = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.in_game_heartbeat_seconds = v
				i = ii
			}
			4 {
				res.has_deprecated_public_ip = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_public_ip = v
				i = ii
			}
			5 {
				res.has_rtime32_server_time = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_server_time = v
				i = ii
			}
			6 {
				res.has_account_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.account_flags = v
				i = ii
			}
			7 {
				res.has_cell_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id = v
				i = ii
			}
			8 {
				res.has_email_domain = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.email_domain = v
				i = ii
			}
			9 {
				res.has_steam2_ticket = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.steam2_ticket = v
				i = ii
			}
			10 {
				res.has_eresult_extended = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult_extended = v
				i = ii
			}
			11 {
				res.has_webapi_authenticate_user_nonce = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.webapi_authenticate_user_nonce = v
				i = ii
			}
			12 {
				res.has_cell_id_ping_threshold = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cell_id_ping_threshold = v
				i = ii
			}
			13 {
				res.has_deprecated_use_pics = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.deprecated_use_pics = v
				i = ii
			}
			14 {
				res.has_vanity_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.vanity_url = v
				i = ii
			}
			15 {
				res.has_public_ip = true
				ii, v := zzz_vproto_internal_unpack_cmsgipaddress(cur_buf, tag_wiretype.wire_type)?
				res.public_ip = v
				i = ii
			}
			20 {
				res.has_client_supplied_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_supplied_steamid = v
				i = ii
			}
			21 {
				res.has_ip_country_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.ip_country_code = v
				i = ii
			}
			22 {
				res.has_parental_settings = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.parental_settings = v
				i = ii
			}
			23 {
				res.has_parental_setting_signature = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.parental_setting_signature = v
				i = ii
			}
			24 {
				res.has_count_loginfailures_to_migrate = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.count_loginfailures_to_migrate = v
				i = ii
			}
			25 {
				res.has_count_disconnects_to_migrate = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.count_disconnects_to_migrate = v
				i = ii
			}
			26 {
				res.has_ogs_data_report_time_window = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.ogs_data_report_time_window = v
				i = ii
			}
			27 {
				res.has_client_instance_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.client_instance_id = v
				i = ii
			}
			28 {
				res.has_force_client_update_check = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.force_client_update_check = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlogonresponse() CMsgClientLogonResponse {
	return CMsgClientLogonResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlogonresponse(o CMsgClientLogonResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlogonresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLogonResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlogonresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestWebAPIAuthenticateUserNonce {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	token_type     int
	has_token_type bool
}

pub fn (o &CMsgClientRequestWebAPIAuthenticateUserNonce) pack() []byte {
	mut res := []byte{}
	if o.has_token_type {
		res << vproto.pack_int32_field(o.token_type, 1)
	}
	return res
}

pub fn cmsgclientrequestwebapiauthenticateusernonce_unpack(buf []byte) ?CMsgClientRequestWebAPIAuthenticateUserNonce {
	mut res := CMsgClientRequestWebAPIAuthenticateUserNonce{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_token_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.token_type = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestwebapiauthenticateusernonce() CMsgClientRequestWebAPIAuthenticateUserNonce {
	return CMsgClientRequestWebAPIAuthenticateUserNonce{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestwebapiauthenticateusernonce(o CMsgClientRequestWebAPIAuthenticateUserNonce, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestwebapiauthenticateusernonce(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestWebAPIAuthenticateUserNonce) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestwebapiauthenticateusernonce_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
mut:
	unknown_fields                     []vproto.UnknownField
pub mut:
	eresult                            int
	has_eresult                        bool
	webapi_authenticate_user_nonce     string
	has_webapi_authenticate_user_nonce bool
	token_type                         int
	has_token_type                     bool
}

pub fn (o &CMsgClientRequestWebAPIAuthenticateUserNonceResponse) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	if o.has_webapi_authenticate_user_nonce {
		res << vproto.pack_string_field(o.webapi_authenticate_user_nonce, 11)
	}
	if o.has_token_type {
		res << vproto.pack_int32_field(o.token_type, 3)
	}
	return res
}

pub fn cmsgclientrequestwebapiauthenticateusernonceresponse_unpack(buf []byte) ?CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
	mut res := CMsgClientRequestWebAPIAuthenticateUserNonceResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			11 {
				res.has_webapi_authenticate_user_nonce = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.webapi_authenticate_user_nonce = v
				i = ii
			}
			3 {
				res.has_token_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.token_type = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientrequestwebapiauthenticateusernonceresponse() CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
	return CMsgClientRequestWebAPIAuthenticateUserNonceResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientrequestwebapiauthenticateusernonceresponse(o CMsgClientRequestWebAPIAuthenticateUserNonceResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientrequestwebapiauthenticateusernonceresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientRequestWebAPIAuthenticateUserNonceResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientrequestwebapiauthenticateusernonceresponse_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLogOff {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CMsgClientLogOff) pack() []byte {
	res := []byte{}
	return res
}

pub fn cmsgclientlogoff_unpack(buf []byte) ?CMsgClientLogOff {
	res := CMsgClientLogOff{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientlogoff() CMsgClientLogOff {
	return CMsgClientLogOff{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientlogoff(o CMsgClientLogOff, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientlogoff(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLogOff) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientlogoff_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientLoggedOff {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	eresult        int
	has_eresult    bool
}

pub fn (o &CMsgClientLoggedOff) pack() []byte {
	mut res := []byte{}
	if o.has_eresult {
		res << vproto.pack_int32_field(o.eresult, 1)
	}
	return res
}

pub fn cmsgclientloggedoff_unpack(buf []byte) ?CMsgClientLoggedOff {
	mut res := CMsgClientLoggedOff{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_eresult = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientloggedoff() CMsgClientLoggedOff {
	return CMsgClientLoggedOff{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientloggedoff(o CMsgClientLoggedOff, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientloggedoff(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientLoggedOff) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientloggedoff_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientNewLoginKey {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	unique_id      u32
	has_unique_id  bool
	login_key      string
	has_login_key  bool
}

pub fn (o &CMsgClientNewLoginKey) pack() []byte {
	mut res := []byte{}
	if o.has_unique_id {
		res << vproto.pack_uint32_field(o.unique_id, 1)
	}
	if o.has_login_key {
		res << vproto.pack_string_field(o.login_key, 2)
	}
	return res
}

pub fn cmsgclientnewloginkey_unpack(buf []byte) ?CMsgClientNewLoginKey {
	mut res := CMsgClientNewLoginKey{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_unique_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.unique_id = v
				i = ii
			}
			2 {
				res.has_login_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.login_key = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientnewloginkey() CMsgClientNewLoginKey {
	return CMsgClientNewLoginKey{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientnewloginkey(o CMsgClientNewLoginKey, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientnewloginkey(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNewLoginKey) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientnewloginkey_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientNewLoginKeyAccepted {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	unique_id      u32
	has_unique_id  bool
}

pub fn (o &CMsgClientNewLoginKeyAccepted) pack() []byte {
	mut res := []byte{}
	if o.has_unique_id {
		res << vproto.pack_uint32_field(o.unique_id, 1)
	}
	return res
}

pub fn cmsgclientnewloginkeyaccepted_unpack(buf []byte) ?CMsgClientNewLoginKeyAccepted {
	mut res := CMsgClientNewLoginKeyAccepted{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_unique_id = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.unique_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientnewloginkeyaccepted() CMsgClientNewLoginKeyAccepted {
	return CMsgClientNewLoginKeyAccepted{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientnewloginkeyaccepted(o CMsgClientNewLoginKeyAccepted, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientnewloginkeyaccepted(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientNewLoginKeyAccepted) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientnewloginkeyaccepted_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientAccountInfo {
mut:
	unknown_fields                          []vproto.UnknownField
pub mut:
	persona_name                            string
	has_persona_name                        bool
	ip_country                              string
	has_ip_country                          bool
	count_authed_computers                  int
	has_count_authed_computers              bool
	account_flags                           u32
	has_account_flags                       bool
	facebook_id                             u64
	has_facebook_id                         bool
	facebook_name                           string
	has_facebook_name                       bool
	steamguard_notify_newmachines           bool
	has_steamguard_notify_newmachines       bool
	steamguard_machine_name_user_chosen     string
	has_steamguard_machine_name_user_chosen bool
	is_phone_verified                       bool
	has_is_phone_verified                   bool
	two_factor_state                        u32
	has_two_factor_state                    bool
	is_phone_identifying                    bool
	has_is_phone_identifying                bool
	is_phone_needing_reverify               bool
	has_is_phone_needing_reverify           bool
}

pub fn (o &CMsgClientAccountInfo) pack() []byte {
	mut res := []byte{}
	if o.has_persona_name {
		res << vproto.pack_string_field(o.persona_name, 1)
	}
	if o.has_ip_country {
		res << vproto.pack_string_field(o.ip_country, 2)
	}
	if o.has_count_authed_computers {
		res << vproto.pack_int32_field(o.count_authed_computers, 5)
	}
	if o.has_account_flags {
		res << vproto.pack_uint32_field(o.account_flags, 7)
	}
	if o.has_facebook_id {
		res << vproto.pack_uint64_field(o.facebook_id, 8)
	}
	if o.has_facebook_name {
		res << vproto.pack_string_field(o.facebook_name, 9)
	}
	if o.has_steamguard_notify_newmachines {
		res << vproto.pack_bool_field(o.steamguard_notify_newmachines, 14)
	}
	if o.has_steamguard_machine_name_user_chosen {
		res << vproto.pack_string_field(o.steamguard_machine_name_user_chosen, 15)
	}
	if o.has_is_phone_verified {
		res << vproto.pack_bool_field(o.is_phone_verified, 16)
	}
	if o.has_two_factor_state {
		res << vproto.pack_uint32_field(o.two_factor_state, 17)
	}
	if o.has_is_phone_identifying {
		res << vproto.pack_bool_field(o.is_phone_identifying, 18)
	}
	if o.has_is_phone_needing_reverify {
		res << vproto.pack_bool_field(o.is_phone_needing_reverify, 19)
	}
	return res
}

pub fn cmsgclientaccountinfo_unpack(buf []byte) ?CMsgClientAccountInfo {
	mut res := CMsgClientAccountInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_persona_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_name = v
				i = ii
			}
			2 {
				res.has_ip_country = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.ip_country = v
				i = ii
			}
			5 {
				res.has_count_authed_computers = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.count_authed_computers = v
				i = ii
			}
			7 {
				res.has_account_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.account_flags = v
				i = ii
			}
			8 {
				res.has_facebook_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.facebook_id = v
				i = ii
			}
			9 {
				res.has_facebook_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.facebook_name = v
				i = ii
			}
			14 {
				res.has_steamguard_notify_newmachines = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.steamguard_notify_newmachines = v
				i = ii
			}
			15 {
				res.has_steamguard_machine_name_user_chosen = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.steamguard_machine_name_user_chosen = v
				i = ii
			}
			16 {
				res.has_is_phone_verified = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_phone_verified = v
				i = ii
			}
			17 {
				res.has_two_factor_state = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.two_factor_state = v
				i = ii
			}
			18 {
				res.has_is_phone_identifying = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_phone_identifying = v
				i = ii
			}
			19 {
				res.has_is_phone_needing_reverify = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_phone_needing_reverify = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientaccountinfo() CMsgClientAccountInfo {
	return CMsgClientAccountInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientaccountinfo(o CMsgClientAccountInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientaccountinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientAccountInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientaccountinfo_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientChallengeRequest {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CMsgClientChallengeRequest) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cmsgclientchallengerequest_unpack(buf []byte) ?CMsgClientChallengeRequest {
	mut res := CMsgClientChallengeRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientchallengerequest() CMsgClientChallengeRequest {
	return CMsgClientChallengeRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientchallengerequest(o CMsgClientChallengeRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientchallengerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChallengeRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientchallengerequest_unpack(v)?
	return i, unpacked
}

pub struct CMsgClientChallengeResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	challenge      u64
	has_challenge  bool
}

pub fn (o &CMsgClientChallengeResponse) pack() []byte {
	mut res := []byte{}
	if o.has_challenge {
		res << vproto.pack_64bit_field(o.challenge, 1)
	}
	return res
}

pub fn cmsgclientchallengeresponse_unpack(buf []byte) ?CMsgClientChallengeResponse {
	mut res := CMsgClientChallengeResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_challenge = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.challenge = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cmsgclientchallengeresponse() CMsgClientChallengeResponse {
	return CMsgClientChallengeResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cmsgclientchallengeresponse(o CMsgClientChallengeResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cmsgclientchallengeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CMsgClientChallengeResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cmsgclientchallengeresponse_unpack(v)?
	return i, unpacked
}
