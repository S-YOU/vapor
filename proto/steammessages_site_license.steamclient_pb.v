// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct CSiteManagerClient_IncomingClient_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	site_instanceid     u64
	has_site_instanceid bool
	client_steamid      u64
	has_client_steamid  bool
	client_local_ip     u32
	has_client_local_ip bool
	connection_key      []byte
	has_connection_key  bool
}

pub fn (o &CSiteManagerClient_IncomingClient_Request) pack() []byte {
	mut res := []byte{}
	if o.has_site_instanceid {
		res << vproto.pack_64bit_field(o.site_instanceid, 1)
	}
	if o.has_client_steamid {
		res << vproto.pack_64bit_field(o.client_steamid, 2)
	}
	if o.has_client_local_ip {
		res << vproto.pack_32bit_field(o.client_local_ip, 3)
	}
	if o.has_connection_key {
		res << vproto.pack_bytes_field(o.connection_key, 4)
	}
	return res
}

pub fn csitemanagerclient_incomingclient_request_unpack(buf []byte) ?CSiteManagerClient_IncomingClient_Request {
	mut res := CSiteManagerClient_IncomingClient_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_site_instanceid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.site_instanceid = v
				i = ii
			}
			2 {
				res.has_client_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_steamid = v
				i = ii
			}
			3 {
				res.has_client_local_ip = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_local_ip = v
				i = ii
			}
			4 {
				res.has_connection_key = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_key = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitemanagerclient_incomingclient_request() CSiteManagerClient_IncomingClient_Request {
	return CSiteManagerClient_IncomingClient_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitemanagerclient_incomingclient_request(o CSiteManagerClient_IncomingClient_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitemanagerclient_incomingclient_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteManagerClient_IncomingClient_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitemanagerclient_incomingclient_request_unpack(v)?
	return i, unpacked
}

pub struct CSiteManagerClient_IncomingClient_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CSiteManagerClient_IncomingClient_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn csitemanagerclient_incomingclient_response_unpack(buf []byte) ?CSiteManagerClient_IncomingClient_Response {
	res := CSiteManagerClient_IncomingClient_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitemanagerclient_incomingclient_response() CSiteManagerClient_IncomingClient_Response {
	return CSiteManagerClient_IncomingClient_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitemanagerclient_incomingclient_response(o CSiteManagerClient_IncomingClient_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitemanagerclient_incomingclient_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteManagerClient_IncomingClient_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitemanagerclient_incomingclient_response_unpack(v)?
	return i, unpacked
}

pub struct CSiteLicense_ClientSeatCheckout_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	eresult        u32
	has_eresult    bool
}

pub fn (o &CSiteLicense_ClientSeatCheckout_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_eresult {
		res << vproto.pack_uint32_field(o.eresult, 2)
	}
	return res
}

pub fn csitelicense_clientseatcheckout_notification_unpack(buf []byte) ?CSiteLicense_ClientSeatCheckout_Notification {
	mut res := CSiteLicense_ClientSeatCheckout_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_eresult = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.eresult = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicense_clientseatcheckout_notification() CSiteLicense_ClientSeatCheckout_Notification {
	return CSiteLicense_ClientSeatCheckout_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicense_clientseatcheckout_notification(o CSiteLicense_ClientSeatCheckout_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicense_clientseatcheckout_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicense_ClientSeatCheckout_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitelicense_clientseatcheckout_notification_unpack(v)?
	return i, unpacked
}

pub struct CSiteManagerClient_TrackedPayments_Notification_Payment {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	transid             u64
	has_transid         bool
	steamid             u64
	has_steamid         bool
	amount              i64
	has_amount          bool
	ecurrency           u32
	has_ecurrency       bool
	time_created        int
	has_time_created    bool
	purchase_status     int
	has_purchase_status bool
	machine_name        string
	has_machine_name    bool
	persona_name        string
	has_persona_name    bool
	profile_url         string
	has_profile_url     bool
	avatar_url          string
	has_avatar_url      bool
}

pub fn (o &CSiteManagerClient_TrackedPayments_Notification_Payment) pack() []byte {
	mut res := []byte{}
	if o.has_transid {
		res << vproto.pack_uint64_field(o.transid, 1)
	}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 2)
	}
	if o.has_amount {
		res << vproto.pack_int64_field(o.amount, 3)
	}
	if o.has_ecurrency {
		res << vproto.pack_uint32_field(o.ecurrency, 4)
	}
	if o.has_time_created {
		res << vproto.pack_int32_field(o.time_created, 5)
	}
	if o.has_purchase_status {
		res << vproto.pack_int32_field(o.purchase_status, 6)
	}
	if o.has_machine_name {
		res << vproto.pack_string_field(o.machine_name, 7)
	}
	if o.has_persona_name {
		res << vproto.pack_string_field(o.persona_name, 8)
	}
	if o.has_profile_url {
		res << vproto.pack_string_field(o.profile_url, 9)
	}
	if o.has_avatar_url {
		res << vproto.pack_string_field(o.avatar_url, 10)
	}
	return res
}

pub fn csitemanagerclient_trackedpayments_notification_payment_unpack(buf []byte) ?CSiteManagerClient_TrackedPayments_Notification_Payment {
	mut res := CSiteManagerClient_TrackedPayments_Notification_Payment{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_transid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.transid = v
				i = ii
			}
			2 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			3 {
				res.has_amount = true
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
				res.amount = v
				i = ii
			}
			4 {
				res.has_ecurrency = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ecurrency = v
				i = ii
			}
			5 {
				res.has_time_created = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_created = v
				i = ii
			}
			6 {
				res.has_purchase_status = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.purchase_status = v
				i = ii
			}
			7 {
				res.has_machine_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.machine_name = v
				i = ii
			}
			8 {
				res.has_persona_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.persona_name = v
				i = ii
			}
			9 {
				res.has_profile_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.profile_url = v
				i = ii
			}
			10 {
				res.has_avatar_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.avatar_url = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitemanagerclient_trackedpayments_notification_payment() CSiteManagerClient_TrackedPayments_Notification_Payment {
	return CSiteManagerClient_TrackedPayments_Notification_Payment{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitemanagerclient_trackedpayments_notification_payment(o CSiteManagerClient_TrackedPayments_Notification_Payment, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitemanagerclient_trackedpayments_notification_payment(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteManagerClient_TrackedPayments_Notification_Payment) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitemanagerclient_trackedpayments_notification_payment_unpack(v)?
	return i, unpacked
}

pub struct CSiteManagerClient_TrackedPayments_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	site_id        u64
	has_site_id    bool
	payments       []CSiteManagerClient_TrackedPayments_Notification_Payment
}

pub fn (o &CSiteManagerClient_TrackedPayments_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_site_id {
		res << vproto.pack_64bit_field(o.site_id, 1)
	}
	// [packed=false]
	for _, x in o.payments {
		res <<
			zzz_vproto_internal_pack_csitemanagerclient_trackedpayments_notification_payment(x, 2)
	}
	return res
}

pub fn csitemanagerclient_trackedpayments_notification_unpack(buf []byte) ?CSiteManagerClient_TrackedPayments_Notification {
	mut res := CSiteManagerClient_TrackedPayments_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_site_id = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.site_id = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_csitemanagerclient_trackedpayments_notification_payment(cur_buf,
					tag_wiretype.wire_type)?
				res.payments << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitemanagerclient_trackedpayments_notification() CSiteManagerClient_TrackedPayments_Notification {
	return CSiteManagerClient_TrackedPayments_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitemanagerclient_trackedpayments_notification(o CSiteManagerClient_TrackedPayments_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitemanagerclient_trackedpayments_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteManagerClient_TrackedPayments_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitemanagerclient_trackedpayments_notification_unpack(v)?
	return i, unpacked
}

pub struct CSiteLicense_InitiateAssociation_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	site_steamid        u64
	has_site_steamid    bool
	site_instanceid     u64
	has_site_instanceid bool
	client_local_ip     u32
	has_client_local_ip bool
}

pub fn (o &CSiteLicense_InitiateAssociation_Request) pack() []byte {
	mut res := []byte{}
	if o.has_site_steamid {
		res << vproto.pack_64bit_field(o.site_steamid, 1)
	}
	if o.has_site_instanceid {
		res << vproto.pack_64bit_field(o.site_instanceid, 2)
	}
	if o.has_client_local_ip {
		res << vproto.pack_32bit_field(o.client_local_ip, 3)
	}
	return res
}

pub fn csitelicense_initiateassociation_request_unpack(buf []byte) ?CSiteLicense_InitiateAssociation_Request {
	mut res := CSiteLicense_InitiateAssociation_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_site_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.site_steamid = v
				i = ii
			}
			2 {
				res.has_site_instanceid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.site_instanceid = v
				i = ii
			}
			3 {
				res.has_client_local_ip = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.client_local_ip = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicense_initiateassociation_request() CSiteLicense_InitiateAssociation_Request {
	return CSiteLicense_InitiateAssociation_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicense_initiateassociation_request(o CSiteLicense_InitiateAssociation_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicense_initiateassociation_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicense_InitiateAssociation_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitelicense_initiateassociation_request_unpack(v)?
	return i, unpacked
}

pub struct CSiteLicense_InitiateAssociation_Response {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	connection_key     []byte
	has_connection_key bool
}

pub fn (o &CSiteLicense_InitiateAssociation_Response) pack() []byte {
	mut res := []byte{}
	if o.has_connection_key {
		res << vproto.pack_bytes_field(o.connection_key, 1)
	}
	return res
}

pub fn csitelicense_initiateassociation_response_unpack(buf []byte) ?CSiteLicense_InitiateAssociation_Response {
	mut res := CSiteLicense_InitiateAssociation_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_connection_key = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.connection_key = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicense_initiateassociation_response() CSiteLicense_InitiateAssociation_Response {
	return CSiteLicense_InitiateAssociation_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicense_initiateassociation_response(o CSiteLicense_InitiateAssociation_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicense_initiateassociation_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicense_InitiateAssociation_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitelicense_initiateassociation_response_unpack(v)?
	return i, unpacked
}

pub struct CSiteLicense_LCSAuthenticate_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	instanceid     u64
	has_instanceid bool
}

pub fn (o &CSiteLicense_LCSAuthenticate_Request) pack() []byte {
	mut res := []byte{}
	if o.has_instanceid {
		res << vproto.pack_64bit_field(o.instanceid, 1)
	}
	return res
}

pub fn csitelicense_lcsauthenticate_request_unpack(buf []byte) ?CSiteLicense_LCSAuthenticate_Request {
	mut res := CSiteLicense_LCSAuthenticate_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_instanceid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.instanceid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicense_lcsauthenticate_request() CSiteLicense_LCSAuthenticate_Request {
	return CSiteLicense_LCSAuthenticate_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicense_lcsauthenticate_request(o CSiteLicense_LCSAuthenticate_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicense_lcsauthenticate_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicense_LCSAuthenticate_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitelicense_lcsauthenticate_request_unpack(v)?
	return i, unpacked
}

pub struct CSiteLicense_LCSAuthenticate_Response {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	site_id              u64
	has_site_id          bool
	site_name            string
	has_site_name        bool
	new_session          bool
	has_new_session      bool
	no_site_licenses     bool
	has_no_site_licenses bool
}

pub fn (o &CSiteLicense_LCSAuthenticate_Response) pack() []byte {
	mut res := []byte{}
	if o.has_site_id {
		res << vproto.pack_uint64_field(o.site_id, 1)
	}
	if o.has_site_name {
		res << vproto.pack_string_field(o.site_name, 2)
	}
	if o.has_new_session {
		res << vproto.pack_bool_field(o.new_session, 3)
	}
	if o.has_no_site_licenses {
		res << vproto.pack_bool_field(o.no_site_licenses, 4)
	}
	return res
}

pub fn csitelicense_lcsauthenticate_response_unpack(buf []byte) ?CSiteLicense_LCSAuthenticate_Response {
	mut res := CSiteLicense_LCSAuthenticate_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_site_id = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.site_id = v
				i = ii
			}
			2 {
				res.has_site_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.site_name = v
				i = ii
			}
			3 {
				res.has_new_session = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.new_session = v
				i = ii
			}
			4 {
				res.has_no_site_licenses = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.no_site_licenses = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicense_lcsauthenticate_response() CSiteLicense_LCSAuthenticate_Response {
	return CSiteLicense_LCSAuthenticate_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicense_lcsauthenticate_response(o CSiteLicense_LCSAuthenticate_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicense_lcsauthenticate_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicense_LCSAuthenticate_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitelicense_lcsauthenticate_response_unpack(v)?
	return i, unpacked
}

pub struct CSiteLicense_LCSAssociateUser_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	steamid          u64
	has_steamid      bool
	local_ip         u32
	has_local_ip     bool
	instanceid       u64
	has_instanceid   bool
	machine_name     string
	has_machine_name bool
}

pub fn (o &CSiteLicense_LCSAssociateUser_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_local_ip {
		res << vproto.pack_32bit_field(o.local_ip, 2)
	}
	if o.has_instanceid {
		res << vproto.pack_64bit_field(o.instanceid, 3)
	}
	if o.has_machine_name {
		res << vproto.pack_string_field(o.machine_name, 4)
	}
	return res
}

pub fn csitelicense_lcsassociateuser_request_unpack(buf []byte) ?CSiteLicense_LCSAssociateUser_Request {
	mut res := CSiteLicense_LCSAssociateUser_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_local_ip = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.local_ip = v
				i = ii
			}
			3 {
				res.has_instanceid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.instanceid = v
				i = ii
			}
			4 {
				res.has_machine_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.machine_name = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicense_lcsassociateuser_request() CSiteLicense_LCSAssociateUser_Request {
	return CSiteLicense_LCSAssociateUser_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicense_lcsassociateuser_request(o CSiteLicense_LCSAssociateUser_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicense_lcsassociateuser_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicense_LCSAssociateUser_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitelicense_lcsassociateuser_request_unpack(v)?
	return i, unpacked
}

pub struct CSiteLicense_LCSAssociateUser_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CSiteLicense_LCSAssociateUser_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn csitelicense_lcsassociateuser_response_unpack(buf []byte) ?CSiteLicense_LCSAssociateUser_Response {
	res := CSiteLicense_LCSAssociateUser_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicense_lcsassociateuser_response() CSiteLicense_LCSAssociateUser_Response {
	return CSiteLicense_LCSAssociateUser_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicense_lcsassociateuser_response(o CSiteLicense_LCSAssociateUser_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicense_lcsassociateuser_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicense_LCSAssociateUser_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitelicense_lcsassociateuser_response_unpack(v)?
	return i, unpacked
}

pub struct CSiteLicense_ClientSeatCheckout_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	instanceid     u64
	has_instanceid bool
	appid          u32
	has_appid      bool
}

pub fn (o &CSiteLicense_ClientSeatCheckout_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_instanceid {
		res << vproto.pack_64bit_field(o.instanceid, 2)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 3)
	}
	return res
}

pub fn csitelicense_clientseatcheckout_request_unpack(buf []byte) ?CSiteLicense_ClientSeatCheckout_Request {
	mut res := CSiteLicense_ClientSeatCheckout_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_instanceid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.instanceid = v
				i = ii
			}
			3 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicense_clientseatcheckout_request() CSiteLicense_ClientSeatCheckout_Request {
	return CSiteLicense_ClientSeatCheckout_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicense_clientseatcheckout_request(o CSiteLicense_ClientSeatCheckout_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicense_clientseatcheckout_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicense_ClientSeatCheckout_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitelicense_clientseatcheckout_request_unpack(v)?
	return i, unpacked
}

pub struct CSiteLicense_ClientSeatCheckout_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CSiteLicense_ClientSeatCheckout_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn csitelicense_clientseatcheckout_response_unpack(buf []byte) ?CSiteLicense_ClientSeatCheckout_Response {
	res := CSiteLicense_ClientSeatCheckout_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicense_clientseatcheckout_response() CSiteLicense_ClientSeatCheckout_Response {
	return CSiteLicense_ClientSeatCheckout_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicense_clientseatcheckout_response(o CSiteLicense_ClientSeatCheckout_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicense_clientseatcheckout_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicense_ClientSeatCheckout_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitelicense_clientseatcheckout_response_unpack(v)?
	return i, unpacked
}

pub struct CSiteLicense_ClientGetAvailableSeats_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	instanceid     u64
	has_instanceid bool
	appid          u32
	has_appid      bool
}

pub fn (o &CSiteLicense_ClientGetAvailableSeats_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_instanceid {
		res << vproto.pack_64bit_field(o.instanceid, 2)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 3)
	}
	return res
}

pub fn csitelicense_clientgetavailableseats_request_unpack(buf []byte) ?CSiteLicense_ClientGetAvailableSeats_Request {
	mut res := CSiteLicense_ClientGetAvailableSeats_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_instanceid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.instanceid = v
				i = ii
			}
			3 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicense_clientgetavailableseats_request() CSiteLicense_ClientGetAvailableSeats_Request {
	return CSiteLicense_ClientGetAvailableSeats_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicense_clientgetavailableseats_request(o CSiteLicense_ClientGetAvailableSeats_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicense_clientgetavailableseats_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicense_ClientGetAvailableSeats_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitelicense_clientgetavailableseats_request_unpack(v)?
	return i, unpacked
}

pub struct CSiteLicense_ClientGetAvailableSeats_Response {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	available_seats     u32
	has_available_seats bool
}

pub fn (o &CSiteLicense_ClientGetAvailableSeats_Response) pack() []byte {
	mut res := []byte{}
	if o.has_available_seats {
		res << vproto.pack_uint32_field(o.available_seats, 1)
	}
	return res
}

pub fn csitelicense_clientgetavailableseats_response_unpack(buf []byte) ?CSiteLicense_ClientGetAvailableSeats_Response {
	mut res := CSiteLicense_ClientGetAvailableSeats_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_available_seats = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.available_seats = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicense_clientgetavailableseats_response() CSiteLicense_ClientGetAvailableSeats_Response {
	return CSiteLicense_ClientGetAvailableSeats_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicense_clientgetavailableseats_response(o CSiteLicense_ClientGetAvailableSeats_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicense_clientgetavailableseats_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicense_ClientGetAvailableSeats_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csitelicense_clientgetavailableseats_response_unpack(v)?
	return i, unpacked
}
