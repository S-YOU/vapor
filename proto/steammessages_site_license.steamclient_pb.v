
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


pub struct CSiteManagerClientIncomingClientRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
site_instanceid u64
has_site_instanceid bool
client_steamid u64
has_client_steamid bool
client_local_ip u32
has_client_local_ip bool
connection_key []byte
has_connection_key bool
}
pub fn (o &CSiteManagerClientIncomingClientRequest) pack() []byte {
mut res := []byte{}
if o.has_site_instanceid {
res << vproto.pack_64bit_field(o.site_instanceid, 1)
}

if o.has_client_steamid {
res << vproto.pack_64bit_field(o.client_steamid, 2)
}

if o.has_client_local_ip {
res << vproto.pack_32bit_field(o.client_local_ip, 3)
}

if o.has_connection_key {
res << vproto.pack_bytes_field(o.connection_key, 4)
}

return res
}

pub fn csitemanagerclientincomingclientrequest_unpack(buf []byte) ?CSiteManagerClientIncomingClientRequest {
mut res := CSiteManagerClientIncomingClientRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_site_instanceid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.site_instanceid = v
i = ii
}

2 {
res.has_client_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.client_steamid = v
i = ii
}

3 {
res.has_client_local_ip = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.client_local_ip = v
i = ii
}

4 {
res.has_connection_key = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.connection_key = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitemanagerclientincomingclientrequest() CSiteManagerClientIncomingClientRequest {
return CSiteManagerClientIncomingClientRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitemanagerclientincomingclientrequest(o CSiteManagerClientIncomingClientRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitemanagerclientincomingclientrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteManagerClientIncomingClientRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitemanagerclientincomingclientrequest_unpack(v)?
return i, unpacked
}
pub struct CSiteManagerClientIncomingClientResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CSiteManagerClientIncomingClientResponse) pack() []byte {
res := []byte{}
return res
}

pub fn csitemanagerclientincomingclientresponse_unpack(buf []byte) ?CSiteManagerClientIncomingClientResponse {
res := CSiteManagerClientIncomingClientResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitemanagerclientincomingclientresponse() CSiteManagerClientIncomingClientResponse {
return CSiteManagerClientIncomingClientResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitemanagerclientincomingclientresponse(o CSiteManagerClientIncomingClientResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitemanagerclientincomingclientresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteManagerClientIncomingClientResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitemanagerclientincomingclientresponse_unpack(v)?
return i, unpacked
}
pub struct CSiteLicenseClientSeatCheckoutNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
eresult u32
has_eresult bool
}
pub fn (o &CSiteLicenseClientSeatCheckoutNotification) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_eresult {
res << vproto.pack_uint32_field(o.eresult, 2)
}

return res
}

pub fn csitelicenseclientseatcheckoutnotification_unpack(buf []byte) ?CSiteLicenseClientSeatCheckoutNotification {
mut res := CSiteLicenseClientSeatCheckoutNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_eresult = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.eresult = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicenseclientseatcheckoutnotification() CSiteLicenseClientSeatCheckoutNotification {
return CSiteLicenseClientSeatCheckoutNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicenseclientseatcheckoutnotification(o CSiteLicenseClientSeatCheckoutNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicenseclientseatcheckoutnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicenseClientSeatCheckoutNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitelicenseclientseatcheckoutnotification_unpack(v)?
return i, unpacked
}
pub struct CSiteManagerClientTrackedPaymentsNotificationPayment {
mut:
unknown_fields []vproto.UnknownField
pub mut:
transid u64
has_transid bool
steamid u64
has_steamid bool
amount i64
has_amount bool
ecurrency u32
has_ecurrency bool
time_created int
has_time_created bool
purchase_status int
has_purchase_status bool
machine_name string
has_machine_name bool
persona_name string
has_persona_name bool
profile_url string
has_profile_url bool
avatar_url string
has_avatar_url bool
}
pub fn (o &CSiteManagerClientTrackedPaymentsNotificationPayment) pack() []byte {
mut res := []byte{}
if o.has_transid {
res << vproto.pack_uint64_field(o.transid, 1)
}

if o.has_steamid {
res << vproto.pack_uint64_field(o.steamid, 2)
}

if o.has_amount {
res << vproto.pack_int64_field(o.amount, 3)
}

if o.has_ecurrency {
res << vproto.pack_uint32_field(o.ecurrency, 4)
}

if o.has_time_created {
res << vproto.pack_int32_field(o.time_created, 5)
}

if o.has_purchase_status {
res << vproto.pack_int32_field(o.purchase_status, 6)
}

if o.has_machine_name {
res << vproto.pack_string_field(o.machine_name, 7)
}

if o.has_persona_name {
res << vproto.pack_string_field(o.persona_name, 8)
}

if o.has_profile_url {
res << vproto.pack_string_field(o.profile_url, 9)
}

if o.has_avatar_url {
res << vproto.pack_string_field(o.avatar_url, 10)
}

return res
}

pub fn csitemanagerclienttrackedpaymentsnotificationpayment_unpack(buf []byte) ?CSiteManagerClientTrackedPaymentsNotificationPayment {
mut res := CSiteManagerClientTrackedPaymentsNotificationPayment{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_transid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.transid = v
i = ii
}

2 {
res.has_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

3 {
res.has_amount = true
ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type)?
res.amount = v
i = ii
}

4 {
res.has_ecurrency = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ecurrency = v
i = ii
}

5 {
res.has_time_created = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.time_created = v
i = ii
}

6 {
res.has_purchase_status = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.purchase_status = v
i = ii
}

7 {
res.has_machine_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.machine_name = v
i = ii
}

8 {
res.has_persona_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.persona_name = v
i = ii
}

9 {
res.has_profile_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.profile_url = v
i = ii
}

10 {
res.has_avatar_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.avatar_url = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitemanagerclienttrackedpaymentsnotificationpayment() CSiteManagerClientTrackedPaymentsNotificationPayment {
return CSiteManagerClientTrackedPaymentsNotificationPayment{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitemanagerclienttrackedpaymentsnotificationpayment(o CSiteManagerClientTrackedPaymentsNotificationPayment, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitemanagerclienttrackedpaymentsnotificationpayment(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteManagerClientTrackedPaymentsNotificationPayment) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitemanagerclienttrackedpaymentsnotificationpayment_unpack(v)?
return i, unpacked
}
pub struct CSiteManagerClientTrackedPaymentsNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
site_id u64
has_site_id bool
payments []CSiteManagerClientTrackedPaymentsNotificationPayment
}
pub fn (o &CSiteManagerClientTrackedPaymentsNotification) pack() []byte {
mut res := []byte{}
if o.has_site_id {
res << vproto.pack_64bit_field(o.site_id, 1)
}

// [packed=false]
for _, x in o.payments {
res << zzz_vproto_internal_pack_csitemanagerclienttrackedpaymentsnotificationpayment(x, 2)
}

return res
}

pub fn csitemanagerclienttrackedpaymentsnotification_unpack(buf []byte) ?CSiteManagerClientTrackedPaymentsNotification {
mut res := CSiteManagerClientTrackedPaymentsNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_site_id = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.site_id = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_csitemanagerclienttrackedpaymentsnotificationpayment(cur_buf, tag_wiretype.wire_type)?
res.payments << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitemanagerclienttrackedpaymentsnotification() CSiteManagerClientTrackedPaymentsNotification {
return CSiteManagerClientTrackedPaymentsNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitemanagerclienttrackedpaymentsnotification(o CSiteManagerClientTrackedPaymentsNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitemanagerclienttrackedpaymentsnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteManagerClientTrackedPaymentsNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitemanagerclienttrackedpaymentsnotification_unpack(v)?
return i, unpacked
}
pub struct CSiteLicenseInitiateAssociationRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
site_steamid u64
has_site_steamid bool
site_instanceid u64
has_site_instanceid bool
client_local_ip u32
has_client_local_ip bool
}
pub fn (o &CSiteLicenseInitiateAssociationRequest) pack() []byte {
mut res := []byte{}
if o.has_site_steamid {
res << vproto.pack_64bit_field(o.site_steamid, 1)
}

if o.has_site_instanceid {
res << vproto.pack_64bit_field(o.site_instanceid, 2)
}

if o.has_client_local_ip {
res << vproto.pack_32bit_field(o.client_local_ip, 3)
}

return res
}

pub fn csitelicenseinitiateassociationrequest_unpack(buf []byte) ?CSiteLicenseInitiateAssociationRequest {
mut res := CSiteLicenseInitiateAssociationRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_site_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.site_steamid = v
i = ii
}

2 {
res.has_site_instanceid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.site_instanceid = v
i = ii
}

3 {
res.has_client_local_ip = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.client_local_ip = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicenseinitiateassociationrequest() CSiteLicenseInitiateAssociationRequest {
return CSiteLicenseInitiateAssociationRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicenseinitiateassociationrequest(o CSiteLicenseInitiateAssociationRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicenseinitiateassociationrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicenseInitiateAssociationRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitelicenseinitiateassociationrequest_unpack(v)?
return i, unpacked
}
pub struct CSiteLicenseInitiateAssociationResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
connection_key []byte
has_connection_key bool
}
pub fn (o &CSiteLicenseInitiateAssociationResponse) pack() []byte {
mut res := []byte{}
if o.has_connection_key {
res << vproto.pack_bytes_field(o.connection_key, 1)
}

return res
}

pub fn csitelicenseinitiateassociationresponse_unpack(buf []byte) ?CSiteLicenseInitiateAssociationResponse {
mut res := CSiteLicenseInitiateAssociationResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_connection_key = true
ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
res.connection_key = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicenseinitiateassociationresponse() CSiteLicenseInitiateAssociationResponse {
return CSiteLicenseInitiateAssociationResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicenseinitiateassociationresponse(o CSiteLicenseInitiateAssociationResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicenseinitiateassociationresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicenseInitiateAssociationResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitelicenseinitiateassociationresponse_unpack(v)?
return i, unpacked
}
pub struct CSiteLicenseLCsauthenticateRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
instanceid u64
has_instanceid bool
}
pub fn (o &CSiteLicenseLCsauthenticateRequest) pack() []byte {
mut res := []byte{}
if o.has_instanceid {
res << vproto.pack_64bit_field(o.instanceid, 1)
}

return res
}

pub fn csitelicenselcsauthenticaterequest_unpack(buf []byte) ?CSiteLicenseLCsauthenticateRequest {
mut res := CSiteLicenseLCsauthenticateRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_instanceid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.instanceid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicenselcsauthenticaterequest() CSiteLicenseLCsauthenticateRequest {
return CSiteLicenseLCsauthenticateRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicenselcsauthenticaterequest(o CSiteLicenseLCsauthenticateRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicenselcsauthenticaterequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicenseLCsauthenticateRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitelicenselcsauthenticaterequest_unpack(v)?
return i, unpacked
}
pub struct CSiteLicenseLCsauthenticateResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
site_id u64
has_site_id bool
site_name string
has_site_name bool
new_session bool
has_new_session bool
no_site_licenses bool
has_no_site_licenses bool
}
pub fn (o &CSiteLicenseLCsauthenticateResponse) pack() []byte {
mut res := []byte{}
if o.has_site_id {
res << vproto.pack_uint64_field(o.site_id, 1)
}

if o.has_site_name {
res << vproto.pack_string_field(o.site_name, 2)
}

if o.has_new_session {
res << vproto.pack_bool_field(o.new_session, 3)
}

if o.has_no_site_licenses {
res << vproto.pack_bool_field(o.no_site_licenses, 4)
}

return res
}

pub fn csitelicenselcsauthenticateresponse_unpack(buf []byte) ?CSiteLicenseLCsauthenticateResponse {
mut res := CSiteLicenseLCsauthenticateResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_site_id = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.site_id = v
i = ii
}

2 {
res.has_site_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.site_name = v
i = ii
}

3 {
res.has_new_session = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.new_session = v
i = ii
}

4 {
res.has_no_site_licenses = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.no_site_licenses = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicenselcsauthenticateresponse() CSiteLicenseLCsauthenticateResponse {
return CSiteLicenseLCsauthenticateResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicenselcsauthenticateresponse(o CSiteLicenseLCsauthenticateResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicenselcsauthenticateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicenseLCsauthenticateResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitelicenselcsauthenticateresponse_unpack(v)?
return i, unpacked
}
pub struct CSiteLicenseLCsassociateUserRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
local_ip u32
has_local_ip bool
instanceid u64
has_instanceid bool
machine_name string
has_machine_name bool
}
pub fn (o &CSiteLicenseLCsassociateUserRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_local_ip {
res << vproto.pack_32bit_field(o.local_ip, 2)
}

if o.has_instanceid {
res << vproto.pack_64bit_field(o.instanceid, 3)
}

if o.has_machine_name {
res << vproto.pack_string_field(o.machine_name, 4)
}

return res
}

pub fn csitelicenselcsassociateuserrequest_unpack(buf []byte) ?CSiteLicenseLCsassociateUserRequest {
mut res := CSiteLicenseLCsassociateUserRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_local_ip = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.local_ip = v
i = ii
}

3 {
res.has_instanceid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.instanceid = v
i = ii
}

4 {
res.has_machine_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.machine_name = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicenselcsassociateuserrequest() CSiteLicenseLCsassociateUserRequest {
return CSiteLicenseLCsassociateUserRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicenselcsassociateuserrequest(o CSiteLicenseLCsassociateUserRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicenselcsassociateuserrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicenseLCsassociateUserRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitelicenselcsassociateuserrequest_unpack(v)?
return i, unpacked
}
pub struct CSiteLicenseLCsassociateUserResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CSiteLicenseLCsassociateUserResponse) pack() []byte {
res := []byte{}
return res
}

pub fn csitelicenselcsassociateuserresponse_unpack(buf []byte) ?CSiteLicenseLCsassociateUserResponse {
res := CSiteLicenseLCsassociateUserResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicenselcsassociateuserresponse() CSiteLicenseLCsassociateUserResponse {
return CSiteLicenseLCsassociateUserResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicenselcsassociateuserresponse(o CSiteLicenseLCsassociateUserResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicenselcsassociateuserresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicenseLCsassociateUserResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitelicenselcsassociateuserresponse_unpack(v)?
return i, unpacked
}
pub struct CSiteLicenseClientSeatCheckoutRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
instanceid u64
has_instanceid bool
appid u32
has_appid bool
}
pub fn (o &CSiteLicenseClientSeatCheckoutRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_instanceid {
res << vproto.pack_64bit_field(o.instanceid, 2)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 3)
}

return res
}

pub fn csitelicenseclientseatcheckoutrequest_unpack(buf []byte) ?CSiteLicenseClientSeatCheckoutRequest {
mut res := CSiteLicenseClientSeatCheckoutRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_instanceid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.instanceid = v
i = ii
}

3 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicenseclientseatcheckoutrequest() CSiteLicenseClientSeatCheckoutRequest {
return CSiteLicenseClientSeatCheckoutRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicenseclientseatcheckoutrequest(o CSiteLicenseClientSeatCheckoutRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicenseclientseatcheckoutrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicenseClientSeatCheckoutRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitelicenseclientseatcheckoutrequest_unpack(v)?
return i, unpacked
}
pub struct CSiteLicenseClientSeatCheckoutResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CSiteLicenseClientSeatCheckoutResponse) pack() []byte {
res := []byte{}
return res
}

pub fn csitelicenseclientseatcheckoutresponse_unpack(buf []byte) ?CSiteLicenseClientSeatCheckoutResponse {
res := CSiteLicenseClientSeatCheckoutResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicenseclientseatcheckoutresponse() CSiteLicenseClientSeatCheckoutResponse {
return CSiteLicenseClientSeatCheckoutResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicenseclientseatcheckoutresponse(o CSiteLicenseClientSeatCheckoutResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicenseclientseatcheckoutresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicenseClientSeatCheckoutResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitelicenseclientseatcheckoutresponse_unpack(v)?
return i, unpacked
}
pub struct CSiteLicenseClientGetAvailableSeatsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
instanceid u64
has_instanceid bool
appid u32
has_appid bool
}
pub fn (o &CSiteLicenseClientGetAvailableSeatsRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_instanceid {
res << vproto.pack_64bit_field(o.instanceid, 2)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 3)
}

return res
}

pub fn csitelicenseclientgetavailableseatsrequest_unpack(buf []byte) ?CSiteLicenseClientGetAvailableSeatsRequest {
mut res := CSiteLicenseClientGetAvailableSeatsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_instanceid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.instanceid = v
i = ii
}

3 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicenseclientgetavailableseatsrequest() CSiteLicenseClientGetAvailableSeatsRequest {
return CSiteLicenseClientGetAvailableSeatsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicenseclientgetavailableseatsrequest(o CSiteLicenseClientGetAvailableSeatsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicenseclientgetavailableseatsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicenseClientGetAvailableSeatsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitelicenseclientgetavailableseatsrequest_unpack(v)?
return i, unpacked
}
pub struct CSiteLicenseClientGetAvailableSeatsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
available_seats u32
has_available_seats bool
}
pub fn (o &CSiteLicenseClientGetAvailableSeatsResponse) pack() []byte {
mut res := []byte{}
if o.has_available_seats {
res << vproto.pack_uint32_field(o.available_seats, 1)
}

return res
}

pub fn csitelicenseclientgetavailableseatsresponse_unpack(buf []byte) ?CSiteLicenseClientGetAvailableSeatsResponse {
mut res := CSiteLicenseClientGetAvailableSeatsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_available_seats = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.available_seats = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csitelicenseclientgetavailableseatsresponse() CSiteLicenseClientGetAvailableSeatsResponse {
return CSiteLicenseClientGetAvailableSeatsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csitelicenseclientgetavailableseatsresponse(o CSiteLicenseClientGetAvailableSeatsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csitelicenseclientgetavailableseatsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CSiteLicenseClientGetAvailableSeatsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := csitelicenseclientgetavailableseatsresponse_unpack(v)?
return i, unpacked
}
