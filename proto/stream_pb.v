// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EStreamChannel {
	k_estreamchannelinvalid = -1
	k_estreamchanneldiscovery = 0
	k_estreamchannelcontrol = 1
	k_estreamchannelstats = 2
	k_estreamchanneldatachannelstart = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamchannel(e EStreamChannel, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamchannel_packed(e []EStreamChannel, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamchannel(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamChannel) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamChannel(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamchannel_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamChannel) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamDiscoveryMessage {
	k_estreamdiscoverypingrequest = 1
	k_estreamdiscoverypingresponse = 2
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamdiscoverymessage(e EStreamDiscoveryMessage, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamdiscoverymessage_packed(e []EStreamDiscoveryMessage, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamdiscoverymessage(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamDiscoveryMessage) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamDiscoveryMessage(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamdiscoverymessage_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamDiscoveryMessage) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamControlMessage {
	k_estreamcontrolauthenticationrequest = 1
	k_estreamcontrolauthenticationresponse = 2
	k_estreamcontrolnegotiationinit = 3
	k_estreamcontrolnegotiationsetconfig = 4
	k_estreamcontrolnegotiationcomplete = 5
	k_estreamcontrolclienthandshake = 6
	k_estreamcontrolserverhandshake = 7
	k_estreamcontrolstartnetworktest = 8
	k_estreamcontrolkeepalive = 9
	k_estreamcontrol_last_setup_message = 15
	k_estreamcontrolstartaudiodata = 50
	k_estreamcontrolstopaudiodata = 51
	k_estreamcontrolstartvideodata = 52
	k_estreamcontrolstopvideodata = 53
	k_estreamcontrolinputmousemotion = 54
	k_estreamcontrolinputmousewheel = 55
	k_estreamcontrolinputmousedown = 56
	k_estreamcontrolinputmouseup = 57
	k_estreamcontrolinputkeydown = 58
	k_estreamcontrolinputkeyup = 59
	k_estreamcontrolinputgamepadattached_obsolete = 60
	k_estreamcontrolinputgamepadevent_obsolete = 61
	k_estreamcontrolinputgamepaddetached_obsolete = 62
	k_estreamcontrolshowcursor = 63
	k_estreamcontrolhidecursor = 64
	k_estreamcontrolsetcursor = 65
	k_estreamcontrolgetcursorimage = 66
	k_estreamcontrolsetcursorimage = 67
	k_estreamcontroldeletecursor = 68
	k_estreamcontrolsettargetframerate = 69
	k_estreamcontrolinputlatencytest = 70
	k_estreamcontrolgamepadrumble_obsolete = 71
	k_estreamcontroloverlayenabled = 74
	k_estreamcontrolinputcontrollerattached_obsolete = 75
	k_estreamcontrolinputcontrollerstate_obsolete = 76
	k_estreamcontroltriggerhapticpulse_obsolete = 77
	k_estreamcontrolinputcontrollerdetached_obsolete = 78
	k_estreamcontrolvideodecoderinfo = 80
	k_estreamcontrolsettitle = 81
	k_estreamcontrolseticon = 82
	k_estreamcontrolquitrequest = 83
	k_estreamcontrolsetqos = 87
	k_estreamcontrolinputcontrollerwirelesspresence_obsolete = 88
	k_estreamcontrolsetgammaramp = 89
	k_estreamcontrolvideoencoderinfo = 90
	k_estreamcontrolinputcontrollerstatehid_obsolete = 93
	k_estreamcontrolsettargetbitrate = 94
	k_estreamcontrolsetcontrollerpairingenabled_obsolete = 95
	k_estreamcontrolsetcontrollerpairingresult_obsolete = 96
	k_estreamcontroltriggercontrollerdisconnect_obsolete = 97
	k_estreamcontrolsetactivity = 98
	k_estreamcontrolsetstreamingclientconfig = 99
	k_estreamcontrolsystemsuspend = 100
	k_estreamcontrolsetcontrollersettings_obsolete = 101
	k_estreamcontrolvirtualhererequest = 102
	k_estreamcontrolvirtualhereready = 103
	k_estreamcontrolvirtualheresharedevice = 104
	k_estreamcontrolsetspectatormode = 105
	k_estreamcontrolremotehid = 106
	k_estreamcontrolstartmicrophonedata = 107
	k_estreamcontrolstopmicrophonedata = 108
	k_estreamcontrolinputtext = 109
	k_estreamcontroltouchconfigactive = 110
	k_estreamcontrolgettouchconfigdata = 111
	k_estreamcontrolsettouchconfigdata = 112
	k_estreamcontrolsavetouchconfiglayout = 113
	k_estreamcontroltouchactionsetactive = 114
	k_estreamcontrolgettouchicondata = 115
	k_estreamcontrolsettouchicondata = 116
	k_estreamcontrolinputtouchfingerdown = 117
	k_estreamcontrolinputtouchfingermotion = 118
	k_estreamcontrolinputtouchfingerup = 119
	k_estreamcontrolsetcapturesize = 120
	k_estreamcontrolsetflashstate = 121
	k_estreamcontrolpause = 122
	k_estreamcontrolresume = 123
	k_estreamcontrolenablehighrescapture = 124
	k_estreamcontroldisablehighrescapture = 125
	k_estreamcontroltogglemagnification = 126
	k_estreamcontrolsetcapslock = 127
	k_estreamcontrolsetkeymap = 128
	k_estreamcontrolstoprequest = 129
	k_estreamcontroltouchactionsetlayeradded = 130
	k_estreamcontroltouchactionsetlayerremoved = 131
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamcontrolmessage(e EStreamControlMessage, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamcontrolmessage_packed(e []EStreamControlMessage, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamcontrolmessage(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamControlMessage) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamControlMessage(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamcontrolmessage_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamControlMessage) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamVersion {
	k_estreamversionnone = 0
	k_estreamversioncurrent = 1
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamversion(e EStreamVersion, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamversion_packed(e []EStreamVersion, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamversion(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamVersion) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamVersion(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamversion_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamVersion) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamAudioCodec {
	k_estreamaudiocodecnone = 0
	k_estreamaudiocodecraw = 1
	k_estreamaudiocodecvorbis = 2
	k_estreamaudiocodecopus = 3
	k_estreamaudiocodecmp3 = 4
	k_estreamaudiocodecaac = 5
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamaudiocodec(e EStreamAudioCodec, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamaudiocodec_packed(e []EStreamAudioCodec, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamaudiocodec(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamAudioCodec) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamAudioCodec(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamaudiocodec_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamAudioCodec) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamVideoCodec {
	k_estreamvideocodecnone = 0
	k_estreamvideocodecraw = 1
	k_estreamvideocodecvp8 = 2
	k_estreamvideocodecvp9 = 3
	k_estreamvideocodech264 = 4
	k_estreamvideocodechevc = 5
	k_estreamvideocodecorbx1 = 6
	k_estreamvideocodecorbx2 = 7
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamvideocodec(e EStreamVideoCodec, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamvideocodec_packed(e []EStreamVideoCodec, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamvideocodec(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamVideoCodec) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamVideoCodec(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamvideocodec_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamVideoCodec) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamQualityPreference {
	k_estreamqualityfast = 1
	k_estreamqualitybalanced = 2
	k_estreamqualitybeautiful = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamqualitypreference(e EStreamQualityPreference, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamqualitypreference_packed(e []EStreamQualityPreference, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamqualitypreference(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamQualityPreference) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamQualityPreference(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamqualitypreference_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamQualityPreference) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamBitrate {
	k_estreambitrateautodetect = -1
	k_estreambitrateunlimited = 0
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreambitrate(e EStreamBitrate, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreambitrate_packed(e []EStreamBitrate, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreambitrate(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamBitrate) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamBitrate(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreambitrate_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamBitrate) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamP2PScope {
	k_estreamp2pscopeunknown = 0
	k_estreamp2pscopedisabled = 1
	k_estreamp2pscopeonlyme = 2
	k_estreamp2pscopefriends = 3
	k_estreamp2pscopeeveryone = 4
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamp2pscope(e EStreamP2PScope, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamp2pscope_packed(e []EStreamP2PScope, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamp2pscope(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamP2PScope) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamP2PScope(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamp2pscope_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamP2PScope) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamHostPlayAudioPreference {
	k_estreamhostplayaudiodefault = 0
	k_estreamhostplayaudioalways = 1
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamhostplayaudiopreference(e EStreamHostPlayAudioPreference, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamhostplayaudiopreference_packed(e []EStreamHostPlayAudioPreference, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamhostplayaudiopreference(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamHostPlayAudioPreference) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamHostPlayAudioPreference(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamhostplayaudiopreference_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamHostPlayAudioPreference) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamingDataType {
	k_estreamingaudiodata = 0
	k_estreamingvideodata = 1
	k_estreamingmicrophonedata = 2
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamingdatatype(e EStreamingDataType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamingdatatype_packed(e []EStreamingDataType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamingdatatype(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamingDataType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamingDataType(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamingdatatype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamingDataType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamMouseButton {
	k_estreammousebuttonleft = 1
	k_estreammousebuttonright = 2
	k_estreammousebuttonmiddle = 16
	k_estreammousebuttonx1 = 32
	k_estreammousebuttonx2 = 64
	k_estreammousebuttonunknown = 4096
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreammousebutton(e EStreamMouseButton, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreammousebutton_packed(e []EStreamMouseButton, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreammousebutton(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamMouseButton) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamMouseButton(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreammousebutton_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamMouseButton) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamMouseWheelDirection {
	k_estreammousewheelup = 120
	k_estreammousewheeldown = -120
	k_estreammousewheelleft = 3
	k_estreammousewheelright = 4
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreammousewheeldirection(e EStreamMouseWheelDirection, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreammousewheeldirection_packed(e []EStreamMouseWheelDirection, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreammousewheeldirection(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamMouseWheelDirection) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamMouseWheelDirection(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreammousewheeldirection_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamMouseWheelDirection) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamFramerateLimiter {
	k_estreamframerateslowcapture = 1
	k_estreamframerateslowconvert = 2
	k_estreamframerateslowencode = 4
	k_estreamframerateslownetwork = 8
	k_estreamframerateslowdecode = 16
	k_estreamframerateslowgame = 32
	k_estreamframerateslowdisplay = 64
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamframeratelimiter(e EStreamFramerateLimiter, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamframeratelimiter_packed(e []EStreamFramerateLimiter, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamframeratelimiter(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamFramerateLimiter) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamFramerateLimiter(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamframeratelimiter_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamFramerateLimiter) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamActivity {
	k_estreamactivityidle = 1
	k_estreamactivitygame = 2
	k_estreamactivitydesktop = 3
	k_estreamactivitysecuredesktop = 4
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamactivity(e EStreamActivity, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamactivity_packed(e []EStreamActivity, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamactivity(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamActivity) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamActivity(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamactivity_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamActivity) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamDataMessage {
	k_estreamdatapacket = 1
	k_estreamdatalost = 2
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamdatamessage(e EStreamDataMessage, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamdatamessage_packed(e []EStreamDataMessage, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamdatamessage(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamDataMessage) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamDataMessage(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamdatamessage_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamDataMessage) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EAudioFormat {
	k_eaudioformatnone = 0
	k_eaudioformat16bitlittleendian = 1
	k_eaudioformatfloat = 2
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eaudioformat(e EAudioFormat, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eaudioformat_packed(e []EAudioFormat, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eaudioformat(buf []byte, tag_wiretype vproto.WireType) ?(int, EAudioFormat) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EAudioFormat(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eaudioformat_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EAudioFormat) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EVideoFormat {
	k_evideoformatnone = 0
	k_evideoformatyv12 = 1
	k_evideoformataccel = 2
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_evideoformat(e EVideoFormat, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_evideoformat_packed(e []EVideoFormat, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_evideoformat(buf []byte, tag_wiretype vproto.WireType) ?(int, EVideoFormat) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EVideoFormat(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_evideoformat_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EVideoFormat) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamStatsMessage {
	k_estreamstatsframeevents = 1
	k_estreamstatsdebugdump = 2
	k_estreamstatslogmessage = 3
	k_estreamstatsloguploadbegin = 4
	k_estreamstatsloguploaddata = 5
	k_estreamstatsloguploadcomplete = 6
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamstatsmessage(e EStreamStatsMessage, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamstatsmessage_packed(e []EStreamStatsMessage, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamstatsmessage(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamStatsMessage) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamStatsMessage(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamstatsmessage_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamStatsMessage) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamFrameEvent {
	k_estreaminputeventstart = 0
	k_estreaminputeventsend = 1
	k_estreaminputeventrecv = 2
	k_estreaminputeventqueued = 3
	k_estreaminputeventhandled = 4
	k_estreamframeeventstart = 5
	k_estreamframeeventcapturebegin = 6
	k_estreamframeeventcaptureend = 7
	k_estreamframeeventconvertbegin = 8
	k_estreamframeeventconvertend = 9
	k_estreamframeeventencodebegin = 10
	k_estreamframeeventencodeend = 11
	k_estreamframeeventsend = 12
	k_estreamframeeventrecv = 13
	k_estreamframeeventdecodebegin = 14
	k_estreamframeeventdecodeend = 15
	k_estreamframeeventuploadbegin = 16
	k_estreamframeeventuploadend = 17
	k_estreamframeeventcomplete = 18
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamframeevent(e EStreamFrameEvent, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamframeevent_packed(e []EStreamFrameEvent, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamframeevent(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamFrameEvent) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamFrameEvent(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamframeevent_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamFrameEvent) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EStreamFrameResult {
	k_estreamframeresultpending = 0
	k_estreamframeresultdisplayed = 1
	k_estreamframeresultdroppednetworkslow = 2
	k_estreamframeresultdroppednetworklost = 3
	k_estreamframeresultdroppeddecodeslow = 4
	k_estreamframeresultdroppeddecodecorrupt = 5
	k_estreamframeresultdroppedlate = 6
	k_estreamframeresultdroppedreset = 7
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamframeresult(e EStreamFrameResult, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_estreamframeresult_packed(e []EStreamFrameResult, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamframeresult(buf []byte, tag_wiretype vproto.WireType) ?(int, EStreamFrameResult) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EStreamFrameResult(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_estreamframeresult_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EStreamFrameResult) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum EFrameAccumulatedStat {
	k_eframestatfps = 0
	k_eframestatcapturedurationms = 1
	k_eframestatconvertdurationms = 2
	k_eframestatencodedurationms = 3
	k_eframestatsteamdurationms = 4
	k_eframestatserverdurationms = 5
	k_eframestatnetworkdurationms = 6
	k_eframestatdecodedurationms = 7
	k_eframestatdisplaydurationms = 8
	k_eframestatclientdurationms = 9
	k_eframestatframedurationms = 10
	k_eframestatinputlatencyms = 11
	k_eframestatgamelatencyms = 12
	k_eframestatroundtriplatencyms = 13
	k_eframestatpingtimems = 14
	k_eframestatserverbitratekbitpersec = 15
	k_eframestatclientbitratekbitpersec = 16
	k_eframestatlinkbandwidthkbitpersec = 17
	k_eframestatpacketlosspercentage = 18
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eframeaccumulatedstat(e EFrameAccumulatedStat, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_eframeaccumulatedstat_packed(e []EFrameAccumulatedStat, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eframeaccumulatedstat(buf []byte, tag_wiretype vproto.WireType) ?(int, EFrameAccumulatedStat) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EFrameAccumulatedStat(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_eframeaccumulatedstat_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EFrameAccumulatedStat) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

[_allow_multiple_values]
enum ELogFileType {
	k_elogfilesystemboot = 0
	k_elogfilesystemreset = 1
	k_elogfilesystemdebug = 2
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_elogfiletype(e ELogFileType, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_elogfiletype_packed(e []ELogFileType, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_elogfiletype(buf []byte, tag_wiretype vproto.WireType) ?(int, ELogFileType) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, ELogFileType(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_elogfiletype_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []ELogFileType) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CDiscoveryPingRequest {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	sequence                  u32
	has_sequence              bool
	packet_size_requested     u32
	has_packet_size_requested bool
}

pub fn (o &CDiscoveryPingRequest) pack() []byte {
	mut res := []byte{}
	if o.has_sequence {
		res << vproto.pack_uint32_field(o.sequence, 1)
	}
	if o.has_packet_size_requested {
		res << vproto.pack_uint32_field(o.packet_size_requested, 2)
	}
	return res
}

pub fn cdiscoverypingrequest_unpack(buf []byte) ?CDiscoveryPingRequest {
	mut res := CDiscoveryPingRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sequence = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sequence = v
				i = ii
			}
			2 {
				res.has_packet_size_requested = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.packet_size_requested = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdiscoverypingrequest() CDiscoveryPingRequest {
	return CDiscoveryPingRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdiscoverypingrequest(o CDiscoveryPingRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdiscoverypingrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CDiscoveryPingRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdiscoverypingrequest_unpack(v)?
	return i, unpacked
}

pub struct CDiscoveryPingResponse {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	sequence                 u32
	has_sequence             bool
	packet_size_received     u32
	has_packet_size_received bool
}

pub fn (o &CDiscoveryPingResponse) pack() []byte {
	mut res := []byte{}
	if o.has_sequence {
		res << vproto.pack_uint32_field(o.sequence, 1)
	}
	if o.has_packet_size_received {
		res << vproto.pack_uint32_field(o.packet_size_received, 2)
	}
	return res
}

pub fn cdiscoverypingresponse_unpack(buf []byte) ?CDiscoveryPingResponse {
	mut res := CDiscoveryPingResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sequence = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.sequence = v
				i = ii
			}
			2 {
				res.has_packet_size_received = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.packet_size_received = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdiscoverypingresponse() CDiscoveryPingResponse {
	return CDiscoveryPingResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdiscoverypingresponse(o CDiscoveryPingResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdiscoverypingresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CDiscoveryPingResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdiscoverypingresponse_unpack(v)?
	return i, unpacked
}

pub struct CStreamingClientHandshakeInfo {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	network_test     int
	has_network_test bool
}

pub fn (o &CStreamingClientHandshakeInfo) pack() []byte {
	mut res := []byte{}
	if o.has_network_test {
		res << vproto.pack_int32_field(o.network_test, 2)
	}
	return res
}

pub fn cstreamingclienthandshakeinfo_unpack(buf []byte) ?CStreamingClientHandshakeInfo {
	mut res := CStreamingClientHandshakeInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				res.has_network_test = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.network_test = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstreamingclienthandshakeinfo() CStreamingClientHandshakeInfo {
	return CStreamingClientHandshakeInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstreamingclienthandshakeinfo(o CStreamingClientHandshakeInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstreamingclienthandshakeinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CStreamingClientHandshakeInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstreamingclienthandshakeinfo_unpack(v)?
	return i, unpacked
}

pub struct CClientHandshakeMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	info           CStreamingClientHandshakeInfo
}

pub fn (o &CClientHandshakeMsg) pack() []byte {
	mut res := []byte{}
	res << zzz_vproto_internal_pack_cstreamingclienthandshakeinfo(o.info, 1)
	return res
}

pub fn cclienthandshakemsg_unpack(buf []byte) ?CClientHandshakeMsg {
	mut res := CClientHandshakeMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cstreamingclienthandshakeinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.info = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cclienthandshakemsg() CClientHandshakeMsg {
	return CClientHandshakeMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cclienthandshakemsg(o CClientHandshakeMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cclienthandshakemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CClientHandshakeMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cclienthandshakemsg_unpack(v)?
	return i, unpacked
}

pub struct CStreamingServerHandshakeInfo {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	mtu            int
	has_mtu        bool
}

pub fn (o &CStreamingServerHandshakeInfo) pack() []byte {
	mut res := []byte{}
	if o.has_mtu {
		res << vproto.pack_int32_field(o.mtu, 1)
	}
	return res
}

pub fn cstreamingserverhandshakeinfo_unpack(buf []byte) ?CStreamingServerHandshakeInfo {
	mut res := CStreamingServerHandshakeInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_mtu = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.mtu = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstreamingserverhandshakeinfo() CStreamingServerHandshakeInfo {
	return CStreamingServerHandshakeInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstreamingserverhandshakeinfo(o CStreamingServerHandshakeInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstreamingserverhandshakeinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CStreamingServerHandshakeInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstreamingserverhandshakeinfo_unpack(v)?
	return i, unpacked
}

pub struct CServerHandshakeMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	info           CStreamingServerHandshakeInfo
}

pub fn (o &CServerHandshakeMsg) pack() []byte {
	mut res := []byte{}
	res << zzz_vproto_internal_pack_cstreamingserverhandshakeinfo(o.info, 1)
	return res
}

pub fn cserverhandshakemsg_unpack(buf []byte) ?CServerHandshakeMsg {
	mut res := CServerHandshakeMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cstreamingserverhandshakeinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.info = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cserverhandshakemsg() CServerHandshakeMsg {
	return CServerHandshakeMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cserverhandshakemsg(o CServerHandshakeMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cserverhandshakemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CServerHandshakeMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cserverhandshakemsg_unpack(v)?
	return i, unpacked
}

pub struct CAuthenticationRequestMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	token          []byte
	has_token      bool
	version        EStreamVersion
	has_version    bool
}

pub fn (o &CAuthenticationRequestMsg) pack() []byte {
	mut res := []byte{}
	if o.has_token {
		res << vproto.pack_bytes_field(o.token, 1)
	}
	if o.has_version {
		res << zzz_vproto_internal_pack_estreamversion(o.version, 2)
	}
	return res
}

pub fn cauthenticationrequestmsg_unpack(buf []byte) ?CAuthenticationRequestMsg {
	mut res := CAuthenticationRequestMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_token = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.token = v
				i = ii
			}
			2 {
				res.has_version = true
				ii, v := zzz_vproto_internal_unpack_estreamversion(cur_buf, tag_wiretype.wire_type)?
				res.version = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cauthenticationrequestmsg() CAuthenticationRequestMsg {
	return CAuthenticationRequestMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cauthenticationrequestmsg(o CAuthenticationRequestMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cauthenticationrequestmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CAuthenticationRequestMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cauthenticationrequestmsg_unpack(v)?
	return i, unpacked
}

[_allow_multiple_values]
enum CAuthenticationResponseMsg_AuthenticationResult {
	succeeded = 0
	failed = 1
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cauthenticationresponsemsg_authenticationresult(e CAuthenticationResponseMsg_AuthenticationResult, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_cauthenticationresponsemsg_authenticationresult_packed(e []CAuthenticationResponseMsg_AuthenticationResult, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cauthenticationresponsemsg_authenticationresult(buf []byte, tag_wiretype vproto.WireType) ?(int, CAuthenticationResponseMsg_AuthenticationResult) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, CAuthenticationResponseMsg_AuthenticationResult(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_cauthenticationresponsemsg_authenticationresult_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []CAuthenticationResponseMsg_AuthenticationResult) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CAuthenticationResponseMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	result         CAuthenticationResponseMsg_AuthenticationResult
	has_result     bool
	version        EStreamVersion
	has_version    bool
}

pub fn (o &CAuthenticationResponseMsg) pack() []byte {
	mut res := []byte{}
	if o.has_result {
		res <<
			zzz_vproto_internal_pack_cauthenticationresponsemsg_authenticationresult(o.result, 1)
	}
	if o.has_version {
		res << zzz_vproto_internal_pack_estreamversion(o.version, 2)
	}
	return res
}

pub fn cauthenticationresponsemsg_unpack(buf []byte) ?CAuthenticationResponseMsg {
	mut res := CAuthenticationResponseMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_result = true
				ii, v := zzz_vproto_internal_unpack_cauthenticationresponsemsg_authenticationresult(cur_buf,
					tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			2 {
				res.has_version = true
				ii, v := zzz_vproto_internal_unpack_estreamversion(cur_buf, tag_wiretype.wire_type)?
				res.version = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cauthenticationresponsemsg() CAuthenticationResponseMsg {
	return CAuthenticationResponseMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cauthenticationresponsemsg(o CAuthenticationResponseMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cauthenticationresponsemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CAuthenticationResponseMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cauthenticationresponsemsg_unpack(v)?
	return i, unpacked
}

pub struct CKeepAliveMsg {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CKeepAliveMsg) pack() []byte {
	res := []byte{}
	return res
}

pub fn ckeepalivemsg_unpack(buf []byte) ?CKeepAliveMsg {
	res := CKeepAliveMsg{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ckeepalivemsg() CKeepAliveMsg {
	return CKeepAliveMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ckeepalivemsg(o CKeepAliveMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ckeepalivemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CKeepAliveMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ckeepalivemsg_unpack(v)?
	return i, unpacked
}

pub struct CStartNetworkTestMsg {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	frames                 u32
	has_frames             bool
	framerate              u32
	has_framerate          bool
	bitrate_kbps           u32
	has_bitrate_kbps       bool
	burst_bitrate_kbps     u32
	has_burst_bitrate_kbps bool
	bandwidth_test         bool
	has_bandwidth_test     bool
}

pub fn (o &CStartNetworkTestMsg) pack() []byte {
	mut res := []byte{}
	if o.has_frames {
		res << vproto.pack_uint32_field(o.frames, 1)
	}
	if o.has_framerate {
		res << vproto.pack_uint32_field(o.framerate, 2)
	}
	if o.has_bitrate_kbps {
		res << vproto.pack_uint32_field(o.bitrate_kbps, 3)
	}
	if o.has_burst_bitrate_kbps {
		res << vproto.pack_uint32_field(o.burst_bitrate_kbps, 4)
	}
	if o.has_bandwidth_test {
		res << vproto.pack_bool_field(o.bandwidth_test, 5)
	}
	return res
}

pub fn cstartnetworktestmsg_unpack(buf []byte) ?CStartNetworkTestMsg {
	mut res := CStartNetworkTestMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_frames = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.frames = v
				i = ii
			}
			2 {
				res.has_framerate = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.framerate = v
				i = ii
			}
			3 {
				res.has_bitrate_kbps = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.bitrate_kbps = v
				i = ii
			}
			4 {
				res.has_burst_bitrate_kbps = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.burst_bitrate_kbps = v
				i = ii
			}
			5 {
				res.has_bandwidth_test = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.bandwidth_test = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstartnetworktestmsg() CStartNetworkTestMsg {
	return CStartNetworkTestMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstartnetworktestmsg(o CStartNetworkTestMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstartnetworktestmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CStartNetworkTestMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstartnetworktestmsg_unpack(v)?
	return i, unpacked
}

pub struct CStreamVideoMode {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	width                        u32
	height                       u32
	refresh_rate                 u32
	has_refresh_rate             bool
	refresh_rate_numerator       u32
	has_refresh_rate_numerator   bool
	refresh_rate_denominator     u32
	has_refresh_rate_denominator bool
}

pub fn (o &CStreamVideoMode) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint32_field(o.width, 1)
	res << vproto.pack_uint32_field(o.height, 2)
	if o.has_refresh_rate {
		res << vproto.pack_uint32_field(o.refresh_rate, 3)
	}
	if o.has_refresh_rate_numerator {
		res << vproto.pack_uint32_field(o.refresh_rate_numerator, 4)
	}
	if o.has_refresh_rate_denominator {
		res << vproto.pack_uint32_field(o.refresh_rate_denominator, 5)
	}
	return res
}

pub fn cstreamvideomode_unpack(buf []byte) ?CStreamVideoMode {
	mut res := CStreamVideoMode{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			3 {
				res.has_refresh_rate = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.refresh_rate = v
				i = ii
			}
			4 {
				res.has_refresh_rate_numerator = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.refresh_rate_numerator = v
				i = ii
			}
			5 {
				res.has_refresh_rate_denominator = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.refresh_rate_denominator = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstreamvideomode() CStreamVideoMode {
	return CStreamVideoMode{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstreamvideomode(o CStreamVideoMode, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstreamvideomode(buf []byte, tag_wiretype vproto.WireType) ?(int, CStreamVideoMode) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstreamvideomode_unpack(v)?
	return i, unpacked
}

pub struct CStreamingClientCaps {
mut:
	unknown_fields                       []vproto.UnknownField
pub mut:
	system_info                          string
	has_system_info                      bool
	system_can_suspend                   bool
	has_system_can_suspend               bool
	maximum_decode_bitrate_kbps          int
	has_maximum_decode_bitrate_kbps      bool
	maximum_burst_bitrate_kbps           int
	has_maximum_burst_bitrate_kbps       bool
	supports_video_hevc                  bool
	has_supports_video_hevc              bool
	disable_steam_store                  bool
	has_disable_steam_store              bool
	disable_client_cursor                bool
	has_disable_client_cursor            bool
	disable_intel_hardware_encoding      bool
	has_disable_intel_hardware_encoding  bool
	disable_amd_hardware_encoding        bool
	has_disable_amd_hardware_encoding    bool
	disable_nvidia_hardware_encoding     bool
	has_disable_nvidia_hardware_encoding bool
	form_factor                          int
	has_form_factor                      bool
}

pub fn (o &CStreamingClientCaps) pack() []byte {
	mut res := []byte{}
	if o.has_system_info {
		res << vproto.pack_string_field(o.system_info, 1)
	}
	if o.has_system_can_suspend {
		res << vproto.pack_bool_field(o.system_can_suspend, 2)
	}
	if o.has_maximum_decode_bitrate_kbps {
		res << vproto.pack_int32_field(o.maximum_decode_bitrate_kbps, 3)
	}
	if o.has_maximum_burst_bitrate_kbps {
		res << vproto.pack_int32_field(o.maximum_burst_bitrate_kbps, 4)
	}
	if o.has_supports_video_hevc {
		res << vproto.pack_bool_field(o.supports_video_hevc, 5)
	}
	if o.has_disable_steam_store {
		res << vproto.pack_bool_field(o.disable_steam_store, 6)
	}
	if o.has_disable_client_cursor {
		res << vproto.pack_bool_field(o.disable_client_cursor, 7)
	}
	if o.has_disable_intel_hardware_encoding {
		res << vproto.pack_bool_field(o.disable_intel_hardware_encoding, 8)
	}
	if o.has_disable_amd_hardware_encoding {
		res << vproto.pack_bool_field(o.disable_amd_hardware_encoding, 9)
	}
	if o.has_disable_nvidia_hardware_encoding {
		res << vproto.pack_bool_field(o.disable_nvidia_hardware_encoding, 10)
	}
	if o.has_form_factor {
		res << vproto.pack_int32_field(o.form_factor, 11)
	}
	return res
}

pub fn cstreamingclientcaps_unpack(buf []byte) ?CStreamingClientCaps {
	mut res := CStreamingClientCaps{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_system_info = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.system_info = v
				i = ii
			}
			2 {
				res.has_system_can_suspend = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.system_can_suspend = v
				i = ii
			}
			3 {
				res.has_maximum_decode_bitrate_kbps = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.maximum_decode_bitrate_kbps = v
				i = ii
			}
			4 {
				res.has_maximum_burst_bitrate_kbps = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.maximum_burst_bitrate_kbps = v
				i = ii
			}
			5 {
				res.has_supports_video_hevc = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.supports_video_hevc = v
				i = ii
			}
			6 {
				res.has_disable_steam_store = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.disable_steam_store = v
				i = ii
			}
			7 {
				res.has_disable_client_cursor = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.disable_client_cursor = v
				i = ii
			}
			8 {
				res.has_disable_intel_hardware_encoding = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.disable_intel_hardware_encoding = v
				i = ii
			}
			9 {
				res.has_disable_amd_hardware_encoding = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.disable_amd_hardware_encoding = v
				i = ii
			}
			10 {
				res.has_disable_nvidia_hardware_encoding = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.disable_nvidia_hardware_encoding = v
				i = ii
			}
			11 {
				res.has_form_factor = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.form_factor = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstreamingclientcaps() CStreamingClientCaps {
	return CStreamingClientCaps{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstreamingclientcaps(o CStreamingClientCaps, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstreamingclientcaps(buf []byte, tag_wiretype vproto.WireType) ?(int, CStreamingClientCaps) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstreamingclientcaps_unpack(v)?
	return i, unpacked
}

pub struct CStreamingClientConfig {
mut:
	unknown_fields                    []vproto.UnknownField
pub mut:
	quality                           EStreamQualityPreference
	has_quality                       bool
	maximum_resolution_x              u32
	has_maximum_resolution_x          bool
	maximum_resolution_y              u32
	has_maximum_resolution_y          bool
	maximum_framerate_numerator       u32
	has_maximum_framerate_numerator   bool
	maximum_framerate_denominator     u32
	has_maximum_framerate_denominator bool
	maximum_bitrate_kbps              int
	has_maximum_bitrate_kbps          bool
	enable_hardware_decoding          bool
	has_enable_hardware_decoding      bool
	enable_performance_overlay        bool
	has_enable_performance_overlay    bool
	enable_video_streaming            bool
	has_enable_video_streaming        bool
	enable_audio_streaming            bool
	has_enable_audio_streaming        bool
	enable_input_streaming            bool
	has_enable_input_streaming        bool
	audio_channels                    int
	has_audio_channels                bool
	enable_video_hevc                 bool
	has_enable_video_hevc             bool
	enable_performance_icons          bool
	has_enable_performance_icons      bool
	enable_microphone_streaming       bool
	has_enable_microphone_streaming   bool
	controller_overlay_hotkey         string
	has_controller_overlay_hotkey     bool
	enable_touch_controller           bool
	has_enable_touch_controller       bool
	p2p_scope                         EStreamP2PScope
	has_p2p_scope                     bool
}

pub fn (o &CStreamingClientConfig) pack() []byte {
	mut res := []byte{}
	if o.has_quality {
		res << zzz_vproto_internal_pack_estreamqualitypreference(o.quality, 1)
	}
	if o.has_maximum_resolution_x {
		res << vproto.pack_uint32_field(o.maximum_resolution_x, 2)
	}
	if o.has_maximum_resolution_y {
		res << vproto.pack_uint32_field(o.maximum_resolution_y, 3)
	}
	if o.has_maximum_framerate_numerator {
		res << vproto.pack_uint32_field(o.maximum_framerate_numerator, 4)
	}
	if o.has_maximum_framerate_denominator {
		res << vproto.pack_uint32_field(o.maximum_framerate_denominator, 5)
	}
	if o.has_maximum_bitrate_kbps {
		res << vproto.pack_int32_field(o.maximum_bitrate_kbps, 6)
	}
	if o.has_enable_hardware_decoding {
		res << vproto.pack_bool_field(o.enable_hardware_decoding, 7)
	}
	if o.has_enable_performance_overlay {
		res << vproto.pack_bool_field(o.enable_performance_overlay, 8)
	}
	if o.has_enable_video_streaming {
		res << vproto.pack_bool_field(o.enable_video_streaming, 9)
	}
	if o.has_enable_audio_streaming {
		res << vproto.pack_bool_field(o.enable_audio_streaming, 10)
	}
	if o.has_enable_input_streaming {
		res << vproto.pack_bool_field(o.enable_input_streaming, 11)
	}
	if o.has_audio_channels {
		res << vproto.pack_int32_field(o.audio_channels, 12)
	}
	if o.has_enable_video_hevc {
		res << vproto.pack_bool_field(o.enable_video_hevc, 13)
	}
	if o.has_enable_performance_icons {
		res << vproto.pack_bool_field(o.enable_performance_icons, 14)
	}
	if o.has_enable_microphone_streaming {
		res << vproto.pack_bool_field(o.enable_microphone_streaming, 15)
	}
	if o.has_controller_overlay_hotkey {
		res << vproto.pack_string_field(o.controller_overlay_hotkey, 16)
	}
	if o.has_enable_touch_controller {
		res << vproto.pack_bool_field(o.enable_touch_controller, 17)
	}
	if o.has_p2p_scope {
		res << zzz_vproto_internal_pack_estreamp2pscope(o.p2p_scope, 18)
	}
	return res
}

pub fn cstreamingclientconfig_unpack(buf []byte) ?CStreamingClientConfig {
	mut res := CStreamingClientConfig{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_quality = true
				ii, v := zzz_vproto_internal_unpack_estreamqualitypreference(cur_buf,
					tag_wiretype.wire_type)?
				res.quality = v
				i = ii
			}
			2 {
				res.has_maximum_resolution_x = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.maximum_resolution_x = v
				i = ii
			}
			3 {
				res.has_maximum_resolution_y = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.maximum_resolution_y = v
				i = ii
			}
			4 {
				res.has_maximum_framerate_numerator = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.maximum_framerate_numerator = v
				i = ii
			}
			5 {
				res.has_maximum_framerate_denominator = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.maximum_framerate_denominator = v
				i = ii
			}
			6 {
				res.has_maximum_bitrate_kbps = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.maximum_bitrate_kbps = v
				i = ii
			}
			7 {
				res.has_enable_hardware_decoding = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_hardware_decoding = v
				i = ii
			}
			8 {
				res.has_enable_performance_overlay = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_performance_overlay = v
				i = ii
			}
			9 {
				res.has_enable_video_streaming = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_video_streaming = v
				i = ii
			}
			10 {
				res.has_enable_audio_streaming = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_audio_streaming = v
				i = ii
			}
			11 {
				res.has_enable_input_streaming = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_input_streaming = v
				i = ii
			}
			12 {
				res.has_audio_channels = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.audio_channels = v
				i = ii
			}
			13 {
				res.has_enable_video_hevc = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_video_hevc = v
				i = ii
			}
			14 {
				res.has_enable_performance_icons = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_performance_icons = v
				i = ii
			}
			15 {
				res.has_enable_microphone_streaming = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_microphone_streaming = v
				i = ii
			}
			16 {
				res.has_controller_overlay_hotkey = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_overlay_hotkey = v
				i = ii
			}
			17 {
				res.has_enable_touch_controller = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_touch_controller = v
				i = ii
			}
			18 {
				res.has_p2p_scope = true
				ii, v := zzz_vproto_internal_unpack_estreamp2pscope(cur_buf, tag_wiretype.wire_type)?
				res.p2p_scope = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstreamingclientconfig() CStreamingClientConfig {
	return CStreamingClientConfig{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstreamingclientconfig(o CStreamingClientConfig, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstreamingclientconfig(buf []byte, tag_wiretype vproto.WireType) ?(int, CStreamingClientConfig) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstreamingclientconfig_unpack(v)?
	return i, unpacked
}

pub struct CStreamingServerConfig {
mut:
	unknown_fields                      []vproto.UnknownField
pub mut:
	change_desktop_resolution           bool
	has_change_desktop_resolution       bool
	dynamically_adjust_resolution       bool
	has_dynamically_adjust_resolution   bool
	enable_capture_nvfbc                bool
	has_enable_capture_nvfbc            bool
	enable_hardware_encoding_nvidia     bool
	has_enable_hardware_encoding_nvidia bool
	enable_hardware_encoding_amd        bool
	has_enable_hardware_encoding_amd    bool
	enable_hardware_encoding_intel      bool
	has_enable_hardware_encoding_intel  bool
	software_encoding_threads           int
	has_software_encoding_threads       bool
	enable_traffic_priority             bool
	has_enable_traffic_priority         bool
	host_play_audio                     EStreamHostPlayAudioPreference
	has_host_play_audio                 bool
}

pub fn (o &CStreamingServerConfig) pack() []byte {
	mut res := []byte{}
	if o.has_change_desktop_resolution {
		res << vproto.pack_bool_field(o.change_desktop_resolution, 1)
	}
	if o.has_dynamically_adjust_resolution {
		res << vproto.pack_bool_field(o.dynamically_adjust_resolution, 2)
	}
	if o.has_enable_capture_nvfbc {
		res << vproto.pack_bool_field(o.enable_capture_nvfbc, 3)
	}
	if o.has_enable_hardware_encoding_nvidia {
		res << vproto.pack_bool_field(o.enable_hardware_encoding_nvidia, 4)
	}
	if o.has_enable_hardware_encoding_amd {
		res << vproto.pack_bool_field(o.enable_hardware_encoding_amd, 5)
	}
	if o.has_enable_hardware_encoding_intel {
		res << vproto.pack_bool_field(o.enable_hardware_encoding_intel, 6)
	}
	if o.has_software_encoding_threads {
		res << vproto.pack_int32_field(o.software_encoding_threads, 7)
	}
	if o.has_enable_traffic_priority {
		res << vproto.pack_bool_field(o.enable_traffic_priority, 8)
	}
	if o.has_host_play_audio {
		res << zzz_vproto_internal_pack_estreamhostplayaudiopreference(o.host_play_audio, 9)
	}
	return res
}

pub fn cstreamingserverconfig_unpack(buf []byte) ?CStreamingServerConfig {
	mut res := CStreamingServerConfig{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_change_desktop_resolution = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.change_desktop_resolution = v
				i = ii
			}
			2 {
				res.has_dynamically_adjust_resolution = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.dynamically_adjust_resolution = v
				i = ii
			}
			3 {
				res.has_enable_capture_nvfbc = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_capture_nvfbc = v
				i = ii
			}
			4 {
				res.has_enable_hardware_encoding_nvidia = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_hardware_encoding_nvidia = v
				i = ii
			}
			5 {
				res.has_enable_hardware_encoding_amd = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_hardware_encoding_amd = v
				i = ii
			}
			6 {
				res.has_enable_hardware_encoding_intel = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_hardware_encoding_intel = v
				i = ii
			}
			7 {
				res.has_software_encoding_threads = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.software_encoding_threads = v
				i = ii
			}
			8 {
				res.has_enable_traffic_priority = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_traffic_priority = v
				i = ii
			}
			9 {
				res.has_host_play_audio = true
				ii, v := zzz_vproto_internal_unpack_estreamhostplayaudiopreference(cur_buf,
					tag_wiretype.wire_type)?
				res.host_play_audio = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstreamingserverconfig() CStreamingServerConfig {
	return CStreamingServerConfig{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstreamingserverconfig(o CStreamingServerConfig, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstreamingserverconfig(buf []byte, tag_wiretype vproto.WireType) ?(int, CStreamingServerConfig) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstreamingserverconfig_unpack(v)?
	return i, unpacked
}

pub struct CNegotiatedConfig {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	reliable_data            bool
	has_reliable_data        bool
	selected_audio_codec     EStreamAudioCodec
	has_selected_audio_codec bool
	selected_video_codec     EStreamVideoCodec
	has_selected_video_codec bool
	available_video_modes    []CStreamVideoMode
	enable_remote_hid        bool
	has_enable_remote_hid    bool
	enable_touch_input       bool
	has_enable_touch_input   bool
}

pub fn (o &CNegotiatedConfig) pack() []byte {
	mut res := []byte{}
	if o.has_reliable_data {
		res << vproto.pack_bool_field(o.reliable_data, 1)
	}
	if o.has_selected_audio_codec {
		res << zzz_vproto_internal_pack_estreamaudiocodec(o.selected_audio_codec, 2)
	}
	if o.has_selected_video_codec {
		res << zzz_vproto_internal_pack_estreamvideocodec(o.selected_video_codec, 3)
	}
	// [packed=false]
	for _, x in o.available_video_modes {
		res << zzz_vproto_internal_pack_cstreamvideomode(x, 4)
	}
	if o.has_enable_remote_hid {
		res << vproto.pack_bool_field(o.enable_remote_hid, 5)
	}
	if o.has_enable_touch_input {
		res << vproto.pack_bool_field(o.enable_touch_input, 6)
	}
	return res
}

pub fn cnegotiatedconfig_unpack(buf []byte) ?CNegotiatedConfig {
	mut res := CNegotiatedConfig{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_reliable_data = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.reliable_data = v
				i = ii
			}
			2 {
				res.has_selected_audio_codec = true
				ii, v := zzz_vproto_internal_unpack_estreamaudiocodec(cur_buf, tag_wiretype.wire_type)?
				res.selected_audio_codec = v
				i = ii
			}
			3 {
				res.has_selected_video_codec = true
				ii, v := zzz_vproto_internal_unpack_estreamvideocodec(cur_buf, tag_wiretype.wire_type)?
				res.selected_video_codec = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstreamvideomode(cur_buf, tag_wiretype.wire_type)?
				res.available_video_modes << v
				i = ii
			}
			5 {
				res.has_enable_remote_hid = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_remote_hid = v
				i = ii
			}
			6 {
				res.has_enable_touch_input = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enable_touch_input = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cnegotiatedconfig() CNegotiatedConfig {
	return CNegotiatedConfig{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cnegotiatedconfig(o CNegotiatedConfig, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cnegotiatedconfig(buf []byte, tag_wiretype vproto.WireType) ?(int, CNegotiatedConfig) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cnegotiatedconfig_unpack(v)?
	return i, unpacked
}

pub struct CNegotiationInitMsg {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	reliable_data            bool
	has_reliable_data        bool
	supported_audio_codecs   []EStreamAudioCodec
	supported_video_codecs   []EStreamVideoCodec
	supports_remote_hid      bool
	has_supports_remote_hid  bool
	supports_touch_input     bool
	has_supports_touch_input bool
}

pub fn (o &CNegotiationInitMsg) pack() []byte {
	mut res := []byte{}
	if o.has_reliable_data {
		res << vproto.pack_bool_field(o.reliable_data, 1)
	}
	// [packed=false]
	for _, x in o.supported_audio_codecs {
		res << zzz_vproto_internal_pack_estreamaudiocodec(x, 2)
	}
	// [packed=false]
	for _, x in o.supported_video_codecs {
		res << zzz_vproto_internal_pack_estreamvideocodec(x, 3)
	}
	if o.has_supports_remote_hid {
		res << vproto.pack_bool_field(o.supports_remote_hid, 4)
	}
	if o.has_supports_touch_input {
		res << vproto.pack_bool_field(o.supports_touch_input, 5)
	}
	return res
}

pub fn cnegotiationinitmsg_unpack(buf []byte) ?CNegotiationInitMsg {
	mut res := CNegotiationInitMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_reliable_data = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.reliable_data = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_estreamaudiocodec(cur_buf, tag_wiretype.wire_type)?
				res.supported_audio_codecs << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_estreamvideocodec(cur_buf, tag_wiretype.wire_type)?
				res.supported_video_codecs << v
				i = ii
			}
			4 {
				res.has_supports_remote_hid = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.supports_remote_hid = v
				i = ii
			}
			5 {
				res.has_supports_touch_input = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.supports_touch_input = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cnegotiationinitmsg() CNegotiationInitMsg {
	return CNegotiationInitMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cnegotiationinitmsg(o CNegotiationInitMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cnegotiationinitmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CNegotiationInitMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cnegotiationinitmsg_unpack(v)?
	return i, unpacked
}

pub struct CNegotiationSetConfigMsg {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	config                      CNegotiatedConfig
	streaming_client_config     CStreamingClientConfig
	has_streaming_client_config bool
	streaming_client_caps       CStreamingClientCaps
	has_streaming_client_caps   bool
}

pub fn (o &CNegotiationSetConfigMsg) pack() []byte {
	mut res := []byte{}
	res << zzz_vproto_internal_pack_cnegotiatedconfig(o.config, 1)
	if o.has_streaming_client_config {
		res << zzz_vproto_internal_pack_cstreamingclientconfig(o.streaming_client_config, 2)
	}
	if o.has_streaming_client_caps {
		res << zzz_vproto_internal_pack_cstreamingclientcaps(o.streaming_client_caps, 3)
	}
	return res
}

pub fn cnegotiationsetconfigmsg_unpack(buf []byte) ?CNegotiationSetConfigMsg {
	mut res := CNegotiationSetConfigMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cnegotiatedconfig(cur_buf, tag_wiretype.wire_type)?
				res.config = v
				i = ii
			}
			2 {
				res.has_streaming_client_config = true
				ii, v := zzz_vproto_internal_unpack_cstreamingclientconfig(cur_buf, tag_wiretype.wire_type)?
				res.streaming_client_config = v
				i = ii
			}
			3 {
				res.has_streaming_client_caps = true
				ii, v := zzz_vproto_internal_unpack_cstreamingclientcaps(cur_buf, tag_wiretype.wire_type)?
				res.streaming_client_caps = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cnegotiationsetconfigmsg() CNegotiationSetConfigMsg {
	return CNegotiationSetConfigMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cnegotiationsetconfigmsg(o CNegotiationSetConfigMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cnegotiationsetconfigmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CNegotiationSetConfigMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cnegotiationsetconfigmsg_unpack(v)?
	return i, unpacked
}

pub struct CNegotiationCompleteMsg {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CNegotiationCompleteMsg) pack() []byte {
	res := []byte{}
	return res
}

pub fn cnegotiationcompletemsg_unpack(buf []byte) ?CNegotiationCompleteMsg {
	res := CNegotiationCompleteMsg{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cnegotiationcompletemsg() CNegotiationCompleteMsg {
	return CNegotiationCompleteMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cnegotiationcompletemsg(o CNegotiationCompleteMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cnegotiationcompletemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CNegotiationCompleteMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cnegotiationcompletemsg_unpack(v)?
	return i, unpacked
}

pub struct CStartAudioDataMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	channel        u32
	codec          EStreamAudioCodec
	has_codec      bool
	codec_data     []byte
	has_codec_data bool
	frequency      u32
	has_frequency  bool
	channels       u32
	has_channels   bool
}

pub fn (o &CStartAudioDataMsg) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint32_field(o.channel, 2)
	if o.has_codec {
		res << zzz_vproto_internal_pack_estreamaudiocodec(o.codec, 3)
	}
	if o.has_codec_data {
		res << vproto.pack_bytes_field(o.codec_data, 4)
	}
	if o.has_frequency {
		res << vproto.pack_uint32_field(o.frequency, 5)
	}
	if o.has_channels {
		res << vproto.pack_uint32_field(o.channels, 6)
	}
	return res
}

pub fn cstartaudiodatamsg_unpack(buf []byte) ?CStartAudioDataMsg {
	mut res := CStartAudioDataMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.channel = v
				i = ii
			}
			3 {
				res.has_codec = true
				ii, v := zzz_vproto_internal_unpack_estreamaudiocodec(cur_buf, tag_wiretype.wire_type)?
				res.codec = v
				i = ii
			}
			4 {
				res.has_codec_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.codec_data = v
				i = ii
			}
			5 {
				res.has_frequency = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.frequency = v
				i = ii
			}
			6 {
				res.has_channels = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.channels = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstartaudiodatamsg() CStartAudioDataMsg {
	return CStartAudioDataMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstartaudiodatamsg(o CStartAudioDataMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstartaudiodatamsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CStartAudioDataMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstartaudiodatamsg_unpack(v)?
	return i, unpacked
}

pub struct CStopAudioDataMsg {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CStopAudioDataMsg) pack() []byte {
	res := []byte{}
	return res
}

pub fn cstopaudiodatamsg_unpack(buf []byte) ?CStopAudioDataMsg {
	res := CStopAudioDataMsg{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstopaudiodatamsg() CStopAudioDataMsg {
	return CStopAudioDataMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstopaudiodatamsg(o CStopAudioDataMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstopaudiodatamsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CStopAudioDataMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstopaudiodatamsg_unpack(v)?
	return i, unpacked
}

pub struct CStartVideoDataMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	channel        u32
	codec          EStreamVideoCodec
	has_codec      bool
	codec_data     []byte
	has_codec_data bool
	width          u32
	has_width      bool
	height         u32
	has_height     bool
}

pub fn (o &CStartVideoDataMsg) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint32_field(o.channel, 1)
	if o.has_codec {
		res << zzz_vproto_internal_pack_estreamvideocodec(o.codec, 2)
	}
	if o.has_codec_data {
		res << vproto.pack_bytes_field(o.codec_data, 3)
	}
	if o.has_width {
		res << vproto.pack_uint32_field(o.width, 4)
	}
	if o.has_height {
		res << vproto.pack_uint32_field(o.height, 5)
	}
	return res
}

pub fn cstartvideodatamsg_unpack(buf []byte) ?CStartVideoDataMsg {
	mut res := CStartVideoDataMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.channel = v
				i = ii
			}
			2 {
				res.has_codec = true
				ii, v := zzz_vproto_internal_unpack_estreamvideocodec(cur_buf, tag_wiretype.wire_type)?
				res.codec = v
				i = ii
			}
			3 {
				res.has_codec_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.codec_data = v
				i = ii
			}
			4 {
				res.has_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			5 {
				res.has_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstartvideodatamsg() CStartVideoDataMsg {
	return CStartVideoDataMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstartvideodatamsg(o CStartVideoDataMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstartvideodatamsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CStartVideoDataMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstartvideodatamsg_unpack(v)?
	return i, unpacked
}

pub struct CStopVideoDataMsg {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CStopVideoDataMsg) pack() []byte {
	res := []byte{}
	return res
}

pub fn cstopvideodatamsg_unpack(buf []byte) ?CStopVideoDataMsg {
	res := CStopVideoDataMsg{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstopvideodatamsg() CStopVideoDataMsg {
	return CStopVideoDataMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstopvideodatamsg(o CStopVideoDataMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstopvideodatamsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CStopVideoDataMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstopvideodatamsg_unpack(v)?
	return i, unpacked
}

pub struct CRecordedInput {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	@type          EStreamControlMessage
	has_type       bool
	timestamp      u32
	has_timestamp  bool
}

pub fn (o &CRecordedInput) pack() []byte {
	mut res := []byte{}
	if o.has_type {
		res << zzz_vproto_internal_pack_estreamcontrolmessage(o.@type, 1)
	}
	if o.has_timestamp {
		res << vproto.pack_uint32_field(o.timestamp, 2)
	}
	return res
}

pub fn crecordedinput_unpack(buf []byte) ?CRecordedInput {
	mut res := CRecordedInput{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_type = true
				ii, v := zzz_vproto_internal_unpack_estreamcontrolmessage(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			2 {
				res.has_timestamp = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_crecordedinput() CRecordedInput {
	return CRecordedInput{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_crecordedinput(o CRecordedInput, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_crecordedinput(buf []byte, tag_wiretype vproto.WireType) ?(int, CRecordedInput) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := crecordedinput_unpack(v)?
	return i, unpacked
}

pub struct CRecordedInputStream {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	entries        []CRecordedInput
}

pub fn (o &CRecordedInputStream) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.entries {
		res << zzz_vproto_internal_pack_crecordedinput(x, 1)
	}
	return res
}

pub fn crecordedinputstream_unpack(buf []byte) ?CRecordedInputStream {
	mut res := CRecordedInputStream{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_crecordedinput(cur_buf, tag_wiretype.wire_type)?
				res.entries << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_crecordedinputstream() CRecordedInputStream {
	return CRecordedInputStream{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_crecordedinputstream(o CRecordedInputStream, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_crecordedinputstream(buf []byte, tag_wiretype vproto.WireType) ?(int, CRecordedInputStream) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := crecordedinputstream_unpack(v)?
	return i, unpacked
}

pub struct CInputLatencyTestMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	input_mark     u32
	color          u32
	has_color      bool
}

pub fn (o &CInputLatencyTestMsg) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint32_field(o.input_mark, 1)
	if o.has_color {
		res << vproto.pack_uint32_field(o.color, 2)
	}
	return res
}

pub fn cinputlatencytestmsg_unpack(buf []byte) ?CInputLatencyTestMsg {
	mut res := CInputLatencyTestMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_mark = v
				i = ii
			}
			2 {
				res.has_color = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.color = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinputlatencytestmsg() CInputLatencyTestMsg {
	return CInputLatencyTestMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinputlatencytestmsg(o CInputLatencyTestMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinputlatencytestmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CInputLatencyTestMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinputlatencytestmsg_unpack(v)?
	return i, unpacked
}

pub struct CInputTouchFingerDownMsg {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	input_mark       u32
	has_input_mark   bool
	fingerid         u64
	has_fingerid     bool
	x_normalized     f32
	has_x_normalized bool
	y_normalized     f32
	has_y_normalized bool
}

pub fn (o &CInputTouchFingerDownMsg) pack() []byte {
	mut res := []byte{}
	if o.has_input_mark {
		res << vproto.pack_uint32_field(o.input_mark, 1)
	}
	if o.has_fingerid {
		res << vproto.pack_uint64_field(o.fingerid, 2)
	}
	if o.has_x_normalized {
		res << vproto.pack_float_field(o.x_normalized, 3)
	}
	if o.has_y_normalized {
		res << vproto.pack_float_field(o.y_normalized, 4)
	}
	return res
}

pub fn cinputtouchfingerdownmsg_unpack(buf []byte) ?CInputTouchFingerDownMsg {
	mut res := CInputTouchFingerDownMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_input_mark = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_mark = v
				i = ii
			}
			2 {
				res.has_fingerid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.fingerid = v
				i = ii
			}
			3 {
				res.has_x_normalized = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.x_normalized = v
				i = ii
			}
			4 {
				res.has_y_normalized = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.y_normalized = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinputtouchfingerdownmsg() CInputTouchFingerDownMsg {
	return CInputTouchFingerDownMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinputtouchfingerdownmsg(o CInputTouchFingerDownMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinputtouchfingerdownmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CInputTouchFingerDownMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinputtouchfingerdownmsg_unpack(v)?
	return i, unpacked
}

pub struct CInputTouchFingerMotionMsg {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	input_mark       u32
	has_input_mark   bool
	fingerid         u64
	has_fingerid     bool
	x_normalized     f32
	has_x_normalized bool
	y_normalized     f32
	has_y_normalized bool
}

pub fn (o &CInputTouchFingerMotionMsg) pack() []byte {
	mut res := []byte{}
	if o.has_input_mark {
		res << vproto.pack_uint32_field(o.input_mark, 1)
	}
	if o.has_fingerid {
		res << vproto.pack_uint64_field(o.fingerid, 2)
	}
	if o.has_x_normalized {
		res << vproto.pack_float_field(o.x_normalized, 3)
	}
	if o.has_y_normalized {
		res << vproto.pack_float_field(o.y_normalized, 4)
	}
	return res
}

pub fn cinputtouchfingermotionmsg_unpack(buf []byte) ?CInputTouchFingerMotionMsg {
	mut res := CInputTouchFingerMotionMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_input_mark = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_mark = v
				i = ii
			}
			2 {
				res.has_fingerid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.fingerid = v
				i = ii
			}
			3 {
				res.has_x_normalized = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.x_normalized = v
				i = ii
			}
			4 {
				res.has_y_normalized = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.y_normalized = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinputtouchfingermotionmsg() CInputTouchFingerMotionMsg {
	return CInputTouchFingerMotionMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinputtouchfingermotionmsg(o CInputTouchFingerMotionMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinputtouchfingermotionmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CInputTouchFingerMotionMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinputtouchfingermotionmsg_unpack(v)?
	return i, unpacked
}

pub struct CInputTouchFingerUpMsg {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	input_mark       u32
	has_input_mark   bool
	fingerid         u64
	has_fingerid     bool
	x_normalized     f32
	has_x_normalized bool
	y_normalized     f32
	has_y_normalized bool
}

pub fn (o &CInputTouchFingerUpMsg) pack() []byte {
	mut res := []byte{}
	if o.has_input_mark {
		res << vproto.pack_uint32_field(o.input_mark, 1)
	}
	if o.has_fingerid {
		res << vproto.pack_uint64_field(o.fingerid, 2)
	}
	if o.has_x_normalized {
		res << vproto.pack_float_field(o.x_normalized, 3)
	}
	if o.has_y_normalized {
		res << vproto.pack_float_field(o.y_normalized, 4)
	}
	return res
}

pub fn cinputtouchfingerupmsg_unpack(buf []byte) ?CInputTouchFingerUpMsg {
	mut res := CInputTouchFingerUpMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_input_mark = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_mark = v
				i = ii
			}
			2 {
				res.has_fingerid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.fingerid = v
				i = ii
			}
			3 {
				res.has_x_normalized = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.x_normalized = v
				i = ii
			}
			4 {
				res.has_y_normalized = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.y_normalized = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinputtouchfingerupmsg() CInputTouchFingerUpMsg {
	return CInputTouchFingerUpMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinputtouchfingerupmsg(o CInputTouchFingerUpMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinputtouchfingerupmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CInputTouchFingerUpMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinputtouchfingerupmsg_unpack(v)?
	return i, unpacked
}

pub struct CInputMouseMotionMsg {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	input_mark       u32
	has_input_mark   bool
	x_normalized     f32
	has_x_normalized bool
	y_normalized     f32
	has_y_normalized bool
	dx               int
	has_dx           bool
	dy               int
	has_dy           bool
}

pub fn (o &CInputMouseMotionMsg) pack() []byte {
	mut res := []byte{}
	if o.has_input_mark {
		res << vproto.pack_uint32_field(o.input_mark, 1)
	}
	if o.has_x_normalized {
		res << vproto.pack_float_field(o.x_normalized, 2)
	}
	if o.has_y_normalized {
		res << vproto.pack_float_field(o.y_normalized, 3)
	}
	if o.has_dx {
		res << vproto.pack_int32_field(o.dx, 4)
	}
	if o.has_dy {
		res << vproto.pack_int32_field(o.dy, 5)
	}
	return res
}

pub fn cinputmousemotionmsg_unpack(buf []byte) ?CInputMouseMotionMsg {
	mut res := CInputMouseMotionMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_input_mark = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_mark = v
				i = ii
			}
			2 {
				res.has_x_normalized = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.x_normalized = v
				i = ii
			}
			3 {
				res.has_y_normalized = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.y_normalized = v
				i = ii
			}
			4 {
				res.has_dx = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.dx = v
				i = ii
			}
			5 {
				res.has_dy = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.dy = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinputmousemotionmsg() CInputMouseMotionMsg {
	return CInputMouseMotionMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinputmousemotionmsg(o CInputMouseMotionMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinputmousemotionmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CInputMouseMotionMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinputmousemotionmsg_unpack(v)?
	return i, unpacked
}

pub struct CInputMouseWheelMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	input_mark     u32
	has_input_mark bool
	direction      EStreamMouseWheelDirection
}

pub fn (o &CInputMouseWheelMsg) pack() []byte {
	mut res := []byte{}
	if o.has_input_mark {
		res << vproto.pack_uint32_field(o.input_mark, 1)
	}
	res << zzz_vproto_internal_pack_estreammousewheeldirection(o.direction, 2)
	return res
}

pub fn cinputmousewheelmsg_unpack(buf []byte) ?CInputMouseWheelMsg {
	mut res := CInputMouseWheelMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_input_mark = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_mark = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_estreammousewheeldirection(cur_buf,
					tag_wiretype.wire_type)?
				res.direction = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinputmousewheelmsg() CInputMouseWheelMsg {
	return CInputMouseWheelMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinputmousewheelmsg(o CInputMouseWheelMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinputmousewheelmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CInputMouseWheelMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinputmousewheelmsg_unpack(v)?
	return i, unpacked
}

pub struct CInputMouseDownMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	input_mark     u32
	has_input_mark bool
	button         EStreamMouseButton
}

pub fn (o &CInputMouseDownMsg) pack() []byte {
	mut res := []byte{}
	if o.has_input_mark {
		res << vproto.pack_uint32_field(o.input_mark, 1)
	}
	res << zzz_vproto_internal_pack_estreammousebutton(o.button, 2)
	return res
}

pub fn cinputmousedownmsg_unpack(buf []byte) ?CInputMouseDownMsg {
	mut res := CInputMouseDownMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_input_mark = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_mark = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_estreammousebutton(cur_buf, tag_wiretype.wire_type)?
				res.button = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinputmousedownmsg() CInputMouseDownMsg {
	return CInputMouseDownMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinputmousedownmsg(o CInputMouseDownMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinputmousedownmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CInputMouseDownMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinputmousedownmsg_unpack(v)?
	return i, unpacked
}

pub struct CInputMouseUpMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	input_mark     u32
	has_input_mark bool
	button         EStreamMouseButton
}

pub fn (o &CInputMouseUpMsg) pack() []byte {
	mut res := []byte{}
	if o.has_input_mark {
		res << vproto.pack_uint32_field(o.input_mark, 1)
	}
	res << zzz_vproto_internal_pack_estreammousebutton(o.button, 2)
	return res
}

pub fn cinputmouseupmsg_unpack(buf []byte) ?CInputMouseUpMsg {
	mut res := CInputMouseUpMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_input_mark = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_mark = v
				i = ii
			}
			2 {
				ii, v := zzz_vproto_internal_unpack_estreammousebutton(cur_buf, tag_wiretype.wire_type)?
				res.button = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinputmouseupmsg() CInputMouseUpMsg {
	return CInputMouseUpMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinputmouseupmsg(o CInputMouseUpMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinputmouseupmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CInputMouseUpMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinputmouseupmsg_unpack(v)?
	return i, unpacked
}

pub struct CInputKeyDownMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	input_mark     u32
	has_input_mark bool
	scancode       u32
}

pub fn (o &CInputKeyDownMsg) pack() []byte {
	mut res := []byte{}
	if o.has_input_mark {
		res << vproto.pack_uint32_field(o.input_mark, 1)
	}
	res << vproto.pack_uint32_field(o.scancode, 2)
	return res
}

pub fn cinputkeydownmsg_unpack(buf []byte) ?CInputKeyDownMsg {
	mut res := CInputKeyDownMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_input_mark = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_mark = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scancode = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinputkeydownmsg() CInputKeyDownMsg {
	return CInputKeyDownMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinputkeydownmsg(o CInputKeyDownMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinputkeydownmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CInputKeyDownMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinputkeydownmsg_unpack(v)?
	return i, unpacked
}

pub struct CInputKeyUpMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	input_mark     u32
	has_input_mark bool
	scancode       u32
}

pub fn (o &CInputKeyUpMsg) pack() []byte {
	mut res := []byte{}
	if o.has_input_mark {
		res << vproto.pack_uint32_field(o.input_mark, 1)
	}
	res << vproto.pack_uint32_field(o.scancode, 2)
	return res
}

pub fn cinputkeyupmsg_unpack(buf []byte) ?CInputKeyUpMsg {
	mut res := CInputKeyUpMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_input_mark = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_mark = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.scancode = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinputkeyupmsg() CInputKeyUpMsg {
	return CInputKeyUpMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinputkeyupmsg(o CInputKeyUpMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinputkeyupmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CInputKeyUpMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinputkeyupmsg_unpack(v)?
	return i, unpacked
}

pub struct CInputTextMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	input_mark     u32
	has_input_mark bool
	text_utf8      string
}

pub fn (o &CInputTextMsg) pack() []byte {
	mut res := []byte{}
	if o.has_input_mark {
		res << vproto.pack_uint32_field(o.input_mark, 1)
	}
	res << vproto.pack_string_field(o.text_utf8, 2)
	return res
}

pub fn cinputtextmsg_unpack(buf []byte) ?CInputTextMsg {
	mut res := CInputTextMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_input_mark = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_mark = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.text_utf8 = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cinputtextmsg() CInputTextMsg {
	return CInputTextMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cinputtextmsg(o CInputTextMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cinputtextmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CInputTextMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cinputtextmsg_unpack(v)?
	return i, unpacked
}

pub struct CSetTitleMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	text           string
	has_text       bool
}

pub fn (o &CSetTitleMsg) pack() []byte {
	mut res := []byte{}
	if o.has_text {
		res << vproto.pack_string_field(o.text, 1)
	}
	return res
}

pub fn csettitlemsg_unpack(buf []byte) ?CSetTitleMsg {
	mut res := CSetTitleMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csettitlemsg() CSetTitleMsg {
	return CSetTitleMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csettitlemsg(o CSetTitleMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csettitlemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetTitleMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csettitlemsg_unpack(v)?
	return i, unpacked
}

pub struct CSetCaptureSizeMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	width          int
	has_width      bool
	height         int
	has_height     bool
}

pub fn (o &CSetCaptureSizeMsg) pack() []byte {
	mut res := []byte{}
	if o.has_width {
		res << vproto.pack_int32_field(o.width, 1)
	}
	if o.has_height {
		res << vproto.pack_int32_field(o.height, 2)
	}
	return res
}

pub fn csetcapturesizemsg_unpack(buf []byte) ?CSetCaptureSizeMsg {
	mut res := CSetCaptureSizeMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_width = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			2 {
				res.has_height = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csetcapturesizemsg() CSetCaptureSizeMsg {
	return CSetCaptureSizeMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csetcapturesizemsg(o CSetCaptureSizeMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csetcapturesizemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetCaptureSizeMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csetcapturesizemsg_unpack(v)?
	return i, unpacked
}

pub struct CSetIconMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	width          int
	has_width      bool
	height         int
	has_height     bool
	image          []byte
	has_image      bool
}

pub fn (o &CSetIconMsg) pack() []byte {
	mut res := []byte{}
	if o.has_width {
		res << vproto.pack_int32_field(o.width, 1)
	}
	if o.has_height {
		res << vproto.pack_int32_field(o.height, 2)
	}
	if o.has_image {
		res << vproto.pack_bytes_field(o.image, 3)
	}
	return res
}

pub fn cseticonmsg_unpack(buf []byte) ?CSetIconMsg {
	mut res := CSetIconMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_width = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			2 {
				res.has_height = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			3 {
				res.has_image = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.image = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cseticonmsg() CSetIconMsg {
	return CSetIconMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cseticonmsg(o CSetIconMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cseticonmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetIconMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cseticonmsg_unpack(v)?
	return i, unpacked
}

pub struct CSetFlashStateMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	flags          u32
	has_flags      bool
	count          u32
	has_count      bool
	timeout_ms     u32
	has_timeout_ms bool
}

pub fn (o &CSetFlashStateMsg) pack() []byte {
	mut res := []byte{}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 1)
	}
	if o.has_count {
		res << vproto.pack_uint32_field(o.count, 2)
	}
	if o.has_timeout_ms {
		res << vproto.pack_uint32_field(o.timeout_ms, 3)
	}
	return res
}

pub fn csetflashstatemsg_unpack(buf []byte) ?CSetFlashStateMsg {
	mut res := CSetFlashStateMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			2 {
				res.has_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			3 {
				res.has_timeout_ms = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timeout_ms = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csetflashstatemsg() CSetFlashStateMsg {
	return CSetFlashStateMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csetflashstatemsg(o CSetFlashStateMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csetflashstatemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetFlashStateMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csetflashstatemsg_unpack(v)?
	return i, unpacked
}

pub struct CShowCursorMsg {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	x_normalized     f32
	has_x_normalized bool
	y_normalized     f32
	has_y_normalized bool
}

pub fn (o &CShowCursorMsg) pack() []byte {
	mut res := []byte{}
	if o.has_x_normalized {
		res << vproto.pack_float_field(o.x_normalized, 1)
	}
	if o.has_y_normalized {
		res << vproto.pack_float_field(o.y_normalized, 2)
	}
	return res
}

pub fn cshowcursormsg_unpack(buf []byte) ?CShowCursorMsg {
	mut res := CShowCursorMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_x_normalized = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.x_normalized = v
				i = ii
			}
			2 {
				res.has_y_normalized = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.y_normalized = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cshowcursormsg() CShowCursorMsg {
	return CShowCursorMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cshowcursormsg(o CShowCursorMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cshowcursormsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CShowCursorMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cshowcursormsg_unpack(v)?
	return i, unpacked
}

pub struct CHideCursorMsg {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CHideCursorMsg) pack() []byte {
	res := []byte{}
	return res
}

pub fn chidecursormsg_unpack(buf []byte) ?CHideCursorMsg {
	res := CHideCursorMsg{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_chidecursormsg() CHideCursorMsg {
	return CHideCursorMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_chidecursormsg(o CHideCursorMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_chidecursormsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CHideCursorMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := chidecursormsg_unpack(v)?
	return i, unpacked
}

pub struct CSetCursorMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	cursor_id      u64
}

pub fn (o &CSetCursorMsg) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint64_field(o.cursor_id, 1)
	return res
}

pub fn csetcursormsg_unpack(buf []byte) ?CSetCursorMsg {
	mut res := CSetCursorMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.cursor_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csetcursormsg() CSetCursorMsg {
	return CSetCursorMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csetcursormsg(o CSetCursorMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csetcursormsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetCursorMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csetcursormsg_unpack(v)?
	return i, unpacked
}

pub struct CGetCursorImageMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	cursor_id      u64
}

pub fn (o &CGetCursorImageMsg) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint64_field(o.cursor_id, 1)
	return res
}

pub fn cgetcursorimagemsg_unpack(buf []byte) ?CGetCursorImageMsg {
	mut res := CGetCursorImageMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.cursor_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgetcursorimagemsg() CGetCursorImageMsg {
	return CGetCursorImageMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgetcursorimagemsg(o CGetCursorImageMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgetcursorimagemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CGetCursorImageMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgetcursorimagemsg_unpack(v)?
	return i, unpacked
}

pub struct CSetCursorImageMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	cursor_id      u64
	width          int
	has_width      bool
	height         int
	has_height     bool
	hot_x          int
	has_hot_x      bool
	hot_y          int
	has_hot_y      bool
	image          []byte
	has_image      bool
}

pub fn (o &CSetCursorImageMsg) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint64_field(o.cursor_id, 1)
	if o.has_width {
		res << vproto.pack_int32_field(o.width, 2)
	}
	if o.has_height {
		res << vproto.pack_int32_field(o.height, 3)
	}
	if o.has_hot_x {
		res << vproto.pack_int32_field(o.hot_x, 4)
	}
	if o.has_hot_y {
		res << vproto.pack_int32_field(o.hot_y, 5)
	}
	if o.has_image {
		res << vproto.pack_bytes_field(o.image, 6)
	}
	return res
}

pub fn csetcursorimagemsg_unpack(buf []byte) ?CSetCursorImageMsg {
	mut res := CSetCursorImageMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.cursor_id = v
				i = ii
			}
			2 {
				res.has_width = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			3 {
				res.has_height = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			4 {
				res.has_hot_x = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.hot_x = v
				i = ii
			}
			5 {
				res.has_hot_y = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.hot_y = v
				i = ii
			}
			6 {
				res.has_image = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.image = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csetcursorimagemsg() CSetCursorImageMsg {
	return CSetCursorImageMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csetcursorimagemsg(o CSetCursorImageMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csetcursorimagemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetCursorImageMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csetcursorimagemsg_unpack(v)?
	return i, unpacked
}

pub struct CVideoDecoderInfoMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	info           string
	has_info       bool
	threads        int
	has_threads    bool
}

pub fn (o &CVideoDecoderInfoMsg) pack() []byte {
	mut res := []byte{}
	if o.has_info {
		res << vproto.pack_string_field(o.info, 1)
	}
	if o.has_threads {
		res << vproto.pack_int32_field(o.threads, 2)
	}
	return res
}

pub fn cvideodecoderinfomsg_unpack(buf []byte) ?CVideoDecoderInfoMsg {
	mut res := CVideoDecoderInfoMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_info = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.info = v
				i = ii
			}
			2 {
				res.has_threads = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.threads = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideodecoderinfomsg() CVideoDecoderInfoMsg {
	return CVideoDecoderInfoMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideodecoderinfomsg(o CVideoDecoderInfoMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideodecoderinfomsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideoDecoderInfoMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideodecoderinfomsg_unpack(v)?
	return i, unpacked
}

pub struct CVideoEncoderInfoMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	info           string
	has_info       bool
}

pub fn (o &CVideoEncoderInfoMsg) pack() []byte {
	mut res := []byte{}
	if o.has_info {
		res << vproto.pack_string_field(o.info, 1)
	}
	return res
}

pub fn cvideoencoderinfomsg_unpack(buf []byte) ?CVideoEncoderInfoMsg {
	mut res := CVideoEncoderInfoMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_info = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.info = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideoencoderinfomsg() CVideoEncoderInfoMsg {
	return CVideoEncoderInfoMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideoencoderinfomsg(o CVideoEncoderInfoMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideoencoderinfomsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideoEncoderInfoMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideoencoderinfomsg_unpack(v)?
	return i, unpacked
}

pub struct CPauseMsg {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPauseMsg) pack() []byte {
	res := []byte{}
	return res
}

pub fn cpausemsg_unpack(buf []byte) ?CPauseMsg {
	res := CPauseMsg{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cpausemsg() CPauseMsg {
	return CPauseMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cpausemsg(o CPauseMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cpausemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CPauseMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cpausemsg_unpack(v)?
	return i, unpacked
}

pub struct CResumeMsg {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CResumeMsg) pack() []byte {
	res := []byte{}
	return res
}

pub fn cresumemsg_unpack(buf []byte) ?CResumeMsg {
	res := CResumeMsg{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cresumemsg() CResumeMsg {
	return CResumeMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cresumemsg(o CResumeMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cresumemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CResumeMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cresumemsg_unpack(v)?
	return i, unpacked
}

pub struct CEnableHighResCaptureMsg {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CEnableHighResCaptureMsg) pack() []byte {
	res := []byte{}
	return res
}

pub fn cenablehighrescapturemsg_unpack(buf []byte) ?CEnableHighResCaptureMsg {
	res := CEnableHighResCaptureMsg{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cenablehighrescapturemsg() CEnableHighResCaptureMsg {
	return CEnableHighResCaptureMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cenablehighrescapturemsg(o CEnableHighResCaptureMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cenablehighrescapturemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CEnableHighResCaptureMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cenablehighrescapturemsg_unpack(v)?
	return i, unpacked
}

pub struct CDisableHighResCaptureMsg {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CDisableHighResCaptureMsg) pack() []byte {
	res := []byte{}
	return res
}

pub fn cdisablehighrescapturemsg_unpack(buf []byte) ?CDisableHighResCaptureMsg {
	res := CDisableHighResCaptureMsg{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdisablehighrescapturemsg() CDisableHighResCaptureMsg {
	return CDisableHighResCaptureMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdisablehighrescapturemsg(o CDisableHighResCaptureMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdisablehighrescapturemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CDisableHighResCaptureMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdisablehighrescapturemsg_unpack(v)?
	return i, unpacked
}

pub struct CToggleMagnificationMsg {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CToggleMagnificationMsg) pack() []byte {
	res := []byte{}
	return res
}

pub fn ctogglemagnificationmsg_unpack(buf []byte) ?CToggleMagnificationMsg {
	res := CToggleMagnificationMsg{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctogglemagnificationmsg() CToggleMagnificationMsg {
	return CToggleMagnificationMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctogglemagnificationmsg(o CToggleMagnificationMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctogglemagnificationmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CToggleMagnificationMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctogglemagnificationmsg_unpack(v)?
	return i, unpacked
}

pub struct CSetCapslockMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	pressed        bool
	has_pressed    bool
}

pub fn (o &CSetCapslockMsg) pack() []byte {
	mut res := []byte{}
	if o.has_pressed {
		res << vproto.pack_bool_field(o.pressed, 1)
	}
	return res
}

pub fn csetcapslockmsg_unpack(buf []byte) ?CSetCapslockMsg {
	mut res := CSetCapslockMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_pressed = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.pressed = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csetcapslockmsg() CSetCapslockMsg {
	return CSetCapslockMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csetcapslockmsg(o CSetCapslockMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csetcapslockmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetCapslockMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csetcapslockmsg_unpack(v)?
	return i, unpacked
}

pub struct CStreamingKeymapEntry {
mut:
	unknown_fields                   []vproto.UnknownField
pub mut:
	scancode                         int
	has_scancode                     bool
	normal_keycode                   int
	has_normal_keycode               bool
	shift_keycode                    int
	has_shift_keycode                bool
	capslock_keycode                 int
	has_capslock_keycode             bool
	shift_capslock_keycode           int
	has_shift_capslock_keycode       bool
	altgr_keycode                    int
	has_altgr_keycode                bool
	altgr_shift_keycode              int
	has_altgr_shift_keycode          bool
	altgr_capslock_keycode           int
	has_altgr_capslock_keycode       bool
	altgr_shift_capslock_keycode     int
	has_altgr_shift_capslock_keycode bool
}

pub fn (o &CStreamingKeymapEntry) pack() []byte {
	mut res := []byte{}
	if o.has_scancode {
		res << vproto.pack_int32_field(o.scancode, 1)
	}
	if o.has_normal_keycode {
		res << vproto.pack_int32_field(o.normal_keycode, 2)
	}
	if o.has_shift_keycode {
		res << vproto.pack_int32_field(o.shift_keycode, 3)
	}
	if o.has_capslock_keycode {
		res << vproto.pack_int32_field(o.capslock_keycode, 4)
	}
	if o.has_shift_capslock_keycode {
		res << vproto.pack_int32_field(o.shift_capslock_keycode, 5)
	}
	if o.has_altgr_keycode {
		res << vproto.pack_int32_field(o.altgr_keycode, 6)
	}
	if o.has_altgr_shift_keycode {
		res << vproto.pack_int32_field(o.altgr_shift_keycode, 7)
	}
	if o.has_altgr_capslock_keycode {
		res << vproto.pack_int32_field(o.altgr_capslock_keycode, 8)
	}
	if o.has_altgr_shift_capslock_keycode {
		res << vproto.pack_int32_field(o.altgr_shift_capslock_keycode, 9)
	}
	return res
}

pub fn cstreamingkeymapentry_unpack(buf []byte) ?CStreamingKeymapEntry {
	mut res := CStreamingKeymapEntry{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_scancode = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.scancode = v
				i = ii
			}
			2 {
				res.has_normal_keycode = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.normal_keycode = v
				i = ii
			}
			3 {
				res.has_shift_keycode = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.shift_keycode = v
				i = ii
			}
			4 {
				res.has_capslock_keycode = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.capslock_keycode = v
				i = ii
			}
			5 {
				res.has_shift_capslock_keycode = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.shift_capslock_keycode = v
				i = ii
			}
			6 {
				res.has_altgr_keycode = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.altgr_keycode = v
				i = ii
			}
			7 {
				res.has_altgr_shift_keycode = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.altgr_shift_keycode = v
				i = ii
			}
			8 {
				res.has_altgr_capslock_keycode = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.altgr_capslock_keycode = v
				i = ii
			}
			9 {
				res.has_altgr_shift_capslock_keycode = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.altgr_shift_capslock_keycode = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstreamingkeymapentry() CStreamingKeymapEntry {
	return CStreamingKeymapEntry{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstreamingkeymapentry(o CStreamingKeymapEntry, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstreamingkeymapentry(buf []byte, tag_wiretype vproto.WireType) ?(int, CStreamingKeymapEntry) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstreamingkeymapentry_unpack(v)?
	return i, unpacked
}

pub struct CStreamingKeymap {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	entries        []CStreamingKeymapEntry
}

pub fn (o &CStreamingKeymap) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.entries {
		res << zzz_vproto_internal_pack_cstreamingkeymapentry(x, 1)
	}
	return res
}

pub fn cstreamingkeymap_unpack(buf []byte) ?CStreamingKeymap {
	mut res := CStreamingKeymap{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cstreamingkeymapentry(cur_buf, tag_wiretype.wire_type)?
				res.entries << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstreamingkeymap() CStreamingKeymap {
	return CStreamingKeymap{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstreamingkeymap(o CStreamingKeymap, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstreamingkeymap(buf []byte, tag_wiretype vproto.WireType) ?(int, CStreamingKeymap) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstreamingkeymap_unpack(v)?
	return i, unpacked
}

pub struct CSetKeymapMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	keymap         CStreamingKeymap
	has_keymap     bool
}

pub fn (o &CSetKeymapMsg) pack() []byte {
	mut res := []byte{}
	if o.has_keymap {
		res << zzz_vproto_internal_pack_cstreamingkeymap(o.keymap, 1)
	}
	return res
}

pub fn csetkeymapmsg_unpack(buf []byte) ?CSetKeymapMsg {
	mut res := CSetKeymapMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_keymap = true
				ii, v := zzz_vproto_internal_unpack_cstreamingkeymap(cur_buf, tag_wiretype.wire_type)?
				res.keymap = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csetkeymapmsg() CSetKeymapMsg {
	return CSetKeymapMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csetkeymapmsg(o CSetKeymapMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csetkeymapmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetKeymapMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csetkeymapmsg_unpack(v)?
	return i, unpacked
}

pub struct CStopRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CStopRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn cstoprequest_unpack(buf []byte) ?CStopRequest {
	res := CStopRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstoprequest() CStopRequest {
	return CStopRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstoprequest(o CStopRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstoprequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CStopRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstoprequest_unpack(v)?
	return i, unpacked
}

pub struct CQuitRequest {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CQuitRequest) pack() []byte {
	res := []byte{}
	return res
}

pub fn cquitrequest_unpack(buf []byte) ?CQuitRequest {
	res := CQuitRequest{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cquitrequest() CQuitRequest {
	return CQuitRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cquitrequest(o CQuitRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cquitrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CQuitRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cquitrequest_unpack(v)?
	return i, unpacked
}

pub struct CDeleteCursorMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	cursor_id      u64
}

pub fn (o &CDeleteCursorMsg) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint64_field(o.cursor_id, 1)
	return res
}

pub fn cdeletecursormsg_unpack(buf []byte) ?CDeleteCursorMsg {
	mut res := CDeleteCursorMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.cursor_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdeletecursormsg() CDeleteCursorMsg {
	return CDeleteCursorMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdeletecursormsg(o CDeleteCursorMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdeletecursormsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CDeleteCursorMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdeletecursormsg_unpack(v)?
	return i, unpacked
}

pub struct CSetStreamingClientConfig {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	config         CStreamingClientConfig
}

pub fn (o &CSetStreamingClientConfig) pack() []byte {
	mut res := []byte{}
	res << zzz_vproto_internal_pack_cstreamingclientconfig(o.config, 1)
	return res
}

pub fn csetstreamingclientconfig_unpack(buf []byte) ?CSetStreamingClientConfig {
	mut res := CSetStreamingClientConfig{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_cstreamingclientconfig(cur_buf, tag_wiretype.wire_type)?
				res.config = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csetstreamingclientconfig() CSetStreamingClientConfig {
	return CSetStreamingClientConfig{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csetstreamingclientconfig(o CSetStreamingClientConfig, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csetstreamingclientconfig(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetStreamingClientConfig) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csetstreamingclientconfig_unpack(v)?
	return i, unpacked
}

pub struct CSetQoSMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	use_qos        bool
}

pub fn (o &CSetQoSMsg) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_bool_field(o.use_qos, 1)
	return res
}

pub fn csetqosmsg_unpack(buf []byte) ?CSetQoSMsg {
	mut res := CSetQoSMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.use_qos = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csetqosmsg() CSetQoSMsg {
	return CSetQoSMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csetqosmsg(o CSetQoSMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csetqosmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetQoSMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csetqosmsg_unpack(v)?
	return i, unpacked
}

pub struct CSetTargetFramerateMsg {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	framerate                 u32
	reasons                   u32
	has_reasons               bool
	framerate_numerator       u32
	has_framerate_numerator   bool
	framerate_denominator     u32
	has_framerate_denominator bool
}

pub fn (o &CSetTargetFramerateMsg) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint32_field(o.framerate, 1)
	if o.has_reasons {
		res << vproto.pack_uint32_field(o.reasons, 2)
	}
	if o.has_framerate_numerator {
		res << vproto.pack_uint32_field(o.framerate_numerator, 3)
	}
	if o.has_framerate_denominator {
		res << vproto.pack_uint32_field(o.framerate_denominator, 4)
	}
	return res
}

pub fn csettargetframeratemsg_unpack(buf []byte) ?CSetTargetFramerateMsg {
	mut res := CSetTargetFramerateMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.framerate = v
				i = ii
			}
			2 {
				res.has_reasons = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.reasons = v
				i = ii
			}
			3 {
				res.has_framerate_numerator = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.framerate_numerator = v
				i = ii
			}
			4 {
				res.has_framerate_denominator = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.framerate_denominator = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csettargetframeratemsg() CSetTargetFramerateMsg {
	return CSetTargetFramerateMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csettargetframeratemsg(o CSetTargetFramerateMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csettargetframeratemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetTargetFramerateMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csettargetframeratemsg_unpack(v)?
	return i, unpacked
}

pub struct CSetTargetBitrateMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	bitrate        int
}

pub fn (o &CSetTargetBitrateMsg) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_int32_field(o.bitrate, 1)
	return res
}

pub fn csettargetbitratemsg_unpack(buf []byte) ?CSetTargetBitrateMsg {
	mut res := CSetTargetBitrateMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.bitrate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csettargetbitratemsg() CSetTargetBitrateMsg {
	return CSetTargetBitrateMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csettargetbitratemsg(o CSetTargetBitrateMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csettargetbitratemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetTargetBitrateMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csettargetbitratemsg_unpack(v)?
	return i, unpacked
}

pub struct COverlayEnabledMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	enabled        bool
}

pub fn (o &COverlayEnabledMsg) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_bool_field(o.enabled, 1)
	return res
}

pub fn coverlayenabledmsg_unpack(buf []byte) ?COverlayEnabledMsg {
	mut res := COverlayEnabledMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enabled = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_coverlayenabledmsg() COverlayEnabledMsg {
	return COverlayEnabledMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_coverlayenabledmsg(o COverlayEnabledMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_coverlayenabledmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, COverlayEnabledMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := coverlayenabledmsg_unpack(v)?
	return i, unpacked
}

pub struct CSetGammaRampMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	gamma_ramp     []byte
	has_gamma_ramp bool
}

pub fn (o &CSetGammaRampMsg) pack() []byte {
	mut res := []byte{}
	if o.has_gamma_ramp {
		res << vproto.pack_bytes_field(o.gamma_ramp, 1)
	}
	return res
}

pub fn csetgammarampmsg_unpack(buf []byte) ?CSetGammaRampMsg {
	mut res := CSetGammaRampMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_gamma_ramp = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.gamma_ramp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csetgammarampmsg() CSetGammaRampMsg {
	return CSetGammaRampMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csetgammarampmsg(o CSetGammaRampMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csetgammarampmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetGammaRampMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csetgammarampmsg_unpack(v)?
	return i, unpacked
}

pub struct CSetActivityMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	activity       EStreamActivity
	has_activity   bool
	appid          u32
	has_appid      bool
	gameid         u64
	has_gameid     bool
}

pub fn (o &CSetActivityMsg) pack() []byte {
	mut res := []byte{}
	if o.has_activity {
		res << zzz_vproto_internal_pack_estreamactivity(o.activity, 1)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 2)
	}
	if o.has_gameid {
		res << vproto.pack_uint64_field(o.gameid, 3)
	}
	return res
}

pub fn csetactivitymsg_unpack(buf []byte) ?CSetActivityMsg {
	mut res := CSetActivityMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_activity = true
				ii, v := zzz_vproto_internal_unpack_estreamactivity(cur_buf, tag_wiretype.wire_type)?
				res.activity = v
				i = ii
			}
			2 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			3 {
				res.has_gameid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.gameid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csetactivitymsg() CSetActivityMsg {
	return CSetActivityMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csetactivitymsg(o CSetActivityMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csetactivitymsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetActivityMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csetactivitymsg_unpack(v)?
	return i, unpacked
}

pub struct CSystemSuspendMsg {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CSystemSuspendMsg) pack() []byte {
	res := []byte{}
	return res
}

pub fn csystemsuspendmsg_unpack(buf []byte) ?CSystemSuspendMsg {
	res := CSystemSuspendMsg{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csystemsuspendmsg() CSystemSuspendMsg {
	return CSystemSuspendMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csystemsuspendmsg(o CSystemSuspendMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csystemsuspendmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSystemSuspendMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csystemsuspendmsg_unpack(v)?
	return i, unpacked
}

pub struct CVirtualHereRequestMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	hostname       string
	has_hostname   bool
}

pub fn (o &CVirtualHereRequestMsg) pack() []byte {
	mut res := []byte{}
	if o.has_hostname {
		res << vproto.pack_string_field(o.hostname, 1)
	}
	return res
}

pub fn cvirtualhererequestmsg_unpack(buf []byte) ?CVirtualHereRequestMsg {
	mut res := CVirtualHereRequestMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_hostname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.hostname = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvirtualhererequestmsg() CVirtualHereRequestMsg {
	return CVirtualHereRequestMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvirtualhererequestmsg(o CVirtualHereRequestMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvirtualhererequestmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualHereRequestMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvirtualhererequestmsg_unpack(v)?
	return i, unpacked
}

pub struct CVirtualHereReadyMsg {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	licensed_device_count     u32
	has_licensed_device_count bool
}

pub fn (o &CVirtualHereReadyMsg) pack() []byte {
	mut res := []byte{}
	if o.has_licensed_device_count {
		res << vproto.pack_uint32_field(o.licensed_device_count, 1)
	}
	return res
}

pub fn cvirtualherereadymsg_unpack(buf []byte) ?CVirtualHereReadyMsg {
	mut res := CVirtualHereReadyMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_licensed_device_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.licensed_device_count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvirtualherereadymsg() CVirtualHereReadyMsg {
	return CVirtualHereReadyMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvirtualherereadymsg(o CVirtualHereReadyMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvirtualherereadymsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualHereReadyMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvirtualherereadymsg_unpack(v)?
	return i, unpacked
}

pub struct CVirtualHereShareDeviceMsg {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	device_address     string
	has_device_address bool
}

pub fn (o &CVirtualHereShareDeviceMsg) pack() []byte {
	mut res := []byte{}
	if o.has_device_address {
		res << vproto.pack_string_field(o.device_address, 1)
	}
	return res
}

pub fn cvirtualheresharedevicemsg_unpack(buf []byte) ?CVirtualHereShareDeviceMsg {
	mut res := CVirtualHereShareDeviceMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_device_address = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.device_address = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvirtualheresharedevicemsg() CVirtualHereShareDeviceMsg {
	return CVirtualHereShareDeviceMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvirtualheresharedevicemsg(o CVirtualHereShareDeviceMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvirtualheresharedevicemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CVirtualHereShareDeviceMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvirtualheresharedevicemsg_unpack(v)?
	return i, unpacked
}

pub struct CSetSpectatorModeMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	enabled        bool
	has_enabled    bool
}

pub fn (o &CSetSpectatorModeMsg) pack() []byte {
	mut res := []byte{}
	if o.has_enabled {
		res << vproto.pack_bool_field(o.enabled, 1)
	}
	return res
}

pub fn csetspectatormodemsg_unpack(buf []byte) ?CSetSpectatorModeMsg {
	mut res := CSetSpectatorModeMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.enabled = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csetspectatormodemsg() CSetSpectatorModeMsg {
	return CSetSpectatorModeMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csetspectatormodemsg(o CSetSpectatorModeMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csetspectatormodemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetSpectatorModeMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csetspectatormodemsg_unpack(v)?
	return i, unpacked
}

pub struct CRemoteHIDMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	data           []byte
	has_data       bool
}

pub fn (o &CRemoteHIDMsg) pack() []byte {
	mut res := []byte{}
	if o.has_data {
		res << vproto.pack_bytes_field(o.data, 1)
	}
	return res
}

pub fn cremotehidmsg_unpack(buf []byte) ?CRemoteHIDMsg {
	mut res := CRemoteHIDMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cremotehidmsg() CRemoteHIDMsg {
	return CRemoteHIDMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cremotehidmsg(o CRemoteHIDMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cremotehidmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CRemoteHIDMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cremotehidmsg_unpack(v)?
	return i, unpacked
}

pub struct CTouchConfigActiveMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	revision       u32
	has_revision   bool
	creator        u64
	has_creator    bool
}

pub fn (o &CTouchConfigActiveMsg) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_revision {
		res << vproto.pack_uint32_field(o.revision, 2)
	}
	if o.has_creator {
		res << vproto.pack_uint64_field(o.creator, 3)
	}
	return res
}

pub fn ctouchconfigactivemsg_unpack(buf []byte) ?CTouchConfigActiveMsg {
	mut res := CTouchConfigActiveMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.revision = v
				i = ii
			}
			3 {
				res.has_creator = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.creator = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctouchconfigactivemsg() CTouchConfigActiveMsg {
	return CTouchConfigActiveMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctouchconfigactivemsg(o CTouchConfigActiveMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctouchconfigactivemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CTouchConfigActiveMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctouchconfigactivemsg_unpack(v)?
	return i, unpacked
}

pub struct CGetTouchConfigDataMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
}

pub fn (o &CGetTouchConfigDataMsg) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cgettouchconfigdatamsg_unpack(buf []byte) ?CGetTouchConfigDataMsg {
	mut res := CGetTouchConfigDataMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgettouchconfigdatamsg() CGetTouchConfigDataMsg {
	return CGetTouchConfigDataMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgettouchconfigdatamsg(o CGetTouchConfigDataMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgettouchconfigdatamsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CGetTouchConfigDataMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgettouchconfigdatamsg_unpack(v)?
	return i, unpacked
}

pub struct CSetTouchConfigDataMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	revision       u32
	has_revision   bool
	data           []byte
	has_data       bool
	layout         []byte
	has_layout     bool
	creator        u64
	has_creator    bool
}

pub fn (o &CSetTouchConfigDataMsg) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_revision {
		res << vproto.pack_uint32_field(o.revision, 2)
	}
	if o.has_data {
		res << vproto.pack_bytes_field(o.data, 3)
	}
	if o.has_layout {
		res << vproto.pack_bytes_field(o.layout, 4)
	}
	if o.has_creator {
		res << vproto.pack_uint64_field(o.creator, 5)
	}
	return res
}

pub fn csettouchconfigdatamsg_unpack(buf []byte) ?CSetTouchConfigDataMsg {
	mut res := CSetTouchConfigDataMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_revision = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.revision = v
				i = ii
			}
			3 {
				res.has_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.data = v
				i = ii
			}
			4 {
				res.has_layout = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.layout = v
				i = ii
			}
			5 {
				res.has_creator = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.creator = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csettouchconfigdatamsg() CSetTouchConfigDataMsg {
	return CSetTouchConfigDataMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csettouchconfigdatamsg(o CSetTouchConfigDataMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csettouchconfigdatamsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetTouchConfigDataMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csettouchconfigdatamsg_unpack(v)?
	return i, unpacked
}

pub struct CSaveTouchConfigLayoutMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	layout         []byte
	has_layout     bool
}

pub fn (o &CSaveTouchConfigLayoutMsg) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_layout {
		res << vproto.pack_bytes_field(o.layout, 4)
	}
	return res
}

pub fn csavetouchconfiglayoutmsg_unpack(buf []byte) ?CSaveTouchConfigLayoutMsg {
	mut res := CSaveTouchConfigLayoutMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			4 {
				res.has_layout = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.layout = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csavetouchconfiglayoutmsg() CSaveTouchConfigLayoutMsg {
	return CSaveTouchConfigLayoutMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csavetouchconfiglayoutmsg(o CSaveTouchConfigLayoutMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csavetouchconfiglayoutmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSaveTouchConfigLayoutMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csavetouchconfiglayoutmsg_unpack(v)?
	return i, unpacked
}

pub struct CTouchActionSetActiveMsg {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	has_appid        bool
	actionset_id     int
	has_actionset_id bool
}

pub fn (o &CTouchActionSetActiveMsg) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_actionset_id {
		res << vproto.pack_int32_field(o.actionset_id, 2)
	}
	return res
}

pub fn ctouchactionsetactivemsg_unpack(buf []byte) ?CTouchActionSetActiveMsg {
	mut res := CTouchActionSetActiveMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_actionset_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.actionset_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctouchactionsetactivemsg() CTouchActionSetActiveMsg {
	return CTouchActionSetActiveMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctouchactionsetactivemsg(o CTouchActionSetActiveMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctouchactionsetactivemsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CTouchActionSetActiveMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctouchactionsetactivemsg_unpack(v)?
	return i, unpacked
}

pub struct CTouchActionSetLayerAddedMsg {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	has_appid        bool
	actionset_id     int
	has_actionset_id bool
}

pub fn (o &CTouchActionSetLayerAddedMsg) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_actionset_id {
		res << vproto.pack_int32_field(o.actionset_id, 2)
	}
	return res
}

pub fn ctouchactionsetlayeraddedmsg_unpack(buf []byte) ?CTouchActionSetLayerAddedMsg {
	mut res := CTouchActionSetLayerAddedMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_actionset_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.actionset_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctouchactionsetlayeraddedmsg() CTouchActionSetLayerAddedMsg {
	return CTouchActionSetLayerAddedMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctouchactionsetlayeraddedmsg(o CTouchActionSetLayerAddedMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctouchactionsetlayeraddedmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CTouchActionSetLayerAddedMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctouchactionsetlayeraddedmsg_unpack(v)?
	return i, unpacked
}

pub struct CTouchActionSetLayerRemovedMsg {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	has_appid        bool
	actionset_id     int
	has_actionset_id bool
}

pub fn (o &CTouchActionSetLayerRemovedMsg) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_actionset_id {
		res << vproto.pack_int32_field(o.actionset_id, 2)
	}
	return res
}

pub fn ctouchactionsetlayerremovedmsg_unpack(buf []byte) ?CTouchActionSetLayerRemovedMsg {
	mut res := CTouchActionSetLayerRemovedMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_actionset_id = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.actionset_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctouchactionsetlayerremovedmsg() CTouchActionSetLayerRemovedMsg {
	return CTouchActionSetLayerRemovedMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctouchactionsetlayerremovedmsg(o CTouchActionSetLayerRemovedMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctouchactionsetlayerremovedmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CTouchActionSetLayerRemovedMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctouchactionsetlayerremovedmsg_unpack(v)?
	return i, unpacked
}

pub struct CGetTouchIconDataMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	icon           string
	has_icon       bool
}

pub fn (o &CGetTouchIconDataMsg) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_icon {
		res << vproto.pack_string_field(o.icon, 2)
	}
	return res
}

pub fn cgettouchicondatamsg_unpack(buf []byte) ?CGetTouchIconDataMsg {
	mut res := CGetTouchIconDataMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_icon = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cgettouchicondatamsg() CGetTouchIconDataMsg {
	return CGetTouchIconDataMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cgettouchicondatamsg(o CGetTouchIconDataMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cgettouchicondatamsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CGetTouchIconDataMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cgettouchicondatamsg_unpack(v)?
	return i, unpacked
}

pub struct CSetTouchIconDataMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
	icon           string
	has_icon       bool
	data           []byte
	has_data       bool
}

pub fn (o &CSetTouchIconDataMsg) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_icon {
		res << vproto.pack_string_field(o.icon, 2)
	}
	if o.has_data {
		res << vproto.pack_bytes_field(o.data, 3)
	}
	return res
}

pub fn csettouchicondatamsg_unpack(buf []byte) ?CSetTouchIconDataMsg {
	mut res := CSetTouchIconDataMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_icon = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.icon = v
				i = ii
			}
			3 {
				res.has_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_csettouchicondatamsg() CSetTouchIconDataMsg {
	return CSetTouchIconDataMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_csettouchicondatamsg(o CSetTouchIconDataMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_csettouchicondatamsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CSetTouchIconDataMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := csettouchicondatamsg_unpack(v)?
	return i, unpacked
}

pub struct CStreamDataLostMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	packets        []u32
}

pub fn (o &CStreamDataLostMsg) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.packets {
		res << vproto.pack_uint32_field(x, 1)
	}
	return res
}

pub fn cstreamdatalostmsg_unpack(buf []byte) ?CStreamDataLostMsg {
	mut res := CStreamDataLostMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.packets << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstreamdatalostmsg() CStreamDataLostMsg {
	return CStreamDataLostMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstreamdatalostmsg(o CStreamDataLostMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstreamdatalostmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CStreamDataLostMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstreamdatalostmsg_unpack(v)?
	return i, unpacked
}

pub struct CAudioFormat {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	format         EAudioFormat
	frequency      u32
	has_frequency  bool
	channels       u32
	has_channels   bool
}

pub fn (o &CAudioFormat) pack() []byte {
	mut res := []byte{}
	res << zzz_vproto_internal_pack_eaudioformat(o.format, 1)
	if o.has_frequency {
		res << vproto.pack_uint32_field(o.frequency, 2)
	}
	if o.has_channels {
		res << vproto.pack_uint32_field(o.channels, 3)
	}
	return res
}

pub fn caudioformat_unpack(buf []byte) ?CAudioFormat {
	mut res := CAudioFormat{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_eaudioformat(cur_buf, tag_wiretype.wire_type)?
				res.format = v
				i = ii
			}
			2 {
				res.has_frequency = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.frequency = v
				i = ii
			}
			3 {
				res.has_channels = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.channels = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caudioformat() CAudioFormat {
	return CAudioFormat{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caudioformat(o CAudioFormat, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caudioformat(buf []byte, tag_wiretype vproto.WireType) ?(int, CAudioFormat) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caudioformat_unpack(v)?
	return i, unpacked
}

pub struct CVideoFormat {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	format         EVideoFormat
	width          u32
	has_width      bool
	height         u32
	has_height     bool
}

pub fn (o &CVideoFormat) pack() []byte {
	mut res := []byte{}
	res << zzz_vproto_internal_pack_evideoformat(o.format, 1)
	if o.has_width {
		res << vproto.pack_uint32_field(o.width, 2)
	}
	if o.has_height {
		res << vproto.pack_uint32_field(o.height, 3)
	}
	return res
}

pub fn cvideoformat_unpack(buf []byte) ?CVideoFormat {
	mut res := CVideoFormat{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_evideoformat(cur_buf, tag_wiretype.wire_type)?
				res.format = v
				i = ii
			}
			2 {
				res.has_width = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.width = v
				i = ii
			}
			3 {
				res.has_height = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.height = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cvideoformat() CVideoFormat {
	return CVideoFormat{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cvideoformat(o CVideoFormat, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cvideoformat(buf []byte, tag_wiretype vproto.WireType) ?(int, CVideoFormat) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cvideoformat_unpack(v)?
	return i, unpacked
}

pub struct CFrameEvent {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	event_id       EStreamFrameEvent
	timestamp      u32
}

pub fn (o &CFrameEvent) pack() []byte {
	mut res := []byte{}
	res << zzz_vproto_internal_pack_estreamframeevent(o.event_id, 1)
	res << vproto.pack_uint32_field(o.timestamp, 2)
	return res
}

pub fn cframeevent_unpack(buf []byte) ?CFrameEvent {
	mut res := CFrameEvent{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_estreamframeevent(cur_buf, tag_wiretype.wire_type)?
				res.event_id = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cframeevent() CFrameEvent {
	return CFrameEvent{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cframeevent(o CFrameEvent, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cframeevent(buf []byte, tag_wiretype vproto.WireType) ?(int, CFrameEvent) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cframeevent_unpack(v)?
	return i, unpacked
}

pub struct CFrameStats {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	frame_id                u32
	input_mark              u32
	has_input_mark          bool
	events                  []CFrameEvent
	result                  EStreamFrameResult
	frame_start_delta       f32
	has_frame_start_delta   bool
	frame_display_delta     f32
	has_frame_display_delta bool
	ping_time               f32
	has_ping_time           bool
	server_bitrate          f32
	has_server_bitrate      bool
	client_bitrate          f32
	has_client_bitrate      bool
	link_bandwidth          f32
	has_link_bandwidth      bool
	packet_loss             f32
	has_packet_loss         bool
	frame_size              u32
	has_frame_size          bool
}

pub fn (o &CFrameStats) pack() []byte {
	mut res := []byte{}
	res << vproto.pack_uint32_field(o.frame_id, 1)
	if o.has_input_mark {
		res << vproto.pack_uint32_field(o.input_mark, 2)
	}
	// [packed=false]
	for _, x in o.events {
		res << zzz_vproto_internal_pack_cframeevent(x, 3)
	}
	res << zzz_vproto_internal_pack_estreamframeresult(o.result, 4)
	if o.has_frame_start_delta {
		res << vproto.pack_float_field(o.frame_start_delta, 5)
	}
	if o.has_frame_display_delta {
		res << vproto.pack_float_field(o.frame_display_delta, 6)
	}
	if o.has_ping_time {
		res << vproto.pack_float_field(o.ping_time, 7)
	}
	if o.has_server_bitrate {
		res << vproto.pack_float_field(o.server_bitrate, 8)
	}
	if o.has_client_bitrate {
		res << vproto.pack_float_field(o.client_bitrate, 9)
	}
	if o.has_link_bandwidth {
		res << vproto.pack_float_field(o.link_bandwidth, 10)
	}
	if o.has_packet_loss {
		res << vproto.pack_float_field(o.packet_loss, 11)
	}
	if o.has_frame_size {
		res << vproto.pack_uint32_field(o.frame_size, 12)
	}
	return res
}

pub fn cframestats_unpack(buf []byte) ?CFrameStats {
	mut res := CFrameStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.frame_id = v
				i = ii
			}
			2 {
				res.has_input_mark = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.input_mark = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cframeevent(cur_buf, tag_wiretype.wire_type)?
				res.events << v
				i = ii
			}
			4 {
				ii, v := zzz_vproto_internal_unpack_estreamframeresult(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			5 {
				res.has_frame_start_delta = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.frame_start_delta = v
				i = ii
			}
			6 {
				res.has_frame_display_delta = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.frame_display_delta = v
				i = ii
			}
			7 {
				res.has_ping_time = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.ping_time = v
				i = ii
			}
			8 {
				res.has_server_bitrate = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.server_bitrate = v
				i = ii
			}
			9 {
				res.has_client_bitrate = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.client_bitrate = v
				i = ii
			}
			10 {
				res.has_link_bandwidth = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.link_bandwidth = v
				i = ii
			}
			11 {
				res.has_packet_loss = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.packet_loss = v
				i = ii
			}
			12 {
				res.has_frame_size = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.frame_size = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cframestats() CFrameStats {
	return CFrameStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cframestats(o CFrameStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cframestats(buf []byte, tag_wiretype vproto.WireType) ?(int, CFrameStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cframestats_unpack(v)?
	return i, unpacked
}

pub struct CFrameStatAccumulatedValue {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	stat_type      EFrameAccumulatedStat
	count          int
	average        f32
	stddev         f32
	has_stddev     bool
}

pub fn (o &CFrameStatAccumulatedValue) pack() []byte {
	mut res := []byte{}
	res << zzz_vproto_internal_pack_eframeaccumulatedstat(o.stat_type, 1)
	res << vproto.pack_int32_field(o.count, 2)
	res << vproto.pack_float_field(o.average, 3)
	if o.has_stddev {
		res << vproto.pack_float_field(o.stddev, 4)
	}
	return res
}

pub fn cframestataccumulatedvalue_unpack(buf []byte) ?CFrameStatAccumulatedValue {
	mut res := CFrameStatAccumulatedValue{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_eframeaccumulatedstat(cur_buf, tag_wiretype.wire_type)?
				res.stat_type = v
				i = ii
			}
			2 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			3 {
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.average = v
				i = ii
			}
			4 {
				res.has_stddev = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.stddev = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cframestataccumulatedvalue() CFrameStatAccumulatedValue {
	return CFrameStatAccumulatedValue{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cframestataccumulatedvalue(o CFrameStatAccumulatedValue, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cframestataccumulatedvalue(buf []byte, tag_wiretype vproto.WireType) ?(int, CFrameStatAccumulatedValue) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cframestataccumulatedvalue_unpack(v)?
	return i, unpacked
}

pub struct CFrameStatsListMsg {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	data_type         EStreamingDataType
	stats             []CFrameStats
	accumulated_stats []CFrameStatAccumulatedValue
	latest_frame_id   int
}

pub fn (o &CFrameStatsListMsg) pack() []byte {
	mut res := []byte{}
	res << zzz_vproto_internal_pack_estreamingdatatype(o.data_type, 1)
	// [packed=false]
	for _, x in o.stats {
		res << zzz_vproto_internal_pack_cframestats(x, 2)
	}
	// [packed=false]
	for _, x in o.accumulated_stats {
		res << zzz_vproto_internal_pack_cframestataccumulatedvalue(x, 3)
	}
	res << vproto.pack_int32_field(o.latest_frame_id, 4)
	return res
}

pub fn cframestatslistmsg_unpack(buf []byte) ?CFrameStatsListMsg {
	mut res := CFrameStatsListMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := zzz_vproto_internal_unpack_estreamingdatatype(cur_buf, tag_wiretype.wire_type)?
				res.data_type = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cframestats(cur_buf, tag_wiretype.wire_type)?
				res.stats << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cframestataccumulatedvalue(cur_buf,
					tag_wiretype.wire_type)?
				res.accumulated_stats << v
				i = ii
			}
			4 {
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.latest_frame_id = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cframestatslistmsg() CFrameStatsListMsg {
	return CFrameStatsListMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cframestatslistmsg(o CFrameStatsListMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cframestatslistmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CFrameStatsListMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cframestatslistmsg_unpack(v)?
	return i, unpacked
}

pub struct CStreamingSessionStats {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	frame_loss_percentage       f32
	has_frame_loss_percentage   bool
	average_network_time_ms     f32
	has_average_network_time_ms bool
	stddev_network_time_ms      f32
	has_stddev_network_time_ms  bool
}

pub fn (o &CStreamingSessionStats) pack() []byte {
	mut res := []byte{}
	if o.has_frame_loss_percentage {
		res << vproto.pack_float_field(o.frame_loss_percentage, 1)
	}
	if o.has_average_network_time_ms {
		res << vproto.pack_float_field(o.average_network_time_ms, 2)
	}
	if o.has_stddev_network_time_ms {
		res << vproto.pack_float_field(o.stddev_network_time_ms, 3)
	}
	return res
}

pub fn cstreamingsessionstats_unpack(buf []byte) ?CStreamingSessionStats {
	mut res := CStreamingSessionStats{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_frame_loss_percentage = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.frame_loss_percentage = v
				i = ii
			}
			2 {
				res.has_average_network_time_ms = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.average_network_time_ms = v
				i = ii
			}
			3 {
				res.has_stddev_network_time_ms = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.stddev_network_time_ms = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cstreamingsessionstats() CStreamingSessionStats {
	return CStreamingSessionStats{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cstreamingsessionstats(o CStreamingSessionStats, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cstreamingsessionstats(buf []byte, tag_wiretype vproto.WireType) ?(int, CStreamingSessionStats) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cstreamingsessionstats_unpack(v)?
	return i, unpacked
}

pub struct CDebugDumpMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	screenshot     []byte
	has_screenshot bool
}

pub fn (o &CDebugDumpMsg) pack() []byte {
	mut res := []byte{}
	if o.has_screenshot {
		res << vproto.pack_bytes_field(o.screenshot, 1)
	}
	return res
}

pub fn cdebugdumpmsg_unpack(buf []byte) ?CDebugDumpMsg {
	mut res := CDebugDumpMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_screenshot = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.screenshot = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cdebugdumpmsg() CDebugDumpMsg {
	return CDebugDumpMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cdebugdumpmsg(o CDebugDumpMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cdebugdumpmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CDebugDumpMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cdebugdumpmsg_unpack(v)?
	return i, unpacked
}

pub struct CLogMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	@type          int
	has_type       bool
	message        string
	has_message    bool
}

pub fn (o &CLogMsg) pack() []byte {
	mut res := []byte{}
	if o.has_type {
		res << vproto.pack_int32_field(o.@type, 1)
	}
	if o.has_message {
		res << vproto.pack_string_field(o.message, 2)
	}
	return res
}

pub fn clogmsg_unpack(buf []byte) ?CLogMsg {
	mut res := CLogMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			2 {
				res.has_message = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.message = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_clogmsg() CLogMsg {
	return CLogMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_clogmsg(o CLogMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_clogmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CLogMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := clogmsg_unpack(v)?
	return i, unpacked
}

pub struct CLogUploadMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	@type          ELogFileType
	has_type       bool
	data           []byte
	has_data       bool
}

pub fn (o &CLogUploadMsg) pack() []byte {
	mut res := []byte{}
	if o.has_type {
		res << zzz_vproto_internal_pack_elogfiletype(o.@type, 1)
	}
	if o.has_data {
		res << vproto.pack_bytes_field(o.data, 3)
	}
	return res
}

pub fn cloguploadmsg_unpack(buf []byte) ?CLogUploadMsg {
	mut res := CLogUploadMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_type = true
				ii, v := zzz_vproto_internal_unpack_elogfiletype(cur_buf, tag_wiretype.wire_type)?
				res.@type = v
				i = ii
			}
			3 {
				res.has_data = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.data = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cloguploadmsg() CLogUploadMsg {
	return CLogUploadMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cloguploadmsg(o CLogUploadMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cloguploadmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CLogUploadMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cloguploadmsg_unpack(v)?
	return i, unpacked
}

pub struct CTransportSignalMsgWebRTCMessage_Candidate {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	sdp_mid             string
	has_sdp_mid         bool
	sdp_mline_index     int
	has_sdp_mline_index bool
	candidate           string
	has_candidate       bool
}

pub fn (o &CTransportSignalMsgWebRTCMessage_Candidate) pack() []byte {
	mut res := []byte{}
	if o.has_sdp_mid {
		res << vproto.pack_string_field(o.sdp_mid, 1)
	}
	if o.has_sdp_mline_index {
		res << vproto.pack_int32_field(o.sdp_mline_index, 2)
	}
	if o.has_candidate {
		res << vproto.pack_string_field(o.candidate, 3)
	}
	return res
}

pub fn ctransportsignalmsgwebrtcmessage_candidate_unpack(buf []byte) ?CTransportSignalMsgWebRTCMessage_Candidate {
	mut res := CTransportSignalMsgWebRTCMessage_Candidate{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_sdp_mid = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.sdp_mid = v
				i = ii
			}
			2 {
				res.has_sdp_mline_index = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.sdp_mline_index = v
				i = ii
			}
			3 {
				res.has_candidate = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.candidate = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctransportsignalmsgwebrtcmessage_candidate() CTransportSignalMsgWebRTCMessage_Candidate {
	return CTransportSignalMsgWebRTCMessage_Candidate{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctransportsignalmsgwebrtcmessage_candidate(o CTransportSignalMsgWebRTCMessage_Candidate, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctransportsignalmsgwebrtcmessage_candidate(buf []byte, tag_wiretype vproto.WireType) ?(int, CTransportSignalMsgWebRTCMessage_Candidate) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctransportsignalmsgwebrtcmessage_candidate_unpack(v)?
	return i, unpacked
}

pub struct CTransportSignalMsg_WebRTCMessage {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CTransportSignalMsg_WebRTCMessage) pack() []byte {
	res := []byte{}
	return res
}

pub fn ctransportsignalmsg_webrtcmessage_unpack(buf []byte) ?CTransportSignalMsg_WebRTCMessage {
	res := CTransportSignalMsg_WebRTCMessage{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctransportsignalmsg_webrtcmessage() CTransportSignalMsg_WebRTCMessage {
	return CTransportSignalMsg_WebRTCMessage{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctransportsignalmsg_webrtcmessage(o CTransportSignalMsg_WebRTCMessage, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctransportsignalmsg_webrtcmessage(buf []byte, tag_wiretype vproto.WireType) ?(int, CTransportSignalMsg_WebRTCMessage) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctransportsignalmsg_webrtcmessage_unpack(v)?
	return i, unpacked
}

pub struct CTransportSignalMsg {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	webrtc         CTransportSignalMsg_WebRTCMessage
	has_webrtc     bool
	sdr            [][]byte
}

pub fn (o &CTransportSignalMsg) pack() []byte {
	mut res := []byte{}
	if o.has_webrtc {
		res << zzz_vproto_internal_pack_ctransportsignalmsg_webrtcmessage(o.webrtc, 1)
	}
	// [packed=false]
	for _, x in o.sdr {
		res << vproto.pack_bytes_field(x, 2)
	}
	return res
}

pub fn ctransportsignalmsg_unpack(buf []byte) ?CTransportSignalMsg {
	mut res := CTransportSignalMsg{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_webrtc = true
				ii, v := zzz_vproto_internal_unpack_ctransportsignalmsg_webrtcmessage(cur_buf,
					tag_wiretype.wire_type)?
				res.webrtc = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.sdr << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_ctransportsignalmsg() CTransportSignalMsg {
	return CTransportSignalMsg{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_ctransportsignalmsg(o CTransportSignalMsg, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_ctransportsignalmsg(buf []byte, tag_wiretype vproto.WireType) ?(int, CTransportSignalMsg) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := ctransportsignalmsg_unpack(v)?
	return i, unpacked
}
