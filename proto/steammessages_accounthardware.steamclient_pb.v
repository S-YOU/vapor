// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EValveIndexComponent {
	k_evalveindexcomponentunknown = 0
	k_evalveindexcomponenthmd = 1
	k_evalveindexcomponentleftknuckle = 2
	k_evalveindexcomponentrightknuckle = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_evalveindexcomponent(e EValveIndexComponent, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_evalveindexcomponent_packed(e []EValveIndexComponent, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_evalveindexcomponent(buf []byte, tag_wiretype vproto.WireType) ?(int, EValveIndexComponent) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EValveIndexComponent(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_evalveindexcomponent_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EValveIndexComponent) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CAccountHardware_RegisterSteamController_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	serial_number       string
	has_serial_number   bool
	controller_code     string
	has_controller_code bool
}

pub fn (o &CAccountHardware_RegisterSteamController_Request) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_controller_code {
		res << vproto.pack_string_field(o.controller_code, 2)
	}
	return res
}

pub fn caccounthardware_registersteamcontroller_request_unpack(buf []byte) ?CAccountHardware_RegisterSteamController_Request {
	mut res := CAccountHardware_RegisterSteamController_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_controller_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_registersteamcontroller_request() CAccountHardware_RegisterSteamController_Request {
	return CAccountHardware_RegisterSteamController_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_registersteamcontroller_request(o CAccountHardware_RegisterSteamController_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_registersteamcontroller_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_RegisterSteamController_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_registersteamcontroller_request_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_RegisterSteamController_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CAccountHardware_RegisterSteamController_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn caccounthardware_registersteamcontroller_response_unpack(buf []byte) ?CAccountHardware_RegisterSteamController_Response {
	res := CAccountHardware_RegisterSteamController_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_registersteamcontroller_response() CAccountHardware_RegisterSteamController_Response {
	return CAccountHardware_RegisterSteamController_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_registersteamcontroller_response(o CAccountHardware_RegisterSteamController_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_registersteamcontroller_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_RegisterSteamController_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_registersteamcontroller_response_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_CompleteSteamControllerRegistration_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	serial_number       string
	has_serial_number   bool
	controller_code     string
	has_controller_code bool
}

pub fn (o &CAccountHardware_CompleteSteamControllerRegistration_Request) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_controller_code {
		res << vproto.pack_string_field(o.controller_code, 2)
	}
	return res
}

pub fn caccounthardware_completesteamcontrollerregistration_request_unpack(buf []byte) ?CAccountHardware_CompleteSteamControllerRegistration_Request {
	mut res := CAccountHardware_CompleteSteamControllerRegistration_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_controller_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_completesteamcontrollerregistration_request() CAccountHardware_CompleteSteamControllerRegistration_Request {
	return CAccountHardware_CompleteSteamControllerRegistration_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_completesteamcontrollerregistration_request(o CAccountHardware_CompleteSteamControllerRegistration_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_completesteamcontrollerregistration_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_CompleteSteamControllerRegistration_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_completesteamcontrollerregistration_request_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_CompleteSteamControllerRegistration_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CAccountHardware_CompleteSteamControllerRegistration_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn caccounthardware_completesteamcontrollerregistration_response_unpack(buf []byte) ?CAccountHardware_CompleteSteamControllerRegistration_Response {
	res := CAccountHardware_CompleteSteamControllerRegistration_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_completesteamcontrollerregistration_response() CAccountHardware_CompleteSteamControllerRegistration_Response {
	return CAccountHardware_CompleteSteamControllerRegistration_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_completesteamcontrollerregistration_response(o CAccountHardware_CompleteSteamControllerRegistration_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_completesteamcontrollerregistration_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_CompleteSteamControllerRegistration_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_completesteamcontrollerregistration_response_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_QueryAccountsRegisteredToSerial_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	serial_number       string
	has_serial_number   bool
	controller_code     string
	has_controller_code bool
}

pub fn (o &CAccountHardware_QueryAccountsRegisteredToSerial_Request) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_controller_code {
		res << vproto.pack_string_field(o.controller_code, 2)
	}
	return res
}

pub fn caccounthardware_queryaccountsregisteredtoserial_request_unpack(buf []byte) ?CAccountHardware_QueryAccountsRegisteredToSerial_Request {
	mut res := CAccountHardware_QueryAccountsRegisteredToSerial_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_controller_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_queryaccountsregisteredtoserial_request() CAccountHardware_QueryAccountsRegisteredToSerial_Request {
	return CAccountHardware_QueryAccountsRegisteredToSerial_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_queryaccountsregisteredtoserial_request(o CAccountHardware_QueryAccountsRegisteredToSerial_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_queryaccountsregisteredtoserial_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_QueryAccountsRegisteredToSerial_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_queryaccountsregisteredtoserial_request_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_QueryAccountsRegisteredToSerial_Accounts {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	accountid                 u32
	has_accountid             bool
	registration_complete     bool
	has_registration_complete bool
}

pub fn (o &CAccountHardware_QueryAccountsRegisteredToSerial_Accounts) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 1)
	}
	if o.has_registration_complete {
		res << vproto.pack_bool_field(o.registration_complete, 2)
	}
	return res
}

pub fn caccounthardware_queryaccountsregisteredtoserial_accounts_unpack(buf []byte) ?CAccountHardware_QueryAccountsRegisteredToSerial_Accounts {
	mut res := CAccountHardware_QueryAccountsRegisteredToSerial_Accounts{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_registration_complete = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.registration_complete = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_queryaccountsregisteredtoserial_accounts() CAccountHardware_QueryAccountsRegisteredToSerial_Accounts {
	return CAccountHardware_QueryAccountsRegisteredToSerial_Accounts{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_queryaccountsregisteredtoserial_accounts(o CAccountHardware_QueryAccountsRegisteredToSerial_Accounts, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_queryaccountsregisteredtoserial_accounts(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_QueryAccountsRegisteredToSerial_Accounts) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_queryaccountsregisteredtoserial_accounts_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_QueryAccountsRegisteredToSerial_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	accounts       []CAccountHardware_QueryAccountsRegisteredToSerial_Accounts
}

pub fn (o &CAccountHardware_QueryAccountsRegisteredToSerial_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.accounts {
		res <<
			zzz_vproto_internal_pack_caccounthardware_queryaccountsregisteredtoserial_accounts(x, 1)
	}
	return res
}

pub fn caccounthardware_queryaccountsregisteredtoserial_response_unpack(buf []byte) ?CAccountHardware_QueryAccountsRegisteredToSerial_Response {
	mut res := CAccountHardware_QueryAccountsRegisteredToSerial_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_caccounthardware_queryaccountsregisteredtoserial_accounts(cur_buf,
					tag_wiretype.wire_type)?
				res.accounts << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_queryaccountsregisteredtoserial_response() CAccountHardware_QueryAccountsRegisteredToSerial_Response {
	return CAccountHardware_QueryAccountsRegisteredToSerial_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_queryaccountsregisteredtoserial_response(o CAccountHardware_QueryAccountsRegisteredToSerial_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_queryaccountsregisteredtoserial_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_QueryAccountsRegisteredToSerial_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_queryaccountsregisteredtoserial_response_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_SteamControllerSetConfig_ControllerConfig {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	appidorname         string
	has_appidorname     bool
	publishedfileid     u64
	has_publishedfileid bool
	templatename        string
	has_templatename    bool
}

pub fn (o &CAccountHardware_SteamControllerSetConfig_ControllerConfig) pack() []byte {
	mut res := []byte{}
	if o.has_appidorname {
		res << vproto.pack_string_field(o.appidorname, 1)
	}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 2)
	}
	if o.has_templatename {
		res << vproto.pack_string_field(o.templatename, 3)
	}
	return res
}

pub fn caccounthardware_steamcontrollersetconfig_controllerconfig_unpack(buf []byte) ?CAccountHardware_SteamControllerSetConfig_ControllerConfig {
	mut res := CAccountHardware_SteamControllerSetConfig_ControllerConfig{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appidorname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.appidorname = v
				i = ii
			}
			2 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			3 {
				res.has_templatename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.templatename = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_steamcontrollersetconfig_controllerconfig() CAccountHardware_SteamControllerSetConfig_ControllerConfig {
	return CAccountHardware_SteamControllerSetConfig_ControllerConfig{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_steamcontrollersetconfig_controllerconfig(o CAccountHardware_SteamControllerSetConfig_ControllerConfig, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_steamcontrollersetconfig_controllerconfig(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_SteamControllerSetConfig_ControllerConfig) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_steamcontrollersetconfig_controllerconfig_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_SteamControllerSetConfig_Request {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	serial_number            string
	has_serial_number        bool
	controller_code          string
	has_controller_code      bool
	accountid                u32
	has_accountid            bool
	configurations           []CAccountHardware_SteamControllerSetConfig_ControllerConfig
	controller_type          int
	has_controller_type      bool
	only_for_this_serial     bool
	has_only_for_this_serial bool
}

pub fn (o &CAccountHardware_SteamControllerSetConfig_Request) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_controller_code {
		res << vproto.pack_string_field(o.controller_code, 2)
	}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 3)
	}
	// [packed=false]
	for _, x in o.configurations {
		res <<
			zzz_vproto_internal_pack_caccounthardware_steamcontrollersetconfig_controllerconfig(x, 4)
	}
	if o.has_controller_type {
		res << vproto.pack_int32_field(o.controller_type, 5)
	}
	if o.has_only_for_this_serial {
		res << vproto.pack_bool_field(o.only_for_this_serial, 6)
	}
	return res
}

pub fn caccounthardware_steamcontrollersetconfig_request_unpack(buf []byte) ?CAccountHardware_SteamControllerSetConfig_Request {
	mut res := CAccountHardware_SteamControllerSetConfig_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_controller_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_code = v
				i = ii
			}
			3 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_caccounthardware_steamcontrollersetconfig_controllerconfig(cur_buf,
					tag_wiretype.wire_type)?
				res.configurations << v
				i = ii
			}
			5 {
				res.has_controller_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_type = v
				i = ii
			}
			6 {
				res.has_only_for_this_serial = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.only_for_this_serial = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_steamcontrollersetconfig_request() CAccountHardware_SteamControllerSetConfig_Request {
	return CAccountHardware_SteamControllerSetConfig_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_steamcontrollersetconfig_request(o CAccountHardware_SteamControllerSetConfig_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_steamcontrollersetconfig_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_SteamControllerSetConfig_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_steamcontrollersetconfig_request_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_SteamControllerSetConfig_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CAccountHardware_SteamControllerSetConfig_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn caccounthardware_steamcontrollersetconfig_response_unpack(buf []byte) ?CAccountHardware_SteamControllerSetConfig_Response {
	res := CAccountHardware_SteamControllerSetConfig_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_steamcontrollersetconfig_response() CAccountHardware_SteamControllerSetConfig_Response {
	return CAccountHardware_SteamControllerSetConfig_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_steamcontrollersetconfig_response(o CAccountHardware_SteamControllerSetConfig_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_steamcontrollersetconfig_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_SteamControllerSetConfig_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_steamcontrollersetconfig_response_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_SteamControllerGetConfig_Request {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	serial_number            string
	has_serial_number        bool
	controller_code          string
	has_controller_code      bool
	accountid                u32
	has_accountid            bool
	appidorname              string
	has_appidorname          bool
	controller_type          int
	has_controller_type      bool
	only_for_this_serial     bool
	has_only_for_this_serial bool
}

pub fn (o &CAccountHardware_SteamControllerGetConfig_Request) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_controller_code {
		res << vproto.pack_string_field(o.controller_code, 2)
	}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 3)
	}
	if o.has_appidorname {
		res << vproto.pack_string_field(o.appidorname, 4)
	}
	if o.has_controller_type {
		res << vproto.pack_int32_field(o.controller_type, 5)
	}
	if o.has_only_for_this_serial {
		res << vproto.pack_bool_field(o.only_for_this_serial, 6)
	}
	return res
}

pub fn caccounthardware_steamcontrollergetconfig_request_unpack(buf []byte) ?CAccountHardware_SteamControllerGetConfig_Request {
	mut res := CAccountHardware_SteamControllerGetConfig_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_controller_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_code = v
				i = ii
			}
			3 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			4 {
				res.has_appidorname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.appidorname = v
				i = ii
			}
			5 {
				res.has_controller_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_type = v
				i = ii
			}
			6 {
				res.has_only_for_this_serial = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.only_for_this_serial = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_steamcontrollergetconfig_request() CAccountHardware_SteamControllerGetConfig_Request {
	return CAccountHardware_SteamControllerGetConfig_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_steamcontrollergetconfig_request(o CAccountHardware_SteamControllerGetConfig_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_steamcontrollergetconfig_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_SteamControllerGetConfig_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_steamcontrollergetconfig_request_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_SteamControllerGetConfig_ControllerConfig {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	appidorname         string
	has_appidorname     bool
	publishedfileid     u64
	has_publishedfileid bool
	templatename        string
	has_templatename    bool
	serial_number       string
	has_serial_number   bool
}

pub fn (o &CAccountHardware_SteamControllerGetConfig_ControllerConfig) pack() []byte {
	mut res := []byte{}
	if o.has_appidorname {
		res << vproto.pack_string_field(o.appidorname, 1)
	}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 2)
	}
	if o.has_templatename {
		res << vproto.pack_string_field(o.templatename, 3)
	}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 4)
	}
	return res
}

pub fn caccounthardware_steamcontrollergetconfig_controllerconfig_unpack(buf []byte) ?CAccountHardware_SteamControllerGetConfig_ControllerConfig {
	mut res := CAccountHardware_SteamControllerGetConfig_ControllerConfig{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appidorname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.appidorname = v
				i = ii
			}
			2 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			3 {
				res.has_templatename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.templatename = v
				i = ii
			}
			4 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_steamcontrollergetconfig_controllerconfig() CAccountHardware_SteamControllerGetConfig_ControllerConfig {
	return CAccountHardware_SteamControllerGetConfig_ControllerConfig{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_steamcontrollergetconfig_controllerconfig(o CAccountHardware_SteamControllerGetConfig_ControllerConfig, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_steamcontrollergetconfig_controllerconfig(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_SteamControllerGetConfig_ControllerConfig) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_steamcontrollergetconfig_controllerconfig_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_SteamControllerGetConfig_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	configurations []CAccountHardware_SteamControllerGetConfig_ControllerConfig
}

pub fn (o &CAccountHardware_SteamControllerGetConfig_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.configurations {
		res <<
			zzz_vproto_internal_pack_caccounthardware_steamcontrollergetconfig_controllerconfig(x, 1)
	}
	return res
}

pub fn caccounthardware_steamcontrollergetconfig_response_unpack(buf []byte) ?CAccountHardware_SteamControllerGetConfig_Response {
	mut res := CAccountHardware_SteamControllerGetConfig_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_caccounthardware_steamcontrollergetconfig_controllerconfig(cur_buf,
					tag_wiretype.wire_type)?
				res.configurations << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_steamcontrollergetconfig_response() CAccountHardware_SteamControllerGetConfig_Response {
	return CAccountHardware_SteamControllerGetConfig_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_steamcontrollergetconfig_response(o CAccountHardware_SteamControllerGetConfig_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_steamcontrollergetconfig_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_SteamControllerGetConfig_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_steamcontrollergetconfig_response_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_DeRegisterSteamController_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	serial_number       string
	has_serial_number   bool
	controller_code     string
	has_controller_code bool
	accountid           u32
	has_accountid       bool
}

pub fn (o &CAccountHardware_DeRegisterSteamController_Request) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_controller_code {
		res << vproto.pack_string_field(o.controller_code, 2)
	}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 3)
	}
	return res
}

pub fn caccounthardware_deregistersteamcontroller_request_unpack(buf []byte) ?CAccountHardware_DeRegisterSteamController_Request {
	mut res := CAccountHardware_DeRegisterSteamController_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_controller_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_code = v
				i = ii
			}
			3 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_deregistersteamcontroller_request() CAccountHardware_DeRegisterSteamController_Request {
	return CAccountHardware_DeRegisterSteamController_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_deregistersteamcontroller_request(o CAccountHardware_DeRegisterSteamController_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_deregistersteamcontroller_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_DeRegisterSteamController_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_deregistersteamcontroller_request_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_DeRegisterSteamController_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CAccountHardware_DeRegisterSteamController_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn caccounthardware_deregistersteamcontroller_response_unpack(buf []byte) ?CAccountHardware_DeRegisterSteamController_Response {
	res := CAccountHardware_DeRegisterSteamController_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_deregistersteamcontroller_response() CAccountHardware_DeRegisterSteamController_Response {
	return CAccountHardware_DeRegisterSteamController_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_deregistersteamcontroller_response(o CAccountHardware_DeRegisterSteamController_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_deregistersteamcontroller_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_DeRegisterSteamController_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_deregistersteamcontroller_response_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_SetPersonalizationFile_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	serial_number       string
	has_serial_number   bool
	publishedfileid     u64
	has_publishedfileid bool
	accountid           u32
	has_accountid       bool
}

pub fn (o &CAccountHardware_SetPersonalizationFile_Request) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 2)
	}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 3)
	}
	return res
}

pub fn caccounthardware_setpersonalizationfile_request_unpack(buf []byte) ?CAccountHardware_SetPersonalizationFile_Request {
	mut res := CAccountHardware_SetPersonalizationFile_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			3 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_setpersonalizationfile_request() CAccountHardware_SetPersonalizationFile_Request {
	return CAccountHardware_SetPersonalizationFile_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_setpersonalizationfile_request(o CAccountHardware_SetPersonalizationFile_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_setpersonalizationfile_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_SetPersonalizationFile_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_setpersonalizationfile_request_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_SetPersonalizationFile_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CAccountHardware_SetPersonalizationFile_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn caccounthardware_setpersonalizationfile_response_unpack(buf []byte) ?CAccountHardware_SetPersonalizationFile_Response {
	res := CAccountHardware_SetPersonalizationFile_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_setpersonalizationfile_response() CAccountHardware_SetPersonalizationFile_Response {
	return CAccountHardware_SetPersonalizationFile_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_setpersonalizationfile_response(o CAccountHardware_SetPersonalizationFile_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_setpersonalizationfile_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_SetPersonalizationFile_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_setpersonalizationfile_response_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_GetPersonalizationFile_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	serial_number     string
	has_serial_number bool
	accountid         u32
	has_accountid     bool
}

pub fn (o &CAccountHardware_GetPersonalizationFile_Request) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 2)
	}
	return res
}

pub fn caccounthardware_getpersonalizationfile_request_unpack(buf []byte) ?CAccountHardware_GetPersonalizationFile_Request {
	mut res := CAccountHardware_GetPersonalizationFile_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_getpersonalizationfile_request() CAccountHardware_GetPersonalizationFile_Request {
	return CAccountHardware_GetPersonalizationFile_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_getpersonalizationfile_request(o CAccountHardware_GetPersonalizationFile_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_getpersonalizationfile_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_GetPersonalizationFile_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_getpersonalizationfile_request_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_GetPersonalizationFile_Response {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
}

pub fn (o &CAccountHardware_GetPersonalizationFile_Response) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	return res
}

pub fn caccounthardware_getpersonalizationfile_response_unpack(buf []byte) ?CAccountHardware_GetPersonalizationFile_Response {
	mut res := CAccountHardware_GetPersonalizationFile_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_getpersonalizationfile_response() CAccountHardware_GetPersonalizationFile_Response {
	return CAccountHardware_GetPersonalizationFile_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_getpersonalizationfile_response(o CAccountHardware_GetPersonalizationFile_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_getpersonalizationfile_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_GetPersonalizationFile_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_getpersonalizationfile_response_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_VRCompatibilityCheck_Request_Pair {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &CAccountHardware_VRCompatibilityCheck_Request_Pair) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn caccounthardware_vrcompatibilitycheck_request_pair_unpack(buf []byte) ?CAccountHardware_VRCompatibilityCheck_Request_Pair {
	mut res := CAccountHardware_VRCompatibilityCheck_Request_Pair{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_vrcompatibilitycheck_request_pair() CAccountHardware_VRCompatibilityCheck_Request_Pair {
	return CAccountHardware_VRCompatibilityCheck_Request_Pair{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_vrcompatibilitycheck_request_pair(o CAccountHardware_VRCompatibilityCheck_Request_Pair, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_vrcompatibilitycheck_request_pair(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_VRCompatibilityCheck_Request_Pair) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_vrcompatibilitycheck_request_pair_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_VRCompatibilityCheck_Request {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	product_name     string
	has_product_name bool
	values           []CAccountHardware_VRCompatibilityCheck_Request_Pair
}

pub fn (o &CAccountHardware_VRCompatibilityCheck_Request) pack() []byte {
	mut res := []byte{}
	if o.has_product_name {
		res << vproto.pack_string_field(o.product_name, 1)
	}
	// [packed=false]
	for _, x in o.values {
		res << zzz_vproto_internal_pack_caccounthardware_vrcompatibilitycheck_request_pair(x, 2)
	}
	return res
}

pub fn caccounthardware_vrcompatibilitycheck_request_unpack(buf []byte) ?CAccountHardware_VRCompatibilityCheck_Request {
	mut res := CAccountHardware_VRCompatibilityCheck_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_product_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.product_name = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_caccounthardware_vrcompatibilitycheck_request_pair(cur_buf,
					tag_wiretype.wire_type)?
				res.values << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_vrcompatibilitycheck_request() CAccountHardware_VRCompatibilityCheck_Request {
	return CAccountHardware_VRCompatibilityCheck_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_vrcompatibilitycheck_request(o CAccountHardware_VRCompatibilityCheck_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_vrcompatibilitycheck_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_VRCompatibilityCheck_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_vrcompatibilitycheck_request_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_VRCompatibilityCheck_Response_Pair {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &CAccountHardware_VRCompatibilityCheck_Response_Pair) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn caccounthardware_vrcompatibilitycheck_response_pair_unpack(buf []byte) ?CAccountHardware_VRCompatibilityCheck_Response_Pair {
	mut res := CAccountHardware_VRCompatibilityCheck_Response_Pair{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_vrcompatibilitycheck_response_pair() CAccountHardware_VRCompatibilityCheck_Response_Pair {
	return CAccountHardware_VRCompatibilityCheck_Response_Pair{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_vrcompatibilitycheck_response_pair(o CAccountHardware_VRCompatibilityCheck_Response_Pair, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_vrcompatibilitycheck_response_pair(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_VRCompatibilityCheck_Response_Pair) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_vrcompatibilitycheck_response_pair_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_VRCompatibilityCheck_Response_ComponentDisplay {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	image          string
	has_image      bool
	value          string
	has_value      bool
}

pub fn (o &CAccountHardware_VRCompatibilityCheck_Response_ComponentDisplay) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_image {
		res << vproto.pack_string_field(o.image, 2)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 3)
	}
	return res
}

pub fn caccounthardware_vrcompatibilitycheck_response_componentdisplay_unpack(buf []byte) ?CAccountHardware_VRCompatibilityCheck_Response_ComponentDisplay {
	mut res := CAccountHardware_VRCompatibilityCheck_Response_ComponentDisplay{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_image = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.image = v
				i = ii
			}
			3 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_vrcompatibilitycheck_response_componentdisplay() CAccountHardware_VRCompatibilityCheck_Response_ComponentDisplay {
	return CAccountHardware_VRCompatibilityCheck_Response_ComponentDisplay{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_vrcompatibilitycheck_response_componentdisplay(o CAccountHardware_VRCompatibilityCheck_Response_ComponentDisplay, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_vrcompatibilitycheck_response_componentdisplay(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_VRCompatibilityCheck_Response_ComponentDisplay) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_vrcompatibilitycheck_response_componentdisplay_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_VRCompatibilityCheck_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	values         []CAccountHardware_VRCompatibilityCheck_Response_Pair
	components     []CAccountHardware_VRCompatibilityCheck_Response_ComponentDisplay
}

pub fn (o &CAccountHardware_VRCompatibilityCheck_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.values {
		res << zzz_vproto_internal_pack_caccounthardware_vrcompatibilitycheck_response_pair(x, 1)
	}
	// [packed=false]
	for _, x in o.components {
		res <<
			zzz_vproto_internal_pack_caccounthardware_vrcompatibilitycheck_response_componentdisplay(x, 2)
	}
	return res
}

pub fn caccounthardware_vrcompatibilitycheck_response_unpack(buf []byte) ?CAccountHardware_VRCompatibilityCheck_Response {
	mut res := CAccountHardware_VRCompatibilityCheck_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_caccounthardware_vrcompatibilitycheck_response_pair(cur_buf,
					tag_wiretype.wire_type)?
				res.values << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_caccounthardware_vrcompatibilitycheck_response_componentdisplay(cur_buf,
					tag_wiretype.wire_type)?
				res.components << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_vrcompatibilitycheck_response() CAccountHardware_VRCompatibilityCheck_Response {
	return CAccountHardware_VRCompatibilityCheck_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_vrcompatibilitycheck_response(o CAccountHardware_VRCompatibilityCheck_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_vrcompatibilitycheck_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_VRCompatibilityCheck_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_vrcompatibilitycheck_response_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_RegisterValveIndexComponent_Request {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	serial_number                  string
	has_serial_number              bool
	manufacturer_serial_number     string
	has_manufacturer_serial_number bool
	component_code                 string
	has_component_code             bool
	component_type                 EValveIndexComponent
	has_component_type             bool
	estimated_time_registered      int
	has_estimated_time_registered  bool
}

pub fn (o &CAccountHardware_RegisterValveIndexComponent_Request) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_manufacturer_serial_number {
		res << vproto.pack_string_field(o.manufacturer_serial_number, 2)
	}
	if o.has_component_code {
		res << vproto.pack_string_field(o.component_code, 3)
	}
	if o.has_component_type {
		res << zzz_vproto_internal_pack_evalveindexcomponent(o.component_type, 4)
	}
	if o.has_estimated_time_registered {
		res << vproto.pack_int32_field(o.estimated_time_registered, 5)
	}
	return res
}

pub fn caccounthardware_registervalveindexcomponent_request_unpack(buf []byte) ?CAccountHardware_RegisterValveIndexComponent_Request {
	mut res := CAccountHardware_RegisterValveIndexComponent_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_manufacturer_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.manufacturer_serial_number = v
				i = ii
			}
			3 {
				res.has_component_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.component_code = v
				i = ii
			}
			4 {
				res.has_component_type = true
				ii, v := zzz_vproto_internal_unpack_evalveindexcomponent(cur_buf, tag_wiretype.wire_type)?
				res.component_type = v
				i = ii
			}
			5 {
				res.has_estimated_time_registered = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.estimated_time_registered = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_registervalveindexcomponent_request() CAccountHardware_RegisterValveIndexComponent_Request {
	return CAccountHardware_RegisterValveIndexComponent_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_registervalveindexcomponent_request(o CAccountHardware_RegisterValveIndexComponent_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_registervalveindexcomponent_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_RegisterValveIndexComponent_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_registervalveindexcomponent_request_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardware_RegisterValveIndexComponent_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CAccountHardware_RegisterValveIndexComponent_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn caccounthardware_registervalveindexcomponent_response_unpack(buf []byte) ?CAccountHardware_RegisterValveIndexComponent_Response {
	res := CAccountHardware_RegisterValveIndexComponent_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardware_registervalveindexcomponent_response() CAccountHardware_RegisterValveIndexComponent_Response {
	return CAccountHardware_RegisterValveIndexComponent_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardware_registervalveindexcomponent_response(o CAccountHardware_RegisterValveIndexComponent_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardware_registervalveindexcomponent_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardware_RegisterValveIndexComponent_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardware_registervalveindexcomponent_response_unpack(v)?
	return i, unpacked
}
