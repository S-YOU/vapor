// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum EValveIndexComponent {
	k_evalveindexcomponentunknown = 0
	k_evalveindexcomponenthmd = 1
	k_evalveindexcomponentleftknuckle = 2
	k_evalveindexcomponentrightknuckle = 3
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_evalveindexcomponent(e EValveIndexComponent, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_evalveindexcomponent(buf []byte, tag_wiretype vproto.WireType) ?(int, EValveIndexComponent) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, EValveIndexComponent(v)
}

pub struct CAccountHardwareRegisterSteamControllerRequest {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	serial_number       string
	has_serial_number   bool
	controller_code     string
	has_controller_code bool
}

pub fn (o &CAccountHardwareRegisterSteamControllerRequest) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_controller_code {
		res << vproto.pack_string_field(o.controller_code, 2)
	}
	return res
}

pub fn caccounthardwareregistersteamcontrollerrequest_unpack(buf []byte) ?CAccountHardwareRegisterSteamControllerRequest {
	mut res := CAccountHardwareRegisterSteamControllerRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_controller_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwareregistersteamcontrollerrequest() CAccountHardwareRegisterSteamControllerRequest {
	return CAccountHardwareRegisterSteamControllerRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwareregistersteamcontrollerrequest(o CAccountHardwareRegisterSteamControllerRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwareregistersteamcontrollerrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareRegisterSteamControllerRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwareregistersteamcontrollerrequest_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareRegisterSteamControllerResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CAccountHardwareRegisterSteamControllerResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn caccounthardwareregistersteamcontrollerresponse_unpack(buf []byte) ?CAccountHardwareRegisterSteamControllerResponse {
	res := CAccountHardwareRegisterSteamControllerResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwareregistersteamcontrollerresponse() CAccountHardwareRegisterSteamControllerResponse {
	return CAccountHardwareRegisterSteamControllerResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwareregistersteamcontrollerresponse(o CAccountHardwareRegisterSteamControllerResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwareregistersteamcontrollerresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareRegisterSteamControllerResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwareregistersteamcontrollerresponse_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareCompleteSteamControllerRegistrationRequest {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	serial_number       string
	has_serial_number   bool
	controller_code     string
	has_controller_code bool
}

pub fn (o &CAccountHardwareCompleteSteamControllerRegistrationRequest) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_controller_code {
		res << vproto.pack_string_field(o.controller_code, 2)
	}
	return res
}

pub fn caccounthardwarecompletesteamcontrollerregistrationrequest_unpack(buf []byte) ?CAccountHardwareCompleteSteamControllerRegistrationRequest {
	mut res := CAccountHardwareCompleteSteamControllerRegistrationRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_controller_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwarecompletesteamcontrollerregistrationrequest() CAccountHardwareCompleteSteamControllerRegistrationRequest {
	return CAccountHardwareCompleteSteamControllerRegistrationRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwarecompletesteamcontrollerregistrationrequest(o CAccountHardwareCompleteSteamControllerRegistrationRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwarecompletesteamcontrollerregistrationrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareCompleteSteamControllerRegistrationRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwarecompletesteamcontrollerregistrationrequest_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareCompleteSteamControllerRegistrationResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CAccountHardwareCompleteSteamControllerRegistrationResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn caccounthardwarecompletesteamcontrollerregistrationresponse_unpack(buf []byte) ?CAccountHardwareCompleteSteamControllerRegistrationResponse {
	res := CAccountHardwareCompleteSteamControllerRegistrationResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwarecompletesteamcontrollerregistrationresponse() CAccountHardwareCompleteSteamControllerRegistrationResponse {
	return CAccountHardwareCompleteSteamControllerRegistrationResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwarecompletesteamcontrollerregistrationresponse(o CAccountHardwareCompleteSteamControllerRegistrationResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwarecompletesteamcontrollerregistrationresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareCompleteSteamControllerRegistrationResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwarecompletesteamcontrollerregistrationresponse_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareQueryAccountsRegisteredToSerialRequest {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	serial_number       string
	has_serial_number   bool
	controller_code     string
	has_controller_code bool
}

pub fn (o &CAccountHardwareQueryAccountsRegisteredToSerialRequest) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_controller_code {
		res << vproto.pack_string_field(o.controller_code, 2)
	}
	return res
}

pub fn caccounthardwarequeryaccountsregisteredtoserialrequest_unpack(buf []byte) ?CAccountHardwareQueryAccountsRegisteredToSerialRequest {
	mut res := CAccountHardwareQueryAccountsRegisteredToSerialRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_controller_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_code = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwarequeryaccountsregisteredtoserialrequest() CAccountHardwareQueryAccountsRegisteredToSerialRequest {
	return CAccountHardwareQueryAccountsRegisteredToSerialRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwarequeryaccountsregisteredtoserialrequest(o CAccountHardwareQueryAccountsRegisteredToSerialRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwarequeryaccountsregisteredtoserialrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareQueryAccountsRegisteredToSerialRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwarequeryaccountsregisteredtoserialrequest_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareQueryAccountsRegisteredToSerialAccounts {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	accountid                 u32
	has_accountid             bool
	registration_complete     bool
	has_registration_complete bool
}

pub fn (o &CAccountHardwareQueryAccountsRegisteredToSerialAccounts) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 1)
	}
	if o.has_registration_complete {
		res << vproto.pack_bool_field(o.registration_complete, 2)
	}
	return res
}

pub fn caccounthardwarequeryaccountsregisteredtoserialaccounts_unpack(buf []byte) ?CAccountHardwareQueryAccountsRegisteredToSerialAccounts {
	mut res := CAccountHardwareQueryAccountsRegisteredToSerialAccounts{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_registration_complete = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.registration_complete = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwarequeryaccountsregisteredtoserialaccounts() CAccountHardwareQueryAccountsRegisteredToSerialAccounts {
	return CAccountHardwareQueryAccountsRegisteredToSerialAccounts{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwarequeryaccountsregisteredtoserialaccounts(o CAccountHardwareQueryAccountsRegisteredToSerialAccounts, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwarequeryaccountsregisteredtoserialaccounts(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareQueryAccountsRegisteredToSerialAccounts) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwarequeryaccountsregisteredtoserialaccounts_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareQueryAccountsRegisteredToSerialResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	accounts       []CAccountHardwareQueryAccountsRegisteredToSerialAccounts
}

pub fn (o &CAccountHardwareQueryAccountsRegisteredToSerialResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.accounts {
		res <<
			zzz_vproto_internal_pack_caccounthardwarequeryaccountsregisteredtoserialaccounts(x, 1)
	}
	return res
}

pub fn caccounthardwarequeryaccountsregisteredtoserialresponse_unpack(buf []byte) ?CAccountHardwareQueryAccountsRegisteredToSerialResponse {
	mut res := CAccountHardwareQueryAccountsRegisteredToSerialResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_caccounthardwarequeryaccountsregisteredtoserialaccounts(cur_buf,
					tag_wiretype.wire_type)?
				res.accounts << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwarequeryaccountsregisteredtoserialresponse() CAccountHardwareQueryAccountsRegisteredToSerialResponse {
	return CAccountHardwareQueryAccountsRegisteredToSerialResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwarequeryaccountsregisteredtoserialresponse(o CAccountHardwareQueryAccountsRegisteredToSerialResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwarequeryaccountsregisteredtoserialresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareQueryAccountsRegisteredToSerialResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwarequeryaccountsregisteredtoserialresponse_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareSteamControllerSetConfigControllerConfig {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	appidorname         string
	has_appidorname     bool
	publishedfileid     u64
	has_publishedfileid bool
	templatename        string
	has_templatename    bool
}

pub fn (o &CAccountHardwareSteamControllerSetConfigControllerConfig) pack() []byte {
	mut res := []byte{}
	if o.has_appidorname {
		res << vproto.pack_string_field(o.appidorname, 1)
	}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 2)
	}
	if o.has_templatename {
		res << vproto.pack_string_field(o.templatename, 3)
	}
	return res
}

pub fn caccounthardwaresteamcontrollersetconfigcontrollerconfig_unpack(buf []byte) ?CAccountHardwareSteamControllerSetConfigControllerConfig {
	mut res := CAccountHardwareSteamControllerSetConfigControllerConfig{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appidorname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.appidorname = v
				i = ii
			}
			2 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			3 {
				res.has_templatename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.templatename = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwaresteamcontrollersetconfigcontrollerconfig() CAccountHardwareSteamControllerSetConfigControllerConfig {
	return CAccountHardwareSteamControllerSetConfigControllerConfig{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwaresteamcontrollersetconfigcontrollerconfig(o CAccountHardwareSteamControllerSetConfigControllerConfig, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwaresteamcontrollersetconfigcontrollerconfig(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareSteamControllerSetConfigControllerConfig) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwaresteamcontrollersetconfigcontrollerconfig_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareSteamControllerSetConfigRequest {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	serial_number            string
	has_serial_number        bool
	controller_code          string
	has_controller_code      bool
	accountid                u32
	has_accountid            bool
	configurations           []CAccountHardwareSteamControllerSetConfigControllerConfig
	controller_type          int
	has_controller_type      bool
	only_for_this_serial     bool
	has_only_for_this_serial bool
}

pub fn (o &CAccountHardwareSteamControllerSetConfigRequest) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_controller_code {
		res << vproto.pack_string_field(o.controller_code, 2)
	}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 3)
	}
	// [packed=false]
	for _, x in o.configurations {
		res <<
			zzz_vproto_internal_pack_caccounthardwaresteamcontrollersetconfigcontrollerconfig(x, 4)
	}
	if o.has_controller_type {
		res << vproto.pack_int32_field(o.controller_type, 5)
	}
	if o.has_only_for_this_serial {
		res << vproto.pack_bool_field(o.only_for_this_serial, 6)
	}
	return res
}

pub fn caccounthardwaresteamcontrollersetconfigrequest_unpack(buf []byte) ?CAccountHardwareSteamControllerSetConfigRequest {
	mut res := CAccountHardwareSteamControllerSetConfigRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_controller_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_code = v
				i = ii
			}
			3 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_caccounthardwaresteamcontrollersetconfigcontrollerconfig(cur_buf,
					tag_wiretype.wire_type)?
				res.configurations << v
				i = ii
			}
			5 {
				res.has_controller_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_type = v
				i = ii
			}
			6 {
				res.has_only_for_this_serial = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.only_for_this_serial = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwaresteamcontrollersetconfigrequest() CAccountHardwareSteamControllerSetConfigRequest {
	return CAccountHardwareSteamControllerSetConfigRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwaresteamcontrollersetconfigrequest(o CAccountHardwareSteamControllerSetConfigRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwaresteamcontrollersetconfigrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareSteamControllerSetConfigRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwaresteamcontrollersetconfigrequest_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareSteamControllerSetConfigResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CAccountHardwareSteamControllerSetConfigResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn caccounthardwaresteamcontrollersetconfigresponse_unpack(buf []byte) ?CAccountHardwareSteamControllerSetConfigResponse {
	res := CAccountHardwareSteamControllerSetConfigResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwaresteamcontrollersetconfigresponse() CAccountHardwareSteamControllerSetConfigResponse {
	return CAccountHardwareSteamControllerSetConfigResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwaresteamcontrollersetconfigresponse(o CAccountHardwareSteamControllerSetConfigResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwaresteamcontrollersetconfigresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareSteamControllerSetConfigResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwaresteamcontrollersetconfigresponse_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareSteamControllerGetConfigRequest {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	serial_number            string
	has_serial_number        bool
	controller_code          string
	has_controller_code      bool
	accountid                u32
	has_accountid            bool
	appidorname              string
	has_appidorname          bool
	controller_type          int
	has_controller_type      bool
	only_for_this_serial     bool
	has_only_for_this_serial bool
}

pub fn (o &CAccountHardwareSteamControllerGetConfigRequest) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_controller_code {
		res << vproto.pack_string_field(o.controller_code, 2)
	}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 3)
	}
	if o.has_appidorname {
		res << vproto.pack_string_field(o.appidorname, 4)
	}
	if o.has_controller_type {
		res << vproto.pack_int32_field(o.controller_type, 5)
	}
	if o.has_only_for_this_serial {
		res << vproto.pack_bool_field(o.only_for_this_serial, 6)
	}
	return res
}

pub fn caccounthardwaresteamcontrollergetconfigrequest_unpack(buf []byte) ?CAccountHardwareSteamControllerGetConfigRequest {
	mut res := CAccountHardwareSteamControllerGetConfigRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_controller_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_code = v
				i = ii
			}
			3 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			4 {
				res.has_appidorname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.appidorname = v
				i = ii
			}
			5 {
				res.has_controller_type = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_type = v
				i = ii
			}
			6 {
				res.has_only_for_this_serial = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.only_for_this_serial = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwaresteamcontrollergetconfigrequest() CAccountHardwareSteamControllerGetConfigRequest {
	return CAccountHardwareSteamControllerGetConfigRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwaresteamcontrollergetconfigrequest(o CAccountHardwareSteamControllerGetConfigRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwaresteamcontrollergetconfigrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareSteamControllerGetConfigRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwaresteamcontrollergetconfigrequest_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareSteamControllerGetConfigControllerConfig {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	appidorname         string
	has_appidorname     bool
	publishedfileid     u64
	has_publishedfileid bool
	templatename        string
	has_templatename    bool
	serial_number       string
	has_serial_number   bool
}

pub fn (o &CAccountHardwareSteamControllerGetConfigControllerConfig) pack() []byte {
	mut res := []byte{}
	if o.has_appidorname {
		res << vproto.pack_string_field(o.appidorname, 1)
	}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 2)
	}
	if o.has_templatename {
		res << vproto.pack_string_field(o.templatename, 3)
	}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 4)
	}
	return res
}

pub fn caccounthardwaresteamcontrollergetconfigcontrollerconfig_unpack(buf []byte) ?CAccountHardwareSteamControllerGetConfigControllerConfig {
	mut res := CAccountHardwareSteamControllerGetConfigControllerConfig{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appidorname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.appidorname = v
				i = ii
			}
			2 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			3 {
				res.has_templatename = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.templatename = v
				i = ii
			}
			4 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwaresteamcontrollergetconfigcontrollerconfig() CAccountHardwareSteamControllerGetConfigControllerConfig {
	return CAccountHardwareSteamControllerGetConfigControllerConfig{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwaresteamcontrollergetconfigcontrollerconfig(o CAccountHardwareSteamControllerGetConfigControllerConfig, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwaresteamcontrollergetconfigcontrollerconfig(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareSteamControllerGetConfigControllerConfig) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwaresteamcontrollergetconfigcontrollerconfig_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareSteamControllerGetConfigResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	configurations []CAccountHardwareSteamControllerGetConfigControllerConfig
}

pub fn (o &CAccountHardwareSteamControllerGetConfigResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.configurations {
		res <<
			zzz_vproto_internal_pack_caccounthardwaresteamcontrollergetconfigcontrollerconfig(x, 1)
	}
	return res
}

pub fn caccounthardwaresteamcontrollergetconfigresponse_unpack(buf []byte) ?CAccountHardwareSteamControllerGetConfigResponse {
	mut res := CAccountHardwareSteamControllerGetConfigResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_caccounthardwaresteamcontrollergetconfigcontrollerconfig(cur_buf,
					tag_wiretype.wire_type)?
				res.configurations << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwaresteamcontrollergetconfigresponse() CAccountHardwareSteamControllerGetConfigResponse {
	return CAccountHardwareSteamControllerGetConfigResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwaresteamcontrollergetconfigresponse(o CAccountHardwareSteamControllerGetConfigResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwaresteamcontrollergetconfigresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareSteamControllerGetConfigResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwaresteamcontrollergetconfigresponse_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareDeRegisterSteamControllerRequest {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	serial_number       string
	has_serial_number   bool
	controller_code     string
	has_controller_code bool
	accountid           u32
	has_accountid       bool
}

pub fn (o &CAccountHardwareDeRegisterSteamControllerRequest) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_controller_code {
		res << vproto.pack_string_field(o.controller_code, 2)
	}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 3)
	}
	return res
}

pub fn caccounthardwarederegistersteamcontrollerrequest_unpack(buf []byte) ?CAccountHardwareDeRegisterSteamControllerRequest {
	mut res := CAccountHardwareDeRegisterSteamControllerRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_controller_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.controller_code = v
				i = ii
			}
			3 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwarederegistersteamcontrollerrequest() CAccountHardwareDeRegisterSteamControllerRequest {
	return CAccountHardwareDeRegisterSteamControllerRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwarederegistersteamcontrollerrequest(o CAccountHardwareDeRegisterSteamControllerRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwarederegistersteamcontrollerrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareDeRegisterSteamControllerRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwarederegistersteamcontrollerrequest_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareDeRegisterSteamControllerResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CAccountHardwareDeRegisterSteamControllerResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn caccounthardwarederegistersteamcontrollerresponse_unpack(buf []byte) ?CAccountHardwareDeRegisterSteamControllerResponse {
	res := CAccountHardwareDeRegisterSteamControllerResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwarederegistersteamcontrollerresponse() CAccountHardwareDeRegisterSteamControllerResponse {
	return CAccountHardwareDeRegisterSteamControllerResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwarederegistersteamcontrollerresponse(o CAccountHardwareDeRegisterSteamControllerResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwarederegistersteamcontrollerresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareDeRegisterSteamControllerResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwarederegistersteamcontrollerresponse_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareSetPersonalizationFileRequest {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	serial_number       string
	has_serial_number   bool
	publishedfileid     u64
	has_publishedfileid bool
	accountid           u32
	has_accountid       bool
}

pub fn (o &CAccountHardwareSetPersonalizationFileRequest) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 2)
	}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 3)
	}
	return res
}

pub fn caccounthardwaresetpersonalizationfilerequest_unpack(buf []byte) ?CAccountHardwareSetPersonalizationFileRequest {
	mut res := CAccountHardwareSetPersonalizationFileRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			3 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwaresetpersonalizationfilerequest() CAccountHardwareSetPersonalizationFileRequest {
	return CAccountHardwareSetPersonalizationFileRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwaresetpersonalizationfilerequest(o CAccountHardwareSetPersonalizationFileRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwaresetpersonalizationfilerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareSetPersonalizationFileRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwaresetpersonalizationfilerequest_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareSetPersonalizationFileResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CAccountHardwareSetPersonalizationFileResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn caccounthardwaresetpersonalizationfileresponse_unpack(buf []byte) ?CAccountHardwareSetPersonalizationFileResponse {
	res := CAccountHardwareSetPersonalizationFileResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwaresetpersonalizationfileresponse() CAccountHardwareSetPersonalizationFileResponse {
	return CAccountHardwareSetPersonalizationFileResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwaresetpersonalizationfileresponse(o CAccountHardwareSetPersonalizationFileResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwaresetpersonalizationfileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareSetPersonalizationFileResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwaresetpersonalizationfileresponse_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareGetPersonalizationFileRequest {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	serial_number     string
	has_serial_number bool
	accountid         u32
	has_accountid     bool
}

pub fn (o &CAccountHardwareGetPersonalizationFileRequest) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 2)
	}
	return res
}

pub fn caccounthardwaregetpersonalizationfilerequest_unpack(buf []byte) ?CAccountHardwareGetPersonalizationFileRequest {
	mut res := CAccountHardwareGetPersonalizationFileRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwaregetpersonalizationfilerequest() CAccountHardwareGetPersonalizationFileRequest {
	return CAccountHardwareGetPersonalizationFileRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwaregetpersonalizationfilerequest(o CAccountHardwareGetPersonalizationFileRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwaregetpersonalizationfilerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareGetPersonalizationFileRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwaregetpersonalizationfilerequest_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareGetPersonalizationFileResponse {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	publishedfileid     u64
	has_publishedfileid bool
}

pub fn (o &CAccountHardwareGetPersonalizationFileResponse) pack() []byte {
	mut res := []byte{}
	if o.has_publishedfileid {
		res << vproto.pack_uint64_field(o.publishedfileid, 1)
	}
	return res
}

pub fn caccounthardwaregetpersonalizationfileresponse_unpack(buf []byte) ?CAccountHardwareGetPersonalizationFileResponse {
	mut res := CAccountHardwareGetPersonalizationFileResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_publishedfileid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.publishedfileid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwaregetpersonalizationfileresponse() CAccountHardwareGetPersonalizationFileResponse {
	return CAccountHardwareGetPersonalizationFileResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwaregetpersonalizationfileresponse(o CAccountHardwareGetPersonalizationFileResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwaregetpersonalizationfileresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareGetPersonalizationFileResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwaregetpersonalizationfileresponse_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareVRcompatibilityCheckRequestPair {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &CAccountHardwareVRcompatibilityCheckRequestPair) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn caccounthardwarevrcompatibilitycheckrequestpair_unpack(buf []byte) ?CAccountHardwareVRcompatibilityCheckRequestPair {
	mut res := CAccountHardwareVRcompatibilityCheckRequestPair{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwarevrcompatibilitycheckrequestpair() CAccountHardwareVRcompatibilityCheckRequestPair {
	return CAccountHardwareVRcompatibilityCheckRequestPair{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwarevrcompatibilitycheckrequestpair(o CAccountHardwareVRcompatibilityCheckRequestPair, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwarevrcompatibilitycheckrequestpair(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareVRcompatibilityCheckRequestPair) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwarevrcompatibilitycheckrequestpair_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareVRcompatibilityCheckRequest {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	product_name     string
	has_product_name bool
	values           []CAccountHardwareVRcompatibilityCheckRequestPair
}

pub fn (o &CAccountHardwareVRcompatibilityCheckRequest) pack() []byte {
	mut res := []byte{}
	if o.has_product_name {
		res << vproto.pack_string_field(o.product_name, 1)
	}
	// [packed=false]
	for _, x in o.values {
		res << zzz_vproto_internal_pack_caccounthardwarevrcompatibilitycheckrequestpair(x, 2)
	}
	return res
}

pub fn caccounthardwarevrcompatibilitycheckrequest_unpack(buf []byte) ?CAccountHardwareVRcompatibilityCheckRequest {
	mut res := CAccountHardwareVRcompatibilityCheckRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_product_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.product_name = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_caccounthardwarevrcompatibilitycheckrequestpair(cur_buf,
					tag_wiretype.wire_type)?
				res.values << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwarevrcompatibilitycheckrequest() CAccountHardwareVRcompatibilityCheckRequest {
	return CAccountHardwareVRcompatibilityCheckRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwarevrcompatibilitycheckrequest(o CAccountHardwareVRcompatibilityCheckRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwarevrcompatibilitycheckrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareVRcompatibilityCheckRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwarevrcompatibilitycheckrequest_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareVRcompatibilityCheckResponsePair {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	key            string
	has_key        bool
	value          string
	has_value      bool
}

pub fn (o &CAccountHardwareVRcompatibilityCheckResponsePair) pack() []byte {
	mut res := []byte{}
	if o.has_key {
		res << vproto.pack_string_field(o.key, 1)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 2)
	}
	return res
}

pub fn caccounthardwarevrcompatibilitycheckresponsepair_unpack(buf []byte) ?CAccountHardwareVRcompatibilityCheckResponsePair {
	mut res := CAccountHardwareVRcompatibilityCheckResponsePair{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_key = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.key = v
				i = ii
			}
			2 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwarevrcompatibilitycheckresponsepair() CAccountHardwareVRcompatibilityCheckResponsePair {
	return CAccountHardwareVRcompatibilityCheckResponsePair{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwarevrcompatibilitycheckresponsepair(o CAccountHardwareVRcompatibilityCheckResponsePair, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwarevrcompatibilitycheckresponsepair(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareVRcompatibilityCheckResponsePair) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwarevrcompatibilitycheckresponsepair_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareVRcompatibilityCheckResponseComponentDisplay {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	name           string
	has_name       bool
	image          string
	has_image      bool
	value          string
	has_value      bool
}

pub fn (o &CAccountHardwareVRcompatibilityCheckResponseComponentDisplay) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_image {
		res << vproto.pack_string_field(o.image, 2)
	}
	if o.has_value {
		res << vproto.pack_string_field(o.value, 3)
	}
	return res
}

pub fn caccounthardwarevrcompatibilitycheckresponsecomponentdisplay_unpack(buf []byte) ?CAccountHardwareVRcompatibilityCheckResponseComponentDisplay {
	mut res := CAccountHardwareVRcompatibilityCheckResponseComponentDisplay{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_image = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.image = v
				i = ii
			}
			3 {
				res.has_value = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.value = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwarevrcompatibilitycheckresponsecomponentdisplay() CAccountHardwareVRcompatibilityCheckResponseComponentDisplay {
	return CAccountHardwareVRcompatibilityCheckResponseComponentDisplay{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwarevrcompatibilitycheckresponsecomponentdisplay(o CAccountHardwareVRcompatibilityCheckResponseComponentDisplay, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwarevrcompatibilitycheckresponsecomponentdisplay(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareVRcompatibilityCheckResponseComponentDisplay) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwarevrcompatibilitycheckresponsecomponentdisplay_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareVRcompatibilityCheckResponse {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	values         []CAccountHardwareVRcompatibilityCheckResponsePair
	components     []CAccountHardwareVRcompatibilityCheckResponseComponentDisplay
}

pub fn (o &CAccountHardwareVRcompatibilityCheckResponse) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.values {
		res << zzz_vproto_internal_pack_caccounthardwarevrcompatibilitycheckresponsepair(x, 1)
	}
	// [packed=false]
	for _, x in o.components {
		res <<
			zzz_vproto_internal_pack_caccounthardwarevrcompatibilitycheckresponsecomponentdisplay(x, 2)
	}
	return res
}

pub fn caccounthardwarevrcompatibilitycheckresponse_unpack(buf []byte) ?CAccountHardwareVRcompatibilityCheckResponse {
	mut res := CAccountHardwareVRcompatibilityCheckResponse{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_caccounthardwarevrcompatibilitycheckresponsepair(cur_buf,
					tag_wiretype.wire_type)?
				res.values << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_caccounthardwarevrcompatibilitycheckresponsecomponentdisplay(cur_buf,
					tag_wiretype.wire_type)?
				res.components << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwarevrcompatibilitycheckresponse() CAccountHardwareVRcompatibilityCheckResponse {
	return CAccountHardwareVRcompatibilityCheckResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwarevrcompatibilitycheckresponse(o CAccountHardwareVRcompatibilityCheckResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwarevrcompatibilitycheckresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareVRcompatibilityCheckResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwarevrcompatibilitycheckresponse_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareRegisterValveIndexComponentRequest {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	serial_number                  string
	has_serial_number              bool
	manufacturer_serial_number     string
	has_manufacturer_serial_number bool
	component_code                 string
	has_component_code             bool
	component_type                 EValveIndexComponent
	has_component_type             bool
	estimated_time_registered      int
	has_estimated_time_registered  bool
}

pub fn (o &CAccountHardwareRegisterValveIndexComponentRequest) pack() []byte {
	mut res := []byte{}
	if o.has_serial_number {
		res << vproto.pack_string_field(o.serial_number, 1)
	}
	if o.has_manufacturer_serial_number {
		res << vproto.pack_string_field(o.manufacturer_serial_number, 2)
	}
	if o.has_component_code {
		res << vproto.pack_string_field(o.component_code, 3)
	}
	if o.has_component_type {
		res << zzz_vproto_internal_pack_evalveindexcomponent(o.component_type, 4)
	}
	if o.has_estimated_time_registered {
		res << vproto.pack_int32_field(o.estimated_time_registered, 5)
	}
	return res
}

pub fn caccounthardwareregistervalveindexcomponentrequest_unpack(buf []byte) ?CAccountHardwareRegisterValveIndexComponentRequest {
	mut res := CAccountHardwareRegisterValveIndexComponentRequest{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.serial_number = v
				i = ii
			}
			2 {
				res.has_manufacturer_serial_number = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.manufacturer_serial_number = v
				i = ii
			}
			3 {
				res.has_component_code = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.component_code = v
				i = ii
			}
			4 {
				res.has_component_type = true
				ii, v := zzz_vproto_internal_unpack_evalveindexcomponent(cur_buf, tag_wiretype.wire_type)?
				res.component_type = v
				i = ii
			}
			5 {
				res.has_estimated_time_registered = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.estimated_time_registered = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwareregistervalveindexcomponentrequest() CAccountHardwareRegisterValveIndexComponentRequest {
	return CAccountHardwareRegisterValveIndexComponentRequest{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwareregistervalveindexcomponentrequest(o CAccountHardwareRegisterValveIndexComponentRequest, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwareregistervalveindexcomponentrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareRegisterValveIndexComponentRequest) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwareregistervalveindexcomponentrequest_unpack(v)?
	return i, unpacked
}

pub struct CAccountHardwareRegisterValveIndexComponentResponse {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CAccountHardwareRegisterValveIndexComponentResponse) pack() []byte {
	res := []byte{}
	return res
}

pub fn caccounthardwareregistervalveindexcomponentresponse_unpack(buf []byte) ?CAccountHardwareRegisterValveIndexComponentResponse {
	res := CAccountHardwareRegisterValveIndexComponentResponse{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_caccounthardwareregistervalveindexcomponentresponse() CAccountHardwareRegisterValveIndexComponentResponse {
	return CAccountHardwareRegisterValveIndexComponentResponse{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_caccounthardwareregistervalveindexcomponentresponse(o CAccountHardwareRegisterValveIndexComponentResponse, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_caccounthardwareregistervalveindexcomponentresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CAccountHardwareRegisterValveIndexComponentResponse) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := caccounthardwareregistervalveindexcomponentresponse_unpack(v)?
	return i, unpacked
}
