// Generated by vproto - Do not modify
module proto

import emily33901.vproto

pub struct COffline_GetOfflineLogonTicket_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	priority       u32
	has_priority   bool
}

pub fn (o &COffline_GetOfflineLogonTicket_Request) pack() []byte {
	mut res := []byte{}
	if o.has_priority {
		res << vproto.pack_uint32_field(o.priority, 1)
	}
	return res
}

pub fn coffline_getofflinelogonticket_request_unpack(buf []byte) ?COffline_GetOfflineLogonTicket_Request {
	mut res := COffline_GetOfflineLogonTicket_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_priority = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.priority = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_coffline_getofflinelogonticket_request() COffline_GetOfflineLogonTicket_Request {
	return COffline_GetOfflineLogonTicket_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_coffline_getofflinelogonticket_request(o COffline_GetOfflineLogonTicket_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_coffline_getofflinelogonticket_request(buf []byte, tag_wiretype vproto.WireType) ?(int, COffline_GetOfflineLogonTicket_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := coffline_getofflinelogonticket_request_unpack(v)?
	return i, unpacked
}

pub struct COffline_GetOfflineLogonTicket_Response {
mut:
	unknown_fields        []vproto.UnknownField
pub mut:
	serialized_ticket     []byte
	has_serialized_ticket bool
	signature             []byte
	has_signature         bool
}

pub fn (o &COffline_GetOfflineLogonTicket_Response) pack() []byte {
	mut res := []byte{}
	if o.has_serialized_ticket {
		res << vproto.pack_bytes_field(o.serialized_ticket, 1)
	}
	if o.has_signature {
		res << vproto.pack_bytes_field(o.signature, 2)
	}
	return res
}

pub fn coffline_getofflinelogonticket_response_unpack(buf []byte) ?COffline_GetOfflineLogonTicket_Response {
	mut res := COffline_GetOfflineLogonTicket_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_serialized_ticket = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.serialized_ticket = v
				i = ii
			}
			2 {
				res.has_signature = true
				ii, v := vproto.unpack_bytes_field(cur_buf, tag_wiretype.wire_type)?
				res.signature = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_coffline_getofflinelogonticket_response() COffline_GetOfflineLogonTicket_Response {
	return COffline_GetOfflineLogonTicket_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_coffline_getofflinelogonticket_response(o COffline_GetOfflineLogonTicket_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_coffline_getofflinelogonticket_response(buf []byte, tag_wiretype vproto.WireType) ?(int, COffline_GetOfflineLogonTicket_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := coffline_getofflinelogonticket_response_unpack(v)?
	return i, unpacked
}

pub struct COffline_GetUnsignedOfflineLogonTicket_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &COffline_GetUnsignedOfflineLogonTicket_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn coffline_getunsignedofflinelogonticket_request_unpack(buf []byte) ?COffline_GetUnsignedOfflineLogonTicket_Request {
	res := COffline_GetUnsignedOfflineLogonTicket_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_coffline_getunsignedofflinelogonticket_request() COffline_GetUnsignedOfflineLogonTicket_Request {
	return COffline_GetUnsignedOfflineLogonTicket_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_coffline_getunsignedofflinelogonticket_request(o COffline_GetUnsignedOfflineLogonTicket_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_coffline_getunsignedofflinelogonticket_request(buf []byte, tag_wiretype vproto.WireType) ?(int, COffline_GetUnsignedOfflineLogonTicket_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := coffline_getunsignedofflinelogonticket_request_unpack(v)?
	return i, unpacked
}

pub struct COffline_OfflineLogonTicket {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	accountid                 u32
	has_accountid             bool
	rtime32_creation_time     u32
	has_rtime32_creation_time bool
}

pub fn (o &COffline_OfflineLogonTicket) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 1)
	}
	if o.has_rtime32_creation_time {
		res << vproto.pack_32bit_field(o.rtime32_creation_time, 2)
	}
	return res
}

pub fn coffline_offlinelogonticket_unpack(buf []byte) ?COffline_OfflineLogonTicket {
	mut res := COffline_OfflineLogonTicket{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_rtime32_creation_time = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.rtime32_creation_time = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_coffline_offlinelogonticket() COffline_OfflineLogonTicket {
	return COffline_OfflineLogonTicket{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_coffline_offlinelogonticket(o COffline_OfflineLogonTicket, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_coffline_offlinelogonticket(buf []byte, tag_wiretype vproto.WireType) ?(int, COffline_OfflineLogonTicket) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := coffline_offlinelogonticket_unpack(v)?
	return i, unpacked
}

pub struct COffline_GetUnsignedOfflineLogonTicket_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ticket         COffline_OfflineLogonTicket
	has_ticket     bool
}

pub fn (o &COffline_GetUnsignedOfflineLogonTicket_Response) pack() []byte {
	mut res := []byte{}
	if o.has_ticket {
		res << zzz_vproto_internal_pack_coffline_offlinelogonticket(o.ticket, 1)
	}
	return res
}

pub fn coffline_getunsignedofflinelogonticket_response_unpack(buf []byte) ?COffline_GetUnsignedOfflineLogonTicket_Response {
	mut res := COffline_GetUnsignedOfflineLogonTicket_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_ticket = true
				ii, v := zzz_vproto_internal_unpack_coffline_offlinelogonticket(cur_buf,
					tag_wiretype.wire_type)?
				res.ticket = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_coffline_getunsignedofflinelogonticket_response() COffline_GetUnsignedOfflineLogonTicket_Response {
	return COffline_GetUnsignedOfflineLogonTicket_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_coffline_getunsignedofflinelogonticket_response(o COffline_GetUnsignedOfflineLogonTicket_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_coffline_getunsignedofflinelogonticket_response(buf []byte, tag_wiretype vproto.WireType) ?(int, COffline_GetUnsignedOfflineLogonTicket_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := coffline_getunsignedofflinelogonticket_response_unpack(v)?
	return i, unpacked
}
