// Generated by vproto - Do not modify
module proto

import emily33901.vproto

[_allow_multiple_values]
enum ENotificationSetting {
	k_enotificationsettingnotifyusedefault = 0
	k_enotificationsettingalways = 1
	k_enotificationsettingnever = 2
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_enotificationsetting(e ENotificationSetting, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_enotificationsetting_packed(e []ENotificationSetting, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_enotificationsetting(buf []byte, tag_wiretype vproto.WireType) ?(int, ENotificationSetting) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
	return i, ENotificationSetting(v)
}

// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_enotificationsetting_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []ENotificationSetting) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype)?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct CPlayer_GetMutualFriendsForIncomingInvites_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_GetMutualFriendsForIncomingInvites_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_getmutualfriendsforincominginvites_request_unpack(buf []byte) ?CPlayer_GetMutualFriendsForIncomingInvites_Request {
	res := CPlayer_GetMutualFriendsForIncomingInvites_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getmutualfriendsforincominginvites_request() CPlayer_GetMutualFriendsForIncomingInvites_Request {
	return CPlayer_GetMutualFriendsForIncomingInvites_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getmutualfriendsforincominginvites_request(o CPlayer_GetMutualFriendsForIncomingInvites_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getmutualfriendsforincominginvites_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetMutualFriendsForIncomingInvites_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getmutualfriendsforincominginvites_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_IncomingInviteMutualFriendList {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	steamid                   u64
	has_steamid               bool
	mutual_friend_account_ids []u32
}

pub fn (o &CPlayer_IncomingInviteMutualFriendList) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	// [packed=false]
	for _, x in o.mutual_friend_account_ids {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cplayer_incominginvitemutualfriendlist_unpack(buf []byte) ?CPlayer_IncomingInviteMutualFriendList {
	mut res := CPlayer_IncomingInviteMutualFriendList{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.mutual_friend_account_ids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_incominginvitemutualfriendlist() CPlayer_IncomingInviteMutualFriendList {
	return CPlayer_IncomingInviteMutualFriendList{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_incominginvitemutualfriendlist(o CPlayer_IncomingInviteMutualFriendList, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_incominginvitemutualfriendlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_IncomingInviteMutualFriendList) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_incominginvitemutualfriendlist_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetMutualFriendsForIncomingInvites_Response {
mut:
	unknown_fields                       []vproto.UnknownField
pub mut:
	incoming_invite_mutual_friends_lists []CPlayer_IncomingInviteMutualFriendList
}

pub fn (o &CPlayer_GetMutualFriendsForIncomingInvites_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.incoming_invite_mutual_friends_lists {
		res << zzz_vproto_internal_pack_cplayer_incominginvitemutualfriendlist(x, 1)
	}
	return res
}

pub fn cplayer_getmutualfriendsforincominginvites_response_unpack(buf []byte) ?CPlayer_GetMutualFriendsForIncomingInvites_Response {
	mut res := CPlayer_GetMutualFriendsForIncomingInvites_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_incominginvitemutualfriendlist(cur_buf,
					tag_wiretype.wire_type)?
				res.incoming_invite_mutual_friends_lists << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getmutualfriendsforincominginvites_response() CPlayer_GetMutualFriendsForIncomingInvites_Response {
	return CPlayer_GetMutualFriendsForIncomingInvites_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getmutualfriendsforincominginvites_response(o CPlayer_GetMutualFriendsForIncomingInvites_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getmutualfriendsforincominginvites_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetMutualFriendsForIncomingInvites_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getmutualfriendsforincominginvites_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetOwnedGames_Request {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	steamid                       u64
	has_steamid                   bool
	include_appinfo               bool
	has_include_appinfo           bool
	include_played_free_games     bool
	has_include_played_free_games bool
	appids_filter                 []u32
	include_free_sub              bool
	has_include_free_sub          bool
}

pub fn (o &CPlayer_GetOwnedGames_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 1)
	}
	if o.has_include_appinfo {
		res << vproto.pack_bool_field(o.include_appinfo, 2)
	}
	if o.has_include_played_free_games {
		res << vproto.pack_bool_field(o.include_played_free_games, 3)
	}
	// [packed=false]
	for _, x in o.appids_filter {
		res << vproto.pack_uint32_field(x, 4)
	}
	if o.has_include_free_sub {
		res << vproto.pack_bool_field(o.include_free_sub, 5)
	}
	return res
}

pub fn cplayer_getownedgames_request_unpack(buf []byte) ?CPlayer_GetOwnedGames_Request {
	mut res := CPlayer_GetOwnedGames_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_include_appinfo = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_appinfo = v
				i = ii
			}
			3 {
				res.has_include_played_free_games = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_played_free_games = v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appids_filter << v
				i = ii
			}
			5 {
				res.has_include_free_sub = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.include_free_sub = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getownedgames_request() CPlayer_GetOwnedGames_Request {
	return CPlayer_GetOwnedGames_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getownedgames_request(o CPlayer_GetOwnedGames_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getownedgames_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetOwnedGames_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getownedgames_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetOwnedGames_Response_Game {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	appid                           int
	has_appid                       bool
	name                            string
	has_name                        bool
	playtime_2weeks                 int
	has_playtime_2weeks             bool
	playtime_forever                int
	has_playtime_forever            bool
	img_icon_url                    string
	has_img_icon_url                bool
	img_logo_url                    string
	has_img_logo_url                bool
	has_community_visible_stats     bool
	has_has_community_visible_stats bool
	playtime_windows_forever        int
	has_playtime_windows_forever    bool
	playtime_mac_forever            int
	has_playtime_mac_forever        bool
	playtime_linux_forever          int
	has_playtime_linux_forever      bool
}

pub fn (o &CPlayer_GetOwnedGames_Response_Game) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_int32_field(o.appid, 1)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 2)
	}
	if o.has_playtime_2weeks {
		res << vproto.pack_int32_field(o.playtime_2weeks, 3)
	}
	if o.has_playtime_forever {
		res << vproto.pack_int32_field(o.playtime_forever, 4)
	}
	if o.has_img_icon_url {
		res << vproto.pack_string_field(o.img_icon_url, 5)
	}
	if o.has_img_logo_url {
		res << vproto.pack_string_field(o.img_logo_url, 6)
	}
	if o.has_has_community_visible_stats {
		res << vproto.pack_bool_field(o.has_community_visible_stats, 7)
	}
	if o.has_playtime_windows_forever {
		res << vproto.pack_int32_field(o.playtime_windows_forever, 8)
	}
	if o.has_playtime_mac_forever {
		res << vproto.pack_int32_field(o.playtime_mac_forever, 9)
	}
	if o.has_playtime_linux_forever {
		res << vproto.pack_int32_field(o.playtime_linux_forever, 10)
	}
	return res
}

pub fn cplayer_getownedgames_response_game_unpack(buf []byte) ?CPlayer_GetOwnedGames_Response_Game {
	mut res := CPlayer_GetOwnedGames_Response_Game{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			3 {
				res.has_playtime_2weeks = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.playtime_2weeks = v
				i = ii
			}
			4 {
				res.has_playtime_forever = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.playtime_forever = v
				i = ii
			}
			5 {
				res.has_img_icon_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.img_icon_url = v
				i = ii
			}
			6 {
				res.has_img_logo_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.img_logo_url = v
				i = ii
			}
			7 {
				res.has_has_community_visible_stats = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.has_community_visible_stats = v
				i = ii
			}
			8 {
				res.has_playtime_windows_forever = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.playtime_windows_forever = v
				i = ii
			}
			9 {
				res.has_playtime_mac_forever = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.playtime_mac_forever = v
				i = ii
			}
			10 {
				res.has_playtime_linux_forever = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.playtime_linux_forever = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getownedgames_response_game() CPlayer_GetOwnedGames_Response_Game {
	return CPlayer_GetOwnedGames_Response_Game{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getownedgames_response_game(o CPlayer_GetOwnedGames_Response_Game, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getownedgames_response_game(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetOwnedGames_Response_Game) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getownedgames_response_game_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetOwnedGames_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	game_count     u32
	has_game_count bool
	games          []CPlayer_GetOwnedGames_Response_Game
}

pub fn (o &CPlayer_GetOwnedGames_Response) pack() []byte {
	mut res := []byte{}
	if o.has_game_count {
		res << vproto.pack_uint32_field(o.game_count, 1)
	}
	// [packed=false]
	for _, x in o.games {
		res << zzz_vproto_internal_pack_cplayer_getownedgames_response_game(x, 2)
	}
	return res
}

pub fn cplayer_getownedgames_response_unpack(buf []byte) ?CPlayer_GetOwnedGames_Response {
	mut res := CPlayer_GetOwnedGames_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_game_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.game_count = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getownedgames_response_game(cur_buf,
					tag_wiretype.wire_type)?
				res.games << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getownedgames_response() CPlayer_GetOwnedGames_Response {
	return CPlayer_GetOwnedGames_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getownedgames_response(o CPlayer_GetOwnedGames_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getownedgames_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetOwnedGames_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getownedgames_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetPlayNext_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	max_age_seconds     u32
	has_max_age_seconds bool
	ignore_appids       []u32
}

pub fn (o &CPlayer_GetPlayNext_Request) pack() []byte {
	mut res := []byte{}
	if o.has_max_age_seconds {
		res << vproto.pack_uint32_field(o.max_age_seconds, 1)
	}
	// [packed=false]
	for _, x in o.ignore_appids {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cplayer_getplaynext_request_unpack(buf []byte) ?CPlayer_GetPlayNext_Request {
	mut res := CPlayer_GetPlayNext_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_max_age_seconds = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.max_age_seconds = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.ignore_appids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getplaynext_request() CPlayer_GetPlayNext_Request {
	return CPlayer_GetPlayNext_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getplaynext_request(o CPlayer_GetPlayNext_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getplaynext_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetPlayNext_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getplaynext_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetPlayNext_Response {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	last_update_time     u32
	has_last_update_time bool
	appids               []u32
}

pub fn (o &CPlayer_GetPlayNext_Response) pack() []byte {
	mut res := []byte{}
	if o.has_last_update_time {
		res << vproto.pack_uint32_field(o.last_update_time, 1)
	}
	// [packed=false]
	for _, x in o.appids {
		res << vproto.pack_uint32_field(x, 2)
	}
	return res
}

pub fn cplayer_getplaynext_response_unpack(buf []byte) ?CPlayer_GetPlayNext_Response {
	mut res := CPlayer_GetPlayNext_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_last_update_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_update_time = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getplaynext_response() CPlayer_GetPlayNext_Response {
	return CPlayer_GetPlayNext_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getplaynext_response(o CPlayer_GetPlayNext_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getplaynext_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetPlayNext_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getplaynext_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetFriendsGameplayInfo_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
}

pub fn (o &CPlayer_GetFriendsGameplayInfo_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cplayer_getfriendsgameplayinfo_request_unpack(buf []byte) ?CPlayer_GetFriendsGameplayInfo_Request {
	mut res := CPlayer_GetFriendsGameplayInfo_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getfriendsgameplayinfo_request() CPlayer_GetFriendsGameplayInfo_Request {
	return CPlayer_GetFriendsGameplayInfo_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getfriendsgameplayinfo_request(o CPlayer_GetFriendsGameplayInfo_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getfriendsgameplayinfo_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetFriendsGameplayInfo_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getfriendsgameplayinfo_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	steamid                    u64
	has_steamid                bool
	minutes_played             u32
	has_minutes_played         bool
	minutes_played_forever     u32
	has_minutes_played_forever bool
}

pub fn (o &CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_minutes_played {
		res << vproto.pack_uint32_field(o.minutes_played, 2)
	}
	if o.has_minutes_played_forever {
		res << vproto.pack_uint32_field(o.minutes_played_forever, 3)
	}
	return res
}

pub fn cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo_unpack(buf []byte) ?CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
	mut res := CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_minutes_played = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.minutes_played = v
				i = ii
			}
			3 {
				res.has_minutes_played_forever = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.minutes_played_forever = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo() CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo {
	return CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo(o CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
mut:
	unknown_fields             []vproto.UnknownField
pub mut:
	steamid                    u64
	has_steamid                bool
	minutes_played             u32
	has_minutes_played         bool
	minutes_played_forever     u32
	has_minutes_played_forever bool
	in_wishlist                bool
	has_in_wishlist            bool
	owned                      bool
	has_owned                  bool
}

pub fn (o &CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_minutes_played {
		res << vproto.pack_uint32_field(o.minutes_played, 2)
	}
	if o.has_minutes_played_forever {
		res << vproto.pack_uint32_field(o.minutes_played_forever, 3)
	}
	if o.has_in_wishlist {
		res << vproto.pack_bool_field(o.in_wishlist, 4)
	}
	if o.has_owned {
		res << vproto.pack_bool_field(o.owned, 5)
	}
	return res
}

pub fn cplayer_getfriendsgameplayinfo_response_owngameplayinfo_unpack(buf []byte) ?CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
	mut res := CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_minutes_played = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.minutes_played = v
				i = ii
			}
			3 {
				res.has_minutes_played_forever = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.minutes_played_forever = v
				i = ii
			}
			4 {
				res.has_in_wishlist = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.in_wishlist = v
				i = ii
			}
			5 {
				res.has_owned = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.owned = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getfriendsgameplayinfo_response_owngameplayinfo() CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo {
	return CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getfriendsgameplayinfo_response_owngameplayinfo(o CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getfriendsgameplayinfo_response_owngameplayinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getfriendsgameplayinfo_response_owngameplayinfo_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetFriendsGameplayInfo_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	your_info       CPlayer_GetFriendsGameplayInfo_Response_OwnGameplayInfo
	has_your_info   bool
	in_game         []CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo
	played_recently []CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo
	played_ever     []CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo
	owns            []CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo
	in_wishlist     []CPlayer_GetFriendsGameplayInfo_Response_FriendsGameplayInfo
}

pub fn (o &CPlayer_GetFriendsGameplayInfo_Response) pack() []byte {
	mut res := []byte{}
	if o.has_your_info {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsgameplayinfo_response_owngameplayinfo(o.your_info, 1)
	}
	// [packed=false]
	for _, x in o.in_game {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo(x, 2)
	}
	// [packed=false]
	for _, x in o.played_recently {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo(x, 3)
	}
	// [packed=false]
	for _, x in o.played_ever {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo(x, 4)
	}
	// [packed=false]
	for _, x in o.owns {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo(x, 5)
	}
	// [packed=false]
	for _, x in o.in_wishlist {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo(x, 6)
	}
	return res
}

pub fn cplayer_getfriendsgameplayinfo_response_unpack(buf []byte) ?CPlayer_GetFriendsGameplayInfo_Response {
	mut res := CPlayer_GetFriendsGameplayInfo_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_your_info = true
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsgameplayinfo_response_owngameplayinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.your_info = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.in_game << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.played_recently << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.played_ever << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.owns << v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsgameplayinfo_response_friendsgameplayinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.in_wishlist << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getfriendsgameplayinfo_response() CPlayer_GetFriendsGameplayInfo_Response {
	return CPlayer_GetFriendsGameplayInfo_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getfriendsgameplayinfo_response(o CPlayer_GetFriendsGameplayInfo_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getfriendsgameplayinfo_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetFriendsGameplayInfo_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getfriendsgameplayinfo_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetFriendsAppsActivity_Request {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	news_language     string
	has_news_language bool
	request_flags     u32
	has_request_flags bool
}

pub fn (o &CPlayer_GetFriendsAppsActivity_Request) pack() []byte {
	mut res := []byte{}
	if o.has_news_language {
		res << vproto.pack_string_field(o.news_language, 1)
	}
	if o.has_request_flags {
		res << vproto.pack_uint32_field(o.request_flags, 2)
	}
	return res
}

pub fn cplayer_getfriendsappsactivity_request_unpack(buf []byte) ?CPlayer_GetFriendsAppsActivity_Request {
	mut res := CPlayer_GetFriendsAppsActivity_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_news_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.news_language = v
				i = ii
			}
			2 {
				res.has_request_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.request_flags = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getfriendsappsactivity_request() CPlayer_GetFriendsAppsActivity_Request {
	return CPlayer_GetFriendsAppsActivity_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getfriendsappsactivity_request(o CPlayer_GetFriendsAppsActivity_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getfriendsappsactivity_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetFriendsAppsActivity_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getfriendsappsactivity_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	steamid                      u64
	has_steamid                  bool
	minutes_played_this_week     u32
	has_minutes_played_this_week bool
	minutes_played_two_weeks     u32
	has_minutes_played_two_weeks bool
	minutes_played_forever       u32
	has_minutes_played_forever   bool
	event_count                  u32
	has_event_count              bool
}

pub fn (o &CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_minutes_played_this_week {
		res << vproto.pack_uint32_field(o.minutes_played_this_week, 2)
	}
	if o.has_minutes_played_two_weeks {
		res << vproto.pack_uint32_field(o.minutes_played_two_weeks, 3)
	}
	if o.has_minutes_played_forever {
		res << vproto.pack_uint32_field(o.minutes_played_forever, 4)
	}
	if o.has_event_count {
		res << vproto.pack_uint32_field(o.event_count, 5)
	}
	return res
}

pub fn cplayer_getfriendsappsactivity_response_friendplaytime_unpack(buf []byte) ?CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
	mut res := CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_minutes_played_this_week = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.minutes_played_this_week = v
				i = ii
			}
			3 {
				res.has_minutes_played_two_weeks = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.minutes_played_two_weeks = v
				i = ii
			}
			4 {
				res.has_minutes_played_forever = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.minutes_played_forever = v
				i = ii
			}
			5 {
				res.has_event_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.event_count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getfriendsappsactivity_response_friendplaytime() CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime {
	return CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getfriendsappsactivity_response_friendplaytime(o CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getfriendsappsactivity_response_friendplaytime(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getfriendsappsactivity_response_friendplaytime_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
mut:
	unknown_fields    []vproto.UnknownField
pub mut:
	appid             u32
	has_appid         bool
	friends           []CPlayer_GetFriendsAppsActivity_Response_FriendPlayTime
	display_order     u32
	has_display_order bool
}

pub fn (o &CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	// [packed=false]
	for _, x in o.friends {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsappsactivity_response_friendplaytime(x, 2)
	}
	if o.has_display_order {
		res << vproto.pack_uint32_field(o.display_order, 3)
	}
	return res
}

pub fn cplayer_getfriendsappsactivity_response_appfriendsinfo_unpack(buf []byte) ?CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
	mut res := CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsappsactivity_response_friendplaytime(cur_buf,
					tag_wiretype.wire_type)?
				res.friends << v
				i = ii
			}
			3 {
				res.has_display_order = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.display_order = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getfriendsappsactivity_response_appfriendsinfo() CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo {
	return CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getfriendsappsactivity_response_appfriendsinfo(o CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getfriendsappsactivity_response_appfriendsinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getfriendsappsactivity_response_appfriendsinfo_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetFriendsAppsActivity_Response {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	trending                []CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo
	recent_purchases        []CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo
	unowned                 []CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo
	popular                 []CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo
	dont_forget             []CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo
	being_discussed         []CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo
	new_to_group            []CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo
	returned_to_group       []CPlayer_GetFriendsAppsActivity_Response_AppFriendsInfo
	active_friend_count     u32
	has_active_friend_count bool
}

pub fn (o &CPlayer_GetFriendsAppsActivity_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.trending {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsappsactivity_response_appfriendsinfo(x, 1)
	}
	// [packed=false]
	for _, x in o.recent_purchases {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsappsactivity_response_appfriendsinfo(x, 2)
	}
	// [packed=false]
	for _, x in o.unowned {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsappsactivity_response_appfriendsinfo(x, 3)
	}
	// [packed=false]
	for _, x in o.popular {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsappsactivity_response_appfriendsinfo(x, 4)
	}
	// [packed=false]
	for _, x in o.dont_forget {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsappsactivity_response_appfriendsinfo(x, 5)
	}
	// [packed=false]
	for _, x in o.being_discussed {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsappsactivity_response_appfriendsinfo(x, 6)
	}
	// [packed=false]
	for _, x in o.new_to_group {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsappsactivity_response_appfriendsinfo(x, 7)
	}
	// [packed=false]
	for _, x in o.returned_to_group {
		res <<
			zzz_vproto_internal_pack_cplayer_getfriendsappsactivity_response_appfriendsinfo(x, 8)
	}
	if o.has_active_friend_count {
		res << vproto.pack_uint32_field(o.active_friend_count, 9)
	}
	return res
}

pub fn cplayer_getfriendsappsactivity_response_unpack(buf []byte) ?CPlayer_GetFriendsAppsActivity_Response {
	mut res := CPlayer_GetFriendsAppsActivity_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsappsactivity_response_appfriendsinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.trending << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsappsactivity_response_appfriendsinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.recent_purchases << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsappsactivity_response_appfriendsinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.unowned << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsappsactivity_response_appfriendsinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.popular << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsappsactivity_response_appfriendsinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.dont_forget << v
				i = ii
			}
			6 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsappsactivity_response_appfriendsinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.being_discussed << v
				i = ii
			}
			7 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsappsactivity_response_appfriendsinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.new_to_group << v
				i = ii
			}
			8 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getfriendsappsactivity_response_appfriendsinfo(cur_buf,
					tag_wiretype.wire_type)?
				res.returned_to_group << v
				i = ii
			}
			9 {
				res.has_active_friend_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.active_friend_count = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getfriendsappsactivity_response() CPlayer_GetFriendsAppsActivity_Response {
	return CPlayer_GetFriendsAppsActivity_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getfriendsappsactivity_response(o CPlayer_GetFriendsAppsActivity_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getfriendsappsactivity_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetFriendsAppsActivity_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getfriendsappsactivity_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetGameBadgeLevels_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
}

pub fn (o &CPlayer_GetGameBadgeLevels_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cplayer_getgamebadgelevels_request_unpack(buf []byte) ?CPlayer_GetGameBadgeLevels_Request {
	mut res := CPlayer_GetGameBadgeLevels_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getgamebadgelevels_request() CPlayer_GetGameBadgeLevels_Request {
	return CPlayer_GetGameBadgeLevels_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getgamebadgelevels_request(o CPlayer_GetGameBadgeLevels_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getgamebadgelevels_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetGameBadgeLevels_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getgamebadgelevels_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetGameBadgeLevels_Response_Badge {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	level            int
	has_level        bool
	series           int
	has_series       bool
	border_color     u32
	has_border_color bool
}

pub fn (o &CPlayer_GetGameBadgeLevels_Response_Badge) pack() []byte {
	mut res := []byte{}
	if o.has_level {
		res << vproto.pack_int32_field(o.level, 1)
	}
	if o.has_series {
		res << vproto.pack_int32_field(o.series, 2)
	}
	if o.has_border_color {
		res << vproto.pack_uint32_field(o.border_color, 3)
	}
	return res
}

pub fn cplayer_getgamebadgelevels_response_badge_unpack(buf []byte) ?CPlayer_GetGameBadgeLevels_Response_Badge {
	mut res := CPlayer_GetGameBadgeLevels_Response_Badge{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_level = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.level = v
				i = ii
			}
			2 {
				res.has_series = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.series = v
				i = ii
			}
			3 {
				res.has_border_color = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.border_color = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getgamebadgelevels_response_badge() CPlayer_GetGameBadgeLevels_Response_Badge {
	return CPlayer_GetGameBadgeLevels_Response_Badge{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getgamebadgelevels_response_badge(o CPlayer_GetGameBadgeLevels_Response_Badge, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getgamebadgelevels_response_badge(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetGameBadgeLevels_Response_Badge) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getgamebadgelevels_response_badge_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetGameBadgeLevels_Response {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	player_level     u32
	has_player_level bool
	badges           []CPlayer_GetGameBadgeLevels_Response_Badge
}

pub fn (o &CPlayer_GetGameBadgeLevels_Response) pack() []byte {
	mut res := []byte{}
	if o.has_player_level {
		res << vproto.pack_uint32_field(o.player_level, 1)
	}
	// [packed=false]
	for _, x in o.badges {
		res << zzz_vproto_internal_pack_cplayer_getgamebadgelevels_response_badge(x, 2)
	}
	return res
}

pub fn cplayer_getgamebadgelevels_response_unpack(buf []byte) ?CPlayer_GetGameBadgeLevels_Response {
	mut res := CPlayer_GetGameBadgeLevels_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_player_level = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.player_level = v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getgamebadgelevels_response_badge(cur_buf,
					tag_wiretype.wire_type)?
				res.badges << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getgamebadgelevels_response() CPlayer_GetGameBadgeLevels_Response {
	return CPlayer_GetGameBadgeLevels_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getgamebadgelevels_response(o CPlayer_GetGameBadgeLevels_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getgamebadgelevels_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetGameBadgeLevels_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getgamebadgelevels_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetProfileBackground_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	language       string
	has_language   bool
}

pub fn (o &CPlayer_GetProfileBackground_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 2)
	}
	return res
}

pub fn cplayer_getprofilebackground_request_unpack(buf []byte) ?CPlayer_GetProfileBackground_Request {
	mut res := CPlayer_GetProfileBackground_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getprofilebackground_request() CPlayer_GetProfileBackground_Request {
	return CPlayer_GetProfileBackground_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getprofilebackground_request(o CPlayer_GetProfileBackground_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getprofilebackground_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetProfileBackground_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getprofilebackground_request_unpack(v)?
	return i, unpacked
}

pub struct ProfileItem {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	communityitemid      u64
	has_communityitemid  bool
	image_small          string
	has_image_small      bool
	image_large          string
	has_image_large      bool
	name                 string
	has_name             bool
	item_title           string
	has_item_title       bool
	item_description     string
	has_item_description bool
	appid                u32
	has_appid            bool
	item_type            u32
	has_item_type        bool
	item_class           u32
	has_item_class       bool
	movie_webm           string
	has_movie_webm       bool
	movie_mp4            string
	has_movie_mp4        bool
	equipped_flags       u32
	has_equipped_flags   bool
}

pub fn (o &ProfileItem) pack() []byte {
	mut res := []byte{}
	if o.has_communityitemid {
		res << vproto.pack_uint64_field(o.communityitemid, 1)
	}
	if o.has_image_small {
		res << vproto.pack_string_field(o.image_small, 2)
	}
	if o.has_image_large {
		res << vproto.pack_string_field(o.image_large, 3)
	}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 4)
	}
	if o.has_item_title {
		res << vproto.pack_string_field(o.item_title, 5)
	}
	if o.has_item_description {
		res << vproto.pack_string_field(o.item_description, 6)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 7)
	}
	if o.has_item_type {
		res << vproto.pack_uint32_field(o.item_type, 8)
	}
	if o.has_item_class {
		res << vproto.pack_uint32_field(o.item_class, 9)
	}
	if o.has_movie_webm {
		res << vproto.pack_string_field(o.movie_webm, 10)
	}
	if o.has_movie_mp4 {
		res << vproto.pack_string_field(o.movie_mp4, 11)
	}
	if o.has_equipped_flags {
		res << vproto.pack_uint32_field(o.equipped_flags, 12)
	}
	return res
}

pub fn profileitem_unpack(buf []byte) ?ProfileItem {
	mut res := ProfileItem{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_communityitemid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.communityitemid = v
				i = ii
			}
			2 {
				res.has_image_small = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.image_small = v
				i = ii
			}
			3 {
				res.has_image_large = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.image_large = v
				i = ii
			}
			4 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			5 {
				res.has_item_title = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.item_title = v
				i = ii
			}
			6 {
				res.has_item_description = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.item_description = v
				i = ii
			}
			7 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			8 {
				res.has_item_type = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.item_type = v
				i = ii
			}
			9 {
				res.has_item_class = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.item_class = v
				i = ii
			}
			10 {
				res.has_movie_webm = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.movie_webm = v
				i = ii
			}
			11 {
				res.has_movie_mp4 = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.movie_mp4 = v
				i = ii
			}
			12 {
				res.has_equipped_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.equipped_flags = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_profileitem() ProfileItem {
	return ProfileItem{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_profileitem(o ProfileItem, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_profileitem(buf []byte, tag_wiretype vproto.WireType) ?(int, ProfileItem) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := profileitem_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetProfileBackground_Response {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	profile_background     ProfileItem
	has_profile_background bool
}

pub fn (o &CPlayer_GetProfileBackground_Response) pack() []byte {
	mut res := []byte{}
	if o.has_profile_background {
		res << zzz_vproto_internal_pack_profileitem(o.profile_background, 1)
	}
	return res
}

pub fn cplayer_getprofilebackground_response_unpack(buf []byte) ?CPlayer_GetProfileBackground_Response {
	mut res := CPlayer_GetProfileBackground_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_profile_background = true
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.profile_background = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getprofilebackground_response() CPlayer_GetProfileBackground_Response {
	return CPlayer_GetProfileBackground_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getprofilebackground_response(o CPlayer_GetProfileBackground_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getprofilebackground_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetProfileBackground_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getprofilebackground_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetProfileBackground_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	communityitemid     u64
	has_communityitemid bool
}

pub fn (o &CPlayer_SetProfileBackground_Request) pack() []byte {
	mut res := []byte{}
	if o.has_communityitemid {
		res << vproto.pack_uint64_field(o.communityitemid, 1)
	}
	return res
}

pub fn cplayer_setprofilebackground_request_unpack(buf []byte) ?CPlayer_SetProfileBackground_Request {
	mut res := CPlayer_SetProfileBackground_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_communityitemid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.communityitemid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setprofilebackground_request() CPlayer_SetProfileBackground_Request {
	return CPlayer_SetProfileBackground_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setprofilebackground_request(o CPlayer_SetProfileBackground_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setprofilebackground_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetProfileBackground_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setprofilebackground_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetProfileBackground_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_SetProfileBackground_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_setprofilebackground_response_unpack(buf []byte) ?CPlayer_SetProfileBackground_Response {
	res := CPlayer_SetProfileBackground_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setprofilebackground_response() CPlayer_SetProfileBackground_Response {
	return CPlayer_SetProfileBackground_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setprofilebackground_response(o CPlayer_SetProfileBackground_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setprofilebackground_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetProfileBackground_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setprofilebackground_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetMiniProfileBackground_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	language       string
	has_language   bool
}

pub fn (o &CPlayer_GetMiniProfileBackground_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 2)
	}
	return res
}

pub fn cplayer_getminiprofilebackground_request_unpack(buf []byte) ?CPlayer_GetMiniProfileBackground_Request {
	mut res := CPlayer_GetMiniProfileBackground_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getminiprofilebackground_request() CPlayer_GetMiniProfileBackground_Request {
	return CPlayer_GetMiniProfileBackground_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getminiprofilebackground_request(o CPlayer_GetMiniProfileBackground_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getminiprofilebackground_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetMiniProfileBackground_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getminiprofilebackground_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetMiniProfileBackground_Response {
mut:
	unknown_fields         []vproto.UnknownField
pub mut:
	profile_background     ProfileItem
	has_profile_background bool
}

pub fn (o &CPlayer_GetMiniProfileBackground_Response) pack() []byte {
	mut res := []byte{}
	if o.has_profile_background {
		res << zzz_vproto_internal_pack_profileitem(o.profile_background, 1)
	}
	return res
}

pub fn cplayer_getminiprofilebackground_response_unpack(buf []byte) ?CPlayer_GetMiniProfileBackground_Response {
	mut res := CPlayer_GetMiniProfileBackground_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_profile_background = true
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.profile_background = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getminiprofilebackground_response() CPlayer_GetMiniProfileBackground_Response {
	return CPlayer_GetMiniProfileBackground_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getminiprofilebackground_response(o CPlayer_GetMiniProfileBackground_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getminiprofilebackground_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetMiniProfileBackground_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getminiprofilebackground_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetMiniProfileBackground_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	communityitemid     u64
	has_communityitemid bool
}

pub fn (o &CPlayer_SetMiniProfileBackground_Request) pack() []byte {
	mut res := []byte{}
	if o.has_communityitemid {
		res << vproto.pack_uint64_field(o.communityitemid, 1)
	}
	return res
}

pub fn cplayer_setminiprofilebackground_request_unpack(buf []byte) ?CPlayer_SetMiniProfileBackground_Request {
	mut res := CPlayer_SetMiniProfileBackground_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_communityitemid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.communityitemid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setminiprofilebackground_request() CPlayer_SetMiniProfileBackground_Request {
	return CPlayer_SetMiniProfileBackground_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setminiprofilebackground_request(o CPlayer_SetMiniProfileBackground_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setminiprofilebackground_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetMiniProfileBackground_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setminiprofilebackground_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetMiniProfileBackground_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_SetMiniProfileBackground_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_setminiprofilebackground_response_unpack(buf []byte) ?CPlayer_SetMiniProfileBackground_Response {
	res := CPlayer_SetMiniProfileBackground_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setminiprofilebackground_response() CPlayer_SetMiniProfileBackground_Response {
	return CPlayer_SetMiniProfileBackground_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setminiprofilebackground_response(o CPlayer_SetMiniProfileBackground_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setminiprofilebackground_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetMiniProfileBackground_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setminiprofilebackground_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetAvatarFrame_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	language       string
	has_language   bool
}

pub fn (o &CPlayer_GetAvatarFrame_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 2)
	}
	return res
}

pub fn cplayer_getavatarframe_request_unpack(buf []byte) ?CPlayer_GetAvatarFrame_Request {
	mut res := CPlayer_GetAvatarFrame_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getavatarframe_request() CPlayer_GetAvatarFrame_Request {
	return CPlayer_GetAvatarFrame_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getavatarframe_request(o CPlayer_GetAvatarFrame_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getavatarframe_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetAvatarFrame_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getavatarframe_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetAvatarFrame_Response {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	avatar_frame     ProfileItem
	has_avatar_frame bool
}

pub fn (o &CPlayer_GetAvatarFrame_Response) pack() []byte {
	mut res := []byte{}
	if o.has_avatar_frame {
		res << zzz_vproto_internal_pack_profileitem(o.avatar_frame, 1)
	}
	return res
}

pub fn cplayer_getavatarframe_response_unpack(buf []byte) ?CPlayer_GetAvatarFrame_Response {
	mut res := CPlayer_GetAvatarFrame_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_avatar_frame = true
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.avatar_frame = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getavatarframe_response() CPlayer_GetAvatarFrame_Response {
	return CPlayer_GetAvatarFrame_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getavatarframe_response(o CPlayer_GetAvatarFrame_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getavatarframe_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetAvatarFrame_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getavatarframe_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetAvatarFrame_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	communityitemid     u64
	has_communityitemid bool
}

pub fn (o &CPlayer_SetAvatarFrame_Request) pack() []byte {
	mut res := []byte{}
	if o.has_communityitemid {
		res << vproto.pack_uint64_field(o.communityitemid, 1)
	}
	return res
}

pub fn cplayer_setavatarframe_request_unpack(buf []byte) ?CPlayer_SetAvatarFrame_Request {
	mut res := CPlayer_SetAvatarFrame_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_communityitemid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.communityitemid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setavatarframe_request() CPlayer_SetAvatarFrame_Request {
	return CPlayer_SetAvatarFrame_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setavatarframe_request(o CPlayer_SetAvatarFrame_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setavatarframe_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetAvatarFrame_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setavatarframe_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetAvatarFrame_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_SetAvatarFrame_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_setavatarframe_response_unpack(buf []byte) ?CPlayer_SetAvatarFrame_Response {
	res := CPlayer_SetAvatarFrame_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setavatarframe_response() CPlayer_SetAvatarFrame_Response {
	return CPlayer_SetAvatarFrame_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setavatarframe_response(o CPlayer_SetAvatarFrame_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setavatarframe_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetAvatarFrame_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setavatarframe_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetAnimatedAvatar_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	language       string
	has_language   bool
}

pub fn (o &CPlayer_GetAnimatedAvatar_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 2)
	}
	return res
}

pub fn cplayer_getanimatedavatar_request_unpack(buf []byte) ?CPlayer_GetAnimatedAvatar_Request {
	mut res := CPlayer_GetAnimatedAvatar_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getanimatedavatar_request() CPlayer_GetAnimatedAvatar_Request {
	return CPlayer_GetAnimatedAvatar_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getanimatedavatar_request(o CPlayer_GetAnimatedAvatar_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getanimatedavatar_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetAnimatedAvatar_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getanimatedavatar_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetAnimatedAvatar_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	avatar         ProfileItem
	has_avatar     bool
}

pub fn (o &CPlayer_GetAnimatedAvatar_Response) pack() []byte {
	mut res := []byte{}
	if o.has_avatar {
		res << zzz_vproto_internal_pack_profileitem(o.avatar, 1)
	}
	return res
}

pub fn cplayer_getanimatedavatar_response_unpack(buf []byte) ?CPlayer_GetAnimatedAvatar_Response {
	mut res := CPlayer_GetAnimatedAvatar_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_avatar = true
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.avatar = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getanimatedavatar_response() CPlayer_GetAnimatedAvatar_Response {
	return CPlayer_GetAnimatedAvatar_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getanimatedavatar_response(o CPlayer_GetAnimatedAvatar_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getanimatedavatar_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetAnimatedAvatar_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getanimatedavatar_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetAnimatedAvatar_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	communityitemid     u64
	has_communityitemid bool
}

pub fn (o &CPlayer_SetAnimatedAvatar_Request) pack() []byte {
	mut res := []byte{}
	if o.has_communityitemid {
		res << vproto.pack_uint64_field(o.communityitemid, 1)
	}
	return res
}

pub fn cplayer_setanimatedavatar_request_unpack(buf []byte) ?CPlayer_SetAnimatedAvatar_Request {
	mut res := CPlayer_SetAnimatedAvatar_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_communityitemid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.communityitemid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setanimatedavatar_request() CPlayer_SetAnimatedAvatar_Request {
	return CPlayer_SetAnimatedAvatar_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setanimatedavatar_request(o CPlayer_SetAnimatedAvatar_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setanimatedavatar_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetAnimatedAvatar_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setanimatedavatar_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetAnimatedAvatar_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_SetAnimatedAvatar_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_setanimatedavatar_response_unpack(buf []byte) ?CPlayer_SetAnimatedAvatar_Response {
	res := CPlayer_SetAnimatedAvatar_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setanimatedavatar_response() CPlayer_SetAnimatedAvatar_Response {
	return CPlayer_SetAnimatedAvatar_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setanimatedavatar_response(o CPlayer_SetAnimatedAvatar_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setanimatedavatar_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetAnimatedAvatar_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setanimatedavatar_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetProfileItemsOwned_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	language       string
	has_language   bool
}

pub fn (o &CPlayer_GetProfileItemsOwned_Request) pack() []byte {
	mut res := []byte{}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 1)
	}
	return res
}

pub fn cplayer_getprofileitemsowned_request_unpack(buf []byte) ?CPlayer_GetProfileItemsOwned_Request {
	mut res := CPlayer_GetProfileItemsOwned_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getprofileitemsowned_request() CPlayer_GetProfileItemsOwned_Request {
	return CPlayer_GetProfileItemsOwned_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getprofileitemsowned_request(o CPlayer_GetProfileItemsOwned_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getprofileitemsowned_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetProfileItemsOwned_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getprofileitemsowned_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetProfileItemsOwned_Response {
mut:
	unknown_fields           []vproto.UnknownField
pub mut:
	profile_backgrounds      []ProfileItem
	mini_profile_backgrounds []ProfileItem
	avatar_frames            []ProfileItem
	animated_avatars         []ProfileItem
	profile_modifiers        []ProfileItem
}

pub fn (o &CPlayer_GetProfileItemsOwned_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.profile_backgrounds {
		res << zzz_vproto_internal_pack_profileitem(x, 1)
	}
	// [packed=false]
	for _, x in o.mini_profile_backgrounds {
		res << zzz_vproto_internal_pack_profileitem(x, 2)
	}
	// [packed=false]
	for _, x in o.avatar_frames {
		res << zzz_vproto_internal_pack_profileitem(x, 3)
	}
	// [packed=false]
	for _, x in o.animated_avatars {
		res << zzz_vproto_internal_pack_profileitem(x, 4)
	}
	// [packed=false]
	for _, x in o.profile_modifiers {
		res << zzz_vproto_internal_pack_profileitem(x, 5)
	}
	return res
}

pub fn cplayer_getprofileitemsowned_response_unpack(buf []byte) ?CPlayer_GetProfileItemsOwned_Response {
	mut res := CPlayer_GetProfileItemsOwned_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.profile_backgrounds << v
				i = ii
			}
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.mini_profile_backgrounds << v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.avatar_frames << v
				i = ii
			}
			4 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.animated_avatars << v
				i = ii
			}
			5 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.profile_modifiers << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getprofileitemsowned_response() CPlayer_GetProfileItemsOwned_Response {
	return CPlayer_GetProfileItemsOwned_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getprofileitemsowned_response(o CPlayer_GetProfileItemsOwned_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getprofileitemsowned_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetProfileItemsOwned_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getprofileitemsowned_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetProfileItemsEquipped_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	language       string
	has_language   bool
}

pub fn (o &CPlayer_GetProfileItemsEquipped_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 2)
	}
	return res
}

pub fn cplayer_getprofileitemsequipped_request_unpack(buf []byte) ?CPlayer_GetProfileItemsEquipped_Request {
	mut res := CPlayer_GetProfileItemsEquipped_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getprofileitemsequipped_request() CPlayer_GetProfileItemsEquipped_Request {
	return CPlayer_GetProfileItemsEquipped_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getprofileitemsequipped_request(o CPlayer_GetProfileItemsEquipped_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getprofileitemsequipped_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetProfileItemsEquipped_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getprofileitemsequipped_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetProfileItemsEquipped_Response {
mut:
	unknown_fields              []vproto.UnknownField
pub mut:
	profile_background          ProfileItem
	has_profile_background      bool
	mini_profile_background     ProfileItem
	has_mini_profile_background bool
	avatar_frame                ProfileItem
	has_avatar_frame            bool
	animated_avatar             ProfileItem
	has_animated_avatar         bool
	profile_modifier            ProfileItem
	has_profile_modifier        bool
}

pub fn (o &CPlayer_GetProfileItemsEquipped_Response) pack() []byte {
	mut res := []byte{}
	if o.has_profile_background {
		res << zzz_vproto_internal_pack_profileitem(o.profile_background, 1)
	}
	if o.has_mini_profile_background {
		res << zzz_vproto_internal_pack_profileitem(o.mini_profile_background, 2)
	}
	if o.has_avatar_frame {
		res << zzz_vproto_internal_pack_profileitem(o.avatar_frame, 3)
	}
	if o.has_animated_avatar {
		res << zzz_vproto_internal_pack_profileitem(o.animated_avatar, 4)
	}
	if o.has_profile_modifier {
		res << zzz_vproto_internal_pack_profileitem(o.profile_modifier, 5)
	}
	return res
}

pub fn cplayer_getprofileitemsequipped_response_unpack(buf []byte) ?CPlayer_GetProfileItemsEquipped_Response {
	mut res := CPlayer_GetProfileItemsEquipped_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_profile_background = true
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.profile_background = v
				i = ii
			}
			2 {
				res.has_mini_profile_background = true
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.mini_profile_background = v
				i = ii
			}
			3 {
				res.has_avatar_frame = true
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.avatar_frame = v
				i = ii
			}
			4 {
				res.has_animated_avatar = true
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.animated_avatar = v
				i = ii
			}
			5 {
				res.has_profile_modifier = true
				ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
				res.profile_modifier = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getprofileitemsequipped_response() CPlayer_GetProfileItemsEquipped_Response {
	return CPlayer_GetProfileItemsEquipped_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getprofileitemsequipped_response(o CPlayer_GetProfileItemsEquipped_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getprofileitemsequipped_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetProfileItemsEquipped_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getprofileitemsequipped_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetEquippedProfileItemFlags_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	communityitemid     u64
	has_communityitemid bool
	flags               u32
	has_flags           bool
}

pub fn (o &CPlayer_SetEquippedProfileItemFlags_Request) pack() []byte {
	mut res := []byte{}
	if o.has_communityitemid {
		res << vproto.pack_uint64_field(o.communityitemid, 1)
	}
	if o.has_flags {
		res << vproto.pack_uint32_field(o.flags, 2)
	}
	return res
}

pub fn cplayer_setequippedprofileitemflags_request_unpack(buf []byte) ?CPlayer_SetEquippedProfileItemFlags_Request {
	mut res := CPlayer_SetEquippedProfileItemFlags_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_communityitemid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.communityitemid = v
				i = ii
			}
			2 {
				res.has_flags = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.flags = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setequippedprofileitemflags_request() CPlayer_SetEquippedProfileItemFlags_Request {
	return CPlayer_SetEquippedProfileItemFlags_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setequippedprofileitemflags_request(o CPlayer_SetEquippedProfileItemFlags_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setequippedprofileitemflags_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetEquippedProfileItemFlags_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setequippedprofileitemflags_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetEquippedProfileItemFlags_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_SetEquippedProfileItemFlags_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_setequippedprofileitemflags_response_unpack(buf []byte) ?CPlayer_SetEquippedProfileItemFlags_Response {
	res := CPlayer_SetEquippedProfileItemFlags_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setequippedprofileitemflags_response() CPlayer_SetEquippedProfileItemFlags_Response {
	return CPlayer_SetEquippedProfileItemFlags_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setequippedprofileitemflags_response(o CPlayer_SetEquippedProfileItemFlags_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setequippedprofileitemflags_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetEquippedProfileItemFlags_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setequippedprofileitemflags_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetEmoticonList_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_GetEmoticonList_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_getemoticonlist_request_unpack(buf []byte) ?CPlayer_GetEmoticonList_Request {
	res := CPlayer_GetEmoticonList_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getemoticonlist_request() CPlayer_GetEmoticonList_Request {
	return CPlayer_GetEmoticonList_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getemoticonlist_request(o CPlayer_GetEmoticonList_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getemoticonlist_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetEmoticonList_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getemoticonlist_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetEmoticonList_Response_Emoticon {
mut:
	unknown_fields     []vproto.UnknownField
pub mut:
	name               string
	has_name           bool
	count              int
	has_count          bool
	time_last_used     u32
	has_time_last_used bool
	use_count          u32
	has_use_count      bool
	time_received      u32
	has_time_received  bool
}

pub fn (o &CPlayer_GetEmoticonList_Response_Emoticon) pack() []byte {
	mut res := []byte{}
	if o.has_name {
		res << vproto.pack_string_field(o.name, 1)
	}
	if o.has_count {
		res << vproto.pack_int32_field(o.count, 2)
	}
	if o.has_time_last_used {
		res << vproto.pack_uint32_field(o.time_last_used, 3)
	}
	if o.has_use_count {
		res << vproto.pack_uint32_field(o.use_count, 4)
	}
	if o.has_time_received {
		res << vproto.pack_uint32_field(o.time_received, 5)
	}
	return res
}

pub fn cplayer_getemoticonlist_response_emoticon_unpack(buf []byte) ?CPlayer_GetEmoticonList_Response_Emoticon {
	mut res := CPlayer_GetEmoticonList_Response_Emoticon{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_name = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.name = v
				i = ii
			}
			2 {
				res.has_count = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.count = v
				i = ii
			}
			3 {
				res.has_time_last_used = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_last_used = v
				i = ii
			}
			4 {
				res.has_use_count = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.use_count = v
				i = ii
			}
			5 {
				res.has_time_received = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_received = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getemoticonlist_response_emoticon() CPlayer_GetEmoticonList_Response_Emoticon {
	return CPlayer_GetEmoticonList_Response_Emoticon{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getemoticonlist_response_emoticon(o CPlayer_GetEmoticonList_Response_Emoticon, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getemoticonlist_response_emoticon(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetEmoticonList_Response_Emoticon) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getemoticonlist_response_emoticon_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetEmoticonList_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	emoticons      []CPlayer_GetEmoticonList_Response_Emoticon
}

pub fn (o &CPlayer_GetEmoticonList_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.emoticons {
		res << zzz_vproto_internal_pack_cplayer_getemoticonlist_response_emoticon(x, 1)
	}
	return res
}

pub fn cplayer_getemoticonlist_response_unpack(buf []byte) ?CPlayer_GetEmoticonList_Response {
	mut res := CPlayer_GetEmoticonList_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getemoticonlist_response_emoticon(cur_buf,
					tag_wiretype.wire_type)?
				res.emoticons << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getemoticonlist_response() CPlayer_GetEmoticonList_Response {
	return CPlayer_GetEmoticonList_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getemoticonlist_response(o CPlayer_GetEmoticonList_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getemoticonlist_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetEmoticonList_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getemoticonlist_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetAchievementsProgress_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	language       string
	has_language   bool
	appids         []u32
}

pub fn (o &CPlayer_GetAchievementsProgress_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 1)
	}
	if o.has_language {
		res << vproto.pack_string_field(o.language, 2)
	}
	// [packed=false]
	for _, x in o.appids {
		res << vproto.pack_uint32_field(x, 3)
	}
	return res
}

pub fn cplayer_getachievementsprogress_request_unpack(buf []byte) ?CPlayer_GetAchievementsProgress_Request {
	mut res := CPlayer_GetAchievementsProgress_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_language = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			3 {
				// [packed=false]
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appids << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getachievementsprogress_request() CPlayer_GetAchievementsProgress_Request {
	return CPlayer_GetAchievementsProgress_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getachievementsprogress_request(o CPlayer_GetAchievementsProgress_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getachievementsprogress_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetAchievementsProgress_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getachievementsprogress_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetAchievementsProgress_Response_AchievementProgress {
mut:
	unknown_fields   []vproto.UnknownField
pub mut:
	appid            u32
	has_appid        bool
	unlocked         u32
	has_unlocked     bool
	total            u32
	has_total        bool
	percentage       f32
	has_percentage   bool
	all_unlocked     bool
	has_all_unlocked bool
	cache_time       u32
	has_cache_time   bool
}

pub fn (o &CPlayer_GetAchievementsProgress_Response_AchievementProgress) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_unlocked {
		res << vproto.pack_uint32_field(o.unlocked, 2)
	}
	if o.has_total {
		res << vproto.pack_uint32_field(o.total, 3)
	}
	if o.has_percentage {
		res << vproto.pack_float_field(o.percentage, 4)
	}
	if o.has_all_unlocked {
		res << vproto.pack_bool_field(o.all_unlocked, 5)
	}
	if o.has_cache_time {
		res << vproto.pack_uint32_field(o.cache_time, 6)
	}
	return res
}

pub fn cplayer_getachievementsprogress_response_achievementprogress_unpack(buf []byte) ?CPlayer_GetAchievementsProgress_Response_AchievementProgress {
	mut res := CPlayer_GetAchievementsProgress_Response_AchievementProgress{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_unlocked = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.unlocked = v
				i = ii
			}
			3 {
				res.has_total = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.total = v
				i = ii
			}
			4 {
				res.has_percentage = true
				ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
				res.percentage = v
				i = ii
			}
			5 {
				res.has_all_unlocked = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.all_unlocked = v
				i = ii
			}
			6 {
				res.has_cache_time = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.cache_time = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getachievementsprogress_response_achievementprogress() CPlayer_GetAchievementsProgress_Response_AchievementProgress {
	return CPlayer_GetAchievementsProgress_Response_AchievementProgress{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getachievementsprogress_response_achievementprogress(o CPlayer_GetAchievementsProgress_Response_AchievementProgress, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getachievementsprogress_response_achievementprogress(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetAchievementsProgress_Response_AchievementProgress) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getachievementsprogress_response_achievementprogress_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetAchievementsProgress_Response {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	achievement_progress []CPlayer_GetAchievementsProgress_Response_AchievementProgress
}

pub fn (o &CPlayer_GetAchievementsProgress_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.achievement_progress {
		res <<
			zzz_vproto_internal_pack_cplayer_getachievementsprogress_response_achievementprogress(x, 1)
	}
	return res
}

pub fn cplayer_getachievementsprogress_response_unpack(buf []byte) ?CPlayer_GetAchievementsProgress_Response {
	mut res := CPlayer_GetAchievementsProgress_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getachievementsprogress_response_achievementprogress(cur_buf,
					tag_wiretype.wire_type)?
				res.achievement_progress << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getachievementsprogress_response() CPlayer_GetAchievementsProgress_Response {
	return CPlayer_GetAchievementsProgress_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getachievementsprogress_response(o CPlayer_GetAchievementsProgress_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getachievementsprogress_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetAchievementsProgress_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getachievementsprogress_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_PostStatusToFriends_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	appid           u32
	has_appid       bool
	status_text     string
	has_status_text bool
}

pub fn (o &CPlayer_PostStatusToFriends_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	if o.has_status_text {
		res << vproto.pack_string_field(o.status_text, 2)
	}
	return res
}

pub fn cplayer_poststatustofriends_request_unpack(buf []byte) ?CPlayer_PostStatusToFriends_Request {
	mut res := CPlayer_PostStatusToFriends_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_status_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.status_text = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_poststatustofriends_request() CPlayer_PostStatusToFriends_Request {
	return CPlayer_PostStatusToFriends_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_poststatustofriends_request(o CPlayer_PostStatusToFriends_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_poststatustofriends_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_PostStatusToFriends_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_poststatustofriends_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_PostStatusToFriends_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_PostStatusToFriends_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_poststatustofriends_response_unpack(buf []byte) ?CPlayer_PostStatusToFriends_Response {
	res := CPlayer_PostStatusToFriends_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_poststatustofriends_response() CPlayer_PostStatusToFriends_Response {
	return CPlayer_PostStatusToFriends_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_poststatustofriends_response(o CPlayer_PostStatusToFriends_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_poststatustofriends_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_PostStatusToFriends_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_poststatustofriends_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetPostedStatus_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	postid         u64
	has_postid     bool
}

pub fn (o &CPlayer_GetPostedStatus_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_uint64_field(o.steamid, 1)
	}
	if o.has_postid {
		res << vproto.pack_uint64_field(o.postid, 2)
	}
	return res
}

pub fn cplayer_getpostedstatus_request_unpack(buf []byte) ?CPlayer_GetPostedStatus_Request {
	mut res := CPlayer_GetPostedStatus_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_postid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.postid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getpostedstatus_request() CPlayer_GetPostedStatus_Request {
	return CPlayer_GetPostedStatus_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getpostedstatus_request(o CPlayer_GetPostedStatus_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getpostedstatus_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetPostedStatus_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getpostedstatus_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetPostedStatus_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	accountid       u32
	has_accountid   bool
	postid          u64
	has_postid      bool
	status_text     string
	has_status_text bool
	deleted         bool
	has_deleted     bool
	appid           u32
	has_appid       bool
}

pub fn (o &CPlayer_GetPostedStatus_Response) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_uint32_field(o.accountid, 1)
	}
	if o.has_postid {
		res << vproto.pack_uint64_field(o.postid, 2)
	}
	if o.has_status_text {
		res << vproto.pack_string_field(o.status_text, 3)
	}
	if o.has_deleted {
		res << vproto.pack_bool_field(o.deleted, 4)
	}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 5)
	}
	return res
}

pub fn cplayer_getpostedstatus_response_unpack(buf []byte) ?CPlayer_GetPostedStatus_Response {
	mut res := CPlayer_GetPostedStatus_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_postid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.postid = v
				i = ii
			}
			3 {
				res.has_status_text = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.status_text = v
				i = ii
			}
			4 {
				res.has_deleted = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.deleted = v
				i = ii
			}
			5 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getpostedstatus_response() CPlayer_GetPostedStatus_Response {
	return CPlayer_GetPostedStatus_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getpostedstatus_response(o CPlayer_GetPostedStatus_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getpostedstatus_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetPostedStatus_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getpostedstatus_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_DeletePostedStatus_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	postid         u64
	has_postid     bool
}

pub fn (o &CPlayer_DeletePostedStatus_Request) pack() []byte {
	mut res := []byte{}
	if o.has_postid {
		res << vproto.pack_uint64_field(o.postid, 1)
	}
	return res
}

pub fn cplayer_deletepostedstatus_request_unpack(buf []byte) ?CPlayer_DeletePostedStatus_Request {
	mut res := CPlayer_DeletePostedStatus_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_postid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.postid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_deletepostedstatus_request() CPlayer_DeletePostedStatus_Request {
	return CPlayer_DeletePostedStatus_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_deletepostedstatus_request(o CPlayer_DeletePostedStatus_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_deletepostedstatus_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_DeletePostedStatus_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_deletepostedstatus_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_DeletePostedStatus_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_DeletePostedStatus_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_deletepostedstatus_response_unpack(buf []byte) ?CPlayer_DeletePostedStatus_Response {
	res := CPlayer_DeletePostedStatus_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_deletepostedstatus_response() CPlayer_DeletePostedStatus_Response {
	return CPlayer_DeletePostedStatus_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_deletepostedstatus_response(o CPlayer_DeletePostedStatus_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_deletepostedstatus_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_DeletePostedStatus_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_deletepostedstatus_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetLastPlayedTimes_Request {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	min_last_played     u32
	has_min_last_played bool
}

pub fn (o &CPlayer_GetLastPlayedTimes_Request) pack() []byte {
	mut res := []byte{}
	if o.has_min_last_played {
		res << vproto.pack_uint32_field(o.min_last_played, 1)
	}
	return res
}

pub fn cplayer_getlastplayedtimes_request_unpack(buf []byte) ?CPlayer_GetLastPlayedTimes_Request {
	mut res := CPlayer_GetLastPlayedTimes_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_min_last_played = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.min_last_played = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getlastplayedtimes_request() CPlayer_GetLastPlayedTimes_Request {
	return CPlayer_GetLastPlayedTimes_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getlastplayedtimes_request(o CPlayer_GetLastPlayedTimes_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getlastplayedtimes_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetLastPlayedTimes_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getlastplayedtimes_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetLastPlayedTimes_Response_Game {
mut:
	unknown_fields               []vproto.UnknownField
pub mut:
	appid                        int
	has_appid                    bool
	last_playtime                u32
	has_last_playtime            bool
	playtime_2weeks              int
	has_playtime_2weeks          bool
	playtime_forever             int
	has_playtime_forever         bool
	first_playtime               u32
	has_first_playtime           bool
	playtime_windows_forever     int
	has_playtime_windows_forever bool
	playtime_mac_forever         int
	has_playtime_mac_forever     bool
	playtime_linux_forever       int
	has_playtime_linux_forever   bool
	first_windows_playtime       u32
	has_first_windows_playtime   bool
	first_mac_playtime           u32
	has_first_mac_playtime       bool
	first_linux_playtime         u32
	has_first_linux_playtime     bool
	last_windows_playtime        u32
	has_last_windows_playtime    bool
	last_mac_playtime            u32
	has_last_mac_playtime        bool
	last_linux_playtime          u32
	has_last_linux_playtime      bool
}

pub fn (o &CPlayer_GetLastPlayedTimes_Response_Game) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_int32_field(o.appid, 1)
	}
	if o.has_last_playtime {
		res << vproto.pack_uint32_field(o.last_playtime, 2)
	}
	if o.has_playtime_2weeks {
		res << vproto.pack_int32_field(o.playtime_2weeks, 3)
	}
	if o.has_playtime_forever {
		res << vproto.pack_int32_field(o.playtime_forever, 4)
	}
	if o.has_first_playtime {
		res << vproto.pack_uint32_field(o.first_playtime, 5)
	}
	if o.has_playtime_windows_forever {
		res << vproto.pack_int32_field(o.playtime_windows_forever, 6)
	}
	if o.has_playtime_mac_forever {
		res << vproto.pack_int32_field(o.playtime_mac_forever, 7)
	}
	if o.has_playtime_linux_forever {
		res << vproto.pack_int32_field(o.playtime_linux_forever, 8)
	}
	if o.has_first_windows_playtime {
		res << vproto.pack_uint32_field(o.first_windows_playtime, 9)
	}
	if o.has_first_mac_playtime {
		res << vproto.pack_uint32_field(o.first_mac_playtime, 10)
	}
	if o.has_first_linux_playtime {
		res << vproto.pack_uint32_field(o.first_linux_playtime, 11)
	}
	if o.has_last_windows_playtime {
		res << vproto.pack_uint32_field(o.last_windows_playtime, 12)
	}
	if o.has_last_mac_playtime {
		res << vproto.pack_uint32_field(o.last_mac_playtime, 13)
	}
	if o.has_last_linux_playtime {
		res << vproto.pack_uint32_field(o.last_linux_playtime, 14)
	}
	return res
}

pub fn cplayer_getlastplayedtimes_response_game_unpack(buf []byte) ?CPlayer_GetLastPlayedTimes_Response_Game {
	mut res := CPlayer_GetLastPlayedTimes_Response_Game{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			2 {
				res.has_last_playtime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_playtime = v
				i = ii
			}
			3 {
				res.has_playtime_2weeks = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.playtime_2weeks = v
				i = ii
			}
			4 {
				res.has_playtime_forever = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.playtime_forever = v
				i = ii
			}
			5 {
				res.has_first_playtime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.first_playtime = v
				i = ii
			}
			6 {
				res.has_playtime_windows_forever = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.playtime_windows_forever = v
				i = ii
			}
			7 {
				res.has_playtime_mac_forever = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.playtime_mac_forever = v
				i = ii
			}
			8 {
				res.has_playtime_linux_forever = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.playtime_linux_forever = v
				i = ii
			}
			9 {
				res.has_first_windows_playtime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.first_windows_playtime = v
				i = ii
			}
			10 {
				res.has_first_mac_playtime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.first_mac_playtime = v
				i = ii
			}
			11 {
				res.has_first_linux_playtime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.first_linux_playtime = v
				i = ii
			}
			12 {
				res.has_last_windows_playtime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_windows_playtime = v
				i = ii
			}
			13 {
				res.has_last_mac_playtime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_mac_playtime = v
				i = ii
			}
			14 {
				res.has_last_linux_playtime = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.last_linux_playtime = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getlastplayedtimes_response_game() CPlayer_GetLastPlayedTimes_Response_Game {
	return CPlayer_GetLastPlayedTimes_Response_Game{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getlastplayedtimes_response_game(o CPlayer_GetLastPlayedTimes_Response_Game, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getlastplayedtimes_response_game(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetLastPlayedTimes_Response_Game) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getlastplayedtimes_response_game_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetLastPlayedTimes_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	games          []CPlayer_GetLastPlayedTimes_Response_Game
}

pub fn (o &CPlayer_GetLastPlayedTimes_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.games {
		res << zzz_vproto_internal_pack_cplayer_getlastplayedtimes_response_game(x, 1)
	}
	return res
}

pub fn cplayer_getlastplayedtimes_response_unpack(buf []byte) ?CPlayer_GetLastPlayedTimes_Response {
	mut res := CPlayer_GetLastPlayedTimes_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getlastplayedtimes_response_game(cur_buf,
					tag_wiretype.wire_type)?
				res.games << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getlastplayedtimes_response() CPlayer_GetLastPlayedTimes_Response {
	return CPlayer_GetLastPlayedTimes_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getlastplayedtimes_response(o CPlayer_GetLastPlayedTimes_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getlastplayedtimes_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetLastPlayedTimes_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getlastplayedtimes_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_AcceptSSA_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_AcceptSSA_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_acceptssa_request_unpack(buf []byte) ?CPlayer_AcceptSSA_Request {
	res := CPlayer_AcceptSSA_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_acceptssa_request() CPlayer_AcceptSSA_Request {
	return CPlayer_AcceptSSA_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_acceptssa_request(o CPlayer_AcceptSSA_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_acceptssa_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_AcceptSSA_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_acceptssa_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_AcceptSSA_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_AcceptSSA_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_acceptssa_response_unpack(buf []byte) ?CPlayer_AcceptSSA_Response {
	res := CPlayer_AcceptSSA_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_acceptssa_response() CPlayer_AcceptSSA_Response {
	return CPlayer_AcceptSSA_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_acceptssa_response(o CPlayer_AcceptSSA_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_acceptssa_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_AcceptSSA_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_acceptssa_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetNicknameList_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_GetNicknameList_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_getnicknamelist_request_unpack(buf []byte) ?CPlayer_GetNicknameList_Request {
	res := CPlayer_GetNicknameList_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getnicknamelist_request() CPlayer_GetNicknameList_Request {
	return CPlayer_GetNicknameList_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getnicknamelist_request(o CPlayer_GetNicknameList_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getnicknamelist_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetNicknameList_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getnicknamelist_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetNicknameList_Response_PlayerNickname {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	accountid      u32
	has_accountid  bool
	nickname       string
	has_nickname   bool
}

pub fn (o &CPlayer_GetNicknameList_Response_PlayerNickname) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_32bit_field(o.accountid, 1)
	}
	if o.has_nickname {
		res << vproto.pack_string_field(o.nickname, 2)
	}
	return res
}

pub fn cplayer_getnicknamelist_response_playernickname_unpack(buf []byte) ?CPlayer_GetNicknameList_Response_PlayerNickname {
	mut res := CPlayer_GetNicknameList_Response_PlayerNickname{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_nickname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.nickname = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getnicknamelist_response_playernickname() CPlayer_GetNicknameList_Response_PlayerNickname {
	return CPlayer_GetNicknameList_Response_PlayerNickname{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getnicknamelist_response_playernickname(o CPlayer_GetNicknameList_Response_PlayerNickname, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getnicknamelist_response_playernickname(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetNicknameList_Response_PlayerNickname) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getnicknamelist_response_playernickname_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetNicknameList_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	nicknames      []CPlayer_GetNicknameList_Response_PlayerNickname
}

pub fn (o &CPlayer_GetNicknameList_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.nicknames {
		res << zzz_vproto_internal_pack_cplayer_getnicknamelist_response_playernickname(x, 1)
	}
	return res
}

pub fn cplayer_getnicknamelist_response_unpack(buf []byte) ?CPlayer_GetNicknameList_Response {
	mut res := CPlayer_GetNicknameList_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getnicknamelist_response_playernickname(cur_buf,
					tag_wiretype.wire_type)?
				res.nicknames << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getnicknamelist_response() CPlayer_GetNicknameList_Response {
	return CPlayer_GetNicknameList_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getnicknamelist_response(o CPlayer_GetNicknameList_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getnicknamelist_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetNicknameList_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getnicknamelist_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetPerFriendPreferences_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_GetPerFriendPreferences_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_getperfriendpreferences_request_unpack(buf []byte) ?CPlayer_GetPerFriendPreferences_Request {
	res := CPlayer_GetPerFriendPreferences_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getperfriendpreferences_request() CPlayer_GetPerFriendPreferences_Request {
	return CPlayer_GetPerFriendPreferences_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getperfriendpreferences_request(o CPlayer_GetPerFriendPreferences_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getperfriendpreferences_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetPerFriendPreferences_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getperfriendpreferences_request_unpack(v)?
	return i, unpacked
}

pub struct PerFriendPreferences {
mut:
	unknown_fields                 []vproto.UnknownField
pub mut:
	accountid                      u32
	has_accountid                  bool
	nickname                       string
	has_nickname                   bool
	notifications_showingame       ENotificationSetting
	has_notifications_showingame   bool
	notifications_showonline       ENotificationSetting
	has_notifications_showonline   bool
	notifications_showmessages     ENotificationSetting
	has_notifications_showmessages bool
	sounds_showingame              ENotificationSetting
	has_sounds_showingame          bool
	sounds_showonline              ENotificationSetting
	has_sounds_showonline          bool
	sounds_showmessages            ENotificationSetting
	has_sounds_showmessages        bool
	notifications_sendmobile       ENotificationSetting
	has_notifications_sendmobile   bool
}

pub fn (o &PerFriendPreferences) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_32bit_field(o.accountid, 1)
	}
	if o.has_nickname {
		res << vproto.pack_string_field(o.nickname, 2)
	}
	if o.has_notifications_showingame {
		res << zzz_vproto_internal_pack_enotificationsetting(o.notifications_showingame, 3)
	}
	if o.has_notifications_showonline {
		res << zzz_vproto_internal_pack_enotificationsetting(o.notifications_showonline, 4)
	}
	if o.has_notifications_showmessages {
		res << zzz_vproto_internal_pack_enotificationsetting(o.notifications_showmessages, 5)
	}
	if o.has_sounds_showingame {
		res << zzz_vproto_internal_pack_enotificationsetting(o.sounds_showingame, 6)
	}
	if o.has_sounds_showonline {
		res << zzz_vproto_internal_pack_enotificationsetting(o.sounds_showonline, 7)
	}
	if o.has_sounds_showmessages {
		res << zzz_vproto_internal_pack_enotificationsetting(o.sounds_showmessages, 8)
	}
	if o.has_notifications_sendmobile {
		res << zzz_vproto_internal_pack_enotificationsetting(o.notifications_sendmobile, 9)
	}
	return res
}

pub fn perfriendpreferences_unpack(buf []byte) ?PerFriendPreferences {
	mut res := PerFriendPreferences{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_nickname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.nickname = v
				i = ii
			}
			3 {
				res.has_notifications_showingame = true
				ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
				res.notifications_showingame = v
				i = ii
			}
			4 {
				res.has_notifications_showonline = true
				ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
				res.notifications_showonline = v
				i = ii
			}
			5 {
				res.has_notifications_showmessages = true
				ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
				res.notifications_showmessages = v
				i = ii
			}
			6 {
				res.has_sounds_showingame = true
				ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
				res.sounds_showingame = v
				i = ii
			}
			7 {
				res.has_sounds_showonline = true
				ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
				res.sounds_showonline = v
				i = ii
			}
			8 {
				res.has_sounds_showmessages = true
				ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
				res.sounds_showmessages = v
				i = ii
			}
			9 {
				res.has_notifications_sendmobile = true
				ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
				res.notifications_sendmobile = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_perfriendpreferences() PerFriendPreferences {
	return PerFriendPreferences{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_perfriendpreferences(o PerFriendPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_perfriendpreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, PerFriendPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := perfriendpreferences_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetPerFriendPreferences_Response {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	preferences    []PerFriendPreferences
}

pub fn (o &CPlayer_GetPerFriendPreferences_Response) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.preferences {
		res << zzz_vproto_internal_pack_perfriendpreferences(x, 1)
	}
	return res
}

pub fn cplayer_getperfriendpreferences_response_unpack(buf []byte) ?CPlayer_GetPerFriendPreferences_Response {
	mut res := CPlayer_GetPerFriendPreferences_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_perfriendpreferences(cur_buf, tag_wiretype.wire_type)?
				res.preferences << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getperfriendpreferences_response() CPlayer_GetPerFriendPreferences_Response {
	return CPlayer_GetPerFriendPreferences_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getperfriendpreferences_response(o CPlayer_GetPerFriendPreferences_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getperfriendpreferences_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetPerFriendPreferences_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getperfriendpreferences_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetPerFriendPreferences_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	preferences     PerFriendPreferences
	has_preferences bool
}

pub fn (o &CPlayer_SetPerFriendPreferences_Request) pack() []byte {
	mut res := []byte{}
	if o.has_preferences {
		res << zzz_vproto_internal_pack_perfriendpreferences(o.preferences, 1)
	}
	return res
}

pub fn cplayer_setperfriendpreferences_request_unpack(buf []byte) ?CPlayer_SetPerFriendPreferences_Request {
	mut res := CPlayer_SetPerFriendPreferences_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_preferences = true
				ii, v := zzz_vproto_internal_unpack_perfriendpreferences(cur_buf, tag_wiretype.wire_type)?
				res.preferences = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setperfriendpreferences_request() CPlayer_SetPerFriendPreferences_Request {
	return CPlayer_SetPerFriendPreferences_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setperfriendpreferences_request(o CPlayer_SetPerFriendPreferences_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setperfriendpreferences_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetPerFriendPreferences_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setperfriendpreferences_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetPerFriendPreferences_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_SetPerFriendPreferences_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_setperfriendpreferences_response_unpack(buf []byte) ?CPlayer_SetPerFriendPreferences_Response {
	res := CPlayer_SetPerFriendPreferences_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setperfriendpreferences_response() CPlayer_SetPerFriendPreferences_Response {
	return CPlayer_SetPerFriendPreferences_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setperfriendpreferences_response(o CPlayer_SetPerFriendPreferences_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setperfriendpreferences_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetPerFriendPreferences_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setperfriendpreferences_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_AddFriend_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CPlayer_AddFriend_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cplayer_addfriend_request_unpack(buf []byte) ?CPlayer_AddFriend_Request {
	mut res := CPlayer_AddFriend_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_addfriend_request() CPlayer_AddFriend_Request {
	return CPlayer_AddFriend_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_addfriend_request(o CPlayer_AddFriend_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_addfriend_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_AddFriend_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_addfriend_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_AddFriend_Response {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	invite_sent             bool
	has_invite_sent         bool
	friend_relationship     u32
	has_friend_relationship bool
	result                  int
	has_result              bool
}

pub fn (o &CPlayer_AddFriend_Response) pack() []byte {
	mut res := []byte{}
	if o.has_invite_sent {
		res << vproto.pack_bool_field(o.invite_sent, 1)
	}
	if o.has_friend_relationship {
		res << vproto.pack_uint32_field(o.friend_relationship, 2)
	}
	if o.has_result {
		res << vproto.pack_int32_field(o.result, 3)
	}
	return res
}

pub fn cplayer_addfriend_response_unpack(buf []byte) ?CPlayer_AddFriend_Response {
	mut res := CPlayer_AddFriend_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_invite_sent = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.invite_sent = v
				i = ii
			}
			2 {
				res.has_friend_relationship = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.friend_relationship = v
				i = ii
			}
			3 {
				res.has_result = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.result = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_addfriend_response() CPlayer_AddFriend_Response {
	return CPlayer_AddFriend_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_addfriend_response(o CPlayer_AddFriend_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_addfriend_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_AddFriend_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_addfriend_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_RemoveFriend_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
}

pub fn (o &CPlayer_RemoveFriend_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	return res
}

pub fn cplayer_removefriend_request_unpack(buf []byte) ?CPlayer_RemoveFriend_Request {
	mut res := CPlayer_RemoveFriend_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_removefriend_request() CPlayer_RemoveFriend_Request {
	return CPlayer_RemoveFriend_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_removefriend_request(o CPlayer_RemoveFriend_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_removefriend_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_RemoveFriend_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_removefriend_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_RemoveFriend_Response {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	friend_relationship     u32
	has_friend_relationship bool
}

pub fn (o &CPlayer_RemoveFriend_Response) pack() []byte {
	mut res := []byte{}
	if o.has_friend_relationship {
		res << vproto.pack_uint32_field(o.friend_relationship, 1)
	}
	return res
}

pub fn cplayer_removefriend_response_unpack(buf []byte) ?CPlayer_RemoveFriend_Response {
	mut res := CPlayer_RemoveFriend_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_friend_relationship = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.friend_relationship = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_removefriend_response() CPlayer_RemoveFriend_Response {
	return CPlayer_RemoveFriend_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_removefriend_response(o CPlayer_RemoveFriend_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_removefriend_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_RemoveFriend_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_removefriend_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_IgnoreFriend_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	steamid        u64
	has_steamid    bool
	unignore       bool
	has_unignore   bool
}

pub fn (o &CPlayer_IgnoreFriend_Request) pack() []byte {
	mut res := []byte{}
	if o.has_steamid {
		res << vproto.pack_64bit_field(o.steamid, 1)
	}
	if o.has_unignore {
		res << vproto.pack_bool_field(o.unignore, 2)
	}
	return res
}

pub fn cplayer_ignorefriend_request_unpack(buf []byte) ?CPlayer_IgnoreFriend_Request {
	mut res := CPlayer_IgnoreFriend_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_steamid = true
				ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
				res.steamid = v
				i = ii
			}
			2 {
				res.has_unignore = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.unignore = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_ignorefriend_request() CPlayer_IgnoreFriend_Request {
	return CPlayer_IgnoreFriend_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_ignorefriend_request(o CPlayer_IgnoreFriend_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_ignorefriend_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_IgnoreFriend_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_ignorefriend_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_IgnoreFriend_Response {
mut:
	unknown_fields          []vproto.UnknownField
pub mut:
	friend_relationship     u32
	has_friend_relationship bool
}

pub fn (o &CPlayer_IgnoreFriend_Response) pack() []byte {
	mut res := []byte{}
	if o.has_friend_relationship {
		res << vproto.pack_uint32_field(o.friend_relationship, 1)
	}
	return res
}

pub fn cplayer_ignorefriend_response_unpack(buf []byte) ?CPlayer_IgnoreFriend_Response {
	mut res := CPlayer_IgnoreFriend_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_friend_relationship = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.friend_relationship = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_ignorefriend_response() CPlayer_IgnoreFriend_Response {
	return CPlayer_IgnoreFriend_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_ignorefriend_response(o CPlayer_IgnoreFriend_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_ignorefriend_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_IgnoreFriend_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_ignorefriend_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetCommunityPreferences_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_GetCommunityPreferences_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_getcommunitypreferences_request_unpack(buf []byte) ?CPlayer_GetCommunityPreferences_Request {
	res := CPlayer_GetCommunityPreferences_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getcommunitypreferences_request() CPlayer_GetCommunityPreferences_Request {
	return CPlayer_GetCommunityPreferences_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getcommunitypreferences_request(o CPlayer_GetCommunityPreferences_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getcommunitypreferences_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetCommunityPreferences_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getcommunitypreferences_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_CommunityPreferences {
mut:
	unknown_fields                  []vproto.UnknownField
pub mut:
	hide_adult_content_violence     bool
	has_hide_adult_content_violence bool
	hide_adult_content_sex          bool
	has_hide_adult_content_sex      bool
	parenthesize_nicknames          bool
	has_parenthesize_nicknames      bool
	timestamp_updated               u32
	has_timestamp_updated           bool
}

pub fn (o &CPlayer_CommunityPreferences) pack() []byte {
	mut res := []byte{}
	if o.has_hide_adult_content_violence {
		res << vproto.pack_bool_field(o.hide_adult_content_violence, 1)
	}
	if o.has_hide_adult_content_sex {
		res << vproto.pack_bool_field(o.hide_adult_content_sex, 2)
	}
	if o.has_parenthesize_nicknames {
		res << vproto.pack_bool_field(o.parenthesize_nicknames, 4)
	}
	if o.has_timestamp_updated {
		res << vproto.pack_uint32_field(o.timestamp_updated, 3)
	}
	return res
}

pub fn cplayer_communitypreferences_unpack(buf []byte) ?CPlayer_CommunityPreferences {
	mut res := CPlayer_CommunityPreferences{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_hide_adult_content_violence = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_adult_content_violence = v
				i = ii
			}
			2 {
				res.has_hide_adult_content_sex = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.hide_adult_content_sex = v
				i = ii
			}
			4 {
				res.has_parenthesize_nicknames = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.parenthesize_nicknames = v
				i = ii
			}
			3 {
				res.has_timestamp_updated = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.timestamp_updated = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_communitypreferences() CPlayer_CommunityPreferences {
	return CPlayer_CommunityPreferences{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_communitypreferences(o CPlayer_CommunityPreferences, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_communitypreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_CommunityPreferences) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_communitypreferences_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetCommunityPreferences_Response {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	preferences     CPlayer_CommunityPreferences
	has_preferences bool
}

pub fn (o &CPlayer_GetCommunityPreferences_Response) pack() []byte {
	mut res := []byte{}
	if o.has_preferences {
		res << zzz_vproto_internal_pack_cplayer_communitypreferences(o.preferences, 1)
	}
	return res
}

pub fn cplayer_getcommunitypreferences_response_unpack(buf []byte) ?CPlayer_GetCommunityPreferences_Response {
	mut res := CPlayer_GetCommunityPreferences_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_preferences = true
				ii, v := zzz_vproto_internal_unpack_cplayer_communitypreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.preferences = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getcommunitypreferences_response() CPlayer_GetCommunityPreferences_Response {
	return CPlayer_GetCommunityPreferences_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getcommunitypreferences_response(o CPlayer_GetCommunityPreferences_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getcommunitypreferences_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetCommunityPreferences_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getcommunitypreferences_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetCommunityPreferences_Request {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	preferences     CPlayer_CommunityPreferences
	has_preferences bool
}

pub fn (o &CPlayer_SetCommunityPreferences_Request) pack() []byte {
	mut res := []byte{}
	if o.has_preferences {
		res << zzz_vproto_internal_pack_cplayer_communitypreferences(o.preferences, 1)
	}
	return res
}

pub fn cplayer_setcommunitypreferences_request_unpack(buf []byte) ?CPlayer_SetCommunityPreferences_Request {
	mut res := CPlayer_SetCommunityPreferences_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_preferences = true
				ii, v := zzz_vproto_internal_unpack_cplayer_communitypreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.preferences = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setcommunitypreferences_request() CPlayer_SetCommunityPreferences_Request {
	return CPlayer_SetCommunityPreferences_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setcommunitypreferences_request(o CPlayer_SetCommunityPreferences_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setcommunitypreferences_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetCommunityPreferences_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setcommunitypreferences_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_SetCommunityPreferences_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_SetCommunityPreferences_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_setcommunitypreferences_response_unpack(buf []byte) ?CPlayer_SetCommunityPreferences_Response {
	res := CPlayer_SetCommunityPreferences_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_setcommunitypreferences_response() CPlayer_SetCommunityPreferences_Response {
	return CPlayer_SetCommunityPreferences_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_setcommunitypreferences_response(o CPlayer_SetCommunityPreferences_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_setcommunitypreferences_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_SetCommunityPreferences_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_setcommunitypreferences_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetNewSteamAnnouncementState_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	language       int
	has_language   bool
}

pub fn (o &CPlayer_GetNewSteamAnnouncementState_Request) pack() []byte {
	mut res := []byte{}
	if o.has_language {
		res << vproto.pack_int32_field(o.language, 1)
	}
	return res
}

pub fn cplayer_getnewsteamannouncementstate_request_unpack(buf []byte) ?CPlayer_GetNewSteamAnnouncementState_Request {
	mut res := CPlayer_GetNewSteamAnnouncementState_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_language = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.language = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getnewsteamannouncementstate_request() CPlayer_GetNewSteamAnnouncementState_Request {
	return CPlayer_GetNewSteamAnnouncementState_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getnewsteamannouncementstate_request(o CPlayer_GetNewSteamAnnouncementState_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getnewsteamannouncementstate_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetNewSteamAnnouncementState_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getnewsteamannouncementstate_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetNewSteamAnnouncementState_Response {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	state                     int
	has_state                 bool
	announcement_headline     string
	has_announcement_headline bool
	announcement_url          string
	has_announcement_url      bool
	time_posted               u32
	has_time_posted           bool
	announcement_gid          u64
	has_announcement_gid      bool
}

pub fn (o &CPlayer_GetNewSteamAnnouncementState_Response) pack() []byte {
	mut res := []byte{}
	if o.has_state {
		res << vproto.pack_int32_field(o.state, 1)
	}
	if o.has_announcement_headline {
		res << vproto.pack_string_field(o.announcement_headline, 2)
	}
	if o.has_announcement_url {
		res << vproto.pack_string_field(o.announcement_url, 3)
	}
	if o.has_time_posted {
		res << vproto.pack_uint32_field(o.time_posted, 4)
	}
	if o.has_announcement_gid {
		res << vproto.pack_uint64_field(o.announcement_gid, 5)
	}
	return res
}

pub fn cplayer_getnewsteamannouncementstate_response_unpack(buf []byte) ?CPlayer_GetNewSteamAnnouncementState_Response {
	mut res := CPlayer_GetNewSteamAnnouncementState_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_state = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			2 {
				res.has_announcement_headline = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.announcement_headline = v
				i = ii
			}
			3 {
				res.has_announcement_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.announcement_url = v
				i = ii
			}
			4 {
				res.has_time_posted = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_posted = v
				i = ii
			}
			5 {
				res.has_announcement_gid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.announcement_gid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getnewsteamannouncementstate_response() CPlayer_GetNewSteamAnnouncementState_Response {
	return CPlayer_GetNewSteamAnnouncementState_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getnewsteamannouncementstate_response(o CPlayer_GetNewSteamAnnouncementState_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getnewsteamannouncementstate_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetNewSteamAnnouncementState_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getnewsteamannouncementstate_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_UpdateSteamAnnouncementLastRead_Request {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	announcement_gid     u64
	has_announcement_gid bool
	time_posted          u32
	has_time_posted      bool
}

pub fn (o &CPlayer_UpdateSteamAnnouncementLastRead_Request) pack() []byte {
	mut res := []byte{}
	if o.has_announcement_gid {
		res << vproto.pack_uint64_field(o.announcement_gid, 1)
	}
	if o.has_time_posted {
		res << vproto.pack_uint32_field(o.time_posted, 2)
	}
	return res
}

pub fn cplayer_updatesteamannouncementlastread_request_unpack(buf []byte) ?CPlayer_UpdateSteamAnnouncementLastRead_Request {
	mut res := CPlayer_UpdateSteamAnnouncementLastRead_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_announcement_gid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.announcement_gid = v
				i = ii
			}
			2 {
				res.has_time_posted = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_posted = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_updatesteamannouncementlastread_request() CPlayer_UpdateSteamAnnouncementLastRead_Request {
	return CPlayer_UpdateSteamAnnouncementLastRead_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_updatesteamannouncementlastread_request(o CPlayer_UpdateSteamAnnouncementLastRead_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_updatesteamannouncementlastread_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_UpdateSteamAnnouncementLastRead_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_updatesteamannouncementlastread_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_UpdateSteamAnnouncementLastRead_Response {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_UpdateSteamAnnouncementLastRead_Response) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_updatesteamannouncementlastread_response_unpack(buf []byte) ?CPlayer_UpdateSteamAnnouncementLastRead_Response {
	res := CPlayer_UpdateSteamAnnouncementLastRead_Response{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_updatesteamannouncementlastread_response() CPlayer_UpdateSteamAnnouncementLastRead_Response {
	return CPlayer_UpdateSteamAnnouncementLastRead_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_updatesteamannouncementlastread_response(o CPlayer_UpdateSteamAnnouncementLastRead_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_updatesteamannouncementlastread_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_UpdateSteamAnnouncementLastRead_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_updatesteamannouncementlastread_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetPrivacySettings_Request {
mut:
	unknown_fields []vproto.UnknownField
}

pub fn (o &CPlayer_GetPrivacySettings_Request) pack() []byte {
	res := []byte{}
	return res
}

pub fn cplayer_getprivacysettings_request_unpack(buf []byte) ?CPlayer_GetPrivacySettings_Request {
	res := CPlayer_GetPrivacySettings_Request{}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getprivacysettings_request() CPlayer_GetPrivacySettings_Request {
	return CPlayer_GetPrivacySettings_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getprivacysettings_request(o CPlayer_GetPrivacySettings_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getprivacysettings_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetPrivacySettings_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getprivacysettings_request_unpack(v)?
	return i, unpacked
}

pub struct CPrivacySettings {
mut:
	unknown_fields                []vproto.UnknownField
pub mut:
	privacy_state                 int
	has_privacy_state             bool
	privacy_state_inventory       int
	has_privacy_state_inventory   bool
	privacy_state_gifts           int
	has_privacy_state_gifts       bool
	privacy_state_ownedgames      int
	has_privacy_state_ownedgames  bool
	privacy_state_playtime        int
	has_privacy_state_playtime    bool
	privacy_state_friendslist     int
	has_privacy_state_friendslist bool
}

pub fn (o &CPrivacySettings) pack() []byte {
	mut res := []byte{}
	if o.has_privacy_state {
		res << vproto.pack_int32_field(o.privacy_state, 1)
	}
	if o.has_privacy_state_inventory {
		res << vproto.pack_int32_field(o.privacy_state_inventory, 2)
	}
	if o.has_privacy_state_gifts {
		res << vproto.pack_int32_field(o.privacy_state_gifts, 3)
	}
	if o.has_privacy_state_ownedgames {
		res << vproto.pack_int32_field(o.privacy_state_ownedgames, 4)
	}
	if o.has_privacy_state_playtime {
		res << vproto.pack_int32_field(o.privacy_state_playtime, 5)
	}
	if o.has_privacy_state_friendslist {
		res << vproto.pack_int32_field(o.privacy_state_friendslist, 6)
	}
	return res
}

pub fn cprivacysettings_unpack(buf []byte) ?CPrivacySettings {
	mut res := CPrivacySettings{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_privacy_state = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.privacy_state = v
				i = ii
			}
			2 {
				res.has_privacy_state_inventory = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.privacy_state_inventory = v
				i = ii
			}
			3 {
				res.has_privacy_state_gifts = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.privacy_state_gifts = v
				i = ii
			}
			4 {
				res.has_privacy_state_ownedgames = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.privacy_state_ownedgames = v
				i = ii
			}
			5 {
				res.has_privacy_state_playtime = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.privacy_state_playtime = v
				i = ii
			}
			6 {
				res.has_privacy_state_friendslist = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.privacy_state_friendslist = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cprivacysettings() CPrivacySettings {
	return CPrivacySettings{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cprivacysettings(o CPrivacySettings, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cprivacysettings(buf []byte, tag_wiretype vproto.WireType) ?(int, CPrivacySettings) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cprivacysettings_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetPrivacySettings_Response {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	privacy_settings     CPrivacySettings
	has_privacy_settings bool
}

pub fn (o &CPlayer_GetPrivacySettings_Response) pack() []byte {
	mut res := []byte{}
	if o.has_privacy_settings {
		res << zzz_vproto_internal_pack_cprivacysettings(o.privacy_settings, 1)
	}
	return res
}

pub fn cplayer_getprivacysettings_response_unpack(buf []byte) ?CPlayer_GetPrivacySettings_Response {
	mut res := CPlayer_GetPrivacySettings_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_privacy_settings = true
				ii, v := zzz_vproto_internal_unpack_cprivacysettings(cur_buf, tag_wiretype.wire_type)?
				res.privacy_settings = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getprivacysettings_response() CPlayer_GetPrivacySettings_Response {
	return CPlayer_GetPrivacySettings_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getprivacysettings_response(o CPlayer_GetPrivacySettings_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getprivacysettings_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetPrivacySettings_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getprivacysettings_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetDurationControl_Request {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	appid          u32
	has_appid      bool
}

pub fn (o &CPlayer_GetDurationControl_Request) pack() []byte {
	mut res := []byte{}
	if o.has_appid {
		res << vproto.pack_uint32_field(o.appid, 1)
	}
	return res
}

pub fn cplayer_getdurationcontrol_request_unpack(buf []byte) ?CPlayer_GetDurationControl_Request {
	mut res := CPlayer_GetDurationControl_Request{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_appid = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.appid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getdurationcontrol_request() CPlayer_GetDurationControl_Request {
	return CPlayer_GetDurationControl_Request{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getdurationcontrol_request(o CPlayer_GetDurationControl_Request, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getdurationcontrol_request(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetDurationControl_Request) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getdurationcontrol_request_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_GetDurationControl_Response {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	is_enabled                bool
	has_is_enabled            bool
	seconds                   int
	has_seconds               bool
	seconds_today             int
	has_seconds_today         bool
	is_steamchina_account     bool
	has_is_steamchina_account bool
	is_age_verified           bool
	has_is_age_verified       bool
	seconds_allowed_today     u32
	has_seconds_allowed_today bool
}

pub fn (o &CPlayer_GetDurationControl_Response) pack() []byte {
	mut res := []byte{}
	if o.has_is_enabled {
		res << vproto.pack_bool_field(o.is_enabled, 1)
	}
	if o.has_seconds {
		res << vproto.pack_int32_field(o.seconds, 2)
	}
	if o.has_seconds_today {
		res << vproto.pack_int32_field(o.seconds_today, 3)
	}
	if o.has_is_steamchina_account {
		res << vproto.pack_bool_field(o.is_steamchina_account, 4)
	}
	if o.has_is_age_verified {
		res << vproto.pack_bool_field(o.is_age_verified, 5)
	}
	if o.has_seconds_allowed_today {
		res << vproto.pack_uint32_field(o.seconds_allowed_today, 6)
	}
	return res
}

pub fn cplayer_getdurationcontrol_response_unpack(buf []byte) ?CPlayer_GetDurationControl_Response {
	mut res := CPlayer_GetDurationControl_Response{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_is_enabled = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_enabled = v
				i = ii
			}
			2 {
				res.has_seconds = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds = v
				i = ii
			}
			3 {
				res.has_seconds_today = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_today = v
				i = ii
			}
			4 {
				res.has_is_steamchina_account = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_steamchina_account = v
				i = ii
			}
			5 {
				res.has_is_age_verified = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_age_verified = v
				i = ii
			}
			6 {
				res.has_seconds_allowed_today = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.seconds_allowed_today = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_getdurationcontrol_response() CPlayer_GetDurationControl_Response {
	return CPlayer_GetDurationControl_Response{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_getdurationcontrol_response(o CPlayer_GetDurationControl_Response, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_getdurationcontrol_response(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_GetDurationControl_Response) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_getdurationcontrol_response_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_LastPlayedTimes_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	games          []CPlayer_GetLastPlayedTimes_Response_Game
}

pub fn (o &CPlayer_LastPlayedTimes_Notification) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.games {
		res << zzz_vproto_internal_pack_cplayer_getlastplayedtimes_response_game(x, 1)
	}
	return res
}

pub fn cplayer_lastplayedtimes_notification_unpack(buf []byte) ?CPlayer_LastPlayedTimes_Notification {
	mut res := CPlayer_LastPlayedTimes_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_cplayer_getlastplayedtimes_response_game(cur_buf,
					tag_wiretype.wire_type)?
				res.games << v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_lastplayedtimes_notification() CPlayer_LastPlayedTimes_Notification {
	return CPlayer_LastPlayedTimes_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_lastplayedtimes_notification(o CPlayer_LastPlayedTimes_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_lastplayedtimes_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_LastPlayedTimes_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_lastplayedtimes_notification_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_FriendNicknameChanged_Notification {
mut:
	unknown_fields      []vproto.UnknownField
pub mut:
	accountid           u32
	has_accountid       bool
	nickname            string
	has_nickname        bool
	is_echo_to_self     bool
	has_is_echo_to_self bool
}

pub fn (o &CPlayer_FriendNicknameChanged_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_32bit_field(o.accountid, 1)
	}
	if o.has_nickname {
		res << vproto.pack_string_field(o.nickname, 2)
	}
	if o.has_is_echo_to_self {
		res << vproto.pack_bool_field(o.is_echo_to_self, 3)
	}
	return res
}

pub fn cplayer_friendnicknamechanged_notification_unpack(buf []byte) ?CPlayer_FriendNicknameChanged_Notification {
	mut res := CPlayer_FriendNicknameChanged_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_nickname = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.nickname = v
				i = ii
			}
			3 {
				res.has_is_echo_to_self = true
				ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
				res.is_echo_to_self = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_friendnicknamechanged_notification() CPlayer_FriendNicknameChanged_Notification {
	return CPlayer_FriendNicknameChanged_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_friendnicknamechanged_notification(o CPlayer_FriendNicknameChanged_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_friendnicknamechanged_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_FriendNicknameChanged_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_friendnicknamechanged_notification_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_FriendEquippedProfileItemsChanged_Notification {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	accountid      u32
	has_accountid  bool
}

pub fn (o &CPlayer_FriendEquippedProfileItemsChanged_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_32bit_field(o.accountid, 1)
	}
	return res
}

pub fn cplayer_friendequippedprofileitemschanged_notification_unpack(buf []byte) ?CPlayer_FriendEquippedProfileItemsChanged_Notification {
	mut res := CPlayer_FriendEquippedProfileItemsChanged_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_friendequippedprofileitemschanged_notification() CPlayer_FriendEquippedProfileItemsChanged_Notification {
	return CPlayer_FriendEquippedProfileItemsChanged_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_friendequippedprofileitemschanged_notification(o CPlayer_FriendEquippedProfileItemsChanged_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_friendequippedprofileitemschanged_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_FriendEquippedProfileItemsChanged_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_friendequippedprofileitemschanged_notification_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_NewSteamAnnouncementState_Notification {
mut:
	unknown_fields            []vproto.UnknownField
pub mut:
	state                     int
	has_state                 bool
	announcement_headline     string
	has_announcement_headline bool
	announcement_url          string
	has_announcement_url      bool
	time_posted               u32
	has_time_posted           bool
	announcement_gid          u64
	has_announcement_gid      bool
}

pub fn (o &CPlayer_NewSteamAnnouncementState_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_state {
		res << vproto.pack_int32_field(o.state, 1)
	}
	if o.has_announcement_headline {
		res << vproto.pack_string_field(o.announcement_headline, 2)
	}
	if o.has_announcement_url {
		res << vproto.pack_string_field(o.announcement_url, 3)
	}
	if o.has_time_posted {
		res << vproto.pack_uint32_field(o.time_posted, 4)
	}
	if o.has_announcement_gid {
		res << vproto.pack_uint64_field(o.announcement_gid, 5)
	}
	return res
}

pub fn cplayer_newsteamannouncementstate_notification_unpack(buf []byte) ?CPlayer_NewSteamAnnouncementState_Notification {
	mut res := CPlayer_NewSteamAnnouncementState_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_state = true
				ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
				res.state = v
				i = ii
			}
			2 {
				res.has_announcement_headline = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.announcement_headline = v
				i = ii
			}
			3 {
				res.has_announcement_url = true
				ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
				res.announcement_url = v
				i = ii
			}
			4 {
				res.has_time_posted = true
				ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
				res.time_posted = v
				i = ii
			}
			5 {
				res.has_announcement_gid = true
				ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
				res.announcement_gid = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_newsteamannouncementstate_notification() CPlayer_NewSteamAnnouncementState_Notification {
	return CPlayer_NewSteamAnnouncementState_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_newsteamannouncementstate_notification(o CPlayer_NewSteamAnnouncementState_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_newsteamannouncementstate_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_NewSteamAnnouncementState_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_newsteamannouncementstate_notification_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_CommunityPreferencesChanged_Notification {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	preferences     CPlayer_CommunityPreferences
	has_preferences bool
}

pub fn (o &CPlayer_CommunityPreferencesChanged_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_preferences {
		res << zzz_vproto_internal_pack_cplayer_communitypreferences(o.preferences, 1)
	}
	return res
}

pub fn cplayer_communitypreferenceschanged_notification_unpack(buf []byte) ?CPlayer_CommunityPreferencesChanged_Notification {
	mut res := CPlayer_CommunityPreferencesChanged_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_preferences = true
				ii, v := zzz_vproto_internal_unpack_cplayer_communitypreferences(cur_buf,
					tag_wiretype.wire_type)?
				res.preferences = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_communitypreferenceschanged_notification() CPlayer_CommunityPreferencesChanged_Notification {
	return CPlayer_CommunityPreferencesChanged_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_communitypreferenceschanged_notification(o CPlayer_CommunityPreferencesChanged_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_communitypreferenceschanged_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_CommunityPreferencesChanged_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_communitypreferenceschanged_notification_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_PerFriendPreferencesChanged_Notification {
mut:
	unknown_fields  []vproto.UnknownField
pub mut:
	accountid       u32
	has_accountid   bool
	preferences     PerFriendPreferences
	has_preferences bool
}

pub fn (o &CPlayer_PerFriendPreferencesChanged_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_accountid {
		res << vproto.pack_32bit_field(o.accountid, 1)
	}
	if o.has_preferences {
		res << zzz_vproto_internal_pack_perfriendpreferences(o.preferences, 2)
	}
	return res
}

pub fn cplayer_perfriendpreferenceschanged_notification_unpack(buf []byte) ?CPlayer_PerFriendPreferencesChanged_Notification {
	mut res := CPlayer_PerFriendPreferencesChanged_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_accountid = true
				ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
				res.accountid = v
				i = ii
			}
			2 {
				res.has_preferences = true
				ii, v := zzz_vproto_internal_unpack_perfriendpreferences(cur_buf, tag_wiretype.wire_type)?
				res.preferences = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_perfriendpreferenceschanged_notification() CPlayer_PerFriendPreferencesChanged_Notification {
	return CPlayer_PerFriendPreferencesChanged_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_perfriendpreferenceschanged_notification(o CPlayer_PerFriendPreferencesChanged_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_perfriendpreferenceschanged_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_PerFriendPreferencesChanged_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_perfriendpreferenceschanged_notification_unpack(v)?
	return i, unpacked
}

pub struct CPlayer_PrivacySettingsChanged_Notification {
mut:
	unknown_fields       []vproto.UnknownField
pub mut:
	privacy_settings     CPrivacySettings
	has_privacy_settings bool
}

pub fn (o &CPlayer_PrivacySettingsChanged_Notification) pack() []byte {
	mut res := []byte{}
	if o.has_privacy_settings {
		res << zzz_vproto_internal_pack_cprivacysettings(o.privacy_settings, 1)
	}
	return res
}

pub fn cplayer_privacysettingschanged_notification_unpack(buf []byte) ?CPlayer_PrivacySettingsChanged_Notification {
	mut res := CPlayer_PrivacySettingsChanged_Notification{}
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				res.has_privacy_settings = true
				ii, v := zzz_vproto_internal_unpack_cprivacysettings(cur_buf, tag_wiretype.wire_type)?
				res.privacy_settings = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayer_privacysettingschanged_notification() CPlayer_PrivacySettingsChanged_Notification {
	return CPlayer_PrivacySettingsChanged_Notification{}
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayer_privacysettingschanged_notification(o CPlayer_PrivacySettingsChanged_Notification, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayer_privacysettingschanged_notification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayer_PrivacySettingsChanged_Notification) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype)?
	mut unpacked := cplayer_privacysettingschanged_notification_unpack(v)?
	return i, unpacked
}
