
// Generated by vproto - Do not modify
module proto

import emily33901.vproto


[_allow_multiple_values]
enum ENotificationSetting {
k_enotificationsettingnotifyusedefault = 0
k_enotificationsettingalways = 1
k_enotificationsettingnever = 2
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_pack_enotificationsetting(e ENotificationSetting, num u32) []byte {
return vproto.pack_int32_field(int(e), num)
}
// FOR INTERNAL USE ONLY
fn zzz_vproto_internal_unpack_enotificationsetting(buf []byte, tag_wiretype vproto.WireType) ?(int, ENotificationSetting) {
i, v := vproto.unpack_int32_field(buf, tag_wiretype)?
return i, ENotificationSetting(v)
}
pub struct CPlayerGetMutualFriendsForIncomingInvitesRequest {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerGetMutualFriendsForIncomingInvitesRequest) pack() []byte {
res := []byte{}
return res
}

pub fn cplayergetmutualfriendsforincominginvitesrequest_unpack(buf []byte) ?CPlayerGetMutualFriendsForIncomingInvitesRequest {
res := CPlayerGetMutualFriendsForIncomingInvitesRequest{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetmutualfriendsforincominginvitesrequest() CPlayerGetMutualFriendsForIncomingInvitesRequest {
return CPlayerGetMutualFriendsForIncomingInvitesRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetmutualfriendsforincominginvitesrequest(o CPlayerGetMutualFriendsForIncomingInvitesRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetmutualfriendsforincominginvitesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetMutualFriendsForIncomingInvitesRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetmutualfriendsforincominginvitesrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerIncomingInviteMutualFriendList {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
mutual_friend_account_ids []u32
}
pub fn (o &CPlayerIncomingInviteMutualFriendList) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

// [packed=false]
for _, x in o.mutual_friend_account_ids {
res << vproto.pack_uint32_field(x, 2)
}

return res
}

pub fn cplayerincominginvitemutualfriendlist_unpack(buf []byte) ?CPlayerIncomingInviteMutualFriendList {
mut res := CPlayerIncomingInviteMutualFriendList{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.mutual_friend_account_ids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerincominginvitemutualfriendlist() CPlayerIncomingInviteMutualFriendList {
return CPlayerIncomingInviteMutualFriendList{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerincominginvitemutualfriendlist(o CPlayerIncomingInviteMutualFriendList, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerincominginvitemutualfriendlist(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerIncomingInviteMutualFriendList) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerincominginvitemutualfriendlist_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetMutualFriendsForIncomingInvitesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
incoming_invite_mutual_friends_lists []CPlayerIncomingInviteMutualFriendList
}
pub fn (o &CPlayerGetMutualFriendsForIncomingInvitesResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.incoming_invite_mutual_friends_lists {
res << zzz_vproto_internal_pack_cplayerincominginvitemutualfriendlist(x, 1)
}

return res
}

pub fn cplayergetmutualfriendsforincominginvitesresponse_unpack(buf []byte) ?CPlayerGetMutualFriendsForIncomingInvitesResponse {
mut res := CPlayerGetMutualFriendsForIncomingInvitesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayerincominginvitemutualfriendlist(cur_buf, tag_wiretype.wire_type)?
res.incoming_invite_mutual_friends_lists << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetmutualfriendsforincominginvitesresponse() CPlayerGetMutualFriendsForIncomingInvitesResponse {
return CPlayerGetMutualFriendsForIncomingInvitesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetmutualfriendsforincominginvitesresponse(o CPlayerGetMutualFriendsForIncomingInvitesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetmutualfriendsforincominginvitesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetMutualFriendsForIncomingInvitesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetmutualfriendsforincominginvitesresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetOwnedGamesRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
include_appinfo bool
has_include_appinfo bool
include_played_free_games bool
has_include_played_free_games bool
appids_filter []u32
include_free_sub bool
has_include_free_sub bool
}
pub fn (o &CPlayerGetOwnedGamesRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_uint64_field(o.steamid, 1)
}

if o.has_include_appinfo {
res << vproto.pack_bool_field(o.include_appinfo, 2)
}

if o.has_include_played_free_games {
res << vproto.pack_bool_field(o.include_played_free_games, 3)
}

// [packed=false]
for _, x in o.appids_filter {
res << vproto.pack_uint32_field(x, 4)
}

if o.has_include_free_sub {
res << vproto.pack_bool_field(o.include_free_sub, 5)
}

return res
}

pub fn cplayergetownedgamesrequest_unpack(buf []byte) ?CPlayerGetOwnedGamesRequest {
mut res := CPlayerGetOwnedGamesRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_include_appinfo = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.include_appinfo = v
i = ii
}

3 {
res.has_include_played_free_games = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.include_played_free_games = v
i = ii
}

4 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appids_filter << v
i = ii
}

5 {
res.has_include_free_sub = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.include_free_sub = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetownedgamesrequest() CPlayerGetOwnedGamesRequest {
return CPlayerGetOwnedGamesRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetownedgamesrequest(o CPlayerGetOwnedGamesRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetownedgamesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetOwnedGamesRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetownedgamesrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetOwnedGamesResponseGame {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid int
has_appid bool
name string
has_name bool
playtime_2weeks int
has_playtime_2weeks bool
playtime_forever int
has_playtime_forever bool
img_icon_url string
has_img_icon_url bool
img_logo_url string
has_img_logo_url bool
has_community_visible_stats bool
has_has_community_visible_stats bool
playtime_windows_forever int
has_playtime_windows_forever bool
playtime_mac_forever int
has_playtime_mac_forever bool
playtime_linux_forever int
has_playtime_linux_forever bool
}
pub fn (o &CPlayerGetOwnedGamesResponseGame) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_int32_field(o.appid, 1)
}

if o.has_name {
res << vproto.pack_string_field(o.name, 2)
}

if o.has_playtime_2weeks {
res << vproto.pack_int32_field(o.playtime_2weeks, 3)
}

if o.has_playtime_forever {
res << vproto.pack_int32_field(o.playtime_forever, 4)
}

if o.has_img_icon_url {
res << vproto.pack_string_field(o.img_icon_url, 5)
}

if o.has_img_logo_url {
res << vproto.pack_string_field(o.img_logo_url, 6)
}

if o.has_has_community_visible_stats {
res << vproto.pack_bool_field(o.has_community_visible_stats, 7)
}

if o.has_playtime_windows_forever {
res << vproto.pack_int32_field(o.playtime_windows_forever, 8)
}

if o.has_playtime_mac_forever {
res << vproto.pack_int32_field(o.playtime_mac_forever, 9)
}

if o.has_playtime_linux_forever {
res << vproto.pack_int32_field(o.playtime_linux_forever, 10)
}

return res
}

pub fn cplayergetownedgamesresponsegame_unpack(buf []byte) ?CPlayerGetOwnedGamesResponseGame {
mut res := CPlayerGetOwnedGamesResponseGame{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

3 {
res.has_playtime_2weeks = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.playtime_2weeks = v
i = ii
}

4 {
res.has_playtime_forever = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.playtime_forever = v
i = ii
}

5 {
res.has_img_icon_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.img_icon_url = v
i = ii
}

6 {
res.has_img_logo_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.img_logo_url = v
i = ii
}

7 {
res.has_has_community_visible_stats = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.has_community_visible_stats = v
i = ii
}

8 {
res.has_playtime_windows_forever = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.playtime_windows_forever = v
i = ii
}

9 {
res.has_playtime_mac_forever = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.playtime_mac_forever = v
i = ii
}

10 {
res.has_playtime_linux_forever = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.playtime_linux_forever = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetownedgamesresponsegame() CPlayerGetOwnedGamesResponseGame {
return CPlayerGetOwnedGamesResponseGame{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetownedgamesresponsegame(o CPlayerGetOwnedGamesResponseGame, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetownedgamesresponsegame(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetOwnedGamesResponseGame) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetownedgamesresponsegame_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetOwnedGamesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
game_count u32
has_game_count bool
games []CPlayerGetOwnedGamesResponseGame
}
pub fn (o &CPlayerGetOwnedGamesResponse) pack() []byte {
mut res := []byte{}
if o.has_game_count {
res << vproto.pack_uint32_field(o.game_count, 1)
}

// [packed=false]
for _, x in o.games {
res << zzz_vproto_internal_pack_cplayergetownedgamesresponsegame(x, 2)
}

return res
}

pub fn cplayergetownedgamesresponse_unpack(buf []byte) ?CPlayerGetOwnedGamesResponse {
mut res := CPlayerGetOwnedGamesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_game_count = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.game_count = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetownedgamesresponsegame(cur_buf, tag_wiretype.wire_type)?
res.games << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetownedgamesresponse() CPlayerGetOwnedGamesResponse {
return CPlayerGetOwnedGamesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetownedgamesresponse(o CPlayerGetOwnedGamesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetownedgamesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetOwnedGamesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetownedgamesresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetPlayNextRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
max_age_seconds u32
has_max_age_seconds bool
ignore_appids []u32
}
pub fn (o &CPlayerGetPlayNextRequest) pack() []byte {
mut res := []byte{}
if o.has_max_age_seconds {
res << vproto.pack_uint32_field(o.max_age_seconds, 1)
}

// [packed=false]
for _, x in o.ignore_appids {
res << vproto.pack_uint32_field(x, 2)
}

return res
}

pub fn cplayergetplaynextrequest_unpack(buf []byte) ?CPlayerGetPlayNextRequest {
mut res := CPlayerGetPlayNextRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_max_age_seconds = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.max_age_seconds = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.ignore_appids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetplaynextrequest() CPlayerGetPlayNextRequest {
return CPlayerGetPlayNextRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetplaynextrequest(o CPlayerGetPlayNextRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetplaynextrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetPlayNextRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetplaynextrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetPlayNextResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
last_update_time u32
has_last_update_time bool
appids []u32
}
pub fn (o &CPlayerGetPlayNextResponse) pack() []byte {
mut res := []byte{}
if o.has_last_update_time {
res << vproto.pack_uint32_field(o.last_update_time, 1)
}

// [packed=false]
for _, x in o.appids {
res << vproto.pack_uint32_field(x, 2)
}

return res
}

pub fn cplayergetplaynextresponse_unpack(buf []byte) ?CPlayerGetPlayNextResponse {
mut res := CPlayerGetPlayNextResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_last_update_time = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_update_time = v
i = ii
}

2 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetplaynextresponse() CPlayerGetPlayNextResponse {
return CPlayerGetPlayNextResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetplaynextresponse(o CPlayerGetPlayNextResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetplaynextresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetPlayNextResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetplaynextresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetFriendsGameplayInfoRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
}
pub fn (o &CPlayerGetFriendsGameplayInfoRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

return res
}

pub fn cplayergetfriendsgameplayinforequest_unpack(buf []byte) ?CPlayerGetFriendsGameplayInfoRequest {
mut res := CPlayerGetFriendsGameplayInfoRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetfriendsgameplayinforequest() CPlayerGetFriendsGameplayInfoRequest {
return CPlayerGetFriendsGameplayInfoRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetfriendsgameplayinforequest(o CPlayerGetFriendsGameplayInfoRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetfriendsgameplayinforequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetFriendsGameplayInfoRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetfriendsgameplayinforequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetFriendsGameplayInfoResponseFriendsGameplayInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
minutes_played u32
has_minutes_played bool
minutes_played_forever u32
has_minutes_played_forever bool
}
pub fn (o &CPlayerGetFriendsGameplayInfoResponseFriendsGameplayInfo) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_minutes_played {
res << vproto.pack_uint32_field(o.minutes_played, 2)
}

if o.has_minutes_played_forever {
res << vproto.pack_uint32_field(o.minutes_played_forever, 3)
}

return res
}

pub fn cplayergetfriendsgameplayinforesponsefriendsgameplayinfo_unpack(buf []byte) ?CPlayerGetFriendsGameplayInfoResponseFriendsGameplayInfo {
mut res := CPlayerGetFriendsGameplayInfoResponseFriendsGameplayInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_minutes_played = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.minutes_played = v
i = ii
}

3 {
res.has_minutes_played_forever = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.minutes_played_forever = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetfriendsgameplayinforesponsefriendsgameplayinfo() CPlayerGetFriendsGameplayInfoResponseFriendsGameplayInfo {
return CPlayerGetFriendsGameplayInfoResponseFriendsGameplayInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetfriendsgameplayinforesponsefriendsgameplayinfo(o CPlayerGetFriendsGameplayInfoResponseFriendsGameplayInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetfriendsgameplayinforesponsefriendsgameplayinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetFriendsGameplayInfoResponseFriendsGameplayInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetfriendsgameplayinforesponsefriendsgameplayinfo_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetFriendsGameplayInfoResponseOwnGameplayInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
minutes_played u32
has_minutes_played bool
minutes_played_forever u32
has_minutes_played_forever bool
in_wishlist bool
has_in_wishlist bool
owned bool
has_owned bool
}
pub fn (o &CPlayerGetFriendsGameplayInfoResponseOwnGameplayInfo) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_minutes_played {
res << vproto.pack_uint32_field(o.minutes_played, 2)
}

if o.has_minutes_played_forever {
res << vproto.pack_uint32_field(o.minutes_played_forever, 3)
}

if o.has_in_wishlist {
res << vproto.pack_bool_field(o.in_wishlist, 4)
}

if o.has_owned {
res << vproto.pack_bool_field(o.owned, 5)
}

return res
}

pub fn cplayergetfriendsgameplayinforesponseowngameplayinfo_unpack(buf []byte) ?CPlayerGetFriendsGameplayInfoResponseOwnGameplayInfo {
mut res := CPlayerGetFriendsGameplayInfoResponseOwnGameplayInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_minutes_played = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.minutes_played = v
i = ii
}

3 {
res.has_minutes_played_forever = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.minutes_played_forever = v
i = ii
}

4 {
res.has_in_wishlist = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.in_wishlist = v
i = ii
}

5 {
res.has_owned = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.owned = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetfriendsgameplayinforesponseowngameplayinfo() CPlayerGetFriendsGameplayInfoResponseOwnGameplayInfo {
return CPlayerGetFriendsGameplayInfoResponseOwnGameplayInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetfriendsgameplayinforesponseowngameplayinfo(o CPlayerGetFriendsGameplayInfoResponseOwnGameplayInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetfriendsgameplayinforesponseowngameplayinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetFriendsGameplayInfoResponseOwnGameplayInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetfriendsgameplayinforesponseowngameplayinfo_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetFriendsGameplayInfoResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
your_info CPlayerGetFriendsGameplayInfoResponseOwnGameplayInfo
has_your_info bool
in_game []CPlayerGetFriendsGameplayInfoResponseFriendsGameplayInfo
played_recently []CPlayerGetFriendsGameplayInfoResponseFriendsGameplayInfo
played_ever []CPlayerGetFriendsGameplayInfoResponseFriendsGameplayInfo
owns []CPlayerGetFriendsGameplayInfoResponseFriendsGameplayInfo
in_wishlist []CPlayerGetFriendsGameplayInfoResponseFriendsGameplayInfo
}
pub fn (o &CPlayerGetFriendsGameplayInfoResponse) pack() []byte {
mut res := []byte{}
if o.has_your_info {
res << zzz_vproto_internal_pack_cplayergetfriendsgameplayinforesponseowngameplayinfo(o.your_info, 1)
}

// [packed=false]
for _, x in o.in_game {
res << zzz_vproto_internal_pack_cplayergetfriendsgameplayinforesponsefriendsgameplayinfo(x, 2)
}

// [packed=false]
for _, x in o.played_recently {
res << zzz_vproto_internal_pack_cplayergetfriendsgameplayinforesponsefriendsgameplayinfo(x, 3)
}

// [packed=false]
for _, x in o.played_ever {
res << zzz_vproto_internal_pack_cplayergetfriendsgameplayinforesponsefriendsgameplayinfo(x, 4)
}

// [packed=false]
for _, x in o.owns {
res << zzz_vproto_internal_pack_cplayergetfriendsgameplayinforesponsefriendsgameplayinfo(x, 5)
}

// [packed=false]
for _, x in o.in_wishlist {
res << zzz_vproto_internal_pack_cplayergetfriendsgameplayinforesponsefriendsgameplayinfo(x, 6)
}

return res
}

pub fn cplayergetfriendsgameplayinforesponse_unpack(buf []byte) ?CPlayerGetFriendsGameplayInfoResponse {
mut res := CPlayerGetFriendsGameplayInfoResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_your_info = true
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsgameplayinforesponseowngameplayinfo(cur_buf, tag_wiretype.wire_type)?
res.your_info = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsgameplayinforesponsefriendsgameplayinfo(cur_buf, tag_wiretype.wire_type)?
res.in_game << v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsgameplayinforesponsefriendsgameplayinfo(cur_buf, tag_wiretype.wire_type)?
res.played_recently << v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsgameplayinforesponsefriendsgameplayinfo(cur_buf, tag_wiretype.wire_type)?
res.played_ever << v
i = ii
}

5 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsgameplayinforesponsefriendsgameplayinfo(cur_buf, tag_wiretype.wire_type)?
res.owns << v
i = ii
}

6 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsgameplayinforesponsefriendsgameplayinfo(cur_buf, tag_wiretype.wire_type)?
res.in_wishlist << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetfriendsgameplayinforesponse() CPlayerGetFriendsGameplayInfoResponse {
return CPlayerGetFriendsGameplayInfoResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetfriendsgameplayinforesponse(o CPlayerGetFriendsGameplayInfoResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetfriendsgameplayinforesponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetFriendsGameplayInfoResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetfriendsgameplayinforesponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetFriendsAppsActivityRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
news_language string
has_news_language bool
request_flags u32
has_request_flags bool
}
pub fn (o &CPlayerGetFriendsAppsActivityRequest) pack() []byte {
mut res := []byte{}
if o.has_news_language {
res << vproto.pack_string_field(o.news_language, 1)
}

if o.has_request_flags {
res << vproto.pack_uint32_field(o.request_flags, 2)
}

return res
}

pub fn cplayergetfriendsappsactivityrequest_unpack(buf []byte) ?CPlayerGetFriendsAppsActivityRequest {
mut res := CPlayerGetFriendsAppsActivityRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_news_language = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.news_language = v
i = ii
}

2 {
res.has_request_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.request_flags = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetfriendsappsactivityrequest() CPlayerGetFriendsAppsActivityRequest {
return CPlayerGetFriendsAppsActivityRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetfriendsappsactivityrequest(o CPlayerGetFriendsAppsActivityRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetfriendsappsactivityrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetFriendsAppsActivityRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetfriendsappsactivityrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetFriendsAppsActivityResponseFriendPlayTime {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
minutes_played_this_week u32
has_minutes_played_this_week bool
minutes_played_two_weeks u32
has_minutes_played_two_weeks bool
minutes_played_forever u32
has_minutes_played_forever bool
event_count u32
has_event_count bool
}
pub fn (o &CPlayerGetFriendsAppsActivityResponseFriendPlayTime) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_minutes_played_this_week {
res << vproto.pack_uint32_field(o.minutes_played_this_week, 2)
}

if o.has_minutes_played_two_weeks {
res << vproto.pack_uint32_field(o.minutes_played_two_weeks, 3)
}

if o.has_minutes_played_forever {
res << vproto.pack_uint32_field(o.minutes_played_forever, 4)
}

if o.has_event_count {
res << vproto.pack_uint32_field(o.event_count, 5)
}

return res
}

pub fn cplayergetfriendsappsactivityresponsefriendplaytime_unpack(buf []byte) ?CPlayerGetFriendsAppsActivityResponseFriendPlayTime {
mut res := CPlayerGetFriendsAppsActivityResponseFriendPlayTime{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_minutes_played_this_week = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.minutes_played_this_week = v
i = ii
}

3 {
res.has_minutes_played_two_weeks = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.minutes_played_two_weeks = v
i = ii
}

4 {
res.has_minutes_played_forever = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.minutes_played_forever = v
i = ii
}

5 {
res.has_event_count = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.event_count = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetfriendsappsactivityresponsefriendplaytime() CPlayerGetFriendsAppsActivityResponseFriendPlayTime {
return CPlayerGetFriendsAppsActivityResponseFriendPlayTime{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetfriendsappsactivityresponsefriendplaytime(o CPlayerGetFriendsAppsActivityResponseFriendPlayTime, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetfriendsappsactivityresponsefriendplaytime(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetFriendsAppsActivityResponseFriendPlayTime) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetfriendsappsactivityresponsefriendplaytime_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetFriendsAppsActivityResponseAppFriendsInfo {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
friends []CPlayerGetFriendsAppsActivityResponseFriendPlayTime
display_order u32
has_display_order bool
}
pub fn (o &CPlayerGetFriendsAppsActivityResponseAppFriendsInfo) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

// [packed=false]
for _, x in o.friends {
res << zzz_vproto_internal_pack_cplayergetfriendsappsactivityresponsefriendplaytime(x, 2)
}

if o.has_display_order {
res << vproto.pack_uint32_field(o.display_order, 3)
}

return res
}

pub fn cplayergetfriendsappsactivityresponseappfriendsinfo_unpack(buf []byte) ?CPlayerGetFriendsAppsActivityResponseAppFriendsInfo {
mut res := CPlayerGetFriendsAppsActivityResponseAppFriendsInfo{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsappsactivityresponsefriendplaytime(cur_buf, tag_wiretype.wire_type)?
res.friends << v
i = ii
}

3 {
res.has_display_order = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.display_order = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetfriendsappsactivityresponseappfriendsinfo() CPlayerGetFriendsAppsActivityResponseAppFriendsInfo {
return CPlayerGetFriendsAppsActivityResponseAppFriendsInfo{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetfriendsappsactivityresponseappfriendsinfo(o CPlayerGetFriendsAppsActivityResponseAppFriendsInfo, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetfriendsappsactivityresponseappfriendsinfo(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetFriendsAppsActivityResponseAppFriendsInfo) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetfriendsappsactivityresponseappfriendsinfo_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetFriendsAppsActivityResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
trending []CPlayerGetFriendsAppsActivityResponseAppFriendsInfo
recent_purchases []CPlayerGetFriendsAppsActivityResponseAppFriendsInfo
unowned []CPlayerGetFriendsAppsActivityResponseAppFriendsInfo
popular []CPlayerGetFriendsAppsActivityResponseAppFriendsInfo
dont_forget []CPlayerGetFriendsAppsActivityResponseAppFriendsInfo
being_discussed []CPlayerGetFriendsAppsActivityResponseAppFriendsInfo
new_to_group []CPlayerGetFriendsAppsActivityResponseAppFriendsInfo
returned_to_group []CPlayerGetFriendsAppsActivityResponseAppFriendsInfo
active_friend_count u32
has_active_friend_count bool
}
pub fn (o &CPlayerGetFriendsAppsActivityResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.trending {
res << zzz_vproto_internal_pack_cplayergetfriendsappsactivityresponseappfriendsinfo(x, 1)
}

// [packed=false]
for _, x in o.recent_purchases {
res << zzz_vproto_internal_pack_cplayergetfriendsappsactivityresponseappfriendsinfo(x, 2)
}

// [packed=false]
for _, x in o.unowned {
res << zzz_vproto_internal_pack_cplayergetfriendsappsactivityresponseappfriendsinfo(x, 3)
}

// [packed=false]
for _, x in o.popular {
res << zzz_vproto_internal_pack_cplayergetfriendsappsactivityresponseappfriendsinfo(x, 4)
}

// [packed=false]
for _, x in o.dont_forget {
res << zzz_vproto_internal_pack_cplayergetfriendsappsactivityresponseappfriendsinfo(x, 5)
}

// [packed=false]
for _, x in o.being_discussed {
res << zzz_vproto_internal_pack_cplayergetfriendsappsactivityresponseappfriendsinfo(x, 6)
}

// [packed=false]
for _, x in o.new_to_group {
res << zzz_vproto_internal_pack_cplayergetfriendsappsactivityresponseappfriendsinfo(x, 7)
}

// [packed=false]
for _, x in o.returned_to_group {
res << zzz_vproto_internal_pack_cplayergetfriendsappsactivityresponseappfriendsinfo(x, 8)
}

if o.has_active_friend_count {
res << vproto.pack_uint32_field(o.active_friend_count, 9)
}

return res
}

pub fn cplayergetfriendsappsactivityresponse_unpack(buf []byte) ?CPlayerGetFriendsAppsActivityResponse {
mut res := CPlayerGetFriendsAppsActivityResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsappsactivityresponseappfriendsinfo(cur_buf, tag_wiretype.wire_type)?
res.trending << v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsappsactivityresponseappfriendsinfo(cur_buf, tag_wiretype.wire_type)?
res.recent_purchases << v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsappsactivityresponseappfriendsinfo(cur_buf, tag_wiretype.wire_type)?
res.unowned << v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsappsactivityresponseappfriendsinfo(cur_buf, tag_wiretype.wire_type)?
res.popular << v
i = ii
}

5 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsappsactivityresponseappfriendsinfo(cur_buf, tag_wiretype.wire_type)?
res.dont_forget << v
i = ii
}

6 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsappsactivityresponseappfriendsinfo(cur_buf, tag_wiretype.wire_type)?
res.being_discussed << v
i = ii
}

7 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsappsactivityresponseappfriendsinfo(cur_buf, tag_wiretype.wire_type)?
res.new_to_group << v
i = ii
}

8 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetfriendsappsactivityresponseappfriendsinfo(cur_buf, tag_wiretype.wire_type)?
res.returned_to_group << v
i = ii
}

9 {
res.has_active_friend_count = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.active_friend_count = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetfriendsappsactivityresponse() CPlayerGetFriendsAppsActivityResponse {
return CPlayerGetFriendsAppsActivityResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetfriendsappsactivityresponse(o CPlayerGetFriendsAppsActivityResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetfriendsappsactivityresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetFriendsAppsActivityResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetfriendsappsactivityresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetGameBadgeLevelsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
}
pub fn (o &CPlayerGetGameBadgeLevelsRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

return res
}

pub fn cplayergetgamebadgelevelsrequest_unpack(buf []byte) ?CPlayerGetGameBadgeLevelsRequest {
mut res := CPlayerGetGameBadgeLevelsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetgamebadgelevelsrequest() CPlayerGetGameBadgeLevelsRequest {
return CPlayerGetGameBadgeLevelsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetgamebadgelevelsrequest(o CPlayerGetGameBadgeLevelsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetgamebadgelevelsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetGameBadgeLevelsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetgamebadgelevelsrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetGameBadgeLevelsResponseBadge {
mut:
unknown_fields []vproto.UnknownField
pub mut:
level int
has_level bool
series int
has_series bool
border_color u32
has_border_color bool
}
pub fn (o &CPlayerGetGameBadgeLevelsResponseBadge) pack() []byte {
mut res := []byte{}
if o.has_level {
res << vproto.pack_int32_field(o.level, 1)
}

if o.has_series {
res << vproto.pack_int32_field(o.series, 2)
}

if o.has_border_color {
res << vproto.pack_uint32_field(o.border_color, 3)
}

return res
}

pub fn cplayergetgamebadgelevelsresponsebadge_unpack(buf []byte) ?CPlayerGetGameBadgeLevelsResponseBadge {
mut res := CPlayerGetGameBadgeLevelsResponseBadge{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_level = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.level = v
i = ii
}

2 {
res.has_series = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.series = v
i = ii
}

3 {
res.has_border_color = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.border_color = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetgamebadgelevelsresponsebadge() CPlayerGetGameBadgeLevelsResponseBadge {
return CPlayerGetGameBadgeLevelsResponseBadge{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetgamebadgelevelsresponsebadge(o CPlayerGetGameBadgeLevelsResponseBadge, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetgamebadgelevelsresponsebadge(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetGameBadgeLevelsResponseBadge) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetgamebadgelevelsresponsebadge_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetGameBadgeLevelsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
player_level u32
has_player_level bool
badges []CPlayerGetGameBadgeLevelsResponseBadge
}
pub fn (o &CPlayerGetGameBadgeLevelsResponse) pack() []byte {
mut res := []byte{}
if o.has_player_level {
res << vproto.pack_uint32_field(o.player_level, 1)
}

// [packed=false]
for _, x in o.badges {
res << zzz_vproto_internal_pack_cplayergetgamebadgelevelsresponsebadge(x, 2)
}

return res
}

pub fn cplayergetgamebadgelevelsresponse_unpack(buf []byte) ?CPlayerGetGameBadgeLevelsResponse {
mut res := CPlayerGetGameBadgeLevelsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_player_level = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.player_level = v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetgamebadgelevelsresponsebadge(cur_buf, tag_wiretype.wire_type)?
res.badges << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetgamebadgelevelsresponse() CPlayerGetGameBadgeLevelsResponse {
return CPlayerGetGameBadgeLevelsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetgamebadgelevelsresponse(o CPlayerGetGameBadgeLevelsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetgamebadgelevelsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetGameBadgeLevelsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetgamebadgelevelsresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetProfileBackgroundRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
language string
has_language bool
}
pub fn (o &CPlayerGetProfileBackgroundRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_language {
res << vproto.pack_string_field(o.language, 2)
}

return res
}

pub fn cplayergetprofilebackgroundrequest_unpack(buf []byte) ?CPlayerGetProfileBackgroundRequest {
mut res := CPlayerGetProfileBackgroundRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_language = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetprofilebackgroundrequest() CPlayerGetProfileBackgroundRequest {
return CPlayerGetProfileBackgroundRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetprofilebackgroundrequest(o CPlayerGetProfileBackgroundRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetprofilebackgroundrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetProfileBackgroundRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetprofilebackgroundrequest_unpack(v)?
return i, unpacked
}
pub struct ProfileItem {
mut:
unknown_fields []vproto.UnknownField
pub mut:
communityitemid u64
has_communityitemid bool
image_small string
has_image_small bool
image_large string
has_image_large bool
name string
has_name bool
item_title string
has_item_title bool
item_description string
has_item_description bool
appid u32
has_appid bool
item_type u32
has_item_type bool
item_class u32
has_item_class bool
movie_webm string
has_movie_webm bool
movie_mp4 string
has_movie_mp4 bool
equipped_flags u32
has_equipped_flags bool
}
pub fn (o &ProfileItem) pack() []byte {
mut res := []byte{}
if o.has_communityitemid {
res << vproto.pack_uint64_field(o.communityitemid, 1)
}

if o.has_image_small {
res << vproto.pack_string_field(o.image_small, 2)
}

if o.has_image_large {
res << vproto.pack_string_field(o.image_large, 3)
}

if o.has_name {
res << vproto.pack_string_field(o.name, 4)
}

if o.has_item_title {
res << vproto.pack_string_field(o.item_title, 5)
}

if o.has_item_description {
res << vproto.pack_string_field(o.item_description, 6)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 7)
}

if o.has_item_type {
res << vproto.pack_uint32_field(o.item_type, 8)
}

if o.has_item_class {
res << vproto.pack_uint32_field(o.item_class, 9)
}

if o.has_movie_webm {
res << vproto.pack_string_field(o.movie_webm, 10)
}

if o.has_movie_mp4 {
res << vproto.pack_string_field(o.movie_mp4, 11)
}

if o.has_equipped_flags {
res << vproto.pack_uint32_field(o.equipped_flags, 12)
}

return res
}

pub fn profileitem_unpack(buf []byte) ?ProfileItem {
mut res := ProfileItem{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_communityitemid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.communityitemid = v
i = ii
}

2 {
res.has_image_small = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.image_small = v
i = ii
}

3 {
res.has_image_large = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.image_large = v
i = ii
}

4 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

5 {
res.has_item_title = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.item_title = v
i = ii
}

6 {
res.has_item_description = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.item_description = v
i = ii
}

7 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

8 {
res.has_item_type = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.item_type = v
i = ii
}

9 {
res.has_item_class = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.item_class = v
i = ii
}

10 {
res.has_movie_webm = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.movie_webm = v
i = ii
}

11 {
res.has_movie_mp4 = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.movie_mp4 = v
i = ii
}

12 {
res.has_equipped_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.equipped_flags = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_profileitem() ProfileItem {
return ProfileItem{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_profileitem(o ProfileItem, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_profileitem(buf []byte, tag_wiretype vproto.WireType) ?(int, ProfileItem) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := profileitem_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetProfileBackgroundResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
profile_background ProfileItem
has_profile_background bool
}
pub fn (o &CPlayerGetProfileBackgroundResponse) pack() []byte {
mut res := []byte{}
if o.has_profile_background {
res << zzz_vproto_internal_pack_profileitem(o.profile_background, 1)
}

return res
}

pub fn cplayergetprofilebackgroundresponse_unpack(buf []byte) ?CPlayerGetProfileBackgroundResponse {
mut res := CPlayerGetProfileBackgroundResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_profile_background = true
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.profile_background = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetprofilebackgroundresponse() CPlayerGetProfileBackgroundResponse {
return CPlayerGetProfileBackgroundResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetprofilebackgroundresponse(o CPlayerGetProfileBackgroundResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetprofilebackgroundresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetProfileBackgroundResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetprofilebackgroundresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetProfileBackgroundRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
communityitemid u64
has_communityitemid bool
}
pub fn (o &CPlayerSetProfileBackgroundRequest) pack() []byte {
mut res := []byte{}
if o.has_communityitemid {
res << vproto.pack_uint64_field(o.communityitemid, 1)
}

return res
}

pub fn cplayersetprofilebackgroundrequest_unpack(buf []byte) ?CPlayerSetProfileBackgroundRequest {
mut res := CPlayerSetProfileBackgroundRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_communityitemid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.communityitemid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetprofilebackgroundrequest() CPlayerSetProfileBackgroundRequest {
return CPlayerSetProfileBackgroundRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetprofilebackgroundrequest(o CPlayerSetProfileBackgroundRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetprofilebackgroundrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetProfileBackgroundRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetprofilebackgroundrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetProfileBackgroundResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerSetProfileBackgroundResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cplayersetprofilebackgroundresponse_unpack(buf []byte) ?CPlayerSetProfileBackgroundResponse {
res := CPlayerSetProfileBackgroundResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetprofilebackgroundresponse() CPlayerSetProfileBackgroundResponse {
return CPlayerSetProfileBackgroundResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetprofilebackgroundresponse(o CPlayerSetProfileBackgroundResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetprofilebackgroundresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetProfileBackgroundResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetprofilebackgroundresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetMiniProfileBackgroundRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
language string
has_language bool
}
pub fn (o &CPlayerGetMiniProfileBackgroundRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_language {
res << vproto.pack_string_field(o.language, 2)
}

return res
}

pub fn cplayergetminiprofilebackgroundrequest_unpack(buf []byte) ?CPlayerGetMiniProfileBackgroundRequest {
mut res := CPlayerGetMiniProfileBackgroundRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_language = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetminiprofilebackgroundrequest() CPlayerGetMiniProfileBackgroundRequest {
return CPlayerGetMiniProfileBackgroundRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetminiprofilebackgroundrequest(o CPlayerGetMiniProfileBackgroundRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetminiprofilebackgroundrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetMiniProfileBackgroundRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetminiprofilebackgroundrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetMiniProfileBackgroundResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
profile_background ProfileItem
has_profile_background bool
}
pub fn (o &CPlayerGetMiniProfileBackgroundResponse) pack() []byte {
mut res := []byte{}
if o.has_profile_background {
res << zzz_vproto_internal_pack_profileitem(o.profile_background, 1)
}

return res
}

pub fn cplayergetminiprofilebackgroundresponse_unpack(buf []byte) ?CPlayerGetMiniProfileBackgroundResponse {
mut res := CPlayerGetMiniProfileBackgroundResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_profile_background = true
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.profile_background = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetminiprofilebackgroundresponse() CPlayerGetMiniProfileBackgroundResponse {
return CPlayerGetMiniProfileBackgroundResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetminiprofilebackgroundresponse(o CPlayerGetMiniProfileBackgroundResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetminiprofilebackgroundresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetMiniProfileBackgroundResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetminiprofilebackgroundresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetMiniProfileBackgroundRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
communityitemid u64
has_communityitemid bool
}
pub fn (o &CPlayerSetMiniProfileBackgroundRequest) pack() []byte {
mut res := []byte{}
if o.has_communityitemid {
res << vproto.pack_uint64_field(o.communityitemid, 1)
}

return res
}

pub fn cplayersetminiprofilebackgroundrequest_unpack(buf []byte) ?CPlayerSetMiniProfileBackgroundRequest {
mut res := CPlayerSetMiniProfileBackgroundRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_communityitemid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.communityitemid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetminiprofilebackgroundrequest() CPlayerSetMiniProfileBackgroundRequest {
return CPlayerSetMiniProfileBackgroundRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetminiprofilebackgroundrequest(o CPlayerSetMiniProfileBackgroundRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetminiprofilebackgroundrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetMiniProfileBackgroundRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetminiprofilebackgroundrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetMiniProfileBackgroundResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerSetMiniProfileBackgroundResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cplayersetminiprofilebackgroundresponse_unpack(buf []byte) ?CPlayerSetMiniProfileBackgroundResponse {
res := CPlayerSetMiniProfileBackgroundResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetminiprofilebackgroundresponse() CPlayerSetMiniProfileBackgroundResponse {
return CPlayerSetMiniProfileBackgroundResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetminiprofilebackgroundresponse(o CPlayerSetMiniProfileBackgroundResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetminiprofilebackgroundresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetMiniProfileBackgroundResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetminiprofilebackgroundresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetAvatarFrameRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
language string
has_language bool
}
pub fn (o &CPlayerGetAvatarFrameRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_language {
res << vproto.pack_string_field(o.language, 2)
}

return res
}

pub fn cplayergetavatarframerequest_unpack(buf []byte) ?CPlayerGetAvatarFrameRequest {
mut res := CPlayerGetAvatarFrameRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_language = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetavatarframerequest() CPlayerGetAvatarFrameRequest {
return CPlayerGetAvatarFrameRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetavatarframerequest(o CPlayerGetAvatarFrameRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetavatarframerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetAvatarFrameRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetavatarframerequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetAvatarFrameResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
avatar_frame ProfileItem
has_avatar_frame bool
}
pub fn (o &CPlayerGetAvatarFrameResponse) pack() []byte {
mut res := []byte{}
if o.has_avatar_frame {
res << zzz_vproto_internal_pack_profileitem(o.avatar_frame, 1)
}

return res
}

pub fn cplayergetavatarframeresponse_unpack(buf []byte) ?CPlayerGetAvatarFrameResponse {
mut res := CPlayerGetAvatarFrameResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_avatar_frame = true
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.avatar_frame = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetavatarframeresponse() CPlayerGetAvatarFrameResponse {
return CPlayerGetAvatarFrameResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetavatarframeresponse(o CPlayerGetAvatarFrameResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetavatarframeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetAvatarFrameResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetavatarframeresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetAvatarFrameRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
communityitemid u64
has_communityitemid bool
}
pub fn (o &CPlayerSetAvatarFrameRequest) pack() []byte {
mut res := []byte{}
if o.has_communityitemid {
res << vproto.pack_uint64_field(o.communityitemid, 1)
}

return res
}

pub fn cplayersetavatarframerequest_unpack(buf []byte) ?CPlayerSetAvatarFrameRequest {
mut res := CPlayerSetAvatarFrameRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_communityitemid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.communityitemid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetavatarframerequest() CPlayerSetAvatarFrameRequest {
return CPlayerSetAvatarFrameRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetavatarframerequest(o CPlayerSetAvatarFrameRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetavatarframerequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetAvatarFrameRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetavatarframerequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetAvatarFrameResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerSetAvatarFrameResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cplayersetavatarframeresponse_unpack(buf []byte) ?CPlayerSetAvatarFrameResponse {
res := CPlayerSetAvatarFrameResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetavatarframeresponse() CPlayerSetAvatarFrameResponse {
return CPlayerSetAvatarFrameResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetavatarframeresponse(o CPlayerSetAvatarFrameResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetavatarframeresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetAvatarFrameResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetavatarframeresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetAnimatedAvatarRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
language string
has_language bool
}
pub fn (o &CPlayerGetAnimatedAvatarRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_language {
res << vproto.pack_string_field(o.language, 2)
}

return res
}

pub fn cplayergetanimatedavatarrequest_unpack(buf []byte) ?CPlayerGetAnimatedAvatarRequest {
mut res := CPlayerGetAnimatedAvatarRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_language = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetanimatedavatarrequest() CPlayerGetAnimatedAvatarRequest {
return CPlayerGetAnimatedAvatarRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetanimatedavatarrequest(o CPlayerGetAnimatedAvatarRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetanimatedavatarrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetAnimatedAvatarRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetanimatedavatarrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetAnimatedAvatarResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
avatar ProfileItem
has_avatar bool
}
pub fn (o &CPlayerGetAnimatedAvatarResponse) pack() []byte {
mut res := []byte{}
if o.has_avatar {
res << zzz_vproto_internal_pack_profileitem(o.avatar, 1)
}

return res
}

pub fn cplayergetanimatedavatarresponse_unpack(buf []byte) ?CPlayerGetAnimatedAvatarResponse {
mut res := CPlayerGetAnimatedAvatarResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_avatar = true
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.avatar = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetanimatedavatarresponse() CPlayerGetAnimatedAvatarResponse {
return CPlayerGetAnimatedAvatarResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetanimatedavatarresponse(o CPlayerGetAnimatedAvatarResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetanimatedavatarresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetAnimatedAvatarResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetanimatedavatarresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetAnimatedAvatarRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
communityitemid u64
has_communityitemid bool
}
pub fn (o &CPlayerSetAnimatedAvatarRequest) pack() []byte {
mut res := []byte{}
if o.has_communityitemid {
res << vproto.pack_uint64_field(o.communityitemid, 1)
}

return res
}

pub fn cplayersetanimatedavatarrequest_unpack(buf []byte) ?CPlayerSetAnimatedAvatarRequest {
mut res := CPlayerSetAnimatedAvatarRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_communityitemid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.communityitemid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetanimatedavatarrequest() CPlayerSetAnimatedAvatarRequest {
return CPlayerSetAnimatedAvatarRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetanimatedavatarrequest(o CPlayerSetAnimatedAvatarRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetanimatedavatarrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetAnimatedAvatarRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetanimatedavatarrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetAnimatedAvatarResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerSetAnimatedAvatarResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cplayersetanimatedavatarresponse_unpack(buf []byte) ?CPlayerSetAnimatedAvatarResponse {
res := CPlayerSetAnimatedAvatarResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetanimatedavatarresponse() CPlayerSetAnimatedAvatarResponse {
return CPlayerSetAnimatedAvatarResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetanimatedavatarresponse(o CPlayerSetAnimatedAvatarResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetanimatedavatarresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetAnimatedAvatarResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetanimatedavatarresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetProfileItemsOwnedRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
language string
has_language bool
}
pub fn (o &CPlayerGetProfileItemsOwnedRequest) pack() []byte {
mut res := []byte{}
if o.has_language {
res << vproto.pack_string_field(o.language, 1)
}

return res
}

pub fn cplayergetprofileitemsownedrequest_unpack(buf []byte) ?CPlayerGetProfileItemsOwnedRequest {
mut res := CPlayerGetProfileItemsOwnedRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_language = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetprofileitemsownedrequest() CPlayerGetProfileItemsOwnedRequest {
return CPlayerGetProfileItemsOwnedRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetprofileitemsownedrequest(o CPlayerGetProfileItemsOwnedRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetprofileitemsownedrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetProfileItemsOwnedRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetprofileitemsownedrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetProfileItemsOwnedResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
profile_backgrounds []ProfileItem
mini_profile_backgrounds []ProfileItem
avatar_frames []ProfileItem
animated_avatars []ProfileItem
profile_modifiers []ProfileItem
}
pub fn (o &CPlayerGetProfileItemsOwnedResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.profile_backgrounds {
res << zzz_vproto_internal_pack_profileitem(x, 1)
}

// [packed=false]
for _, x in o.mini_profile_backgrounds {
res << zzz_vproto_internal_pack_profileitem(x, 2)
}

// [packed=false]
for _, x in o.avatar_frames {
res << zzz_vproto_internal_pack_profileitem(x, 3)
}

// [packed=false]
for _, x in o.animated_avatars {
res << zzz_vproto_internal_pack_profileitem(x, 4)
}

// [packed=false]
for _, x in o.profile_modifiers {
res << zzz_vproto_internal_pack_profileitem(x, 5)
}

return res
}

pub fn cplayergetprofileitemsownedresponse_unpack(buf []byte) ?CPlayerGetProfileItemsOwnedResponse {
mut res := CPlayerGetProfileItemsOwnedResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.profile_backgrounds << v
i = ii
}

2 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.mini_profile_backgrounds << v
i = ii
}

3 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.avatar_frames << v
i = ii
}

4 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.animated_avatars << v
i = ii
}

5 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.profile_modifiers << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetprofileitemsownedresponse() CPlayerGetProfileItemsOwnedResponse {
return CPlayerGetProfileItemsOwnedResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetprofileitemsownedresponse(o CPlayerGetProfileItemsOwnedResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetprofileitemsownedresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetProfileItemsOwnedResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetprofileitemsownedresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetProfileItemsEquippedRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
language string
has_language bool
}
pub fn (o &CPlayerGetProfileItemsEquippedRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_language {
res << vproto.pack_string_field(o.language, 2)
}

return res
}

pub fn cplayergetprofileitemsequippedrequest_unpack(buf []byte) ?CPlayerGetProfileItemsEquippedRequest {
mut res := CPlayerGetProfileItemsEquippedRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_language = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetprofileitemsequippedrequest() CPlayerGetProfileItemsEquippedRequest {
return CPlayerGetProfileItemsEquippedRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetprofileitemsequippedrequest(o CPlayerGetProfileItemsEquippedRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetprofileitemsequippedrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetProfileItemsEquippedRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetprofileitemsequippedrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetProfileItemsEquippedResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
profile_background ProfileItem
has_profile_background bool
mini_profile_background ProfileItem
has_mini_profile_background bool
avatar_frame ProfileItem
has_avatar_frame bool
animated_avatar ProfileItem
has_animated_avatar bool
profile_modifier ProfileItem
has_profile_modifier bool
}
pub fn (o &CPlayerGetProfileItemsEquippedResponse) pack() []byte {
mut res := []byte{}
if o.has_profile_background {
res << zzz_vproto_internal_pack_profileitem(o.profile_background, 1)
}

if o.has_mini_profile_background {
res << zzz_vproto_internal_pack_profileitem(o.mini_profile_background, 2)
}

if o.has_avatar_frame {
res << zzz_vproto_internal_pack_profileitem(o.avatar_frame, 3)
}

if o.has_animated_avatar {
res << zzz_vproto_internal_pack_profileitem(o.animated_avatar, 4)
}

if o.has_profile_modifier {
res << zzz_vproto_internal_pack_profileitem(o.profile_modifier, 5)
}

return res
}

pub fn cplayergetprofileitemsequippedresponse_unpack(buf []byte) ?CPlayerGetProfileItemsEquippedResponse {
mut res := CPlayerGetProfileItemsEquippedResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_profile_background = true
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.profile_background = v
i = ii
}

2 {
res.has_mini_profile_background = true
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.mini_profile_background = v
i = ii
}

3 {
res.has_avatar_frame = true
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.avatar_frame = v
i = ii
}

4 {
res.has_animated_avatar = true
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.animated_avatar = v
i = ii
}

5 {
res.has_profile_modifier = true
ii, v := zzz_vproto_internal_unpack_profileitem(cur_buf, tag_wiretype.wire_type)?
res.profile_modifier = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetprofileitemsequippedresponse() CPlayerGetProfileItemsEquippedResponse {
return CPlayerGetProfileItemsEquippedResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetprofileitemsequippedresponse(o CPlayerGetProfileItemsEquippedResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetprofileitemsequippedresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetProfileItemsEquippedResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetprofileitemsequippedresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetEquippedProfileItemFlagsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
communityitemid u64
has_communityitemid bool
flags u32
has_flags bool
}
pub fn (o &CPlayerSetEquippedProfileItemFlagsRequest) pack() []byte {
mut res := []byte{}
if o.has_communityitemid {
res << vproto.pack_uint64_field(o.communityitemid, 1)
}

if o.has_flags {
res << vproto.pack_uint32_field(o.flags, 2)
}

return res
}

pub fn cplayersetequippedprofileitemflagsrequest_unpack(buf []byte) ?CPlayerSetEquippedProfileItemFlagsRequest {
mut res := CPlayerSetEquippedProfileItemFlagsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_communityitemid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.communityitemid = v
i = ii
}

2 {
res.has_flags = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.flags = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetequippedprofileitemflagsrequest() CPlayerSetEquippedProfileItemFlagsRequest {
return CPlayerSetEquippedProfileItemFlagsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetequippedprofileitemflagsrequest(o CPlayerSetEquippedProfileItemFlagsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetequippedprofileitemflagsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetEquippedProfileItemFlagsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetequippedprofileitemflagsrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetEquippedProfileItemFlagsResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerSetEquippedProfileItemFlagsResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cplayersetequippedprofileitemflagsresponse_unpack(buf []byte) ?CPlayerSetEquippedProfileItemFlagsResponse {
res := CPlayerSetEquippedProfileItemFlagsResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetequippedprofileitemflagsresponse() CPlayerSetEquippedProfileItemFlagsResponse {
return CPlayerSetEquippedProfileItemFlagsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetequippedprofileitemflagsresponse(o CPlayerSetEquippedProfileItemFlagsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetequippedprofileitemflagsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetEquippedProfileItemFlagsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetequippedprofileitemflagsresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetEmoticonListRequest {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerGetEmoticonListRequest) pack() []byte {
res := []byte{}
return res
}

pub fn cplayergetemoticonlistrequest_unpack(buf []byte) ?CPlayerGetEmoticonListRequest {
res := CPlayerGetEmoticonListRequest{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetemoticonlistrequest() CPlayerGetEmoticonListRequest {
return CPlayerGetEmoticonListRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetemoticonlistrequest(o CPlayerGetEmoticonListRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetemoticonlistrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetEmoticonListRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetemoticonlistrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetEmoticonListResponseEmoticon {
mut:
unknown_fields []vproto.UnknownField
pub mut:
name string
has_name bool
count int
has_count bool
time_last_used u32
has_time_last_used bool
use_count u32
has_use_count bool
time_received u32
has_time_received bool
}
pub fn (o &CPlayerGetEmoticonListResponseEmoticon) pack() []byte {
mut res := []byte{}
if o.has_name {
res << vproto.pack_string_field(o.name, 1)
}

if o.has_count {
res << vproto.pack_int32_field(o.count, 2)
}

if o.has_time_last_used {
res << vproto.pack_uint32_field(o.time_last_used, 3)
}

if o.has_use_count {
res << vproto.pack_uint32_field(o.use_count, 4)
}

if o.has_time_received {
res << vproto.pack_uint32_field(o.time_received, 5)
}

return res
}

pub fn cplayergetemoticonlistresponseemoticon_unpack(buf []byte) ?CPlayerGetEmoticonListResponseEmoticon {
mut res := CPlayerGetEmoticonListResponseEmoticon{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_name = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.name = v
i = ii
}

2 {
res.has_count = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.count = v
i = ii
}

3 {
res.has_time_last_used = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_last_used = v
i = ii
}

4 {
res.has_use_count = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.use_count = v
i = ii
}

5 {
res.has_time_received = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_received = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetemoticonlistresponseemoticon() CPlayerGetEmoticonListResponseEmoticon {
return CPlayerGetEmoticonListResponseEmoticon{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetemoticonlistresponseemoticon(o CPlayerGetEmoticonListResponseEmoticon, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetemoticonlistresponseemoticon(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetEmoticonListResponseEmoticon) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetemoticonlistresponseemoticon_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetEmoticonListResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
emoticons []CPlayerGetEmoticonListResponseEmoticon
}
pub fn (o &CPlayerGetEmoticonListResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.emoticons {
res << zzz_vproto_internal_pack_cplayergetemoticonlistresponseemoticon(x, 1)
}

return res
}

pub fn cplayergetemoticonlistresponse_unpack(buf []byte) ?CPlayerGetEmoticonListResponse {
mut res := CPlayerGetEmoticonListResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetemoticonlistresponseemoticon(cur_buf, tag_wiretype.wire_type)?
res.emoticons << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetemoticonlistresponse() CPlayerGetEmoticonListResponse {
return CPlayerGetEmoticonListResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetemoticonlistresponse(o CPlayerGetEmoticonListResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetemoticonlistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetEmoticonListResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetemoticonlistresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetAchievementsProgressRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
language string
has_language bool
appids []u32
}
pub fn (o &CPlayerGetAchievementsProgressRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_uint64_field(o.steamid, 1)
}

if o.has_language {
res << vproto.pack_string_field(o.language, 2)
}

// [packed=false]
for _, x in o.appids {
res << vproto.pack_uint32_field(x, 3)
}

return res
}

pub fn cplayergetachievementsprogressrequest_unpack(buf []byte) ?CPlayerGetAchievementsProgressRequest {
mut res := CPlayerGetAchievementsProgressRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_language = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

3 {
// [packed=false]
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appids << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetachievementsprogressrequest() CPlayerGetAchievementsProgressRequest {
return CPlayerGetAchievementsProgressRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetachievementsprogressrequest(o CPlayerGetAchievementsProgressRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetachievementsprogressrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetAchievementsProgressRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetachievementsprogressrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetAchievementsProgressResponseAchievementProgress {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
unlocked u32
has_unlocked bool
total u32
has_total bool
percentage f32
has_percentage bool
all_unlocked bool
has_all_unlocked bool
cache_time u32
has_cache_time bool
}
pub fn (o &CPlayerGetAchievementsProgressResponseAchievementProgress) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_unlocked {
res << vproto.pack_uint32_field(o.unlocked, 2)
}

if o.has_total {
res << vproto.pack_uint32_field(o.total, 3)
}

if o.has_percentage {
res << vproto.pack_float_field(o.percentage, 4)
}

if o.has_all_unlocked {
res << vproto.pack_bool_field(o.all_unlocked, 5)
}

if o.has_cache_time {
res << vproto.pack_uint32_field(o.cache_time, 6)
}

return res
}

pub fn cplayergetachievementsprogressresponseachievementprogress_unpack(buf []byte) ?CPlayerGetAchievementsProgressResponseAchievementProgress {
mut res := CPlayerGetAchievementsProgressResponseAchievementProgress{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_unlocked = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.unlocked = v
i = ii
}

3 {
res.has_total = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.total = v
i = ii
}

4 {
res.has_percentage = true
ii, v := vproto.unpack_float_field(cur_buf, tag_wiretype.wire_type)?
res.percentage = v
i = ii
}

5 {
res.has_all_unlocked = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.all_unlocked = v
i = ii
}

6 {
res.has_cache_time = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.cache_time = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetachievementsprogressresponseachievementprogress() CPlayerGetAchievementsProgressResponseAchievementProgress {
return CPlayerGetAchievementsProgressResponseAchievementProgress{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetachievementsprogressresponseachievementprogress(o CPlayerGetAchievementsProgressResponseAchievementProgress, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetachievementsprogressresponseachievementprogress(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetAchievementsProgressResponseAchievementProgress) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetachievementsprogressresponseachievementprogress_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetAchievementsProgressResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
achievement_progress []CPlayerGetAchievementsProgressResponseAchievementProgress
}
pub fn (o &CPlayerGetAchievementsProgressResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.achievement_progress {
res << zzz_vproto_internal_pack_cplayergetachievementsprogressresponseachievementprogress(x, 1)
}

return res
}

pub fn cplayergetachievementsprogressresponse_unpack(buf []byte) ?CPlayerGetAchievementsProgressResponse {
mut res := CPlayerGetAchievementsProgressResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetachievementsprogressresponseachievementprogress(cur_buf, tag_wiretype.wire_type)?
res.achievement_progress << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetachievementsprogressresponse() CPlayerGetAchievementsProgressResponse {
return CPlayerGetAchievementsProgressResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetachievementsprogressresponse(o CPlayerGetAchievementsProgressResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetachievementsprogressresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetAchievementsProgressResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetachievementsprogressresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerPostStatusToFriendsRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
status_text string
has_status_text bool
}
pub fn (o &CPlayerPostStatusToFriendsRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

if o.has_status_text {
res << vproto.pack_string_field(o.status_text, 2)
}

return res
}

pub fn cplayerpoststatustofriendsrequest_unpack(buf []byte) ?CPlayerPostStatusToFriendsRequest {
mut res := CPlayerPostStatusToFriendsRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_status_text = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.status_text = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerpoststatustofriendsrequest() CPlayerPostStatusToFriendsRequest {
return CPlayerPostStatusToFriendsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerpoststatustofriendsrequest(o CPlayerPostStatusToFriendsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerpoststatustofriendsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerPostStatusToFriendsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerpoststatustofriendsrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerPostStatusToFriendsResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerPostStatusToFriendsResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cplayerpoststatustofriendsresponse_unpack(buf []byte) ?CPlayerPostStatusToFriendsResponse {
res := CPlayerPostStatusToFriendsResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerpoststatustofriendsresponse() CPlayerPostStatusToFriendsResponse {
return CPlayerPostStatusToFriendsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerpoststatustofriendsresponse(o CPlayerPostStatusToFriendsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerpoststatustofriendsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerPostStatusToFriendsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerpoststatustofriendsresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetPostedStatusRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
postid u64
has_postid bool
}
pub fn (o &CPlayerGetPostedStatusRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_uint64_field(o.steamid, 1)
}

if o.has_postid {
res << vproto.pack_uint64_field(o.postid, 2)
}

return res
}

pub fn cplayergetpostedstatusrequest_unpack(buf []byte) ?CPlayerGetPostedStatusRequest {
mut res := CPlayerGetPostedStatusRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_postid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.postid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetpostedstatusrequest() CPlayerGetPostedStatusRequest {
return CPlayerGetPostedStatusRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetpostedstatusrequest(o CPlayerGetPostedStatusRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetpostedstatusrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetPostedStatusRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetpostedstatusrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetPostedStatusResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
accountid u32
has_accountid bool
postid u64
has_postid bool
status_text string
has_status_text bool
deleted bool
has_deleted bool
appid u32
has_appid bool
}
pub fn (o &CPlayerGetPostedStatusResponse) pack() []byte {
mut res := []byte{}
if o.has_accountid {
res << vproto.pack_uint32_field(o.accountid, 1)
}

if o.has_postid {
res << vproto.pack_uint64_field(o.postid, 2)
}

if o.has_status_text {
res << vproto.pack_string_field(o.status_text, 3)
}

if o.has_deleted {
res << vproto.pack_bool_field(o.deleted, 4)
}

if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 5)
}

return res
}

pub fn cplayergetpostedstatusresponse_unpack(buf []byte) ?CPlayerGetPostedStatusResponse {
mut res := CPlayerGetPostedStatusResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_accountid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.accountid = v
i = ii
}

2 {
res.has_postid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.postid = v
i = ii
}

3 {
res.has_status_text = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.status_text = v
i = ii
}

4 {
res.has_deleted = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.deleted = v
i = ii
}

5 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetpostedstatusresponse() CPlayerGetPostedStatusResponse {
return CPlayerGetPostedStatusResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetpostedstatusresponse(o CPlayerGetPostedStatusResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetpostedstatusresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetPostedStatusResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetpostedstatusresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerDeletePostedStatusRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
postid u64
has_postid bool
}
pub fn (o &CPlayerDeletePostedStatusRequest) pack() []byte {
mut res := []byte{}
if o.has_postid {
res << vproto.pack_uint64_field(o.postid, 1)
}

return res
}

pub fn cplayerdeletepostedstatusrequest_unpack(buf []byte) ?CPlayerDeletePostedStatusRequest {
mut res := CPlayerDeletePostedStatusRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_postid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.postid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerdeletepostedstatusrequest() CPlayerDeletePostedStatusRequest {
return CPlayerDeletePostedStatusRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerdeletepostedstatusrequest(o CPlayerDeletePostedStatusRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerdeletepostedstatusrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerDeletePostedStatusRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerdeletepostedstatusrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerDeletePostedStatusResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerDeletePostedStatusResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cplayerdeletepostedstatusresponse_unpack(buf []byte) ?CPlayerDeletePostedStatusResponse {
res := CPlayerDeletePostedStatusResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerdeletepostedstatusresponse() CPlayerDeletePostedStatusResponse {
return CPlayerDeletePostedStatusResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerdeletepostedstatusresponse(o CPlayerDeletePostedStatusResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerdeletepostedstatusresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerDeletePostedStatusResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerdeletepostedstatusresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetLastPlayedTimesRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
min_last_played u32
has_min_last_played bool
}
pub fn (o &CPlayerGetLastPlayedTimesRequest) pack() []byte {
mut res := []byte{}
if o.has_min_last_played {
res << vproto.pack_uint32_field(o.min_last_played, 1)
}

return res
}

pub fn cplayergetlastplayedtimesrequest_unpack(buf []byte) ?CPlayerGetLastPlayedTimesRequest {
mut res := CPlayerGetLastPlayedTimesRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_min_last_played = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.min_last_played = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetlastplayedtimesrequest() CPlayerGetLastPlayedTimesRequest {
return CPlayerGetLastPlayedTimesRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetlastplayedtimesrequest(o CPlayerGetLastPlayedTimesRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetlastplayedtimesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetLastPlayedTimesRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetlastplayedtimesrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetLastPlayedTimesResponseGame {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid int
has_appid bool
last_playtime u32
has_last_playtime bool
playtime_2weeks int
has_playtime_2weeks bool
playtime_forever int
has_playtime_forever bool
first_playtime u32
has_first_playtime bool
playtime_windows_forever int
has_playtime_windows_forever bool
playtime_mac_forever int
has_playtime_mac_forever bool
playtime_linux_forever int
has_playtime_linux_forever bool
first_windows_playtime u32
has_first_windows_playtime bool
first_mac_playtime u32
has_first_mac_playtime bool
first_linux_playtime u32
has_first_linux_playtime bool
last_windows_playtime u32
has_last_windows_playtime bool
last_mac_playtime u32
has_last_mac_playtime bool
last_linux_playtime u32
has_last_linux_playtime bool
}
pub fn (o &CPlayerGetLastPlayedTimesResponseGame) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_int32_field(o.appid, 1)
}

if o.has_last_playtime {
res << vproto.pack_uint32_field(o.last_playtime, 2)
}

if o.has_playtime_2weeks {
res << vproto.pack_int32_field(o.playtime_2weeks, 3)
}

if o.has_playtime_forever {
res << vproto.pack_int32_field(o.playtime_forever, 4)
}

if o.has_first_playtime {
res << vproto.pack_uint32_field(o.first_playtime, 5)
}

if o.has_playtime_windows_forever {
res << vproto.pack_int32_field(o.playtime_windows_forever, 6)
}

if o.has_playtime_mac_forever {
res << vproto.pack_int32_field(o.playtime_mac_forever, 7)
}

if o.has_playtime_linux_forever {
res << vproto.pack_int32_field(o.playtime_linux_forever, 8)
}

if o.has_first_windows_playtime {
res << vproto.pack_uint32_field(o.first_windows_playtime, 9)
}

if o.has_first_mac_playtime {
res << vproto.pack_uint32_field(o.first_mac_playtime, 10)
}

if o.has_first_linux_playtime {
res << vproto.pack_uint32_field(o.first_linux_playtime, 11)
}

if o.has_last_windows_playtime {
res << vproto.pack_uint32_field(o.last_windows_playtime, 12)
}

if o.has_last_mac_playtime {
res << vproto.pack_uint32_field(o.last_mac_playtime, 13)
}

if o.has_last_linux_playtime {
res << vproto.pack_uint32_field(o.last_linux_playtime, 14)
}

return res
}

pub fn cplayergetlastplayedtimesresponsegame_unpack(buf []byte) ?CPlayerGetLastPlayedTimesResponseGame {
mut res := CPlayerGetLastPlayedTimesResponseGame{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

2 {
res.has_last_playtime = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_playtime = v
i = ii
}

3 {
res.has_playtime_2weeks = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.playtime_2weeks = v
i = ii
}

4 {
res.has_playtime_forever = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.playtime_forever = v
i = ii
}

5 {
res.has_first_playtime = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.first_playtime = v
i = ii
}

6 {
res.has_playtime_windows_forever = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.playtime_windows_forever = v
i = ii
}

7 {
res.has_playtime_mac_forever = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.playtime_mac_forever = v
i = ii
}

8 {
res.has_playtime_linux_forever = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.playtime_linux_forever = v
i = ii
}

9 {
res.has_first_windows_playtime = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.first_windows_playtime = v
i = ii
}

10 {
res.has_first_mac_playtime = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.first_mac_playtime = v
i = ii
}

11 {
res.has_first_linux_playtime = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.first_linux_playtime = v
i = ii
}

12 {
res.has_last_windows_playtime = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_windows_playtime = v
i = ii
}

13 {
res.has_last_mac_playtime = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_mac_playtime = v
i = ii
}

14 {
res.has_last_linux_playtime = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.last_linux_playtime = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetlastplayedtimesresponsegame() CPlayerGetLastPlayedTimesResponseGame {
return CPlayerGetLastPlayedTimesResponseGame{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetlastplayedtimesresponsegame(o CPlayerGetLastPlayedTimesResponseGame, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetlastplayedtimesresponsegame(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetLastPlayedTimesResponseGame) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetlastplayedtimesresponsegame_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetLastPlayedTimesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
games []CPlayerGetLastPlayedTimesResponseGame
}
pub fn (o &CPlayerGetLastPlayedTimesResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.games {
res << zzz_vproto_internal_pack_cplayergetlastplayedtimesresponsegame(x, 1)
}

return res
}

pub fn cplayergetlastplayedtimesresponse_unpack(buf []byte) ?CPlayerGetLastPlayedTimesResponse {
mut res := CPlayerGetLastPlayedTimesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetlastplayedtimesresponsegame(cur_buf, tag_wiretype.wire_type)?
res.games << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetlastplayedtimesresponse() CPlayerGetLastPlayedTimesResponse {
return CPlayerGetLastPlayedTimesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetlastplayedtimesresponse(o CPlayerGetLastPlayedTimesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetlastplayedtimesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetLastPlayedTimesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetlastplayedtimesresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerAcceptSSarequest {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerAcceptSSarequest) pack() []byte {
res := []byte{}
return res
}

pub fn cplayeracceptssarequest_unpack(buf []byte) ?CPlayerAcceptSSarequest {
res := CPlayerAcceptSSarequest{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayeracceptssarequest() CPlayerAcceptSSarequest {
return CPlayerAcceptSSarequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayeracceptssarequest(o CPlayerAcceptSSarequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayeracceptssarequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerAcceptSSarequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayeracceptssarequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerAcceptSSaresponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerAcceptSSaresponse) pack() []byte {
res := []byte{}
return res
}

pub fn cplayeracceptssaresponse_unpack(buf []byte) ?CPlayerAcceptSSaresponse {
res := CPlayerAcceptSSaresponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayeracceptssaresponse() CPlayerAcceptSSaresponse {
return CPlayerAcceptSSaresponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayeracceptssaresponse(o CPlayerAcceptSSaresponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayeracceptssaresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerAcceptSSaresponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayeracceptssaresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetNicknameListRequest {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerGetNicknameListRequest) pack() []byte {
res := []byte{}
return res
}

pub fn cplayergetnicknamelistrequest_unpack(buf []byte) ?CPlayerGetNicknameListRequest {
res := CPlayerGetNicknameListRequest{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetnicknamelistrequest() CPlayerGetNicknameListRequest {
return CPlayerGetNicknameListRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetnicknamelistrequest(o CPlayerGetNicknameListRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetnicknamelistrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetNicknameListRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetnicknamelistrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetNicknameListResponsePlayerNickname {
mut:
unknown_fields []vproto.UnknownField
pub mut:
accountid u32
has_accountid bool
nickname string
has_nickname bool
}
pub fn (o &CPlayerGetNicknameListResponsePlayerNickname) pack() []byte {
mut res := []byte{}
if o.has_accountid {
res << vproto.pack_32bit_field(o.accountid, 1)
}

if o.has_nickname {
res << vproto.pack_string_field(o.nickname, 2)
}

return res
}

pub fn cplayergetnicknamelistresponseplayernickname_unpack(buf []byte) ?CPlayerGetNicknameListResponsePlayerNickname {
mut res := CPlayerGetNicknameListResponsePlayerNickname{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_accountid = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.accountid = v
i = ii
}

2 {
res.has_nickname = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.nickname = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetnicknamelistresponseplayernickname() CPlayerGetNicknameListResponsePlayerNickname {
return CPlayerGetNicknameListResponsePlayerNickname{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetnicknamelistresponseplayernickname(o CPlayerGetNicknameListResponsePlayerNickname, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetnicknamelistresponseplayernickname(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetNicknameListResponsePlayerNickname) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetnicknamelistresponseplayernickname_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetNicknameListResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
nicknames []CPlayerGetNicknameListResponsePlayerNickname
}
pub fn (o &CPlayerGetNicknameListResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.nicknames {
res << zzz_vproto_internal_pack_cplayergetnicknamelistresponseplayernickname(x, 1)
}

return res
}

pub fn cplayergetnicknamelistresponse_unpack(buf []byte) ?CPlayerGetNicknameListResponse {
mut res := CPlayerGetNicknameListResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetnicknamelistresponseplayernickname(cur_buf, tag_wiretype.wire_type)?
res.nicknames << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetnicknamelistresponse() CPlayerGetNicknameListResponse {
return CPlayerGetNicknameListResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetnicknamelistresponse(o CPlayerGetNicknameListResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetnicknamelistresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetNicknameListResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetnicknamelistresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetPerFriendPreferencesRequest {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerGetPerFriendPreferencesRequest) pack() []byte {
res := []byte{}
return res
}

pub fn cplayergetperfriendpreferencesrequest_unpack(buf []byte) ?CPlayerGetPerFriendPreferencesRequest {
res := CPlayerGetPerFriendPreferencesRequest{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetperfriendpreferencesrequest() CPlayerGetPerFriendPreferencesRequest {
return CPlayerGetPerFriendPreferencesRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetperfriendpreferencesrequest(o CPlayerGetPerFriendPreferencesRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetperfriendpreferencesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetPerFriendPreferencesRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetperfriendpreferencesrequest_unpack(v)?
return i, unpacked
}
pub struct PerFriendPreferences {
mut:
unknown_fields []vproto.UnknownField
pub mut:
accountid u32
has_accountid bool
nickname string
has_nickname bool
notifications_showingame ENotificationSetting
has_notifications_showingame bool
notifications_showonline ENotificationSetting
has_notifications_showonline bool
notifications_showmessages ENotificationSetting
has_notifications_showmessages bool
sounds_showingame ENotificationSetting
has_sounds_showingame bool
sounds_showonline ENotificationSetting
has_sounds_showonline bool
sounds_showmessages ENotificationSetting
has_sounds_showmessages bool
notifications_sendmobile ENotificationSetting
has_notifications_sendmobile bool
}
pub fn (o &PerFriendPreferences) pack() []byte {
mut res := []byte{}
if o.has_accountid {
res << vproto.pack_32bit_field(o.accountid, 1)
}

if o.has_nickname {
res << vproto.pack_string_field(o.nickname, 2)
}

if o.has_notifications_showingame {
res << zzz_vproto_internal_pack_enotificationsetting(o.notifications_showingame, 3)
}

if o.has_notifications_showonline {
res << zzz_vproto_internal_pack_enotificationsetting(o.notifications_showonline, 4)
}

if o.has_notifications_showmessages {
res << zzz_vproto_internal_pack_enotificationsetting(o.notifications_showmessages, 5)
}

if o.has_sounds_showingame {
res << zzz_vproto_internal_pack_enotificationsetting(o.sounds_showingame, 6)
}

if o.has_sounds_showonline {
res << zzz_vproto_internal_pack_enotificationsetting(o.sounds_showonline, 7)
}

if o.has_sounds_showmessages {
res << zzz_vproto_internal_pack_enotificationsetting(o.sounds_showmessages, 8)
}

if o.has_notifications_sendmobile {
res << zzz_vproto_internal_pack_enotificationsetting(o.notifications_sendmobile, 9)
}

return res
}

pub fn perfriendpreferences_unpack(buf []byte) ?PerFriendPreferences {
mut res := PerFriendPreferences{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_accountid = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.accountid = v
i = ii
}

2 {
res.has_nickname = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.nickname = v
i = ii
}

3 {
res.has_notifications_showingame = true
ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
res.notifications_showingame = v
i = ii
}

4 {
res.has_notifications_showonline = true
ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
res.notifications_showonline = v
i = ii
}

5 {
res.has_notifications_showmessages = true
ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
res.notifications_showmessages = v
i = ii
}

6 {
res.has_sounds_showingame = true
ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
res.sounds_showingame = v
i = ii
}

7 {
res.has_sounds_showonline = true
ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
res.sounds_showonline = v
i = ii
}

8 {
res.has_sounds_showmessages = true
ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
res.sounds_showmessages = v
i = ii
}

9 {
res.has_notifications_sendmobile = true
ii, v := zzz_vproto_internal_unpack_enotificationsetting(cur_buf, tag_wiretype.wire_type)?
res.notifications_sendmobile = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_perfriendpreferences() PerFriendPreferences {
return PerFriendPreferences{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_perfriendpreferences(o PerFriendPreferences, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_perfriendpreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, PerFriendPreferences) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := perfriendpreferences_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetPerFriendPreferencesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
preferences []PerFriendPreferences
}
pub fn (o &CPlayerGetPerFriendPreferencesResponse) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.preferences {
res << zzz_vproto_internal_pack_perfriendpreferences(x, 1)
}

return res
}

pub fn cplayergetperfriendpreferencesresponse_unpack(buf []byte) ?CPlayerGetPerFriendPreferencesResponse {
mut res := CPlayerGetPerFriendPreferencesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_perfriendpreferences(cur_buf, tag_wiretype.wire_type)?
res.preferences << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetperfriendpreferencesresponse() CPlayerGetPerFriendPreferencesResponse {
return CPlayerGetPerFriendPreferencesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetperfriendpreferencesresponse(o CPlayerGetPerFriendPreferencesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetperfriendpreferencesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetPerFriendPreferencesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetperfriendpreferencesresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetPerFriendPreferencesRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
preferences PerFriendPreferences
has_preferences bool
}
pub fn (o &CPlayerSetPerFriendPreferencesRequest) pack() []byte {
mut res := []byte{}
if o.has_preferences {
res << zzz_vproto_internal_pack_perfriendpreferences(o.preferences, 1)
}

return res
}

pub fn cplayersetperfriendpreferencesrequest_unpack(buf []byte) ?CPlayerSetPerFriendPreferencesRequest {
mut res := CPlayerSetPerFriendPreferencesRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_preferences = true
ii, v := zzz_vproto_internal_unpack_perfriendpreferences(cur_buf, tag_wiretype.wire_type)?
res.preferences = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetperfriendpreferencesrequest() CPlayerSetPerFriendPreferencesRequest {
return CPlayerSetPerFriendPreferencesRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetperfriendpreferencesrequest(o CPlayerSetPerFriendPreferencesRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetperfriendpreferencesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetPerFriendPreferencesRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetperfriendpreferencesrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetPerFriendPreferencesResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerSetPerFriendPreferencesResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cplayersetperfriendpreferencesresponse_unpack(buf []byte) ?CPlayerSetPerFriendPreferencesResponse {
res := CPlayerSetPerFriendPreferencesResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetperfriendpreferencesresponse() CPlayerSetPerFriendPreferencesResponse {
return CPlayerSetPerFriendPreferencesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetperfriendpreferencesresponse(o CPlayerSetPerFriendPreferencesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetperfriendpreferencesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetPerFriendPreferencesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetperfriendpreferencesresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerAddFriendRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
}
pub fn (o &CPlayerAddFriendRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

return res
}

pub fn cplayeraddfriendrequest_unpack(buf []byte) ?CPlayerAddFriendRequest {
mut res := CPlayerAddFriendRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayeraddfriendrequest() CPlayerAddFriendRequest {
return CPlayerAddFriendRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayeraddfriendrequest(o CPlayerAddFriendRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayeraddfriendrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerAddFriendRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayeraddfriendrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerAddFriendResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
invite_sent bool
has_invite_sent bool
friend_relationship u32
has_friend_relationship bool
result int
has_result bool
}
pub fn (o &CPlayerAddFriendResponse) pack() []byte {
mut res := []byte{}
if o.has_invite_sent {
res << vproto.pack_bool_field(o.invite_sent, 1)
}

if o.has_friend_relationship {
res << vproto.pack_uint32_field(o.friend_relationship, 2)
}

if o.has_result {
res << vproto.pack_int32_field(o.result, 3)
}

return res
}

pub fn cplayeraddfriendresponse_unpack(buf []byte) ?CPlayerAddFriendResponse {
mut res := CPlayerAddFriendResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_invite_sent = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.invite_sent = v
i = ii
}

2 {
res.has_friend_relationship = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.friend_relationship = v
i = ii
}

3 {
res.has_result = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.result = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayeraddfriendresponse() CPlayerAddFriendResponse {
return CPlayerAddFriendResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayeraddfriendresponse(o CPlayerAddFriendResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayeraddfriendresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerAddFriendResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayeraddfriendresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerRemoveFriendRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
}
pub fn (o &CPlayerRemoveFriendRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

return res
}

pub fn cplayerremovefriendrequest_unpack(buf []byte) ?CPlayerRemoveFriendRequest {
mut res := CPlayerRemoveFriendRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerremovefriendrequest() CPlayerRemoveFriendRequest {
return CPlayerRemoveFriendRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerremovefriendrequest(o CPlayerRemoveFriendRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerremovefriendrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerRemoveFriendRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerremovefriendrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerRemoveFriendResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
friend_relationship u32
has_friend_relationship bool
}
pub fn (o &CPlayerRemoveFriendResponse) pack() []byte {
mut res := []byte{}
if o.has_friend_relationship {
res << vproto.pack_uint32_field(o.friend_relationship, 1)
}

return res
}

pub fn cplayerremovefriendresponse_unpack(buf []byte) ?CPlayerRemoveFriendResponse {
mut res := CPlayerRemoveFriendResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_friend_relationship = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.friend_relationship = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerremovefriendresponse() CPlayerRemoveFriendResponse {
return CPlayerRemoveFriendResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerremovefriendresponse(o CPlayerRemoveFriendResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerremovefriendresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerRemoveFriendResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerremovefriendresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerIgnoreFriendRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
steamid u64
has_steamid bool
unignore bool
has_unignore bool
}
pub fn (o &CPlayerIgnoreFriendRequest) pack() []byte {
mut res := []byte{}
if o.has_steamid {
res << vproto.pack_64bit_field(o.steamid, 1)
}

if o.has_unignore {
res << vproto.pack_bool_field(o.unignore, 2)
}

return res
}

pub fn cplayerignorefriendrequest_unpack(buf []byte) ?CPlayerIgnoreFriendRequest {
mut res := CPlayerIgnoreFriendRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_steamid = true
ii, v := vproto.unpack_64bit_field(cur_buf, tag_wiretype.wire_type)?
res.steamid = v
i = ii
}

2 {
res.has_unignore = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.unignore = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerignorefriendrequest() CPlayerIgnoreFriendRequest {
return CPlayerIgnoreFriendRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerignorefriendrequest(o CPlayerIgnoreFriendRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerignorefriendrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerIgnoreFriendRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerignorefriendrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerIgnoreFriendResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
friend_relationship u32
has_friend_relationship bool
}
pub fn (o &CPlayerIgnoreFriendResponse) pack() []byte {
mut res := []byte{}
if o.has_friend_relationship {
res << vproto.pack_uint32_field(o.friend_relationship, 1)
}

return res
}

pub fn cplayerignorefriendresponse_unpack(buf []byte) ?CPlayerIgnoreFriendResponse {
mut res := CPlayerIgnoreFriendResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_friend_relationship = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.friend_relationship = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerignorefriendresponse() CPlayerIgnoreFriendResponse {
return CPlayerIgnoreFriendResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerignorefriendresponse(o CPlayerIgnoreFriendResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerignorefriendresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerIgnoreFriendResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerignorefriendresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetCommunityPreferencesRequest {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerGetCommunityPreferencesRequest) pack() []byte {
res := []byte{}
return res
}

pub fn cplayergetcommunitypreferencesrequest_unpack(buf []byte) ?CPlayerGetCommunityPreferencesRequest {
res := CPlayerGetCommunityPreferencesRequest{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetcommunitypreferencesrequest() CPlayerGetCommunityPreferencesRequest {
return CPlayerGetCommunityPreferencesRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetcommunitypreferencesrequest(o CPlayerGetCommunityPreferencesRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetcommunitypreferencesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetCommunityPreferencesRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetcommunitypreferencesrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerCommunityPreferences {
mut:
unknown_fields []vproto.UnknownField
pub mut:
hide_adult_content_violence bool
has_hide_adult_content_violence bool
hide_adult_content_sex bool
has_hide_adult_content_sex bool
parenthesize_nicknames bool
has_parenthesize_nicknames bool
timestamp_updated u32
has_timestamp_updated bool
}
pub fn (o &CPlayerCommunityPreferences) pack() []byte {
mut res := []byte{}
if o.has_hide_adult_content_violence {
res << vproto.pack_bool_field(o.hide_adult_content_violence, 1)
}

if o.has_hide_adult_content_sex {
res << vproto.pack_bool_field(o.hide_adult_content_sex, 2)
}

if o.has_parenthesize_nicknames {
res << vproto.pack_bool_field(o.parenthesize_nicknames, 4)
}

if o.has_timestamp_updated {
res << vproto.pack_uint32_field(o.timestamp_updated, 3)
}

return res
}

pub fn cplayercommunitypreferences_unpack(buf []byte) ?CPlayerCommunityPreferences {
mut res := CPlayerCommunityPreferences{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_hide_adult_content_violence = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.hide_adult_content_violence = v
i = ii
}

2 {
res.has_hide_adult_content_sex = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.hide_adult_content_sex = v
i = ii
}

4 {
res.has_parenthesize_nicknames = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.parenthesize_nicknames = v
i = ii
}

3 {
res.has_timestamp_updated = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.timestamp_updated = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayercommunitypreferences() CPlayerCommunityPreferences {
return CPlayerCommunityPreferences{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayercommunitypreferences(o CPlayerCommunityPreferences, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayercommunitypreferences(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerCommunityPreferences) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayercommunitypreferences_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetCommunityPreferencesResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
preferences CPlayerCommunityPreferences
has_preferences bool
}
pub fn (o &CPlayerGetCommunityPreferencesResponse) pack() []byte {
mut res := []byte{}
if o.has_preferences {
res << zzz_vproto_internal_pack_cplayercommunitypreferences(o.preferences, 1)
}

return res
}

pub fn cplayergetcommunitypreferencesresponse_unpack(buf []byte) ?CPlayerGetCommunityPreferencesResponse {
mut res := CPlayerGetCommunityPreferencesResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_preferences = true
ii, v := zzz_vproto_internal_unpack_cplayercommunitypreferences(cur_buf, tag_wiretype.wire_type)?
res.preferences = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetcommunitypreferencesresponse() CPlayerGetCommunityPreferencesResponse {
return CPlayerGetCommunityPreferencesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetcommunitypreferencesresponse(o CPlayerGetCommunityPreferencesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetcommunitypreferencesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetCommunityPreferencesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetcommunitypreferencesresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetCommunityPreferencesRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
preferences CPlayerCommunityPreferences
has_preferences bool
}
pub fn (o &CPlayerSetCommunityPreferencesRequest) pack() []byte {
mut res := []byte{}
if o.has_preferences {
res << zzz_vproto_internal_pack_cplayercommunitypreferences(o.preferences, 1)
}

return res
}

pub fn cplayersetcommunitypreferencesrequest_unpack(buf []byte) ?CPlayerSetCommunityPreferencesRequest {
mut res := CPlayerSetCommunityPreferencesRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_preferences = true
ii, v := zzz_vproto_internal_unpack_cplayercommunitypreferences(cur_buf, tag_wiretype.wire_type)?
res.preferences = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetcommunitypreferencesrequest() CPlayerSetCommunityPreferencesRequest {
return CPlayerSetCommunityPreferencesRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetcommunitypreferencesrequest(o CPlayerSetCommunityPreferencesRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetcommunitypreferencesrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetCommunityPreferencesRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetcommunitypreferencesrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerSetCommunityPreferencesResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerSetCommunityPreferencesResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cplayersetcommunitypreferencesresponse_unpack(buf []byte) ?CPlayerSetCommunityPreferencesResponse {
res := CPlayerSetCommunityPreferencesResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayersetcommunitypreferencesresponse() CPlayerSetCommunityPreferencesResponse {
return CPlayerSetCommunityPreferencesResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayersetcommunitypreferencesresponse(o CPlayerSetCommunityPreferencesResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayersetcommunitypreferencesresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerSetCommunityPreferencesResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayersetcommunitypreferencesresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetNewSteamAnnouncementStateRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
language int
has_language bool
}
pub fn (o &CPlayerGetNewSteamAnnouncementStateRequest) pack() []byte {
mut res := []byte{}
if o.has_language {
res << vproto.pack_int32_field(o.language, 1)
}

return res
}

pub fn cplayergetnewsteamannouncementstaterequest_unpack(buf []byte) ?CPlayerGetNewSteamAnnouncementStateRequest {
mut res := CPlayerGetNewSteamAnnouncementStateRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_language = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.language = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetnewsteamannouncementstaterequest() CPlayerGetNewSteamAnnouncementStateRequest {
return CPlayerGetNewSteamAnnouncementStateRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetnewsteamannouncementstaterequest(o CPlayerGetNewSteamAnnouncementStateRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetnewsteamannouncementstaterequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetNewSteamAnnouncementStateRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetnewsteamannouncementstaterequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetNewSteamAnnouncementStateResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
state int
has_state bool
announcement_headline string
has_announcement_headline bool
announcement_url string
has_announcement_url bool
time_posted u32
has_time_posted bool
announcement_gid u64
has_announcement_gid bool
}
pub fn (o &CPlayerGetNewSteamAnnouncementStateResponse) pack() []byte {
mut res := []byte{}
if o.has_state {
res << vproto.pack_int32_field(o.state, 1)
}

if o.has_announcement_headline {
res << vproto.pack_string_field(o.announcement_headline, 2)
}

if o.has_announcement_url {
res << vproto.pack_string_field(o.announcement_url, 3)
}

if o.has_time_posted {
res << vproto.pack_uint32_field(o.time_posted, 4)
}

if o.has_announcement_gid {
res << vproto.pack_uint64_field(o.announcement_gid, 5)
}

return res
}

pub fn cplayergetnewsteamannouncementstateresponse_unpack(buf []byte) ?CPlayerGetNewSteamAnnouncementStateResponse {
mut res := CPlayerGetNewSteamAnnouncementStateResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_state = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.state = v
i = ii
}

2 {
res.has_announcement_headline = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.announcement_headline = v
i = ii
}

3 {
res.has_announcement_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.announcement_url = v
i = ii
}

4 {
res.has_time_posted = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_posted = v
i = ii
}

5 {
res.has_announcement_gid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.announcement_gid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetnewsteamannouncementstateresponse() CPlayerGetNewSteamAnnouncementStateResponse {
return CPlayerGetNewSteamAnnouncementStateResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetnewsteamannouncementstateresponse(o CPlayerGetNewSteamAnnouncementStateResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetnewsteamannouncementstateresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetNewSteamAnnouncementStateResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetnewsteamannouncementstateresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerUpdateSteamAnnouncementLastReadRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
announcement_gid u64
has_announcement_gid bool
time_posted u32
has_time_posted bool
}
pub fn (o &CPlayerUpdateSteamAnnouncementLastReadRequest) pack() []byte {
mut res := []byte{}
if o.has_announcement_gid {
res << vproto.pack_uint64_field(o.announcement_gid, 1)
}

if o.has_time_posted {
res << vproto.pack_uint32_field(o.time_posted, 2)
}

return res
}

pub fn cplayerupdatesteamannouncementlastreadrequest_unpack(buf []byte) ?CPlayerUpdateSteamAnnouncementLastReadRequest {
mut res := CPlayerUpdateSteamAnnouncementLastReadRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_announcement_gid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.announcement_gid = v
i = ii
}

2 {
res.has_time_posted = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_posted = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerupdatesteamannouncementlastreadrequest() CPlayerUpdateSteamAnnouncementLastReadRequest {
return CPlayerUpdateSteamAnnouncementLastReadRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerupdatesteamannouncementlastreadrequest(o CPlayerUpdateSteamAnnouncementLastReadRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerupdatesteamannouncementlastreadrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerUpdateSteamAnnouncementLastReadRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerupdatesteamannouncementlastreadrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerUpdateSteamAnnouncementLastReadResponse {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerUpdateSteamAnnouncementLastReadResponse) pack() []byte {
res := []byte{}
return res
}

pub fn cplayerupdatesteamannouncementlastreadresponse_unpack(buf []byte) ?CPlayerUpdateSteamAnnouncementLastReadResponse {
res := CPlayerUpdateSteamAnnouncementLastReadResponse{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerupdatesteamannouncementlastreadresponse() CPlayerUpdateSteamAnnouncementLastReadResponse {
return CPlayerUpdateSteamAnnouncementLastReadResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerupdatesteamannouncementlastreadresponse(o CPlayerUpdateSteamAnnouncementLastReadResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerupdatesteamannouncementlastreadresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerUpdateSteamAnnouncementLastReadResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerupdatesteamannouncementlastreadresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetPrivacySettingsRequest {
mut:
unknown_fields []vproto.UnknownField
}
pub fn (o &CPlayerGetPrivacySettingsRequest) pack() []byte {
res := []byte{}
return res
}

pub fn cplayergetprivacysettingsrequest_unpack(buf []byte) ?CPlayerGetPrivacySettingsRequest {
res := CPlayerGetPrivacySettingsRequest{}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetprivacysettingsrequest() CPlayerGetPrivacySettingsRequest {
return CPlayerGetPrivacySettingsRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetprivacysettingsrequest(o CPlayerGetPrivacySettingsRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetprivacysettingsrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetPrivacySettingsRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetprivacysettingsrequest_unpack(v)?
return i, unpacked
}
pub struct CPrivacySettings {
mut:
unknown_fields []vproto.UnknownField
pub mut:
privacy_state int
has_privacy_state bool
privacy_state_inventory int
has_privacy_state_inventory bool
privacy_state_gifts int
has_privacy_state_gifts bool
privacy_state_ownedgames int
has_privacy_state_ownedgames bool
privacy_state_playtime int
has_privacy_state_playtime bool
privacy_state_friendslist int
has_privacy_state_friendslist bool
}
pub fn (o &CPrivacySettings) pack() []byte {
mut res := []byte{}
if o.has_privacy_state {
res << vproto.pack_int32_field(o.privacy_state, 1)
}

if o.has_privacy_state_inventory {
res << vproto.pack_int32_field(o.privacy_state_inventory, 2)
}

if o.has_privacy_state_gifts {
res << vproto.pack_int32_field(o.privacy_state_gifts, 3)
}

if o.has_privacy_state_ownedgames {
res << vproto.pack_int32_field(o.privacy_state_ownedgames, 4)
}

if o.has_privacy_state_playtime {
res << vproto.pack_int32_field(o.privacy_state_playtime, 5)
}

if o.has_privacy_state_friendslist {
res << vproto.pack_int32_field(o.privacy_state_friendslist, 6)
}

return res
}

pub fn cprivacysettings_unpack(buf []byte) ?CPrivacySettings {
mut res := CPrivacySettings{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_privacy_state = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.privacy_state = v
i = ii
}

2 {
res.has_privacy_state_inventory = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.privacy_state_inventory = v
i = ii
}

3 {
res.has_privacy_state_gifts = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.privacy_state_gifts = v
i = ii
}

4 {
res.has_privacy_state_ownedgames = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.privacy_state_ownedgames = v
i = ii
}

5 {
res.has_privacy_state_playtime = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.privacy_state_playtime = v
i = ii
}

6 {
res.has_privacy_state_friendslist = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.privacy_state_friendslist = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cprivacysettings() CPrivacySettings {
return CPrivacySettings{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cprivacysettings(o CPrivacySettings, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cprivacysettings(buf []byte, tag_wiretype vproto.WireType) ?(int, CPrivacySettings) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cprivacysettings_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetPrivacySettingsResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
privacy_settings CPrivacySettings
has_privacy_settings bool
}
pub fn (o &CPlayerGetPrivacySettingsResponse) pack() []byte {
mut res := []byte{}
if o.has_privacy_settings {
res << zzz_vproto_internal_pack_cprivacysettings(o.privacy_settings, 1)
}

return res
}

pub fn cplayergetprivacysettingsresponse_unpack(buf []byte) ?CPlayerGetPrivacySettingsResponse {
mut res := CPlayerGetPrivacySettingsResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_privacy_settings = true
ii, v := zzz_vproto_internal_unpack_cprivacysettings(cur_buf, tag_wiretype.wire_type)?
res.privacy_settings = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetprivacysettingsresponse() CPlayerGetPrivacySettingsResponse {
return CPlayerGetPrivacySettingsResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetprivacysettingsresponse(o CPlayerGetPrivacySettingsResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetprivacysettingsresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetPrivacySettingsResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetprivacysettingsresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetDurationControlRequest {
mut:
unknown_fields []vproto.UnknownField
pub mut:
appid u32
has_appid bool
}
pub fn (o &CPlayerGetDurationControlRequest) pack() []byte {
mut res := []byte{}
if o.has_appid {
res << vproto.pack_uint32_field(o.appid, 1)
}

return res
}

pub fn cplayergetdurationcontrolrequest_unpack(buf []byte) ?CPlayerGetDurationControlRequest {
mut res := CPlayerGetDurationControlRequest{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_appid = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.appid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetdurationcontrolrequest() CPlayerGetDurationControlRequest {
return CPlayerGetDurationControlRequest{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetdurationcontrolrequest(o CPlayerGetDurationControlRequest, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetdurationcontrolrequest(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetDurationControlRequest) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetdurationcontrolrequest_unpack(v)?
return i, unpacked
}
pub struct CPlayerGetDurationControlResponse {
mut:
unknown_fields []vproto.UnknownField
pub mut:
is_enabled bool
has_is_enabled bool
seconds int
has_seconds bool
seconds_today int
has_seconds_today bool
is_steamchina_account bool
has_is_steamchina_account bool
is_age_verified bool
has_is_age_verified bool
seconds_allowed_today u32
has_seconds_allowed_today bool
}
pub fn (o &CPlayerGetDurationControlResponse) pack() []byte {
mut res := []byte{}
if o.has_is_enabled {
res << vproto.pack_bool_field(o.is_enabled, 1)
}

if o.has_seconds {
res << vproto.pack_int32_field(o.seconds, 2)
}

if o.has_seconds_today {
res << vproto.pack_int32_field(o.seconds_today, 3)
}

if o.has_is_steamchina_account {
res << vproto.pack_bool_field(o.is_steamchina_account, 4)
}

if o.has_is_age_verified {
res << vproto.pack_bool_field(o.is_age_verified, 5)
}

if o.has_seconds_allowed_today {
res << vproto.pack_uint32_field(o.seconds_allowed_today, 6)
}

return res
}

pub fn cplayergetdurationcontrolresponse_unpack(buf []byte) ?CPlayerGetDurationControlResponse {
mut res := CPlayerGetDurationControlResponse{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_is_enabled = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_enabled = v
i = ii
}

2 {
res.has_seconds = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds = v
i = ii
}

3 {
res.has_seconds_today = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_today = v
i = ii
}

4 {
res.has_is_steamchina_account = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_steamchina_account = v
i = ii
}

5 {
res.has_is_age_verified = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_age_verified = v
i = ii
}

6 {
res.has_seconds_allowed_today = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.seconds_allowed_today = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayergetdurationcontrolresponse() CPlayerGetDurationControlResponse {
return CPlayerGetDurationControlResponse{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayergetdurationcontrolresponse(o CPlayerGetDurationControlResponse, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayergetdurationcontrolresponse(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerGetDurationControlResponse) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayergetdurationcontrolresponse_unpack(v)?
return i, unpacked
}
pub struct CPlayerLastPlayedTimesNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
games []CPlayerGetLastPlayedTimesResponseGame
}
pub fn (o &CPlayerLastPlayedTimesNotification) pack() []byte {
mut res := []byte{}
// [packed=false]
for _, x in o.games {
res << zzz_vproto_internal_pack_cplayergetlastplayedtimesresponsegame(x, 1)
}

return res
}

pub fn cplayerlastplayedtimesnotification_unpack(buf []byte) ?CPlayerLastPlayedTimesNotification {
mut res := CPlayerLastPlayedTimesNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
// [packed=false]
ii, v := zzz_vproto_internal_unpack_cplayergetlastplayedtimesresponsegame(cur_buf, tag_wiretype.wire_type)?
res.games << v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerlastplayedtimesnotification() CPlayerLastPlayedTimesNotification {
return CPlayerLastPlayedTimesNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerlastplayedtimesnotification(o CPlayerLastPlayedTimesNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerlastplayedtimesnotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerLastPlayedTimesNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerlastplayedtimesnotification_unpack(v)?
return i, unpacked
}
pub struct CPlayerFriendNicknameChangedNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
accountid u32
has_accountid bool
nickname string
has_nickname bool
is_echo_to_self bool
has_is_echo_to_self bool
}
pub fn (o &CPlayerFriendNicknameChangedNotification) pack() []byte {
mut res := []byte{}
if o.has_accountid {
res << vproto.pack_32bit_field(o.accountid, 1)
}

if o.has_nickname {
res << vproto.pack_string_field(o.nickname, 2)
}

if o.has_is_echo_to_self {
res << vproto.pack_bool_field(o.is_echo_to_self, 3)
}

return res
}

pub fn cplayerfriendnicknamechangednotification_unpack(buf []byte) ?CPlayerFriendNicknameChangedNotification {
mut res := CPlayerFriendNicknameChangedNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_accountid = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.accountid = v
i = ii
}

2 {
res.has_nickname = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.nickname = v
i = ii
}

3 {
res.has_is_echo_to_self = true
ii, v := vproto.unpack_bool_field(cur_buf, tag_wiretype.wire_type)?
res.is_echo_to_self = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerfriendnicknamechangednotification() CPlayerFriendNicknameChangedNotification {
return CPlayerFriendNicknameChangedNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerfriendnicknamechangednotification(o CPlayerFriendNicknameChangedNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerfriendnicknamechangednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerFriendNicknameChangedNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerfriendnicknamechangednotification_unpack(v)?
return i, unpacked
}
pub struct CPlayerFriendEquippedProfileItemsChangedNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
accountid u32
has_accountid bool
}
pub fn (o &CPlayerFriendEquippedProfileItemsChangedNotification) pack() []byte {
mut res := []byte{}
if o.has_accountid {
res << vproto.pack_32bit_field(o.accountid, 1)
}

return res
}

pub fn cplayerfriendequippedprofileitemschangednotification_unpack(buf []byte) ?CPlayerFriendEquippedProfileItemsChangedNotification {
mut res := CPlayerFriendEquippedProfileItemsChangedNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_accountid = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.accountid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerfriendequippedprofileitemschangednotification() CPlayerFriendEquippedProfileItemsChangedNotification {
return CPlayerFriendEquippedProfileItemsChangedNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerfriendequippedprofileitemschangednotification(o CPlayerFriendEquippedProfileItemsChangedNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerfriendequippedprofileitemschangednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerFriendEquippedProfileItemsChangedNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerfriendequippedprofileitemschangednotification_unpack(v)?
return i, unpacked
}
pub struct CPlayerNewSteamAnnouncementStateNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
state int
has_state bool
announcement_headline string
has_announcement_headline bool
announcement_url string
has_announcement_url bool
time_posted u32
has_time_posted bool
announcement_gid u64
has_announcement_gid bool
}
pub fn (o &CPlayerNewSteamAnnouncementStateNotification) pack() []byte {
mut res := []byte{}
if o.has_state {
res << vproto.pack_int32_field(o.state, 1)
}

if o.has_announcement_headline {
res << vproto.pack_string_field(o.announcement_headline, 2)
}

if o.has_announcement_url {
res << vproto.pack_string_field(o.announcement_url, 3)
}

if o.has_time_posted {
res << vproto.pack_uint32_field(o.time_posted, 4)
}

if o.has_announcement_gid {
res << vproto.pack_uint64_field(o.announcement_gid, 5)
}

return res
}

pub fn cplayernewsteamannouncementstatenotification_unpack(buf []byte) ?CPlayerNewSteamAnnouncementStateNotification {
mut res := CPlayerNewSteamAnnouncementStateNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_state = true
ii, v := vproto.unpack_int32_field(cur_buf, tag_wiretype.wire_type)?
res.state = v
i = ii
}

2 {
res.has_announcement_headline = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.announcement_headline = v
i = ii
}

3 {
res.has_announcement_url = true
ii, v := vproto.unpack_string_field(cur_buf, tag_wiretype.wire_type)?
res.announcement_url = v
i = ii
}

4 {
res.has_time_posted = true
ii, v := vproto.unpack_uint32_field(cur_buf, tag_wiretype.wire_type)?
res.time_posted = v
i = ii
}

5 {
res.has_announcement_gid = true
ii, v := vproto.unpack_uint64_field(cur_buf, tag_wiretype.wire_type)?
res.announcement_gid = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayernewsteamannouncementstatenotification() CPlayerNewSteamAnnouncementStateNotification {
return CPlayerNewSteamAnnouncementStateNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayernewsteamannouncementstatenotification(o CPlayerNewSteamAnnouncementStateNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayernewsteamannouncementstatenotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerNewSteamAnnouncementStateNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayernewsteamannouncementstatenotification_unpack(v)?
return i, unpacked
}
pub struct CPlayerCommunityPreferencesChangedNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
preferences CPlayerCommunityPreferences
has_preferences bool
}
pub fn (o &CPlayerCommunityPreferencesChangedNotification) pack() []byte {
mut res := []byte{}
if o.has_preferences {
res << zzz_vproto_internal_pack_cplayercommunitypreferences(o.preferences, 1)
}

return res
}

pub fn cplayercommunitypreferenceschangednotification_unpack(buf []byte) ?CPlayerCommunityPreferencesChangedNotification {
mut res := CPlayerCommunityPreferencesChangedNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_preferences = true
ii, v := zzz_vproto_internal_unpack_cplayercommunitypreferences(cur_buf, tag_wiretype.wire_type)?
res.preferences = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayercommunitypreferenceschangednotification() CPlayerCommunityPreferencesChangedNotification {
return CPlayerCommunityPreferencesChangedNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayercommunitypreferenceschangednotification(o CPlayerCommunityPreferencesChangedNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayercommunitypreferenceschangednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerCommunityPreferencesChangedNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayercommunitypreferenceschangednotification_unpack(v)?
return i, unpacked
}
pub struct CPlayerPerFriendPreferencesChangedNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
accountid u32
has_accountid bool
preferences PerFriendPreferences
has_preferences bool
}
pub fn (o &CPlayerPerFriendPreferencesChangedNotification) pack() []byte {
mut res := []byte{}
if o.has_accountid {
res << vproto.pack_32bit_field(o.accountid, 1)
}

if o.has_preferences {
res << zzz_vproto_internal_pack_perfriendpreferences(o.preferences, 2)
}

return res
}

pub fn cplayerperfriendpreferenceschangednotification_unpack(buf []byte) ?CPlayerPerFriendPreferencesChangedNotification {
mut res := CPlayerPerFriendPreferencesChangedNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_accountid = true
ii, v := vproto.unpack_32bit_field(cur_buf, tag_wiretype.wire_type)?
res.accountid = v
i = ii
}

2 {
res.has_preferences = true
ii, v := zzz_vproto_internal_unpack_perfriendpreferences(cur_buf, tag_wiretype.wire_type)?
res.preferences = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerperfriendpreferenceschangednotification() CPlayerPerFriendPreferencesChangedNotification {
return CPlayerPerFriendPreferencesChangedNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerperfriendpreferenceschangednotification(o CPlayerPerFriendPreferencesChangedNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerperfriendpreferenceschangednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerPerFriendPreferencesChangedNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerperfriendpreferenceschangednotification_unpack(v)?
return i, unpacked
}
pub struct CPlayerPrivacySettingsChangedNotification {
mut:
unknown_fields []vproto.UnknownField
pub mut:
privacy_settings CPrivacySettings
has_privacy_settings bool
}
pub fn (o &CPlayerPrivacySettingsChangedNotification) pack() []byte {
mut res := []byte{}
if o.has_privacy_settings {
res << zzz_vproto_internal_pack_cprivacysettings(o.privacy_settings, 1)
}

return res
}

pub fn cplayerprivacysettingschangednotification_unpack(buf []byte) ?CPlayerPrivacySettingsChangedNotification {
mut res := CPlayerPrivacySettingsChangedNotification{}
mut total := 0
		for total < buf.len {
			mut i := 0
			buf_before_wire_type := buf[total..]
			tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or { return error('malformed protobuf (couldnt parse tag & wire type)') }
			cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
			match tag_wiretype.tag {
1 {
res.has_privacy_settings = true
ii, v := zzz_vproto_internal_unpack_cprivacysettings(cur_buf, tag_wiretype.wire_type)?
res.privacy_settings = v
i = ii
}

else {
ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
res.unknown_fields << vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
i = ii
}
}
if i == 0 { return error('malformed protobuf (didnt unpack a field)') }
total += tag_wiretype.consumed + i
}
return res
}

// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_new_cplayerprivacysettingschangednotification() CPlayerPrivacySettingsChangedNotification {
return CPlayerPrivacySettingsChangedNotification{}
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_pack_cplayerprivacysettingschangednotification(o CPlayerPrivacySettingsChangedNotification, num u32) []byte {
return vproto.pack_message_field(o.pack(), num)
}
// FOR INTERNAL USE ONLY
pub fn zzz_vproto_internal_unpack_cplayerprivacysettingschangednotification(buf []byte, tag_wiretype vproto.WireType) ?(int, CPlayerPrivacySettingsChangedNotification) {
i, v := vproto.unpack_message_field(buf, tag_wiretype)?
mut unpacked := cplayerprivacysettingschangednotification_unpack(v)?
return i, unpacked
}
